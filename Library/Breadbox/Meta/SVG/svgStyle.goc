/***********************************************************************
 * svgStyle.goc — styling: stroke/fill/width/fill-rule & color keywords
 ***********************************************************************/
@include <stdapp.goh>

@include <SVG/colors.goh>

#include <Ansi/string.h>
#include <Ansi/stdlib.h>
#include <Ansi/ctype.h>
#include <file.h>
#include <system.h>
#include <graphics.h>
#include <gstring.h>
#include <meta.h>
#include <float.h>

#include "SVG/svg.h"
#include "SVG/dbglog.h"

/* ---- group style stack (fill/stroke/stroke-width) ---- */
static MemHandle gStyleStackH = NullHandle;
static byte gStyleDepth = 0;

Boolean SvgStyleStackInit(void)
{
    SvgGroupStyle *stack;
    word bytes;

    gStyleDepth = 0;
    bytes = (word)(SVG_STYLE_GSTACK_MAX * sizeof(SvgGroupStyle));

    if (gStyleStackH == NullHandle) {
        gStyleStackH = MemAlloc(bytes, HF_DYNAMIC, HAF_ZERO_INIT);
        if (gStyleStackH == NullHandle) {
            return FALSE;
        }
    }

    stack = (SvgGroupStyle *)MemLock(gStyleStackH);
    if (stack == NULL) {
        SvgStyleStackFree();
        return FALSE;
    }

    MemUnlock(gStyleStackH);
    return TRUE;
}

void SvgStyleStackFree(void)
{
    if (gStyleStackH != NullHandle) {
        MemFree(gStyleStackH);
        gStyleStackH = NullHandle;
    }
    gStyleDepth = 0;
}

/* Maintain the group style stack in movable heap memory. */
static SvgGroupStyle* SvgStyleStackLock(void)
{
    SvgGroupStyle *stack;

    if (gStyleStackH == NullHandle) {
        return NULL;
    }

    stack = (SvgGroupStyle *)MemLock(gStyleStackH);
    if (stack == NULL) {
        SvgStyleStackFree();
    }
    return stack;
}

static void SvgStyleStackUnlock(void)
{
    if (gStyleStackH != NullHandle) {
        MemUnlock(gStyleStackH);
    }
}

static Boolean SvgStyleFindNamedColor(const char *name, word *r, word *g, word *b)
{
    MemHandle       mh;
    SvgNamedColor  *rec;
    word            i, count, elemSize;

    mh = OptrToHandle(@SvgNamedColors);
    ObjLockObjBlock(mh);

    count = ChunkArrayGetCount(@SvgNamedColors);
    for (i = 0; i < count; i++) {
        rec = (SvgNamedColor*) ChunkArrayElementToPtr(@SvgNamedColors, i, &elemSize);
        if (rec && SvgUtilAsciiNoCaseEq(rec->SNC_name, name)) {
            *r = rec->SNC_r; *g = rec->SNC_g; *b = rec->SNC_b;
            MemUnlock(mh);
            return TRUE;
        }
    }
    MemUnlock(mh);
    return FALSE;
}

/* ---- paint resolution: url(#id) fallback or none; solid colors only ---- */

/* Returns TRUE if 'raw' resolves to a solid color and sets r,g,b.
   Returns FALSE if the used value is NONE (includes unresolved url()).
   Supports: "none", "#rgb/#rrggbb", "rgb(...)", named colors,
             "url(#id)" [optional fallback color after ')'].
   Gradients/patterns are not implemented, so any url() without fallback => NONE. */
static Boolean SvgStyleResolveCurrentColor(const char *tag, word *r, word *g, word *b);

static Boolean
SvgStyleResolvePaintToSolidOrNone(const char *tag,
                                  const char *prop,
                                  const char *raw,
                                  word *r,
                                  word *g,
                                  word *b)
{
    const char *p;
    const char *rp;
    word rr;
    word gg;
    word bb;

    Boolean isFill;
    Boolean isColor;

    if (raw == NULL) { return FALSE; }

    p = SvgParserSkipWS(raw);

    isFill = (prop != NULL && SvgUtilAsciiNoCaseEq(prop, "fill"));
    isColor = (prop != NULL && SvgUtilAsciiNoCaseEq(prop, "color"));

    if (SvgUtilAsciiNoCaseEq(p, "inherit"))
    {
        char inherited[64];
        Boolean haveInherited;

        inherited[0] = 0;
        haveInherited = SvgStyleResolvePropWithGroups(tag, prop,
                                                     inherited,
                                                     sizeof(inherited),
                                                     TRUE);
        if (!haveInherited || inherited[0] == 0)
        {
            if (isFill || isColor)
            {
                *r = 0;
                *g = 0;
                *b = 0;
                return TRUE;
            }
            return FALSE;
        }
        return SvgStyleResolvePaintToSolidOrNone(tag, prop, inherited, r, g, b);
    }

    if (SvgUtilAsciiNoCaseEq(p, "currentColor"))
    {
        return SvgStyleResolveCurrentColor(tag, r, g, b);
    }

    if (SvgUtilAsciiNoCaseEq(p, "none")) {
        return FALSE;
    }

    /* url(...)[ fallback]?  Case-insensitive check for "url(" at start */
    if ((p[0]=='u' || p[0]=='U') &&
        (p[1]=='r' || p[1]=='R') &&
        (p[2]=='l' || p[2]=='L') &&
        p[3]=='(')
    {
        /* find ')' */
        rp = p + 4;
        while (*rp && *rp != ')') { rp++; }
        if (*rp == ')') {
            const char *after;
            after = SvgParserSkipWS(rp + 1);

            /* No fallback token -> NONE per spec */
            if (*after == 0) {
                return FALSE;
            }

            if (SvgStyleResolvePaintToSolidOrNone(tag, prop, after, &rr, &gg, &bb))
            {
                *r = rr;
                *g = gg;
                *b = bb;
                return TRUE;
            }

            return FALSE;
        }

        /* Malformed url( -> NONE */
        return FALSE;
    }

    /* direct color */
    if (SvgUtilExpandShortHex(p, &rr, &gg, &bb)) {
        *r = rr; *g = gg; *b = bb;
        return TRUE;
    }
    if (p[0] == '#' && strlen(p) >= 7) {
        *r = SvgUtilHexByte(p + 1);
        *g = SvgUtilHexByte(p + 3);
        *b = SvgUtilHexByte(p + 5);
        return TRUE;
    }
    if (SvgUtilParseRGBFunc(p, &rr, &gg, &bb)) {
        *r = rr; *g = gg; *b = bb;
        return TRUE;
    }
    if (SvgStyleFindNamedColor(p, &rr, &gg, &bb)) {
        *r = rr; *g = gg; *b = bb;
        return TRUE;
    }

    /* Unknown token -> NONE */
    return FALSE;
}

static Boolean
SvgStyleResolveCurrentColor(const char *tag, word *r, word *g, word *b)
{
    char colorBuf[64];
    Boolean haveColor;

    if (r == NULL || g == NULL || b == NULL)
    {
        return FALSE;
    }

    *r = 0;
    *g = 0;
    *b = 0;

    if (tag == NULL)
    {
        return TRUE;
    }

    haveColor = SvgStyleResolvePropWithGroups(tag, "color", colorBuf,
                                              sizeof(colorBuf), FALSE);
    if (!haveColor || colorBuf[0] == 0)
    {
        return TRUE;
    }

    if (SvgUtilAsciiNoCaseEq(colorBuf, "inherit"))
    {
        haveColor = SvgStyleResolvePropWithGroups(tag, "color", colorBuf,
                                                  sizeof(colorBuf), TRUE);
        if (!haveColor || colorBuf[0] == 0)
        {
            return TRUE;
        }
    }

    if (SvgUtilAsciiNoCaseEq(colorBuf, "currentColor"))
    {
        return TRUE;
    }

    return SvgStyleResolvePaintToSolidOrNone(tag, "color", colorBuf, r, g, b);
}


/* ---- group style stuff ---- */

Boolean SvgStyleGroupStrokeWidthGet(WWFixedAsDWord *outW)
{
    SvgGroupStyle *stack;
    Boolean haveWidth;

    if (outW == NULL) { return FALSE; }

    stack = SvgStyleStackLock();
    if (stack == NULL) { return FALSE; }

    haveWidth = FALSE;
    if (gStyleDepth > 0 && stack[gStyleDepth-1].swSet)
    {
        *outW = stack[gStyleDepth-1].strokeWidth;
        haveWidth = TRUE;
    }

    SvgStyleStackUnlock();
    return haveWidth;
}

/* Called on <g ...> */
void SvgStyleGroupPush(const char *tag)
{
    SvgGroupStyle st;
    char buf[64];
    char frBuf[24];
    const char *pwalk;
    SvgGroupStyle *stack;
    word depth;

    stack = SvgStyleStackLock();
    if (stack == NULL) {
        return;
    }

    st.fillSet = FALSE;
    st.strokeSet = FALSE;
    st.swSet = FALSE;
    st.fillVal[0] = 0;
    st.strokeVal[0] = 0;
    st.strokeWidth = SvgGeomMakeWWFixedFromInt(1);
    st.colorSet = FALSE;
    st.colorVal[0] = 0;

    /* inherit from parent */
    st.frSet = FALSE; st.fr = 0;
    st.lcSet = FALSE; st.lc = 0;
    st.ljSet = FALSE; st.lj = 0;
    if (gStyleDepth > 0) {
        st.frSet = stack[gStyleDepth-1].frSet;
        st.fr    = stack[gStyleDepth-1].fr;
        st.lcSet = stack[gStyleDepth-1].lcSet;
        st.lc    = stack[gStyleDepth-1].lc;
        st.ljSet = stack[gStyleDepth-1].ljSet;
        st.lj    = stack[gStyleDepth-1].lj;
    }

    /* inline style/attributes: fill, stroke */
    if (SvgParseGetInlineStyleProp(tag, "fill", st.fillVal, sizeof(st.fillVal)) ||
        SvgParserGetAttrBounded(tag, "fill", st.fillVal, sizeof(st.fillVal))) {
        st.fillSet = TRUE;
        if (SvgUtilAsciiNoCaseEq(st.fillVal, "inherit"))
        {
            st.fillSet = FALSE;
            st.fillVal[0] = 0;
            if (gStyleDepth > 0)
            {
                depth = gStyleDepth;
                while (depth > 0)
                {
                    depth--;
                    if (stack[depth].fillSet)
                    {
                        strncpy(st.fillVal, stack[depth].fillVal,
                                sizeof(st.fillVal) - 1);
                        st.fillVal[sizeof(st.fillVal) - 1] = 0;
                        st.fillSet = TRUE;
                        break;
                    }
                }
            }
        }
    }
    if (SvgParseGetInlineStyleProp(tag, "stroke", st.strokeVal, sizeof(st.strokeVal)) ||
        SvgParserGetAttrBounded(tag, "stroke", st.strokeVal, sizeof(st.strokeVal))) {
        st.strokeSet = TRUE;
        if (SvgUtilAsciiNoCaseEq(st.strokeVal, "inherit"))
        {
            st.strokeSet = FALSE;
            st.strokeVal[0] = 0;
            if (gStyleDepth > 0)
            {
                depth = gStyleDepth;
                while (depth > 0)
                {
                    depth--;
                    if (stack[depth].strokeSet)
                    {
                        strncpy(st.strokeVal, stack[depth].strokeVal,
                                sizeof(st.strokeVal) - 1);
                        st.strokeVal[sizeof(st.strokeVal) - 1] = 0;
                        st.strokeSet = TRUE;
                        break;
                    }
                }
            }
        }
    }

    /* color */
    buf[0] = 0;
    if (!SvgParseGetInlineStyleProp(tag, "color", buf, sizeof(buf)))
    {
        (void)SvgParserGetAttrBounded(tag, "color", buf, sizeof(buf));
    }
    if (buf[0])
    {
        if (SvgUtilAsciiNoCaseEq(buf, "inherit"))
        {
            if (gStyleDepth > 0)
            {
                depth = gStyleDepth;
                while (depth > 0)
                {
                    depth--;
                    if (stack[depth].colorSet)
                    {
                        strncpy(st.colorVal, stack[depth].colorVal,
                                sizeof(st.colorVal) - 1);
                        st.colorVal[sizeof(st.colorVal) - 1] = 0;
                        st.colorSet = TRUE;
                        break;
                    }
                }
            }
        }
        else
        {
            strncpy(st.colorVal, buf, sizeof(st.colorVal) - 1);
            st.colorVal[sizeof(st.colorVal) - 1] = 0;
            st.colorSet = TRUE;
        }
    }

    /* stroke-width */
    buf[0] = 0;
    if (!SvgParseGetInlineStyleProp(tag, "stroke-width", buf, sizeof(buf))) {
        (void)SvgParserGetAttrBounded(tag, "stroke-width", buf, sizeof(buf));
    }
    if (buf[0]) {
        pwalk = buf;
        while (*pwalk && (isdigit((byte)*pwalk) || *pwalk=='+' || *pwalk=='-' || *pwalk=='.')) pwalk++;
        if (pwalk != buf) {
            char save = *pwalk;
            *(char*)pwalk = 0;
            (void)SvgUtilParseWWFixed16_16(buf, &st.strokeWidth);
            *(char*)pwalk = save;
            st.swSet = TRUE;
        }
    }

    /* fill-rule */
    frBuf[0] = 0;
    if (!SvgParseGetInlineStyleProp(tag, "fill-rule", frBuf, sizeof(frBuf))) {
        (void)SvgParserGetAttrBounded(tag, "fill-rule", frBuf, sizeof(frBuf));
    }
    if (frBuf[0]) {
        if (SvgUtilAsciiNoCaseEq(frBuf, "evenodd")) { st.fr = 1; st.frSet = TRUE; }
        else if (SvgUtilAsciiNoCaseEq(frBuf, "nonzero") || SvgUtilAsciiNoCaseEq(frBuf, "winding")) { st.fr = 0; st.frSet = TRUE; }
        /* inherit/other -> keep */
    }

    /* >>> ADD HERE: stroke-linecap / stroke-linejoin <<< */

    /* stroke-linecap */
    buf[0] = 0;
    if (!SvgParseGetInlineStyleProp(tag, "stroke-linecap", buf, sizeof(buf))) {
        (void)SvgParserGetAttrBounded(tag, "stroke-linecap", buf, sizeof(buf));
    }
    if (buf[0]) {
        if (SvgUtilAsciiNoCaseEq(buf, "round"))   { st.lc = 1; st.lcSet = TRUE; }
        else if (SvgUtilAsciiNoCaseEq(buf, "square")) { st.lc = 2; st.lcSet = TRUE; }
        else if (SvgUtilAsciiNoCaseEq(buf, "butt"))   { st.lc = 0; st.lcSet = TRUE; }
        /* inherit/other -> keep */
    }

    /* stroke-linejoin */
    buf[0] = 0;
    if (!SvgParseGetInlineStyleProp(tag, "stroke-linejoin", buf, sizeof(buf))) {
        (void)SvgParserGetAttrBounded(tag, "stroke-linejoin", buf, sizeof(buf));
    }
    if (buf[0]) {
        if (SvgUtilAsciiNoCaseEq(buf, "round"))  { st.lj = 1; st.ljSet = TRUE; }
        else if (SvgUtilAsciiNoCaseEq(buf, "bevel")) { st.lj = 2; st.ljSet = TRUE; }
        else if (SvgUtilAsciiNoCaseEq(buf, "miter")) { st.lj = 0; st.ljSet = TRUE; }
        /* inherit/other -> keep */
    }

    /* push */
    if (gStyleDepth < SVG_STYLE_GSTACK_MAX) {
        stack[gStyleDepth++] = st;
    }

    SvgStyleStackUnlock();
}


void SvgStyleGroupPop(void)
{
    if (gStyleDepth > 0) gStyleDepth--;
}


/* resolve property with group fallback — strings only (fill/stroke) */
static Boolean SvgStyleResolvePropWithGroups(const char *tag,
                                             const char *prop,
                                             char *out,
                                             word outSize,
                                             Boolean skipLocal)
{
    const SvgGroupStyle *gs;
    SvgGroupStyle *stack;
    Boolean result;
    Boolean isFill;
    Boolean isStroke;
    Boolean isColor;
    word depth;

    if (outSize == 0) return FALSE;
    out[0] = 0;

    if (!skipLocal && tag != NULL)
    {
        if (SvgParseGetInlineStyleProp(tag, prop, out, outSize) ||
            SvgParserGetAttrBounded(tag, prop, out, outSize))
        {
            if (!SvgUtilAsciiNoCaseEq(out, "inherit"))
            {
                return TRUE;
            }
            out[0] = 0;
        }
    }

    if (gStyleDepth == 0) return FALSE;
    stack = SvgStyleStackLock();
    if (stack == NULL) return FALSE;

    isFill = (prop != NULL && SvgUtilAsciiNoCaseEq(prop, "fill"));
    isStroke = (prop != NULL && SvgUtilAsciiNoCaseEq(prop, "stroke"));
    isColor = (prop != NULL && SvgUtilAsciiNoCaseEq(prop, "color"));

    result = FALSE;
    depth = gStyleDepth;

    while (depth > 0 && !result)
    {
        depth--;
        gs = &stack[depth];
        if (isFill && gs->fillSet)
        {
            strncpy(out, gs->fillVal, outSize - 1);
            out[outSize - 1] = 0;
            if (!SvgUtilAsciiNoCaseEq(out, "inherit"))
            {
                result = TRUE;
            }
            else
            {
                out[0] = 0;
            }
        }
        else if (isStroke && gs->strokeSet)
        {
            strncpy(out, gs->strokeVal, outSize - 1);
            out[outSize - 1] = 0;
            if (!SvgUtilAsciiNoCaseEq(out, "inherit"))
            {
                result = TRUE;
            }
            else
            {
                out[0] = 0;
            }
        }
        else if (isColor && gs->colorSet)
        {
            strncpy(out, gs->colorVal, outSize - 1);
            out[outSize - 1] = 0;
            if (!SvgUtilAsciiNoCaseEq(out, "inherit"))
            {
                result = TRUE;
            }
            else
            {
                out[0] = 0;
            }
        }
    }

    SvgStyleStackUnlock();
    return result;
}

/* ---- public style API ---- */

void SvgStyleApplyStrokeAndFill(const char *tag)
{
    static char sFill[64];
    static char sStroke[64];
    word r;
    word g;
    word b;
    Boolean have;

    sFill[0] = 0;
    sStroke[0] = 0;

    /* stroke; initial = none */
    have = SvgStyleResolvePropWithGroups(tag, "stroke", sStroke,
                                         sizeof(sStroke), FALSE);
    if (have) {
        if (SvgStyleResolvePaintToSolidOrNone(tag, "stroke", sStroke,
                                              &r, &g, &b)) {
            Meta_SetLineColor(CF_RGB, r, g, b);
        }
        /* else NONE: do not set a line color */
    }
    /* else: no property anywhere -> stays NONE */

    /* fill; initial = black */
    have = SvgStyleResolvePropWithGroups(tag, "fill", sFill,
                                         sizeof(sFill), FALSE);
    if (!have) {
        /* property absent -> initial black */
        Meta_SetAreaColor(CF_RGB, 0, 0, 0);
    } else {
        if (SvgStyleResolvePaintToSolidOrNone(tag, "fill", sFill,
                                              &r, &g, &b)) {
            Meta_SetAreaColor(CF_RGB, r, g, b);
        }
        /* else NONE: do not set an area color */
    }
}

void SvgStyleApplyFillRule(const char *tag)
{
    static char buf[32];
    int useEvenOdd;
    buf[0] = 0;

    /* element-local value wins */
    if (!SvgParseGetInlineStyleProp(tag, "fill-rule", buf, sizeof(buf)))
    {
        (void)SvgParserGetAttrBounded(tag, "fill-rule", buf, sizeof(buf));
    }

    if (buf[0])
    {
        if (SvgUtilAsciiNoCaseEq(buf, "evenodd")) { Meta_SetFillRule(ODD_EVEN); return; }
        if (SvgUtilAsciiNoCaseEq(buf, "nonzero") || SvgUtilAsciiNoCaseEq(buf, "winding")) { Meta_SetFillRule(WINDING); return; }
        if (SvgUtilAsciiNoCaseEq(buf, "inherit")) { buf[0] = 0; } /* fall through to group */
    }

    /* inherit from current group if present */
    if (gStyleDepth > 0)
    {
        SvgGroupStyle *stack = SvgStyleStackLock();
        if (stack != NULL && stack[gStyleDepth-1].frSet)
        {
            useEvenOdd = (int)stack[gStyleDepth-1].fr;
            SvgStyleStackUnlock();
            if (useEvenOdd) { Meta_SetFillRule(ODD_EVEN); }
            else { Meta_SetFillRule(WINDING); }
            return;
        }
        SvgStyleStackUnlock();
    }

    /* initial */
    Meta_SetFillRule(WINDING);
}


void SvgStyleApplyStrokeWidth(const char *tag)
{
    WWFixedAsDWord lw;
    char b[24];
    const char *pwalk;
    char save;
    Boolean haveWidth;

    /* Try element-local width first */
    b[0] = 0;
    haveWidth = FALSE;

    if (SvgParseGetInlineStyleProp(tag, "stroke-width", b, sizeof(b)) ||
        SvgParserGetAttrBounded(tag, "stroke-width", b, sizeof(b)))
    {
        pwalk = b;
        while (*pwalk &&
               (isdigit((byte)*pwalk) || *pwalk=='+' || *pwalk=='-' || *pwalk=='.'))
        {
            pwalk++;
        }
        save = *pwalk;
        *(char*)pwalk = 0;
        (void)SvgUtilParseWWFixed16_16(b, &lw);
        *(char*)pwalk = save;
        haveWidth = TRUE;
    }

    /* Else inherit from group */
    if (!haveWidth)
    {
        if (SvgStyleGroupStrokeWidthGet(&lw))
        {
            haveWidth = TRUE;
        }
    }

    /* Else default per SVG */
    if (!haveWidth)
    {
        lw = SvgGeomMakeWWFixedFromInt(1);
    }

    Meta_SetLineWidth(lw);
    SvgStyleApplyStrokeCapJoin(tag);
}

void SvgStyleApplyStrokeCapJoin(const char *tag)
{
    char  b[32];
    byte  lc;
    byte  lj;
    SvgGroupStyle *stack;

    stack = (gStyleDepth > 0) ? SvgStyleStackLock() : NULL;
    /* linecap: element > group > initial(butt) */
    lc = 0;
    b[0] = 0;
    if (!SvgParseGetInlineStyleProp(tag, "stroke-linecap", b, sizeof(b))) {
        (void)SvgParserGetAttrBounded(tag, "stroke-linecap", b, sizeof(b));
    }
    if (b[0]) {
        if (SvgUtilAsciiNoCaseEq(b, "round")) lc = 1;
        else if (SvgUtilAsciiNoCaseEq(b, "square")) lc = 2;
        else if (SvgUtilAsciiNoCaseEq(b, "inherit")) b[0] = 0;
        /* else butt or unknown -> lc stays 0 */
    }
    if (!b[0] && stack != NULL && stack[gStyleDepth-1].lcSet) {
        lc = stack[gStyleDepth-1].lc;
    }
    Meta_SetLineEnd( (lc==1)? LE_ROUNDCAP : (lc==2)? LE_SQUARECAP : LE_BUTTCAP );

    /* linejoin: element > group > initial(miter) */
    lj = 0;
    b[0] = 0;
    if (!SvgParseGetInlineStyleProp(tag, "stroke-linejoin", b, sizeof(b))) {
        (void)SvgParserGetAttrBounded(tag, "stroke-linejoin", b, sizeof(b));
    }
    if (b[0]) {
        if (SvgUtilAsciiNoCaseEq(b, "round")) lj = 1;
        else if (SvgUtilAsciiNoCaseEq(b, "bevel")) lj = 2;
        else if (SvgUtilAsciiNoCaseEq(b, "inherit")) b[0] = 0;
        /* else miter or unknown -> lj stays 0 */
    }
    if (!b[0] && stack != NULL && stack[gStyleDepth-1].ljSet) {
        lj = stack[gStyleDepth-1].lj;
    }

    if (stack != NULL) {
        SvgStyleStackUnlock();
    }

    Meta_SetLineJoin( (lj==1) ? LJ_ROUND : ((lj==2)? LJ_BEVELED : LJ_MITERED));
}

Boolean SvgStyleHasStroke(const char *tag)
{
    char b[64];
    word r;
    word g;
    word bb;
    if (SvgStyleResolvePropWithGroups(tag, "stroke", b, sizeof(b), FALSE)) {
        return SvgStyleResolvePaintToSolidOrNone(tag, "stroke", b, &r, &g, &bb);
    }
    return FALSE; /* initial */
}

Boolean SvgStyleHasFill(const char *tag)
{
    char b[64];
    word r;
    word g;
    word bb;
    if (SvgStyleResolvePropWithGroups(tag, "fill", b, sizeof(b), FALSE)) {
        return SvgStyleResolvePaintToSolidOrNone(tag, "fill", b, &r, &g, &bb);
    }
    return TRUE; /* initial */
}
