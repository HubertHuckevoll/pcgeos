/***********************************************************************
 * svgStyle.goc — styling: stroke/fill/width/fill-rule & color keywords
 ***********************************************************************/
@include <stdapp.goh>

@include <SVG/colors.goh>

#include <Ansi/string.h>
#include <Ansi/stdlib.h>
#include <Ansi/ctype.h>
#include <file.h>
#include <system.h>
#include <graphics.h>
#include <gstring.h>
#include <meta.h>
#include <float.h>

#include "SVG/svg.h"
#include "SVG/dbglog.h"

/* ---- group style stack (fill/stroke/stroke-width) ---- */
static MemHandle gStyleStackH = NullHandle;
static byte gStyleDepth = 0;

Boolean SvgStyleStackInit(void)
{
    SvgGroupStyle *stack;
    word bytes;

    gStyleDepth = 0;
    bytes = (word)(SVG_STYLE_GSTACK_MAX * sizeof(SvgGroupStyle));

    if (gStyleStackH == NullHandle) {
        gStyleStackH = MemAlloc(bytes, HF_DYNAMIC, HAF_ZERO_INIT);
        if (gStyleStackH == NullHandle) {
            return FALSE;
        }
    }

    stack = (SvgGroupStyle *)MemLock(gStyleStackH);
    if (stack == NULL) {
        SvgStyleStackFree();
        return FALSE;
    }

    MemUnlock(gStyleStackH);
    return TRUE;
}

void SvgStyleStackFree(void)
{
    if (gStyleStackH != NullHandle) {
        MemFree(gStyleStackH);
        gStyleStackH = NullHandle;
    }
    gStyleDepth = 0;
}

/* Maintain the group style stack in movable heap memory. */
static SvgGroupStyle* SvgStyleStackLock(void)
{
    SvgGroupStyle *stack;

    if (gStyleStackH == NullHandle) {
        return NULL;
    }

    stack = (SvgGroupStyle *)MemLock(gStyleStackH);
    if (stack == NULL) {
        SvgStyleStackFree();
    }
    return stack;
}

static void SvgStyleStackUnlock(void)
{
    if (gStyleStackH != NullHandle) {
        MemUnlock(gStyleStackH);
    }
}

static Boolean SvgStyleFindNamedColor(const char *name, word *r, word *g, word *b)
{
    MemHandle       mh;
    SvgNamedColor  *rec;
    word            i, count, elemSize;

    mh = OptrToHandle(@SvgNamedColors);
    ObjLockObjBlock(mh);

    count = ChunkArrayGetCount(@SvgNamedColors);
    for (i = 0; i < count; i++) {
        rec = (SvgNamedColor*) ChunkArrayElementToPtr(@SvgNamedColors, i, &elemSize);
        if (rec && SvgUtilAsciiNoCaseEq(rec->SNC_name, name)) {
            *r = rec->SNC_r; *g = rec->SNC_g; *b = rec->SNC_b;
            MemUnlock(mh);
            return TRUE;
        }
    }
    MemUnlock(mh);
    return FALSE;
}

/* ---- paint resolution: url(#id) fallback or none; solid colors only ---- */

/* Returns TRUE if 'raw' resolves to a solid color and sets r,g,b.
   Returns FALSE if the used value is NONE (includes unresolved url()).
   Supports: "none", "#rgb/#rrggbb", "rgb(...)", named colors,
             "url(#id)" [optional fallback color after ')'].
   Gradients/patterns are not implemented, so any url() without fallback => NONE. */
static Boolean
SvgStyleResolvePaintToSolidOrNone(const char *raw, word *r, word *g, word *b)
{
    const char *p;
    const char *rp;
    word rr;
    word gg;
    word bb;

    if (raw == NULL) { return FALSE; }

    p = SvgUtilSkipSpace(raw);

    if (SvgUtilAsciiNoCaseEq(p, "none")) {
        return FALSE;
    }

    /* url(...)[ fallback]?  Case-insensitive check for "url(" at start */
    if ((p[0]=='u' || p[0]=='U') &&
        (p[1]=='r' || p[1]=='R') &&
        (p[2]=='l' || p[2]=='L') &&
        p[3]=='(')
    {
        /* find ')' */
        rp = p + 4;
        while (*rp && *rp != ')') { rp++; }
        if (*rp == ')') {
            const char *after;
            after = SvgUtilSkipSpace(rp + 1);

            /* No fallback token -> NONE per spec */
            if (*after == 0) {
                return FALSE;
            }

            /* Fallback is present: try to parse as color */
            if (SvgUtilExpandShortHex(after, &rr, &gg, &bb) ||
                (after[0] == '#' && strlen(after) >= 7 &&
                 (rr = SvgUtilHexByte(after + 1), gg = SvgUtilHexByte(after + 3), bb = SvgUtilHexByte(after + 5), 1)) ||
                SvgUtilParseRGBFunc(after, &rr, &gg, &bb) ||
                SvgStyleFindNamedColor(after, &rr, &gg, &bb))
            {
                *r = rr; *g = gg; *b = bb;
                return TRUE;
            }

            /* Fallback token not a color, treat as NONE */
            return FALSE;
        }

        /* Malformed url( -> NONE */
        return FALSE;
    }

    /* direct color */
    if (SvgUtilExpandShortHex(p, &rr, &gg, &bb)) {
        *r = rr; *g = gg; *b = bb;
        return TRUE;
    }
    if (p[0] == '#' && strlen(p) >= 7) {
        *r = SvgUtilHexByte(p + 1);
        *g = SvgUtilHexByte(p + 3);
        *b = SvgUtilHexByte(p + 5);
        return TRUE;
    }
    if (SvgUtilParseRGBFunc(p, &rr, &gg, &bb)) {
        *r = rr; *g = gg; *b = bb;
        return TRUE;
    }
    if (SvgStyleFindNamedColor(p, &rr, &gg, &bb)) {
        *r = rr; *g = gg; *b = bb;
        return TRUE;
    }

    /* Unknown token -> NONE */
    return FALSE;
}


/* ---- group style stuff ---- */

Boolean SvgStyleGroupStrokeWidthGet(WWFixedAsDWord *outW)
{
    SvgGroupStyle *stack;
    Boolean haveWidth;

    if (outW == NULL) { return FALSE; }

    stack = SvgStyleStackLock();
    if (stack == NULL) { return FALSE; }

    haveWidth = FALSE;
    if (gStyleDepth > 0 && stack[gStyleDepth-1].swSet)
    {
        *outW = stack[gStyleDepth-1].strokeWidth;
        haveWidth = TRUE;
    }

    SvgStyleStackUnlock();
    return haveWidth;
}

/* Called on <g ...> */
void SvgStyleGroupPush(const char *tag)
{
    SvgGroupStyle st;
    char buf[64];
    char frBuf[24];
    const char *pwalk;
    SvgGroupStyle *stack;

    stack = SvgStyleStackLock();
    if (stack == NULL) {
        return;
    }

    st.fillSet = FALSE;
    st.strokeSet = FALSE;
    st.swSet = FALSE;
    st.fillVal[0] = 0;
    st.strokeVal[0] = 0;
    st.strokeWidth = SvgGeomMakeWWFixedFromInt(1);

    /* inherit from parent */
    st.frSet = FALSE; st.fr = 0;
    st.lcSet = FALSE; st.lc = 0;
    st.ljSet = FALSE; st.lj = 0;
    if (gStyleDepth > 0) {
        st.frSet = stack[gStyleDepth-1].frSet;
        st.fr    = stack[gStyleDepth-1].fr;
        st.lcSet = stack[gStyleDepth-1].lcSet;
        st.lc    = stack[gStyleDepth-1].lc;
        st.ljSet = stack[gStyleDepth-1].ljSet;
        st.lj    = stack[gStyleDepth-1].lj;
    }

    /* inline style/attributes: fill, stroke */
    if (SvgUtilGetInlineProp(tag, "fill", st.fillVal, sizeof(st.fillVal)) ||
        SvgParserGetAttrBounded(tag, "fill", st.fillVal, sizeof(st.fillVal))) {
        st.fillSet = TRUE;
    }
    if (SvgUtilGetInlineProp(tag, "stroke", st.strokeVal, sizeof(st.strokeVal)) ||
        SvgParserGetAttrBounded(tag, "stroke", st.strokeVal, sizeof(st.strokeVal))) {
        st.strokeSet = TRUE;
    }

    /* stroke-width */
    buf[0] = 0;
    if (!SvgUtilGetInlineProp(tag, "stroke-width", buf, sizeof(buf))) {
        (void)SvgParserGetAttrBounded(tag, "stroke-width", buf, sizeof(buf));
    }
    if (buf[0]) {
        pwalk = buf;
        while (*pwalk && (isdigit((byte)*pwalk) || *pwalk=='+' || *pwalk=='-' || *pwalk=='.')) pwalk++;
        if (pwalk != buf) {
            char save = *pwalk;
            *(char*)pwalk = 0;
            (void)SvgUtilParseWWFixed16_16(buf, &st.strokeWidth);
            *(char*)pwalk = save;
            st.swSet = TRUE;
        }
    }

    /* fill-rule */
    frBuf[0] = 0;
    if (!SvgUtilGetInlineProp(tag, "fill-rule", frBuf, sizeof(frBuf))) {
        (void)SvgParserGetAttrBounded(tag, "fill-rule", frBuf, sizeof(frBuf));
    }
    if (frBuf[0]) {
        if (SvgUtilAsciiNoCaseEq(frBuf, "evenodd")) { st.fr = 1; st.frSet = TRUE; }
        else if (SvgUtilAsciiNoCaseEq(frBuf, "nonzero") || SvgUtilAsciiNoCaseEq(frBuf, "winding")) { st.fr = 0; st.frSet = TRUE; }
        /* inherit/other -> keep */
    }

    /* >>> ADD HERE: stroke-linecap / stroke-linejoin <<< */

    /* stroke-linecap */
    buf[0] = 0;
    if (!SvgUtilGetInlineProp(tag, "stroke-linecap", buf, sizeof(buf))) {
        (void)SvgParserGetAttrBounded(tag, "stroke-linecap", buf, sizeof(buf));
    }
    if (buf[0]) {
        if (SvgUtilAsciiNoCaseEq(buf, "round"))   { st.lc = 1; st.lcSet = TRUE; }
        else if (SvgUtilAsciiNoCaseEq(buf, "square")) { st.lc = 2; st.lcSet = TRUE; }
        else if (SvgUtilAsciiNoCaseEq(buf, "butt"))   { st.lc = 0; st.lcSet = TRUE; }
        /* inherit/other -> keep */
    }

    /* stroke-linejoin */
    buf[0] = 0;
    if (!SvgUtilGetInlineProp(tag, "stroke-linejoin", buf, sizeof(buf))) {
        (void)SvgParserGetAttrBounded(tag, "stroke-linejoin", buf, sizeof(buf));
    }
    if (buf[0]) {
        if (SvgUtilAsciiNoCaseEq(buf, "round"))  { st.lj = 1; st.ljSet = TRUE; }
        else if (SvgUtilAsciiNoCaseEq(buf, "bevel")) { st.lj = 2; st.ljSet = TRUE; }
        else if (SvgUtilAsciiNoCaseEq(buf, "miter")) { st.lj = 0; st.ljSet = TRUE; }
        /* inherit/other -> keep */
    }

    /* push */
    if (gStyleDepth < SVG_STYLE_GSTACK_MAX) {
        stack[gStyleDepth++] = st;
    }

    SvgStyleStackUnlock();
}


void SvgStyleGroupPop(void)
{
    if (gStyleDepth > 0) gStyleDepth--;
}


/* resolve property with group fallback — strings only (fill/stroke) */
static Boolean SvgStyleResolvePropWithGroups(const char *tag,
                                             const char *prop,
                                             char *out, word outSize)
{
    const SvgGroupStyle *gs;
    SvgGroupStyle *stack;
    Boolean result;

    if (outSize == 0) return FALSE;
    out[0] = 0;

    if (SvgUtilGetInlineProp(tag, prop, out, outSize)) return TRUE;
    if (SvgParserGetAttrBounded(tag, prop, out, outSize)) return TRUE;

    if (gStyleDepth == 0) return FALSE;
    stack = SvgStyleStackLock();
    if (stack == NULL) return FALSE;

    gs = &stack[gStyleDepth-1];
    result = FALSE;

    if (!strncmp(prop, "fill", 4) && gs->fillSet)
    {
        strncpy(out, gs->fillVal, outSize-1);
        out[outSize-1] = 0;
        result = TRUE;
        goto done;
    }
    if (!strncmp(prop, "stroke", 6) && gs->strokeSet)
    {
        strncpy(out, gs->strokeVal, outSize-1);
        out[outSize-1] = 0;
        result = TRUE;
        goto done;
    }

done:
    SvgStyleStackUnlock();
    return result;
}

/* ---- public style API ---- */

void SvgStyleApplyStrokeAndFill(const char *tag)
{
    static char sFill[64];
    static char sStroke[64];
    word r;
    word g;
    word b;
    Boolean have;

    sFill[0] = 0;
    sStroke[0] = 0;

    /* stroke; initial = none */
    have = SvgStyleResolvePropWithGroups(tag, "stroke", sStroke, sizeof(sStroke));
    if (have) {
        if (SvgStyleResolvePaintToSolidOrNone(sStroke, &r, &g, &b)) {
            Meta_SetLineColor(CF_RGB, r, g, b);
        }
        /* else NONE: do not set a line color */
    }
    /* else: no property anywhere -> stays NONE */

    /* fill; initial = black */
    have = SvgStyleResolvePropWithGroups(tag, "fill", sFill, sizeof(sFill));
    if (!have) {
        /* property absent -> initial black */
        Meta_SetAreaColor(CF_RGB, 0, 0, 0);
    } else {
        if (SvgStyleResolvePaintToSolidOrNone(sFill, &r, &g, &b)) {
            Meta_SetAreaColor(CF_RGB, r, g, b);
        }
        /* else NONE: do not set an area color */
    }
}


void SvgStyleApplyFillRule(const char *tag)
{
    static char buf[32];
    int useEvenOdd;
    buf[0] = 0;

    /* element-local value wins */
    if (!SvgUtilGetInlineProp(tag, "fill-rule", buf, sizeof(buf)))
    {
        (void)SvgParserGetAttrBounded(tag, "fill-rule", buf, sizeof(buf));
    }

    if (buf[0])
    {
        if (SvgUtilAsciiNoCaseEq(buf, "evenodd")) { Meta_SetFillRule(ODD_EVEN); return; }
        if (SvgUtilAsciiNoCaseEq(buf, "nonzero") || SvgUtilAsciiNoCaseEq(buf, "winding")) { Meta_SetFillRule(WINDING); return; }
        if (SvgUtilAsciiNoCaseEq(buf, "inherit")) { buf[0] = 0; } /* fall through to group */
    }

    /* inherit from current group if present */
    if (gStyleDepth > 0)
    {
        SvgGroupStyle *stack = SvgStyleStackLock();
        if (stack != NULL && stack[gStyleDepth-1].frSet)
        {
            useEvenOdd = (int)stack[gStyleDepth-1].fr;
            SvgStyleStackUnlock();
            if (useEvenOdd) { Meta_SetFillRule(ODD_EVEN); }
            else { Meta_SetFillRule(WINDING); }
            return;
        }
        SvgStyleStackUnlock();
    }

    /* initial */
    Meta_SetFillRule(WINDING);
}


void SvgStyleApplyStrokeWidth(const char *tag)
{
    WWFixedAsDWord lw;
    char b[24];
    const char *pwalk;
    char save;
    Boolean haveWidth;

    /* Try element-local width first */
    b[0] = 0;
    haveWidth = FALSE;

    if (SvgUtilGetInlineProp(tag, "stroke-width", b, sizeof(b)) ||
        SvgParserGetAttrBounded(tag, "stroke-width", b, sizeof(b)))
    {
        pwalk = b;
        while (*pwalk &&
               (isdigit((byte)*pwalk) || *pwalk=='+' || *pwalk=='-' || *pwalk=='.'))
        {
            pwalk++;
        }
        save = *pwalk;
        *(char*)pwalk = 0;
        (void)SvgUtilParseWWFixed16_16(b, &lw);
        *(char*)pwalk = save;
        haveWidth = TRUE;
    }

    /* Else inherit from group */
    if (!haveWidth)
    {
        if (SvgStyleGroupStrokeWidthGet(&lw))
        {
            haveWidth = TRUE;
        }
    }

    /* Else default per SVG */
    if (!haveWidth)
    {
        lw = SvgGeomMakeWWFixedFromInt(1);
    }

    Meta_SetLineWidth(lw);
    SvgStyleApplyStrokeCapJoin(tag);
}

void SvgStyleApplyStrokeCapJoin(const char *tag)
{
    char  b[32];
    byte  lc;
    byte  lj;
    SvgGroupStyle *stack;

    stack = (gStyleDepth > 0) ? SvgStyleStackLock() : NULL;
    /* linecap: element > group > initial(butt) */
    lc = 0;
    b[0] = 0;
    if (!SvgUtilGetInlineProp(tag, "stroke-linecap", b, sizeof(b))) {
        (void)SvgParserGetAttrBounded(tag, "stroke-linecap", b, sizeof(b));
    }
    if (b[0]) {
        if (SvgUtilAsciiNoCaseEq(b, "round")) lc = 1;
        else if (SvgUtilAsciiNoCaseEq(b, "square")) lc = 2;
        else if (SvgUtilAsciiNoCaseEq(b, "inherit")) b[0] = 0;
        /* else butt or unknown -> lc stays 0 */
    }
    if (!b[0] && stack != NULL && stack[gStyleDepth-1].lcSet) {
        lc = stack[gStyleDepth-1].lc;
    }
    Meta_SetLineEnd( (lc==1)? LE_ROUNDCAP : (lc==2)? LE_SQUARECAP : LE_BUTTCAP );

    /* linejoin: element > group > initial(miter) */
    lj = 0;
    b[0] = 0;
    if (!SvgUtilGetInlineProp(tag, "stroke-linejoin", b, sizeof(b))) {
        (void)SvgParserGetAttrBounded(tag, "stroke-linejoin", b, sizeof(b));
    }
    if (b[0]) {
        if (SvgUtilAsciiNoCaseEq(b, "round")) lj = 1;
        else if (SvgUtilAsciiNoCaseEq(b, "bevel")) lj = 2;
        else if (SvgUtilAsciiNoCaseEq(b, "inherit")) b[0] = 0;
        /* else miter or unknown -> lj stays 0 */
    }
    if (!b[0] && stack != NULL && stack[gStyleDepth-1].ljSet) {
        lj = stack[gStyleDepth-1].lj;
    }

    if (stack != NULL) {
        SvgStyleStackUnlock();
    }

    Meta_SetLineJoin( (lj==1) ? LJ_ROUND : ((lj==2)? LJ_BEVELED : LJ_MITERED));
}

Boolean SvgStyleHasStroke(const char *tag)
{
    char b[64];
    word r;
    word g;
    word bb;
    if (SvgStyleResolvePropWithGroups(tag, "stroke", b, sizeof(b))) {
        return SvgStyleResolvePaintToSolidOrNone(b, &r, &g, &bb);
    }
    return FALSE; /* initial */
}

Boolean SvgStyleHasFill(const char *tag)
{
    char b[64];
    word r;
    word g;
    word bb;
    if (SvgStyleResolvePropWithGroups(tag, "fill", b, sizeof(b))) {
        return SvgStyleResolvePaintToSolidOrNone(b, &r, &g, &bb);
    }
    return TRUE; /* initial */
}
