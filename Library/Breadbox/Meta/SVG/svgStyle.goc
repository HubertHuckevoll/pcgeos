/***********************************************************************
 * svgStyle.goc â€” styling: stroke/fill/width/fill-rule & color keywords
 ***********************************************************************/
@include <stdapp.goh>

#include <Ansi/string.h>
#include <Ansi/stdlib.h>
#include <Ansi/ctype.h>
#include <file.h>
#include <system.h>
#include <graphics.h>
#include <gstring.h>
#include <meta.h>
#include <float.h>

#include "SVG/svg.h"
#include "SVG/dbglog.h"


/* ---- group style stack (fill/stroke/stroke-width) ---- */
static SvgGroupStyle gStyleStack[SVG_STYLE_GSTACK_MAX];
static int gStyleDepth = 0;


/* ---------- tiny hex helpers (style-local) ---------- */
static word SvgStyleHexNibble(char c)
{
    if (c >= '0' && c <= '9') return (word)(c - '0');
    if (c >= 'A' && c <= 'F') return (word)(10 + (c - 'A'));
    if (c >= 'a' && c <= 'f') return (word)(10 + (c - 'a'));
    return 0;
}
static word SvgStyleHexByte(const char *p)
{
    return (word)((SvgStyleHexNibble(p[0]) << 4) | SvgStyleHexNibble(p[1]));
}

/* ---- color keyword resource ---- */
@start MetaSvgNamedColorRes, data;

@chunkArray SvgNamedColor SvgNamedColors = {
    {240,248,255,"aliceblue"},
    {250,235,215,"antiquewhite"},
    {  0,255,255,"aqua"},
    {127,255,212,"aquamarine"},
    {240,255,255,"azure"},
    {245,245,220,"beige"},
    {255,228,196,"bisque"},
    {  0,  0,  0,"black"},
    {255,235,205,"blanchedalmond"},
    {  0,  0,255,"blue"},
    {138, 43,226,"blueviolet"},
    {165, 42, 42,"brown"},
    {222,184,135,"burlywood"},
    { 95,158,160,"cadetblue"},
    {127,255,  0,"chartreuse"},
    {210,105, 30,"chocolate"},
    {255,127, 80,"coral"},
    {100,149,237,"cornflowerblue"},
    {255,248,220,"cornsilk"},
    {220, 20, 60,"crimson"},
    {  0,255,255,"cyan"},
    {  0,  0,139,"darkblue"},
    {  0,139,139,"darkcyan"},
    {184,134, 11,"darkgoldenrod"},
    {169,169,169,"darkgray"},
    {  0,100,  0,"darkgreen"},
    {169,169,169,"darkgrey"},
    {189,183,107,"darkkhaki"},
    {139,  0,139,"darkmagenta"},
    { 85,107, 47,"darkolivegreen"},
    {255,140,  0,"darkorange"},
    {153, 50,204,"darkorchid"},
    {139,  0,  0,"darkred"},
    {233,150,122,"darksalmon"},
    {143,188,143,"darkseagreen"},
    { 72, 61,139,"darkslateblue"},
    { 47, 79, 79,"darkslategray"},
    { 47, 79, 79,"darkslategrey"},
    {  0,206,209,"darkturquoise"},
    {148,  0,211,"darkviolet"},
    {255, 20,147,"deeppink"},
    {  0,191,255,"deepskyblue"},
    {105,105,105,"dimgray"},
    {105,105,105,"dimgrey"},
    { 30,144,255,"dodgerblue"},
    {178, 34, 34,"firebrick"},
    {255,250,240,"floralwhite"},
    { 34,139, 34,"forestgreen"},
    {255,  0,255,"fuchsia"},
    {220,220,220,"gainsboro"},
    {248,248,255,"ghostwhite"},
    {255,215,  0,"gold"},
    {218,165, 32,"goldenrod"},
    {128,128,128,"gray"},
    {128,128,128,"grey"},
    {  0,128,  0,"green"},
    {173,255, 47,"greenyellow"},
    {240,255,240,"honeydew"},
    {255,105,180,"hotpink"},
    {205, 92, 92,"indianred"},
    { 75,  0,130,"indigo"},
    {255,255,240,"ivory"},
    {240,230,140,"khaki"},
    {230,230,250,"lavender"},
    {255,240,245,"lavenderblush"},
    {124,252,  0,"lawngreen"},
    {255,250,205,"lemonchiffon"},
    {173,216,230,"lightblue"},
    {240,128,128,"lightcoral"},
    {224,255,255,"lightcyan"},
    {250,250,210,"lightgoldenrodyellow"},
    {211,211,211,"lightgray"},
    {144,238,144,"lightgreen"},
    {211,211,211,"lightgrey"},
    {255,182,193,"lightpink"},
    {255,160,122,"lightsalmon"},
    { 32,178,170,"lightseagreen"},
    {135,206,250,"lightskyblue"},
    {119,136,153,"lightslategray"},
    {119,136,153,"lightslategrey"},
    {176,196,222,"lightsteelblue"},
    {255,255,224,"lightyellow"},
    {  0,255,  0,"lime"},
    { 50,205, 50,"limegreen"},
    {250,240,230,"linen"},
    {255,  0,255,"magenta"},
    {128,  0,  0,"maroon"},
    {102,205,170,"mediumaquamarine"},
    {  0,  0,205,"mediumblue"},
    {186, 85,211,"mediumorchid"},
    {147,112,219,"mediumpurple"},
    { 60,179,113,"mediumseagreen"},
    {123,104,238,"mediumslateblue"},
    {  0,250,154,"mediumspringgreen"},
    { 72,209,204,"mediumturquoise"},
    {199, 21,133,"mediumvioletred"},
    { 25, 25,112,"midnightblue"},
    {245,255,250,"mintcream"},
    {255,228,225,"mistyrose"},
    {255,228,181,"moccasin"},
    {255,222,173,"navajowhite"},
    {  0,  0,128,"navy"},
    {253,245,230,"oldlace"},
    {128,128,  0,"olive"},
    {107,142, 35,"olivedrab"},
    {255,165,  0,"orange"},
    {255, 69,  0,"orangered"},
    {218,112,214,"orchid"},
    {238,232,170,"palegoldenrod"},
    {152,251,152,"palegreen"},
    {175,238,238,"paleturquoise"},
    {219,112,147,"palevioletred"},
    {255,239,213,"papayawhip"},
    {255,218,185,"peachpuff"},
    {205,133, 63,"peru"},
    {255,192,203,"pink"},
    {221,160,221,"plum"},
    {176,224,230,"powderblue"},
    {128,  0,128,"purple"},
    {255,  0,  0,"red"},
    {188,143,143,"rosybrown"},
    { 65,105,225,"royalblue"},
    {139, 69, 19,"saddlebrown"},
    {250,128,114,"salmon"},
    {244,164, 96,"sandybrown"},
    { 46,139, 87,"seagreen"},
    {255,245,238,"seashell"},
    {160, 82, 45,"sienna"},
    {192,192,192,"silver"},
    {135,206,235,"skyblue"},
    {106, 90,205,"slateblue"},
    {112,128,144,"slategray"},
    {112,128,144,"slategrey"},
    {255,250,250,"snow"},
    {  0,255,127,"springgreen"},
    { 70,130,180,"steelblue"},
    {210,180,140,"tan"},
    {  0,128,128,"teal"},
    {216,191,216,"thistle"},
    {255, 99, 71,"tomato"},
    { 64,224,208,"turquoise"},
    {238,130,238,"violet"},
    {245,222,179,"wheat"},
    {255,255,255,"white"},
    {245,245,245,"whitesmoke"},
    {255,255,  0,"yellow"},
    {154,205, 50,"yellowgreen"}
};

@end MetaSvgNamedColorRes;

/* ---- color parsing helpers ---- */
static Boolean SvgStyleExpandShortHex(const char *s, word *r, word *g, word *b)
{
    if (s[0] == '#' && strlen(s) == 4) {
        char hh[7];
        hh[0] = '#';
        hh[1] = s[1]; hh[2] = s[1];
        hh[3] = s[2]; hh[4] = s[2];
        hh[5] = s[3]; hh[6] = s[3];
        *r = SvgStyleHexByte(hh + 1);
        *g = SvgStyleHexByte(hh + 3);
        *b = SvgStyleHexByte(hh + 5);
        return TRUE;
    }
    return FALSE;
}

static Boolean SvgStyleParseRGBFunc(const char *s, word *r, word *g, word *b)
{
    const char *p;
    int v1;
    int v2;
    int v3;
    int isPct;

    p = strstr(s, "rgb(");
    if (!p) {
        return FALSE;
    }
    p += 4;

    isPct = 0;
    v1 = atoi(p);
    while (*p && *p != ',' && *p != ')' && *p != '%') p++;
    if (*p == '%') { isPct = 1; p++; }
    if (*p == ',') p++;
    v2 = atoi(p);
    while (*p && *p != ',' && *p != ')' && *p != '%') p++;
    if (*p == '%') { isPct = 1; p++; }
    if (*p == ',') p++;
    v3 = atoi(p);
    while (*p && *p != ')' && *p != '%') p++;
    if (*p == '%') { isPct = 1; }

    if (isPct) {
        if (v1 < 0) v1 = 0; if (v1 > 100) v1 = 100;
        if (v2 < 0) v2 = 0; if (v2 > 100) v2 = 100;
        if (v3 < 0) v3 = 0; if (v3 > 100) v3 = 100;
        *r = (word)((v1 * 255) / 100);
        *g = (word)((v2 * 255) / 100);
        *b = (word)((v3 * 255) / 100);
    } else {
        if (v1 < 0) v1 = 0; if (v1 > 255) v1 = 255;
        if (v2 < 0) v2 = 0; if (v2 > 255) v2 = 255;
        if (v3 < 0) v3 = 0; if (v3 > 255) v3 = 255;
        *r = (word)v1; *g = (word)v2; *b = (word)v3;
    }
    return TRUE;
}

static Boolean SvgStyleFindNamedColor(const char *name, word *r, word *g, word *b)
{
    MemHandle       mh;
    SvgNamedColor  *rec;
    word            i, count, elemSize;

    mh = OptrToHandle(@SvgNamedColors);
    ObjLockObjBlock(mh);

    count = ChunkArrayGetCount(@SvgNamedColors);
    for (i = 0; i < count; i++) {
        rec = (SvgNamedColor*) ChunkArrayElementToPtr(@SvgNamedColors, i, &elemSize);
        if (rec && SvgUtilAsciiNoCaseEq(rec->SNC_name, name)) {
            *r = rec->SNC_r; *g = rec->SNC_g; *b = rec->SNC_b;
            MemUnlock(mh);
            return TRUE;
        }
    }
    MemUnlock(mh);
    return FALSE;
}


/* -------- inline style="a:b; c:d" parser (case-insensitive) -------- */

static Boolean SvgStyleKeyEqNoCase(const char *kb, const char *ke,
                                   const char *prop)
{
    const char *p;
    const char *k;

    p = prop;
    k = kb;
    while (k < ke && *p) {
        char kc, pc;
        kc = *k++; pc = *p++;
        if (kc >= 'A' && kc <= 'Z') kc = (char)(kc + ('a' - 'A'));
        if (pc >= 'A' && pc <= 'Z') pc = (char)(pc + ('a' - 'A'));
        if (kc != pc) return FALSE;
    }
    return (k == ke && *p == 0);
}

/* Extract a property value from style="..."; returns FALSE if absent. */
static Boolean SvgStyleGetInlineProp(const char *tag,
                                     const char *prop,
                                     char *out, word outSize)
{
    char styleBuf[192];
    const char *s;
    const char *kb;  /* key begin   */
    const char *ke;  /* key end     */
    const char *vb;  /* value begin */
    const char *ve;  /* value end   */
    word n;

    if (outSize == 0) return FALSE;
    out[0] = 0;

    if (!SvgParserGetAttrBounded(tag, "style", styleBuf, sizeof(styleBuf)))
        return FALSE;

    s = styleBuf;
    for (;;) {
        while (*s == ';' || isspace((byte)*s)) s++;
        if (!*s) break;

        kb = s;
        while (*s && *s != ':' && *s != ';') s++;
        if (*s != ':') {
            while (*s && *s != ';') s++;
            if (*s == ';') s++;
            continue;
        }
        ke = s;
        s++; /* past ':' */

        while (*s && isspace((byte)*s)) s++;
        vb = s;
        while (*s && *s != ';') s++;
        ve = s;
        while (ve > vb && isspace((byte)ve[-1])) ve--;

        if (SvgStyleKeyEqNoCase(kb, ke, prop)) {
            n = (word)(ve - vb);
            if (n >= outSize) n = (word)(outSize - 1);
            if (n > 0) memcpy(out, vb, n);
            out[n] = 0;
            return TRUE;
        }
        if (*s == ';') s++;
    }
    return FALSE;
}

/* ---- group style stuff ---- */

Boolean SvgStyleGroupStrokeWidthGet(WWFixedAsDWord *outW)
{
    if (outW == NULL) { return FALSE; }
    if (gStyleDepth > 0 && gStyleStack[gStyleDepth-1].swSet)
    {
        *outW = gStyleStack[gStyleDepth-1].strokeWidth;
        return TRUE;
    }
    return FALSE;
}

/* Called on <g ...> */
void SvgStyleGroupPush(const char *tag)
{
    SvgGroupStyle st;
    char buf[64];
    const char *pwalk;

    st.fillSet = FALSE;
    st.strokeSet = FALSE;
    st.swSet = FALSE;
    st.fillVal[0] = 0;
    st.strokeVal[0] = 0;
    st.strokeWidth = SvgGeomMakeWWFixedFromInt(1);

    /* inline style= takes precedence within the tag, so read both */
    if (SvgStyleGetInlineProp(tag, "fill", st.fillVal, sizeof(st.fillVal)) ||
        SvgParserGetAttrBounded(tag, "fill", st.fillVal, sizeof(st.fillVal)))
    {
        st.fillSet = TRUE;
    }
    if (SvgStyleGetInlineProp(tag, "stroke", st.strokeVal, sizeof(st.strokeVal)) ||
        SvgParserGetAttrBounded(tag, "stroke", st.strokeVal, sizeof(st.strokeVal)))
    {
        st.strokeSet = TRUE;
    }
    buf[0] = 0;
    if (!SvgStyleGetInlineProp(tag, "stroke-width", buf, sizeof(buf)))
    {
        (void)SvgParserGetAttrBounded(tag, "stroke-width", buf, sizeof(buf));
    }
    if (buf[0])
    {
        pwalk = buf;
        while (*pwalk && (isdigit((byte)*pwalk) || *pwalk=='+' || *pwalk=='-' || *pwalk=='.')) pwalk++;
        if (pwalk != buf)
        {
            char save;
            save = *pwalk;
            *(char*)pwalk = 0;
            (void)SvgParserParseWWFixed16_16(buf, &st.strokeWidth);
            *(char*)pwalk = save;
            st.swSet = TRUE;
        }
    }

    if (gStyleDepth < SVG_STYLE_GSTACK_MAX)
    {
        gStyleStack[gStyleDepth++] = st;
    }
}

/* Called on </g> */
void SvgStyleGroupPop(void)
{
    if (gStyleDepth > 0) gStyleDepth--;
}

/* resolve property with group fallback */
static Boolean SvgStyleResolvePropWithGroups(const char *tag, const char *prop, char *out, word outSize)
{
    if (outSize == 0) return FALSE;
    out[0] = 0;

    if (SvgStyleGetInlineProp(tag, prop, out, outSize)) return TRUE;
    if (SvgParserGetAttrBounded(tag, prop, out, outSize)) return TRUE;

    if (gStyleDepth > 0)
    {
        const SvgGroupStyle *gs;
        gs = &gStyleStack[gStyleDepth-1];
        if (!strncmp(prop, "fill", 4) && gs->fillSet)
        {
            strncpy(out, gs->fillVal, outSize-1);
            out[outSize-1] = 0;
            return TRUE;
        }
        if (!strncmp(prop, "stroke", 6) && gs->strokeSet)
        {
            strncpy(out, gs->strokeVal, outSize-1);
            out[outSize-1] = 0;
            return TRUE;
        }
        if (!strncmp(prop, "stroke-width", 12) && gs->swSet)
        {
            /* serialize fixed to decimal minimally; consumers only test presence */
            WWFixedAsDWord w;
            int v;
            w = gs->strokeWidth;
            v = SvgGeomWWFixedToSWordRound(w);
            sprintf(out, outSize, "%d", (int)v);
            return TRUE;
        }
    }
    return FALSE;
}


/* ---- public style API ---- */

void SvgStyleApplyStrokeAndFill(const char *tag)
{
    static char sFill[64];
    static char sStroke[64];
    word r;
    word g;
    word b;

    sFill[0] = 0;
    sStroke[0] = 0;

    /* stroke; initial value none */
    if (!SvgStyleResolvePropWithGroups(tag, "stroke", sStroke, sizeof(sStroke)))
    {
        sStroke[0] = 0; /* remains none */
    }
    if (sStroke[0] && strcmp(sStroke, "none") != 0)
    {
        if (sStroke[0] == '#' && strlen(sStroke) >= 7)
        {
            Meta_SetLineColor(CF_RGB, SvgStyleHexByte(sStroke + 1), SvgStyleHexByte(sStroke + 3), SvgStyleHexByte(sStroke + 5));
        }
        else if (SvgStyleExpandShortHex(sStroke, &r, &g, &b) || SvgStyleParseRGBFunc(sStroke, &r, &g, &b) || SvgStyleFindNamedColor(sStroke, &r, &g, &b))
        {
            Meta_SetLineColor(CF_RGB, r, g, b);
        }
    }

    /* fill; initial value black */
    if (!SvgStyleResolvePropWithGroups(tag, "fill", sFill, sizeof(sFill)))
    {
        /* default */
        Meta_SetAreaColor(CF_RGB, 0, 0, 0);
    }
    else if (strcmp(sFill, "none") != 0)
    {
        if (sFill[0] == '#' && strlen(sFill) >= 7)
        {
            Meta_SetAreaColor(CF_RGB, SvgStyleHexByte(sFill + 1), SvgStyleHexByte(sFill + 3), SvgStyleHexByte(sFill + 5));
        }
        else if (SvgStyleExpandShortHex(sFill, &r, &g, &b) || SvgStyleParseRGBFunc(sFill, &r, &g, &b) || SvgStyleFindNamedColor(sFill, &r, &g, &b))
        {
            Meta_SetAreaColor(CF_RGB, r, g, b);
        }
    }
    /* else: fill="none" -> no area color set */
}

void SvgStyleApplyFillRule(const char *tag)
{
    static char buf[32];
    buf[0] = 0;
    if (!SvgStyleGetInlineProp(tag, "fill-rule", buf, sizeof(buf)))
    {
        (void)SvgParserGetAttrBounded(tag, "fill-rule", buf, sizeof(buf));
    }
    if (buf[0] && !strcmp(buf, "evenodd")) { Meta_SetFillRule(ODD_EVEN); }
    else { Meta_SetFillRule(WINDING); }
}

void SvgStyleApplyStrokeWidth(const char *tag)
{
    WWFixedAsDWord lw;
    char b[24];
    const char *pwalk;
    char save;
    Boolean haveWidth;

    /* Try element-local width first */
    b[0] = 0;
    haveWidth = FALSE;

    if (SvgStyleGetInlineProp(tag, "stroke-width", b, sizeof(b)) ||
        SvgParserGetAttrBounded(tag, "stroke-width", b, sizeof(b)))
    {
        pwalk = b;
        while (*pwalk &&
               (isdigit((byte)*pwalk) || *pwalk=='+' || *pwalk=='-' || *pwalk=='.'))
        {
            pwalk++;
        }
        save = *pwalk;
        *(char*)pwalk = 0;
        (void)SvgParserParseWWFixed16_16(b, &lw);
        *(char*)pwalk = save;
        haveWidth = TRUE;
    }

    /* Else inherit from group */
    if (!haveWidth)
    {
        if (SvgStyleGroupStrokeWidthGet(&lw))
        {
            haveWidth = TRUE;
        }
    }

    /* Else default per SVG */
    if (!haveWidth)
    {
        lw = SvgGeomMakeWWFixedFromInt(1);
    }

    Meta_SetLineWidth(lw);
}


Boolean SvgStyleHasStroke(const char *tag)
{
    char b[64];
    if (SvgStyleResolvePropWithGroups(tag, "stroke", b, sizeof(b)))
        return strcmp(b, "none") != 0;
    return FALSE; /* SVG initial */
}

Boolean SvgStyleHasFill(const char *tag)
{
    char b[64];
    if (SvgStyleResolvePropWithGroups(tag, "fill", b, sizeof(b)))
        return strcmp(b, "none") != 0;
    return TRUE; /* SVG initial */
}
