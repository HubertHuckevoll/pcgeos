/***********************************************************************
 * svgParse.goc â€” low-level parser helpers
 ***********************************************************************/
@include <stdapp.goh>

#include <Ansi/string.h>
#include <Ansi/ctype.h>
#include <file.h>

#include "SVG/svg.h"


/* skip common ASCII whitespace characters */
const char* SvgParserSkipWS(const char *p)
{
    while (*p == ' ' || *p == '\t' || *p == '\r' || *p == '\n') { p++; }
    return p;
}

/* skip whitespace, optional comma, then whitespace again */
const char* SvgParserSkipCommaWS(const char *p)
{
    p = SvgParserSkipWS(p);
    if (*p == ',')
    {
        p++;
        p = SvgParserSkipWS(p);
    }
    return p;
}

Boolean SvgParserGetAttrBounded(const char *tag, const char *name,
                                char *out, word outSize)
{
    const char *s;
    word        nlen;

    if (outSize == 0) return FALSE;
    out[0] = 0;

    s = tag;
    while (*s && !isspace(*s) && *s != '>' && *s != '/')
    {
        s++;
    }

    nlen = (word)strlen(name);

    while (*s && *s != '>')
    {
        const char *an;
        word        alen;

        while (*s && (isspace(*s) || *s == '/'))
        {
            s++;
        }
        if (!*s || *s == '>')
        {
            break;
        }

        an = s;
        alen = 0;

        while (*s && *s != '=' && !isspace(*s) && *s != '>' && *s != '/')
        {
            s++;
            alen++;
        }

        if (alen == nlen && !memcmp(an, name, nlen))
        {
            while (*s && isspace(*s)) s++;
            if (*s != '=') return FALSE;
            s++;
            while (*s && isspace(*s)) s++;

            if (*s == '"' || *s == '\'')
            {
                char  q;
                word  i;

                q = *s++;
                i = 0;
                while (*s && *s != q && i < (outSize - 1))
                {
                    out[i++] = *s++;
                }
                out[i] = 0;
                if (*s == q) s++;
            }
            else
            {
                word i;
                i = 0;
                while (*s && !isspace(*s) && *s != '>' && i < (outSize - 1))
                {
                    out[i++] = *s++;
                }
                out[i] = 0;
            }
            return TRUE;
        }
        else
        {
            while (*s && isspace(*s)) s++;
            if (*s == '=')
            {
                s++;
                while (*s && isspace(*s)) s++;
                if (*s == '"' || *s == '\'')
                {
                    char q = *s++;
                    while (*s && *s != q) s++;
                    if (*s == q) s++;
                }
                else
                {
                    while (*s && !isspace(*s) && *s != '>') s++;
                }
            }
        }
    }
    return FALSE;
}

Boolean SvgParserTagIs(const char *tag, const char *name)
{
    const char *s;
    const char *n;

    s = tag;
    n = name;
    while (*s && !isspace(*s) && *s != '/' && *s != '>')
    {
        if (*n == 0 || *s != *n)
        {
            return FALSE;
        }
        s++;
        n++;
    }
    return (*n == 0);
}

void SvgParserScanInit(SvgScanCtx *c)
{
    c->ioH = 0;
    c->ioP = NULL;
    c->bytes = 0;
    c->pos = 0;
    c->inTag = FALSE;
    c->inQuote = FALSE;
    c->quoteCh = 0;
    c->tagLen = 0;
}

Boolean SvgParserScanNextTag(FileHandle fh, SvgScanCtx *c, SVGScratch *sc)
{
    for (;;)
    {
        if (c->pos >= c->bytes)
        {
            word r;

            if (!c->ioP) return FALSE;
            r = FileRead(fh, (void*)c->ioP, SVG_IO_BUF_SIZE, FALSE);
            if (r == (word)-1 || r == 0) return FALSE;
            c->bytes = r;
            c->pos   = 0;
        }

        {
            char ch;
            ch = c->ioP[c->pos++];

            if (!c->inTag)
            {
                if (ch == '<')
                {
                    c->inTag = TRUE;
                    c->inQuote = FALSE;
                    c->quoteCh = 0;
                    c->tagLen = 0;
                }
                continue;
            }

            if (c->inQuote)
            {
                if (ch == c->quoteCh) c->inQuote = FALSE;
                if (c->tagLen < (TAG_BUF_SIZE-1)) sc->tag[c->tagLen++] = ch;
                continue;
            }
            else
            {
                if (ch == '"' || ch == '\'')
                {
                    c->inQuote = TRUE;
                    c->quoteCh = ch;
                    if (c->tagLen < (TAG_BUF_SIZE-1)) sc->tag[c->tagLen++] = ch;
                    continue;
                }
                if (ch != '>')
                {
                    if (c->tagLen < (TAG_BUF_SIZE-1)) sc->tag[c->tagLen++] = ch;
                    continue;
                }

                sc->tag[c->tagLen] = 0;
                c->inTag = FALSE;
                return TRUE;
            }
        }
    }
}

Boolean SvgParseGetInlineStyleProp(const char *tag, const char *prop,
                             char *out, word outSize)
{
    char styleBuf[192];
    const char *s;
    const char *kb;
    const char *ke;
    const char *vb;
    const char *ve;
    word n;

    if (outSize == 0) return FALSE;
    out[0] = 0;

    if (!SvgParserGetAttrBounded(tag, "style", styleBuf, sizeof(styleBuf)))
        return FALSE;

    s = styleBuf;
    for (;;) {
        while (*s == ';' || isspace((byte)*s)) s++;
        if (!*s) break;

        kb = s;
        while (*s && *s != ':' && *s != ';') s++;
        if (*s != ':') {
            while (*s && *s != ';') s++;
            if (*s == ';') s++;
            continue;
        }
        ke = s;
        s++;

        while (*s && isspace((byte)*s)) s++;
        vb = s;
        while (*s && *s != ';') s++;
        ve = s;
        while (ve > vb && isspace((byte)ve[-1])) ve--;

        if (SvgUtilKeyEqNoCase(kb, ke, prop)) {
            n = (word)(ve - vb);
            if (n >= outSize) n = (word)(outSize - 1);
            if (n > 0) memcpy(out, vb, n);
            out[n] = 0;
            return TRUE;
        }
        if (*s == ';') s++;
    }
    return FALSE;
}
