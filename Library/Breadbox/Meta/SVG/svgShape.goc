/***********************************************************************
 * svgShape.goc — simple SVG elements: line/polyline/polygon/rect/ellipse/circle
 ***********************************************************************/
@include <stdapp.goh>

#include <Ansi/string.h>
#include <Ansi/stdlib.h>
#include <Ansi/ctype.h>
#include <file.h>
#include <system.h>
#include <graphics.h>
#include <gstring.h>
#include <meta.h>
#include <float.h>

#include "SVG/svg.h"
#include "SVG/dbglog.h"

/* ---- points parser (axis-aware) ---- */
void SvgShapeParsePoints(const char *points, SVGScratch *sc, word *numPointsP)
{
    const char *s;
    sword       x;
    sword       y;

    s = points;
    *numPointsP = 0;

    while (*s)
    {
        s = SvgParserSkipWS(s);
        if (!*s) break;

        {
            WWFixedAsDWord f;
            const char *p;
            p = SvgUtilParseWWFixed16_16(s, &f);
            x = SvgViewMapPosX_F(f);
            while (*p) {
                if (*p == ' ' || *p == ',' || *p == '\t' ||
                    *p == '\r' || *p == '\n' ||
                    *p == 'Z' || *p == 'z' ||
                    isalpha((byte)*p)) break;
                p++;
            }
            s = p;
        }

        if (*s == ',') s++;
        s = SvgParserSkipWS(s);

        {
            WWFixedAsDWord f;
            const char *p;
            p = SvgUtilParseWWFixed16_16(s, &f);
            y = SvgViewMapPosY_F(f);
            while (*p) {
                if (*p == ' ' || *p == ',' || *p == '\t' ||
                    *p == '\r' || *p == '\n' ||
                    *p == 'Z' || *p == 'z' ||
                    isalpha((byte)*p)) break;
                p++;
            }
            s = p;
        }

        if (!SvgScratchEnsurePointCapacity(sc, (word)(*numPointsP + 1)))
        {
            LOG_STR("[SHAPE]", "ParsePoints: ensure failed");
            break;
        }

        sc->ptsP[*numPointsP].P_x = x;
        sc->ptsP[*numPointsP].P_y = y;
        (*numPointsP)++;

        while (*s && (isspace(*s) || *s == ',')) s++;
    }
}

/* ---- simple tag handlers ---- */

void SvgShapeHandleLine(const char *tag)
{
    static char     xb[32], yb[32], x2b[32], y2b[32];
    WWFixedAsDWord  fx1;
    WWFixedAsDWord  fy1;
    WWFixedAsDWord  fx2;
    WWFixedAsDWord  fy2;
    SvgMatrix       ctm;
    sword           x1w;
    sword           y1w;
    sword           x2w;
    sword           y2w;

    fx1 = MakeWWFixed(0);
    fy1 = MakeWWFixed(0);
    fx2 = MakeWWFixed(0);
    fy2 = MakeWWFixed(0);

    if (SvgParserGetAttrBounded(tag, "x1", xb, sizeof(xb)))
    {
        (void)SvgUtilParseWWFixed16_16(xb, &fx1);
    }
    if (SvgParserGetAttrBounded(tag, "y1", yb, sizeof(yb)))
    {
        (void)SvgUtilParseWWFixed16_16(yb, &fy1);
    }
    if (SvgParserGetAttrBounded(tag, "x2", x2b, sizeof(x2b)))
    {
        (void)SvgUtilParseWWFixed16_16(x2b, &fx2);
    }
    if (SvgParserGetAttrBounded(tag, "y2", y2b, sizeof(y2b)))
    {
        (void)SvgUtilParseWWFixed16_16(y2b, &fy2);
    }

    SvgStyleApplyStrokeAndFill(tag);
    SvgStyleApplyStrokeWidth(tag);

    /* world CTM = View ∘ Element (parent CTM omitted here) */
    SvgXformBuildWorld(tag, NULL, &ctm);

    /* apply CTM to the two points (do math in 16.16 for precision) */
    {
        WWFixedAsDWord X, Y, Xp, Yp;

        X  = fx1; Y  = fy1;
        Xp = GrAddWWFixed(GrAddWWFixed(GrMulWWFixed(ctm.a, X), GrMulWWFixed(ctm.c, Y)), ctm.e);
        Yp = GrAddWWFixed(GrAddWWFixed(GrMulWWFixed(ctm.b, X), GrMulWWFixed(ctm.d, Y)), ctm.f);
        x1w = SvgGeomWWFixedToSWordRound(Xp);
        y1w = SvgGeomWWFixedToSWordRound(Yp);

        X  = fx2; Y  = fy2;
        Xp = GrAddWWFixed(GrAddWWFixed(GrMulWWFixed(ctm.a, X), GrMulWWFixed(ctm.c, Y)), ctm.e);
        Yp = GrAddWWFixed(GrAddWWFixed(GrMulWWFixed(ctm.b, X), GrMulWWFixed(ctm.d, Y)), ctm.f);
        x2w = SvgGeomWWFixedToSWordRound(Xp);
        y2w = SvgGeomWWFixedToSWordRound(Yp);
    }

    Meta_Line(x1w, y1w, x2w, y2w);
}


void SvgShapeHandlePolyline(const char *tag, SVGScratch *sc)
{
    word      np;
    word      i;
    SvgMatrix worldM;

    sc->pb[0] = 0;
    if (SvgParserGetAttrBounded(tag, "points", sc->pb, sizeof(sc->pb)))
    {
        SvgStyleApplyStrokeAndFill(tag);
        SvgStyleApplyStrokeWidth(tag);

        /* parse points in user space */
        SvgShapeParsePoints(sc->pb, sc, &np);
        if (np > 1)
        {
            /* use full world CTM: View ∘ Group ∘ Element */
            SvgXformBuildWorld(tag, NULL, &worldM);

            for (i = 0; i < np; i++) {
                sword px = sc->ptsP[i].P_x;
                sword py = sc->ptsP[i].P_y;
                SvgXformApplyPoint(&px, &py, &worldM);
                sc->ptsP[i].P_x = px;
                sc->ptsP[i].P_y = py;
            }

            Meta_Polyline(sc->ptsP, np);
        }
    }
}


void SvgShapeHandlePolygon(const char *tag, SVGScratch *sc)
{
    word      np;
    word      i;
    SvgMatrix worldM;

    sc->pb[0] = 0;
    if (SvgParserGetAttrBounded(tag, "points", sc->pb, sizeof(sc->pb)))
    {
        SvgStyleApplyStrokeAndFill(tag);
        SvgStyleApplyFillRule(tag);
        SvgStyleApplyStrokeWidth(tag);

        /* parse points in user space */
        SvgShapeParsePoints(sc->pb, sc, &np);
        if (np > 2)
        {
            /* use full world CTM: View ∘ Group ∘ Element */
            SvgXformBuildWorld(tag, NULL, &worldM);

            for (i = 0; i < np; i++) {
                sword px = sc->ptsP[i].P_x;
                sword py = sc->ptsP[i].P_y;
                SvgXformApplyPoint(&px, &py, &worldM);
                sc->ptsP[i].P_x = px;
                sc->ptsP[i].P_y = py;
            }

            Meta_Polygon(sc->ptsP, np, SvgStyleHasFill(tag), SvgStyleHasStroke(tag));
        }
    }
}


void SvgShapeHandleRect(const char *tag)
{
    static char     xb[32], yb[32], wb[32], hb[32];
    WWFixedAsDWord  fx;
    WWFixedAsDWord  fy;
    WWFixedAsDWord  fw;
    WWFixedAsDWord  fh;
    SvgMatrix       ctm;
    Point           pts[4];
    WWFixedAsDWord  X, Y, Xp, Yp;
    Boolean        hasWidth;
    Boolean        hasHeight;

    fx = MakeWWFixed(0);
    fy = MakeWWFixed(0);

    hasWidth = SvgParserGetAttrBounded(tag, "width", wb, sizeof(wb));
    hasHeight = SvgParserGetAttrBounded(tag, "height", hb, sizeof(hb));
    if (!hasWidth || !hasHeight)
    {
        return;
    }

    (void)SvgUtilParseWWFixed16_16(wb, &fw);
    (void)SvgUtilParseWWFixed16_16(hb, &fh);

    if (SvgParserGetAttrBounded(tag, "x", xb, sizeof(xb)))
    {
        (void)SvgUtilParseWWFixed16_16(xb, &fx);
    }
    if (SvgParserGetAttrBounded(tag, "y", yb, sizeof(yb)))
    {
        (void)SvgUtilParseWWFixed16_16(yb, &fy);
    }

    SvgStyleApplyStrokeAndFill(tag);
    SvgStyleApplyFillRule(tag);
    SvgStyleApplyStrokeWidth(tag);

    SvgXformBuildWorld(tag, NULL, &ctm);

    /* p0 = (x,      y)      */
    X = fx;            Y = fy;
    Xp = GrAddWWFixed(GrAddWWFixed(GrMulWWFixed(ctm.a, X), GrMulWWFixed(ctm.c, Y)), ctm.e);
    Yp = GrAddWWFixed(GrAddWWFixed(GrMulWWFixed(ctm.b, X), GrMulWWFixed(ctm.d, Y)), ctm.f);
    pts[0].P_x = SvgGeomWWFixedToSWordRound(Xp);
    pts[0].P_y = SvgGeomWWFixedToSWordRound(Yp);

    /* p1 = (x+w,    y)      */
    X = GrAddWWFixed(fx, fw); Y = fy;
    Xp = GrAddWWFixed(GrAddWWFixed(GrMulWWFixed(ctm.a, X), GrMulWWFixed(ctm.c, Y)), ctm.e);
    Yp = GrAddWWFixed(GrAddWWFixed(GrMulWWFixed(ctm.b, X), GrMulWWFixed(ctm.d, Y)), ctm.f);
    pts[1].P_x = SvgGeomWWFixedToSWordRound(Xp);
    pts[1].P_y = SvgGeomWWFixedToSWordRound(Yp);

    /* p2 = (x+w,    y+h)    */
    X = GrAddWWFixed(fx, fw); Y = GrAddWWFixed(fy, fh);
    Xp = GrAddWWFixed(GrAddWWFixed(GrMulWWFixed(ctm.a, X), GrMulWWFixed(ctm.c, Y)), ctm.e);
    Yp = GrAddWWFixed(GrAddWWFixed(GrMulWWFixed(ctm.b, X), GrMulWWFixed(ctm.d, Y)), ctm.f);
    pts[2].P_x = SvgGeomWWFixedToSWordRound(Xp);
    pts[2].P_y = SvgGeomWWFixedToSWordRound(Yp);

    /* p3 = (x,      y+h)    */
    X = fx;            Y = GrAddWWFixed(fy, fh);
    Xp = GrAddWWFixed(GrAddWWFixed(GrMulWWFixed(ctm.a, X), GrMulWWFixed(ctm.c, Y)), ctm.e);
    Yp = GrAddWWFixed(GrAddWWFixed(GrMulWWFixed(ctm.b, X), GrMulWWFixed(ctm.d, Y)), ctm.f);
    pts[3].P_x = SvgGeomWWFixedToSWordRound(Xp);
    pts[3].P_y = SvgGeomWWFixedToSWordRound(Yp);

    Meta_Polygon(pts, 4, SvgStyleHasFill(tag), SvgStyleHasStroke(tag));
}


void SvgShapeHandleEllipse(const char *tag)
{
    static char     cxb[32], cyb[32], rxb[32], ryb[32];
    WWFixedAsDWord  fcx;
    WWFixedAsDWord  fcy;
    WWFixedAsDWord  frx;
    WWFixedAsDWord  fry;
    SvgMatrix       ctm;

    Boolean        hasRx;
    Boolean        hasRy;

    fcx = MakeWWFixed(0);
    fcy = MakeWWFixed(0);
    frx = MakeWWFixed(0);
    fry = MakeWWFixed(0);

    hasRx = SvgParserGetAttrBounded(tag, "rx", rxb, sizeof(rxb));
    hasRy = SvgParserGetAttrBounded(tag, "ry", ryb, sizeof(ryb));
    if (!hasRx || !hasRy)
    {
        return;
    }

    (void)SvgUtilParseWWFixed16_16(rxb, &frx);
    (void)SvgUtilParseWWFixed16_16(ryb, &fry);

    if (SvgParserGetAttrBounded(tag, "cx", cxb, sizeof(cxb)))
    {
        (void)SvgUtilParseWWFixed16_16(cxb, &fcx);
    }
    if (SvgParserGetAttrBounded(tag, "cy", cyb, sizeof(cyb)))
    {
        (void)SvgUtilParseWWFixed16_16(cyb, &fcy);
    }

    SvgStyleApplyStrokeAndFill(tag);
    SvgStyleApplyStrokeWidth(tag);

    SvgXformBuildWorld(tag, NULL, &ctm);

    if ((sdword)ctm.b == 0 && (sdword)ctm.c == 0)
    {
        /* axis-aligned: center maps with point, radii map with vector */
        WWFixedAsDWord X, Y, Xp, Yp;
        sword          cxw, cyw, rxw, ryw;
        WWFixedAsDWord vxX, vxY, vyX, vyY;

        /* center */
        X = fcx; Y = fcy;
        Xp = GrAddWWFixed(GrAddWWFixed(GrMulWWFixed(ctm.a, X), GrMulWWFixed(ctm.c, Y)), ctm.e);
        Yp = GrAddWWFixed(GrAddWWFixed(GrMulWWFixed(ctm.b, X), GrMulWWFixed(ctm.d, Y)), ctm.f);
        cxw = SvgGeomWWFixedToSWordRound(Xp);
        cyw = SvgGeomWWFixedToSWordRound(Yp);

        /* vector (rx,0) -> (a*rx, b*rx); but b==0 here */
        vxX = GrMulWWFixed(ctm.a, frx);
        vxY = GrMulWWFixed(ctm.b, frx);
        /* vector (0,ry) -> (c*ry, d*ry); but c==0 here */
        vyX = GrMulWWFixed(ctm.c, fry);
        vyY = GrMulWWFixed(ctm.d, fry);

        rxw = SvgGeomWWFixedToSWordRound((sdword)vxX < 0 ? (WWFixedAsDWord)(-(sdword)vxX) : vxX);
        ryw = SvgGeomWWFixedToSWordRound((sdword)vyY < 0 ? (WWFixedAsDWord)(-(sdword)vyY) : vyY);

        Meta_Ellipse(cxw, cyw, rxw, ryw, 0, SvgStyleHasFill(tag), SvgStyleHasStroke(tag));
    }
    else
    {
        /* rotated/sheared: flatten to polygon */
        enum { NSEG = 48 };
        Point          pts[NSEG];
        word           i;
        WWFixedAsDWord stepDeg;
        WWFixedAsDWord tDeg;

        stepDeg = GrSDivWWFixed(MakeWWFixed(360), MakeWWFixed(NSEG));
        tDeg    = MakeWWFixed(0);

        for (i = 0; i < NSEG; i++) {
            WWFixedAsDWord cs, sn;
            WWFixedAsDWord xu, yu;   /* user-space point on ellipse */
            WWFixedAsDWord Xp, Yp;   /* world point after CTM */

            cs = GrQuickCosine(tDeg);
            sn = GrQuickSine(tDeg);

            xu = GrAddWWFixed(fcx, GrMulWWFixed(frx, cs));
            yu = GrAddWWFixed(fcy, GrMulWWFixed(fry, sn));

            Xp = GrAddWWFixed(GrAddWWFixed(GrMulWWFixed(ctm.a, xu), GrMulWWFixed(ctm.c, yu)), ctm.e);
            Yp = GrAddWWFixed(GrAddWWFixed(GrMulWWFixed(ctm.b, xu), GrMulWWFixed(ctm.d, yu)), ctm.f);

            pts[i].P_x = SvgGeomWWFixedToSWordRound(Xp);
            pts[i].P_y = SvgGeomWWFixedToSWordRound(Yp);

            tDeg = GrAddWWFixed(tDeg, stepDeg);
        }

        Meta_Polygon(pts, NSEG, SvgStyleHasFill(tag), SvgStyleHasStroke(tag));
    }
}


void SvgShapeHandleCircle(const char *tag)
{
    static char     cxb[32], cyb[32], rb[32];
    WWFixedAsDWord  fcx;
    WWFixedAsDWord  fcy;
    WWFixedAsDWord  fr;
    SvgMatrix       ctm;

    Boolean        hasRadius;
    Boolean        strokePresent;
    Boolean        fillPresent;
    Boolean        forcedRoundJoin;

    fcx = MakeWWFixed(0);
    fcy = MakeWWFixed(0);
    fr = MakeWWFixed(0);

    hasRadius = SvgParserGetAttrBounded(tag, "r", rb, sizeof(rb));
    if (!hasRadius)
    {
        return;
    }

    (void)SvgUtilParseWWFixed16_16(rb, &fr);

    if (SvgParserGetAttrBounded(tag, "cx", cxb, sizeof(cxb)))
    {
        (void)SvgUtilParseWWFixed16_16(cxb, &fcx);
    }
    if (SvgParserGetAttrBounded(tag, "cy", cyb, sizeof(cyb)))
    {
        (void)SvgUtilParseWWFixed16_16(cyb, &fcy);
    }

    SvgStyleApplyStrokeAndFill(tag);
    SvgStyleApplyStrokeWidth(tag);

    fillPresent = SvgStyleHasFill(tag);
    strokePresent = SvgStyleHasStroke(tag);
    forcedRoundJoin = FALSE;

    if (strokePresent && !SvgStyleIsLineJoinExplicit(tag))
    {
        Meta_SetLineJoin(LJ_ROUND);
        forcedRoundJoin = TRUE;
    }

    SvgXformBuildWorld(tag, NULL, &ctm);

    if ((sdword)ctm.b == 0 && (sdword)ctm.c == 0)
    {
        WWFixedAsDWord X, Y, Xp, Yp;
        sword          cxw, cyw, rxw, ryw;
        WWFixedAsDWord vxX, vyY;

        /* center */
        X = fcx; Y = fcy;
        Xp = GrAddWWFixed(GrAddWWFixed(GrMulWWFixed(ctm.a, X), GrMulWWFixed(ctm.c, Y)), ctm.e);
        Yp = GrAddWWFixed(GrAddWWFixed(GrMulWWFixed(ctm.b, X), GrMulWWFixed(ctm.d, Y)), ctm.f);
        cxw = SvgGeomWWFixedToSWordRound(Xp);
        cyw = SvgGeomWWFixedToSWordRound(Yp);

        /* radii along axes (axis-aligned case) */
        vxX = GrMulWWFixed(ctm.a, fr);
        vyY = GrMulWWFixed(ctm.d, fr);
        rxw = SvgGeomWWFixedToSWordRound((sdword)vxX < 0 ? (WWFixedAsDWord)(-(sdword)vxX) : vxX);
        ryw = SvgGeomWWFixedToSWordRound((sdword)vyY < 0 ? (WWFixedAsDWord)(-(sdword)vyY) : vyY);

        Meta_Ellipse(cxw, cyw, rxw, ryw, 0, fillPresent, strokePresent);
    }
    else
    {
        /* rotated/sheared: flatten to polygon */
        enum { NSEG = 48 };
        Point          pts[NSEG];
        word           i;
        WWFixedAsDWord stepDeg;
        WWFixedAsDWord tDeg;

        stepDeg = GrSDivWWFixed(MakeWWFixed(360), MakeWWFixed(NSEG));
        tDeg    = MakeWWFixed(0);

        for (i = 0; i < NSEG; i++) {
            WWFixedAsDWord cs, sn;
            WWFixedAsDWord xu, yu;
            WWFixedAsDWord Xp, Yp;

            cs = GrQuickCosine(tDeg);
            sn = GrQuickSine(tDeg);

            xu = GrAddWWFixed(fcx, GrMulWWFixed(fr, cs));
            yu = GrAddWWFixed(fcy, GrMulWWFixed(fr, sn));

            Xp = GrAddWWFixed(GrAddWWFixed(GrMulWWFixed(ctm.a, xu), GrMulWWFixed(ctm.c, yu)), ctm.e);
            Yp = GrAddWWFixed(GrAddWWFixed(GrMulWWFixed(ctm.b, xu), GrMulWWFixed(ctm.d, yu)), ctm.f);

            pts[i].P_x = SvgGeomWWFixedToSWordRound(Xp);
            pts[i].P_y = SvgGeomWWFixedToSWordRound(Yp);

            tDeg = GrAddWWFixed(tDeg, stepDeg);
        }

        Meta_Polygon(pts, NSEG, fillPresent, strokePresent);
    }

    if (forcedRoundJoin)
    {
        Meta_SetLineJoin(LJ_MITERED);
    }
}
