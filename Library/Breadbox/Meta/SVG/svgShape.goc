/***********************************************************************
 * svgShape.goc â€” simple SVG elements: line/polyline/polygon/rect/ellipse/circle
 ***********************************************************************/
#include "SVG/svg.goh"

/* ---- points parser (axis-aware) ---- */

void SvgShapeParsePoints(const char *points, Point *pointsP, word *numPointsP)
{
    const char *s;
    sword       x;
    sword       y;

    s = points;
    *numPointsP = 0;

    while (*s && *numPointsP < MAX_SVG_POINTS)
    {
        s = SvgParserSkipWS(s);
        if (!*s) break;

        {
            WWFixedAsDWord f;
            const char *p;
            p = SvgParserParseWWFixed16_16(s, &f);
            x = SvgViewMapPosX_F(f);
            while (*p) {
                if (*p == ' ' || *p == ',' || *p == '\t' ||
                    *p == '\r' || *p == '\n' ||
                    *p == 'Z' || *p == 'z' ||
                    isalpha((byte)*p)) break;
                p++;
            }
            s = p;
        }

        if (*s == ',') s++;
        s = SvgParserSkipWS(s);

        {
            WWFixedAsDWord f;
            const char *p;
            p = SvgParserParseWWFixed16_16(s, &f);
            y = SvgViewMapPosY_F(f);
            while (*p) {
                if (*p == ' ' || *p == ',' || *p == '\t' ||
                    *p == '\r' || *p == '\n' ||
                    *p == 'Z' || *p == 'z' ||
                    isalpha((byte)*p)) break;
                p++;
            }
            s = p;
        }

        pointsP[*numPointsP].P_x = x;
        pointsP[*numPointsP].P_y = y;
        (*numPointsP)++;

        while (*s && (isspace(*s) || *s == ',')) s++;
    }
}

/* element-local transform="scale(...)" (kept) */
void SvgShapeGetLocalScale(const char *tag, WWFixedAsDWord *sxOut, WWFixedAsDWord *syOut)
{
    static char buf[96];
    char *p;
    const char *s;
    WWFixedAsDWord sx;
    WWFixedAsDWord sy;

    sx = WWFIXED_ONE; sy = WWFIXED_ONE;
    if (!SvgParserGetAttrBounded(tag, "transform", buf, sizeof(buf))) { *sxOut=sx; *syOut=sy; return; }
    p = strstr(buf, "scale"); if (!p) { *sxOut=sx; *syOut=sy; return; }
    p = strchr(p, '('); if (!p) { *sxOut=sx; *syOut=sy; return; }
    s = p + 1;
    s = SvgParserParseWWFixed16_16(s, &sx);
    while (*s && isspace(*s)) s++;
    if (*s == ',') { s++; (void)SvgParserParseWWFixed16_16(s, &sy); } else { sy = sx; }
    if ((sdword)sx == 0) sx = (WWFixedAsDWord)1;
    if ((sdword)sy == 0) sy = (WWFixedAsDWord)1;
    *sxOut = sx; *syOut = sy;
}

void SvgShapeApplyScalePoint(sword *x, sword *y, WWFixedAsDWord sx, WWFixedAsDWord sy)
{
    WWFixedAsDWord X;
    WWFixedAsDWord Y;

    X = (WWFixedAsDWord)((sdword)(*x) << 16);
    Y = (WWFixedAsDWord)((sdword)(*y) << 16);
    X = GrMulWWFixed(X, sx);
    Y = GrMulWWFixed(Y, sy);
    *x = (sword)((sdword)X >> 16);
    *y = (sword)((sdword)Y >> 16);
}

sword SvgShapeScaleLength(sword v, WWFixedAsDWord s)
{
    WWFixedAsDWord V;
    WWFixedAsDWord R;
    sword out;

    V = (WWFixedAsDWord)((sdword)v << 16);
    R = GrMulWWFixed(V, s);
    out = (sword)((sdword)R >> 16);
    if (out < 0) out = (sword)(-out);
    return out;
}

/* ---- simple tag handlers ---- */

void SvgShapeHandleLine(const char *tag)
{
    WWFixedAsDWord  sx;
    WWFixedAsDWord  sy;
    sword           x1;
    sword           y1;
    sword           x2;
    sword           y2;
    static char     xb[32], yb[32], x2b[32], y2b[32];

    if (SvgParserGetAttrBounded(tag, "x1", xb, sizeof(xb)) &&
        SvgParserGetAttrBounded(tag, "y1", yb, sizeof(yb)) &&
        SvgParserGetAttrBounded(tag, "x2", x2b, sizeof(x2b)) &&
        SvgParserGetAttrBounded(tag, "y2", y2b, sizeof(y2b)))
    {
        SvgStyleApplyStrokeAndFill(tag);
        SvgStyleApplyStrokeWidth(tag);

        {
            WWFixedAsDWord f;
            (void)SvgParserParseWWFixed16_16(xb, &f); x1 = SvgViewMapPosX_F(f);
            (void)SvgParserParseWWFixed16_16(yb, &f); y1 = SvgViewMapPosY_F(f);
            (void)SvgParserParseWWFixed16_16(x2b,&f); x2 = SvgViewMapPosX_F(f);
            (void)SvgParserParseWWFixed16_16(y2b,&f); y2 = SvgViewMapPosY_F(f);
        }

        SvgShapeGetLocalScale(tag, &sx, &sy);
        SvgShapeApplyScalePoint(&x1, &y1, sx, sy);
        SvgShapeApplyScalePoint(&x2, &y2, sx, sy);

        Meta_Line(x1, y1, x2, y2);
    }
}

void SvgShapeHandlePolyline(const char *tag, SVGScratch *sc)
{
    word            np;
    WWFixedAsDWord  sx;
    WWFixedAsDWord  sy;
    word            i;

    sc->pb[0] = 0;
    if (SvgParserGetAttrBounded(tag, "points", sc->pb, sizeof(sc->pb)))
    {
        SvgStyleApplyStrokeAndFill(tag);
        SvgStyleApplyStrokeWidth(tag);

        SvgShapeParsePoints(sc->pb, sc->pts, &np);
        if (np > 0)
        {
            SvgShapeGetLocalScale(tag, &sx, &sy);
            for (i = 0; i < np; i++)
            {
                sword px;
                sword py;

                px = sc->pts[i].P_x;
                py = sc->pts[i].P_y;
                SvgShapeApplyScalePoint(&px, &py, sx, sy);
                sc->pts[i].P_x = px;
                sc->pts[i].P_y = py;
            }
            Meta_Polyline(sc->pts, np);
        }
    }
}

void SvgShapeHandlePolygon(const char *tag, SVGScratch *sc)
{
    word            np;
    WWFixedAsDWord  sx;
    WWFixedAsDWord  sy;
    word            i;

    sc->pb[0] = 0;
    if (SvgParserGetAttrBounded(tag, "points", sc->pb, sizeof(sc->pb)))
    {
        SvgStyleApplyStrokeAndFill(tag);
        SvgStyleParseFillRule(tag);
        SvgStyleApplyStrokeWidth(tag);

        SvgShapeParsePoints(sc->pb, sc->pts, &np);
        if (np > 0)
        {
            SvgShapeGetLocalScale(tag, &sx, &sy);
            for (i = 0; i < np; i++)
            {
                sword px;
                sword py;

                px = sc->pts[i].P_x;
                py = sc->pts[i].P_y;
                SvgShapeApplyScalePoint(&px, &py, sx, sy);
                sc->pts[i].P_x = px;
                sc->pts[i].P_y = py;
            }
            Meta_Polygon(sc->pts, np, SvgStyleHasFill(tag), SvgStyleHasStroke(tag));
        }
    }
}

void SvgShapeHandleRect(const char *tag)
{
    static char     xb[32], yb[32], wb[32], hb[32];
    sword           x;
    sword           y;
    sword           x2;
    sword           y2;
    WWFixedAsDWord  sx;
    WWFixedAsDWord  sy;

    if (SvgParserGetAttrBounded(tag, "x", xb, sizeof(xb)) &&
        SvgParserGetAttrBounded(tag, "y", yb, sizeof(yb)) &&
        SvgParserGetAttrBounded(tag, "width", wb, sizeof(wb)) &&
        SvgParserGetAttrBounded(tag, "height", hb, sizeof(hb)))
    {
        SvgStyleApplyStrokeAndFill(tag);
        SvgStyleApplyStrokeWidth(tag);

        {
            WWFixedAsDWord f;
            (void)SvgParserParseWWFixed16_16(xb, &f); x  = SvgViewMapPosX_F(f);
            (void)SvgParserParseWWFixed16_16(yb, &f); y  = SvgViewMapPosY_F(f);
            (void)SvgParserParseWWFixed16_16(wb, &f); x2 = (sword)(x + SvgViewMapLenX_F(f));
            (void)SvgParserParseWWFixed16_16(hb, &f); y2 = (sword)(y + SvgViewMapLenY_F(f));
        }

        SvgShapeGetLocalScale(tag, &sx, &sy);
        SvgShapeApplyScalePoint(&x,  &y,  sx, sy);
        SvgShapeApplyScalePoint(&x2, &y2, sx, sy);

        if (y > y2) { sword t = y; y = y2; y2 = t; }
        if (x > x2) { sword t = x; x = x2; x2 = t; }

        Meta_Rect(x, y, x2, y2, SvgStyleHasFill(tag), SvgStyleHasStroke(tag));
    }
}

void SvgShapeHandleEllipse(const char *tag)
{
    static char     cxb[32], cyb[32], rxb[32], ryb[32];
    sword           cx;
    sword           cy;
    sword           rx;
    sword           ry;
    WWFixedAsDWord  sx;
    WWFixedAsDWord  sy;

    if (SvgParserGetAttrBounded(tag, "cx", cxb, sizeof(cxb)) &&
        SvgParserGetAttrBounded(tag, "cy", cyb, sizeof(cyb)) &&
        SvgParserGetAttrBounded(tag, "rx", rxb, sizeof(rxb)) &&
        SvgParserGetAttrBounded(tag, "ry", ryb, sizeof(ryb)))
    {
        SvgStyleApplyStrokeAndFill(tag);
        SvgStyleApplyStrokeWidth(tag);

        {
            WWFixedAsDWord f;
            (void)SvgParserParseWWFixed16_16(cxb, &f); cx = SvgViewMapPosX_F(f);
            (void)SvgParserParseWWFixed16_16(cyb, &f); cy = SvgViewMapPosY_F(f);
            (void)SvgParserParseWWFixed16_16(rxb, &f); rx = SvgViewMapLenX_F(f);
            (void)SvgParserParseWWFixed16_16(ryb, &f); ry = SvgViewMapLenY_F(f);
        }

        SvgShapeGetLocalScale(tag, &sx, &sy);
        SvgShapeApplyScalePoint(&cx, &cy, sx, sy);
        rx = SvgShapeScaleLength(rx, sx);
        ry = SvgShapeScaleLength(ry, sy);

        Meta_Ellipse(cx, cy, rx, ry, 0, SvgStyleHasFill(tag), SvgStyleHasStroke(tag));
    }
}

void SvgShapeHandleCircle(const char *tag)
{
    static char     cxb[32], cyb[32], rb[32];
    sword           cx;
    sword           cy;
    sword           r;
    sword           rx;
    sword           ry;
    WWFixedAsDWord  sx;
    WWFixedAsDWord  sy;

    if (SvgParserGetAttrBounded(tag, "cx", cxb, sizeof(cxb)) &&
        SvgParserGetAttrBounded(tag, "cy", cyb, sizeof(cyb)) &&
        SvgParserGetAttrBounded(tag, "r",  rb,  sizeof(rb)))
    {
        SvgStyleApplyStrokeAndFill(tag);
        SvgStyleApplyStrokeWidth(tag);

        {
            WWFixedAsDWord f;
            (void)SvgParserParseWWFixed16_16(cxb, &f); cx = SvgViewMapPosX_F(f);
            (void)SvgParserParseWWFixed16_16(cyb, &f); cy = SvgViewMapPosY_F(f);
            (void)SvgParserParseWWFixed16_16(rb,  &f); r  = SvgViewMapLenX_F(f);
        }

        SvgShapeGetLocalScale(tag, &sx, &sy);
        SvgShapeApplyScalePoint(&cx, &cy, sx, sy);
        rx = SvgShapeScaleLength(r, sx);
        ry = SvgShapeScaleLength(r, sy);

        Meta_Ellipse(cx, cy, rx, ry, 0, SvgStyleHasFill(tag), SvgStyleHasStroke(tag));
    }
}
