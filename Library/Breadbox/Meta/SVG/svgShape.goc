/***********************************************************************
 * svgShape.goc — simple SVG elements: line/polyline/polygon/rect/ellipse/circle
 ***********************************************************************/
@include <stdapp.goh>

#include <Ansi/string.h>
#include <Ansi/stdlib.h>
#include <Ansi/ctype.h>
#include <file.h>
#include <system.h>
#include <graphics.h>
#include <gstring.h>
#include <meta.h>
#include <float.h>

#include "SVG/svg.h"
#include "SVG/dbglog.h"

/* ---- points parser (axis-aware) ---- */

void SvgShapeParsePoints(const char *points, Point *pointsP, word *numPointsP)
{
    const char *s;
    sword       x;
    sword       y;

    s = points;
    *numPointsP = 0;

    while (*s && *numPointsP < MAX_SVG_POINTS)
    {
        s = SvgUtilSkipSpace(s);
        if (!*s) break;

        {
            WWFixedAsDWord f;
            const char *p;
            p = SvgParserParseWWFixed16_16(s, &f);
            x = SvgViewMapPosX_F(f);
            while (*p) {
                if (*p == ' ' || *p == ',' || *p == '\t' ||
                    *p == '\r' || *p == '\n' ||
                    *p == 'Z' || *p == 'z' ||
                    isalpha((byte)*p)) break;
                p++;
            }
            s = p;
        }

        if (*s == ',') s++;
        s = SvgUtilSkipSpace(s);

        {
            WWFixedAsDWord f;
            const char *p;
            p = SvgParserParseWWFixed16_16(s, &f);
            y = SvgViewMapPosY_F(f);
            while (*p) {
                if (*p == ' ' || *p == ',' || *p == '\t' ||
                    *p == '\r' || *p == '\n' ||
                    *p == 'Z' || *p == 'z' ||
                    isalpha((byte)*p)) break;
                p++;
            }
            s = p;
        }

        pointsP[*numPointsP].P_x = x;
        pointsP[*numPointsP].P_y = y;
        (*numPointsP)++;

        while (*s && (isspace(*s) || *s == ',')) s++;
    }
}

sword SvgShapeScaleLength(sword v, WWFixedAsDWord s)
{
    WWFixedAsDWord V;
    WWFixedAsDWord R;
    sword out;

    V = (WWFixedAsDWord)((sdword)v << 16);
    R = GrMulWWFixed(V, s);
    out = (sword)((sdword)R >> 16);
    if (out < 0) out = (sword)(-out);
    return out;
}

/* ---- simple tag handlers ---- */

void SvgShapeHandleLine(const char *tag)
{
    static char     xb[32], yb[32], x2b[32], y2b[32];
    WWFixedAsDWord  fx1;
    WWFixedAsDWord  fy1;
    WWFixedAsDWord  fx2;
    WWFixedAsDWord  fy2;
    SvgMatrix       ctm;
    sword           x1w;
    sword           y1w;
    sword           x2w;
    sword           y2w;

    if (SvgParserGetAttrBounded(tag, "x1", xb, sizeof(xb)) &&
        SvgParserGetAttrBounded(tag, "y1", yb, sizeof(yb)) &&
        SvgParserGetAttrBounded(tag, "x2", x2b, sizeof(x2b)) &&
        SvgParserGetAttrBounded(tag, "y2", y2b, sizeof(y2b)))
    {
        SvgStyleApplyStrokeAndFill(tag);
        SvgStyleApplyStrokeWidth(tag);

        (void)SvgParserParseWWFixed16_16(xb,  &fx1);
        (void)SvgParserParseWWFixed16_16(yb,  &fy1);
        (void)SvgParserParseWWFixed16_16(x2b, &fx2);
        (void)SvgParserParseWWFixed16_16(y2b, &fy2);

        /* world CTM = View ∘ Element (parent CTM omitted here) */
        SvgXformBuildWorld(tag, NULL, &ctm);

        /* apply CTM to the two points (do math in 16.16 for precision) */
        {
            WWFixedAsDWord X, Y, Xp, Yp;

            X  = fx1; Y  = fy1;
            Xp = GrAddWWFixed(GrAddWWFixed(GrMulWWFixed(ctm.a, X), GrMulWWFixed(ctm.c, Y)), ctm.e);
            Yp = GrAddWWFixed(GrAddWWFixed(GrMulWWFixed(ctm.b, X), GrMulWWFixed(ctm.d, Y)), ctm.f);
            x1w = SvgGeomWWFixedToSWordRound(Xp);
            y1w = SvgGeomWWFixedToSWordRound(Yp);

            X  = fx2; Y  = fy2;
            Xp = GrAddWWFixed(GrAddWWFixed(GrMulWWFixed(ctm.a, X), GrMulWWFixed(ctm.c, Y)), ctm.e);
            Yp = GrAddWWFixed(GrAddWWFixed(GrMulWWFixed(ctm.b, X), GrMulWWFixed(ctm.d, Y)), ctm.f);
            x2w = SvgGeomWWFixedToSWordRound(Xp);
            y2w = SvgGeomWWFixedToSWordRound(Yp);
        }

        Meta_Line(x1w, y1w, x2w, y2w);
    }
}


void SvgShapeHandlePolyline(const char *tag, SVGScratch *sc)
{
    word      np;
    word      i;
    SvgMatrix worldM;

    sc->pb[0] = 0;
    if (SvgParserGetAttrBounded(tag, "points", sc->pb, sizeof(sc->pb)))
    {
        SvgStyleApplyStrokeAndFill(tag);
        SvgStyleApplyStrokeWidth(tag);

        /* parse points in user space */
        SvgShapeParsePoints(sc->pb, sc->pts, &np);
        if (np > 1)
        {
            /* use full world CTM: View ∘ Group ∘ Element */
            SvgXformBuildWorld(tag, NULL, &worldM);

            for (i = 0; i < np; i++) {
                sword px = sc->pts[i].P_x;
                sword py = sc->pts[i].P_y;
                SvgXformApplyPoint(&px, &py, &worldM);
                sc->pts[i].P_x = px;
                sc->pts[i].P_y = py;
            }

            Meta_Polyline(sc->pts, np);
        }
    }
}


void SvgShapeHandlePolygon(const char *tag, SVGScratch *sc)
{
    word      np;
    word      i;
    SvgMatrix worldM;

    sc->pb[0] = 0;
    if (SvgParserGetAttrBounded(tag, "points", sc->pb, sizeof(sc->pb)))
    {
        SvgStyleApplyStrokeAndFill(tag);
        SvgStyleApplyFillRule(tag);
        SvgStyleApplyStrokeWidth(tag);

        /* parse points in user space */
        SvgShapeParsePoints(sc->pb, sc->pts, &np);
        if (np > 2)
        {
            /* use full world CTM: View ∘ Group ∘ Element */
            SvgXformBuildWorld(tag, NULL, &worldM);

            for (i = 0; i < np; i++) {
                sword px = sc->pts[i].P_x;
                sword py = sc->pts[i].P_y;
                SvgXformApplyPoint(&px, &py, &worldM);
                sc->pts[i].P_x = px;
                sc->pts[i].P_y = py;
            }

            Meta_Polygon(sc->pts, np, SvgStyleHasFill(tag), SvgStyleHasStroke(tag));
        }
    }
}


void SvgShapeHandleRect(const char *tag)
{
    static char     xb[32], yb[32], wb[32], hb[32];
    WWFixedAsDWord  fx;
    WWFixedAsDWord  fy;
    WWFixedAsDWord  fw;
    WWFixedAsDWord  fh;
    SvgMatrix       ctm;
    Point           pts[4];
    WWFixedAsDWord  X, Y, Xp, Yp;

    if (SvgParserGetAttrBounded(tag, "x", xb, sizeof(xb)) &&
        SvgParserGetAttrBounded(tag, "y", yb, sizeof(yb)) &&
        SvgParserGetAttrBounded(tag, "width",  wb, sizeof(wb)) &&
        SvgParserGetAttrBounded(tag, "height", hb, sizeof(hb)))
    {
        SvgStyleApplyStrokeAndFill(tag);
        SvgStyleApplyFillRule(tag);
        SvgStyleApplyStrokeWidth(tag);

        (void)SvgParserParseWWFixed16_16(xb, &fx);
        (void)SvgParserParseWWFixed16_16(yb, &fy);
        (void)SvgParserParseWWFixed16_16(wb, &fw);
        (void)SvgParserParseWWFixed16_16(hb, &fh);

        SvgXformBuildWorld(tag, NULL, &ctm);

        /* p0 = (x,      y)      */
        X = fx;            Y = fy;
        Xp = GrAddWWFixed(GrAddWWFixed(GrMulWWFixed(ctm.a, X), GrMulWWFixed(ctm.c, Y)), ctm.e);
        Yp = GrAddWWFixed(GrAddWWFixed(GrMulWWFixed(ctm.b, X), GrMulWWFixed(ctm.d, Y)), ctm.f);
        pts[0].P_x = SvgGeomWWFixedToSWordRound(Xp);
        pts[0].P_y = SvgGeomWWFixedToSWordRound(Yp);

        /* p1 = (x+w,    y)      */
        X = GrAddWWFixed(fx, fw); Y = fy;
        Xp = GrAddWWFixed(GrAddWWFixed(GrMulWWFixed(ctm.a, X), GrMulWWFixed(ctm.c, Y)), ctm.e);
        Yp = GrAddWWFixed(GrAddWWFixed(GrMulWWFixed(ctm.b, X), GrMulWWFixed(ctm.d, Y)), ctm.f);
        pts[1].P_x = SvgGeomWWFixedToSWordRound(Xp);
        pts[1].P_y = SvgGeomWWFixedToSWordRound(Yp);

        /* p2 = (x+w,    y+h)    */
        X = GrAddWWFixed(fx, fw); Y = GrAddWWFixed(fy, fh);
        Xp = GrAddWWFixed(GrAddWWFixed(GrMulWWFixed(ctm.a, X), GrMulWWFixed(ctm.c, Y)), ctm.e);
        Yp = GrAddWWFixed(GrAddWWFixed(GrMulWWFixed(ctm.b, X), GrMulWWFixed(ctm.d, Y)), ctm.f);
        pts[2].P_x = SvgGeomWWFixedToSWordRound(Xp);
        pts[2].P_y = SvgGeomWWFixedToSWordRound(Yp);

        /* p3 = (x,      y+h)    */
        X = fx;            Y = GrAddWWFixed(fy, fh);
        Xp = GrAddWWFixed(GrAddWWFixed(GrMulWWFixed(ctm.a, X), GrMulWWFixed(ctm.c, Y)), ctm.e);
        Yp = GrAddWWFixed(GrAddWWFixed(GrMulWWFixed(ctm.b, X), GrMulWWFixed(ctm.d, Y)), ctm.f);
        pts[3].P_x = SvgGeomWWFixedToSWordRound(Xp);
        pts[3].P_y = SvgGeomWWFixedToSWordRound(Yp);

        Meta_Polygon(pts, 4, SvgStyleHasFill(tag), SvgStyleHasStroke(tag));
    }
}


void SvgShapeHandleEllipse(const char *tag)
{
    static char     cxb[32], cyb[32], rxb[32], ryb[32];
    WWFixedAsDWord  fcx;
    WWFixedAsDWord  fcy;
    WWFixedAsDWord  frx;
    WWFixedAsDWord  fry;
    SvgMatrix       ctm;

    if (SvgParserGetAttrBounded(tag, "cx", cxb, sizeof(cxb)) &&
        SvgParserGetAttrBounded(tag, "cy", cyb, sizeof(cyb)) &&
        SvgParserGetAttrBounded(tag, "rx", rxb, sizeof(rxb)) &&
        SvgParserGetAttrBounded(tag, "ry", ryb, sizeof(ryb)))
    {
        SvgStyleApplyStrokeAndFill(tag);
        SvgStyleApplyStrokeWidth(tag);

        (void)SvgParserParseWWFixed16_16(cxb, &fcx);
        (void)SvgParserParseWWFixed16_16(cyb, &fcy);
        (void)SvgParserParseWWFixed16_16(rxb, &frx);
        (void)SvgParserParseWWFixed16_16(ryb, &fry);

        SvgXformBuildWorld(tag, NULL, &ctm);

        if ((sdword)ctm.b == 0 && (sdword)ctm.c == 0)
        {
            /* axis-aligned: center maps with point, radii map with vector */
            WWFixedAsDWord X, Y, Xp, Yp;
            sword          cxw, cyw, rxw, ryw;
            WWFixedAsDWord vxX, vxY, vyX, vyY;

            /* center */
            X = fcx; Y = fcy;
            Xp = GrAddWWFixed(GrAddWWFixed(GrMulWWFixed(ctm.a, X), GrMulWWFixed(ctm.c, Y)), ctm.e);
            Yp = GrAddWWFixed(GrAddWWFixed(GrMulWWFixed(ctm.b, X), GrMulWWFixed(ctm.d, Y)), ctm.f);
            cxw = SvgGeomWWFixedToSWordRound(Xp);
            cyw = SvgGeomWWFixedToSWordRound(Yp);

            /* vector (rx,0) -> (a*rx, b*rx); but b==0 here */
            vxX = GrMulWWFixed(ctm.a, frx);
            vxY = GrMulWWFixed(ctm.b, frx);
            /* vector (0,ry) -> (c*ry, d*ry); but c==0 here */
            vyX = GrMulWWFixed(ctm.c, fry);
            vyY = GrMulWWFixed(ctm.d, fry);

            rxw = SvgGeomWWFixedToSWordRound((sdword)vxX < 0 ? (WWFixedAsDWord)(-(sdword)vxX) : vxX);
            ryw = SvgGeomWWFixedToSWordRound((sdword)vyY < 0 ? (WWFixedAsDWord)(-(sdword)vyY) : vyY);

            Meta_Ellipse(cxw, cyw, rxw, ryw, 0, SvgStyleHasFill(tag), SvgStyleHasStroke(tag));
        }
        else
        {
            /* rotated/sheared: flatten to polygon */
            enum { NSEG = 48 };
            Point          pts[NSEG];
            word           i;
            WWFixedAsDWord stepDeg;
            WWFixedAsDWord tDeg;

            stepDeg = GrSDivWWFixed(MakeWWFixed(360), MakeWWFixed(NSEG));
            tDeg    = MakeWWFixed(0);

            for (i = 0; i < NSEG; i++) {
                WWFixedAsDWord cs, sn;
                WWFixedAsDWord xu, yu;   /* user-space point on ellipse */
                WWFixedAsDWord Xp, Yp;   /* world point after CTM */

                cs = GrQuickCosine(tDeg);
                sn = GrQuickSine(tDeg);

                xu = GrAddWWFixed(fcx, GrMulWWFixed(frx, cs));
                yu = GrAddWWFixed(fcy, GrMulWWFixed(fry, sn));

                Xp = GrAddWWFixed(GrAddWWFixed(GrMulWWFixed(ctm.a, xu), GrMulWWFixed(ctm.c, yu)), ctm.e);
                Yp = GrAddWWFixed(GrAddWWFixed(GrMulWWFixed(ctm.b, xu), GrMulWWFixed(ctm.d, yu)), ctm.f);

                pts[i].P_x = SvgGeomWWFixedToSWordRound(Xp);
                pts[i].P_y = SvgGeomWWFixedToSWordRound(Yp);

                tDeg = GrAddWWFixed(tDeg, stepDeg);
            }

            Meta_Polygon(pts, NSEG, SvgStyleHasFill(tag), SvgStyleHasStroke(tag));
        }
    }
}


void SvgShapeHandleCircle(const char *tag)
{
    static char     cxb[32], cyb[32], rb[32];
    WWFixedAsDWord  fcx;
    WWFixedAsDWord  fcy;
    WWFixedAsDWord  fr;
    SvgMatrix       ctm;

    if (SvgParserGetAttrBounded(tag, "cx", cxb, sizeof(cxb)) &&
        SvgParserGetAttrBounded(tag, "cy", cyb, sizeof(cyb)) &&
        SvgParserGetAttrBounded(tag, "r",  rb,  sizeof(rb)))
    {
        SvgStyleApplyStrokeAndFill(tag);
        SvgStyleApplyStrokeWidth(tag);

        (void)SvgParserParseWWFixed16_16(cxb, &fcx);
        (void)SvgParserParseWWFixed16_16(cyb, &fcy);
        (void)SvgParserParseWWFixed16_16(rb,  &fr);

        SvgXformBuildWorld(tag, NULL, &ctm);

        if ((sdword)ctm.b == 0 && (sdword)ctm.c == 0)
        {
            WWFixedAsDWord X, Y, Xp, Yp;
            sword          cxw, cyw, rxw, ryw;
            WWFixedAsDWord vxX, vyY;

            /* center */
            X = fcx; Y = fcy;
            Xp = GrAddWWFixed(GrAddWWFixed(GrMulWWFixed(ctm.a, X), GrMulWWFixed(ctm.c, Y)), ctm.e);
            Yp = GrAddWWFixed(GrAddWWFixed(GrMulWWFixed(ctm.b, X), GrMulWWFixed(ctm.d, Y)), ctm.f);
            cxw = SvgGeomWWFixedToSWordRound(Xp);
            cyw = SvgGeomWWFixedToSWordRound(Yp);

            /* radii along axes (axis-aligned case) */
            vxX = GrMulWWFixed(ctm.a, fr);
            vyY = GrMulWWFixed(ctm.d, fr);
            rxw = SvgGeomWWFixedToSWordRound((sdword)vxX < 0 ? (WWFixedAsDWord)(-(sdword)vxX) : vxX);
            ryw = SvgGeomWWFixedToSWordRound((sdword)vyY < 0 ? (WWFixedAsDWord)(-(sdword)vyY) : vyY);

            Meta_Ellipse(cxw, cyw, rxw, ryw, 0, SvgStyleHasFill(tag), SvgStyleHasStroke(tag));
        }
        else
        {
            /* rotated/sheared: flatten to polygon */
            enum { NSEG = 48 };
            Point          pts[NSEG];
            word           i;
            WWFixedAsDWord stepDeg;
            WWFixedAsDWord tDeg;

            stepDeg = GrSDivWWFixed(MakeWWFixed(360), MakeWWFixed(NSEG));
            tDeg    = MakeWWFixed(0);

            for (i = 0; i < NSEG; i++) {
                WWFixedAsDWord cs, sn;
                WWFixedAsDWord xu, yu;
                WWFixedAsDWord Xp, Yp;

                cs = GrQuickCosine(tDeg);
                sn = GrQuickSine(tDeg);

                xu = GrAddWWFixed(fcx, GrMulWWFixed(fr, cs));
                yu = GrAddWWFixed(fcy, GrMulWWFixed(fr, sn));

                Xp = GrAddWWFixed(GrAddWWFixed(GrMulWWFixed(ctm.a, xu), GrMulWWFixed(ctm.c, yu)), ctm.e);
                Yp = GrAddWWFixed(GrAddWWFixed(GrMulWWFixed(ctm.b, xu), GrMulWWFixed(ctm.d, yu)), ctm.f);

                pts[i].P_x = SvgGeomWWFixedToSWordRound(Xp);
                pts[i].P_y = SvgGeomWWFixedToSWordRound(Yp);

                tDeg = GrAddWWFixed(tDeg, stepDeg);
            }

            Meta_Polygon(pts, NSEG, SvgStyleHasFill(tag), SvgStyleHasStroke(tag));
        }
    }
}

