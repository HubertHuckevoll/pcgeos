/***********************************************************************
 * svgUtil.goc â€” common ASCII helpers
 ***********************************************************************/
@include <stdapp.goh>

#include <Ansi/string.h>
#include <Ansi/stdlib.h>
#include <Ansi/ctype.h>
#include <file.h>
#include <system.h>
#include <graphics.h>
#include <gstring.h>
#include <meta.h>
#include <float.h>

#include "SVG/svg.h"
#include "SVG/dbglog.h"

/* small ASCII case-insensitive compare */
Boolean SvgUtilAsciiNoCaseEq(const char *a, const char *b)
{
    byte ca;
    byte cb;

    while (*a || *b) {
        ca = (byte)*a++;
        cb = (byte)*b++;
        if (ca >= 'A' && ca <= 'Z') ca = (byte)(ca + ('a' - 'A'));
        if (cb >= 'A' && cb <= 'Z') cb = (byte)(cb + ('a' - 'A'));
        if (ca != cb) return FALSE;
        if (ca == 0)  return TRUE;
    }
    return TRUE;
}

word SvgUtilHexNibble(char c)
{
    if (c >= '0' && c <= '9') return (word)(c - '0');
    if (c >= 'A' && c <= 'F') return (word)(10 + (c - 'A'));
    if (c >= 'a' && c <= 'f') return (word)(10 + (c - 'a'));
    return 0;
}

word SvgUtilHexByte(const char *p)
{
    return (word)((SvgUtilHexNibble(p[0]) << 4) | SvgUtilHexNibble(p[1]));
}

Boolean SvgUtilExpandShortHex(const char *s, word *r, word *g, word *b)
{
    if (s[0] == '#' && strlen(s) == 4) {
        char hh[7];
        hh[0] = '#';
        hh[1] = s[1]; hh[2] = s[1];
        hh[3] = s[2]; hh[4] = s[2];
        hh[5] = s[3]; hh[6] = s[3];
        *r = SvgUtilHexByte(hh + 1);
        *g = SvgUtilHexByte(hh + 3);
        *b = SvgUtilHexByte(hh + 5);
        return TRUE;
    }
    return FALSE;
}

Boolean SvgUtilParseRGBFunc(const char *s, word *r, word *g, word *b)
{
    const char *p;
    int v1;
    int v2;
    int v3;
    int isPct;

    p = strstr(s, "rgb(");
    if (!p) {
        return FALSE;
    }
    p += 4;

    isPct = 0;
    v1 = atoi(p);
    while (*p && *p != ',' && *p != ')' && *p != '%') p++;
    if (*p == '%') { isPct = 1; p++; }
    if (*p == ',') p++;
    v2 = atoi(p);
    while (*p && *p != ',' && *p != ')' && *p != '%') p++;
    if (*p == '%') { isPct = 1; p++; }
    if (*p == ',') p++;
    v3 = atoi(p);
    while (*p && *p != ')' && *p != '%') p++;
    if (*p == '%') { isPct = 1; }

    if (isPct) {
        if (v1 < 0) v1 = 0; if (v1 > 100) v1 = 100;
        if (v2 < 0) v2 = 0; if (v2 > 100) v2 = 100;
        if (v3 < 0) v3 = 0; if (v3 > 100) v3 = 100;
        *r = (word)((v1 * 255) / 100);
        *g = (word)((v2 * 255) / 100);
        *b = (word)((v3 * 255) / 100);
    } else {
        if (v1 < 0) v1 = 0; if (v1 > 255) v1 = 255;
        if (v2 < 0) v2 = 0; if (v2 > 255) v2 = 255;
        if (v3 < 0) v3 = 0; if (v3 > 255) v3 = 255;
        *r = (word)v1; *g = (word)v2; *b = (word)v3;
    }
    return TRUE;
}

Boolean SvgUtilKeyEqNoCase(const char *kb, const char *ke, const char *prop)
{
    const char *p;
    const char *k;

    p = prop;
    k = kb;
    while (k < ke && *p) {
        char kc, pc;
        kc = *k++; pc = *p++;
        if (kc >= 'A' && kc <= 'Z') kc = (char)(kc + ('a' - 'A'));
        if (pc >= 'A' && pc <= 'Z') pc = (char)(pc + ('a' - 'A'));
        if (kc != pc) return FALSE;
    }
    return (k == ke && *p == 0);
}

const char* SvgUtilParseWWFixed16_16(const char *s, WWFixedAsDWord *out)
{
    sdword           sign;
    dword            ip;
    dword            frac;
    dword            scale;
    word             c;
    WWFixedAsDWord   result;
    dword            fpart;
    dword            num;

    sign  = 1;
    ip    = 0;
    frac  = 0;
    scale = 1;

    while (*s && isspace((unsigned char)*s))
    {
        s++;
    }
    if (*s == '+')
    {
        s++;
    }
    else if (*s == '-')
    {
        sign = -1;
        s++;
    }

    while ((c = (word)(byte)*s) >= '0' && c <= '9')
    {
        ip = ip * 10 + (c - '0');
        s++;
    }

    if (*s == '.')
    {
        s++;
        while ((c = (word)(byte)*s) >= '0' && c <= '9')
        {
            if (scale < 1000000UL)
            {
                frac  = frac * 10 + (c - '0');
                scale = scale * 10;
            }
            s++;
        }
    }

    result = SvgGeomMakeWWFixedFromInt((int)ip);

    fpart = 0;
    if (scale != 0)
    {
        num   = (frac << 8);
        num   = (num + (scale >> 1)) / scale;
        fpart = (num << 8);
        result += (WWFixedAsDWord)fpart;
    }

    if (sign < 0)
    {
        result = (WWFixedAsDWord)(0 - (sdword)result);
    }

#ifdef DEBUG_LOG
    if (scale >= 1000000UL && frac != 0) {
        LOG_STR("[SvgUtilParseWWFixed16_16]", "fraction scale capped at 1e6");
    }
    if ((sdword)result == 0 && (ip!=0 || frac!=0)) {
        LOG_STR("[SvgUtilParseWWFixed16_16]", "result rounded to zero");
    }
#endif

    *out = result;
    return s;
}
