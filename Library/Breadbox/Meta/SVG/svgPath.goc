/***********************************************************************
 * svgPath.goc — <path> handler + subcommands + flatteners
 ***********************************************************************/
@include <stdapp.goh>

#include <Ansi/string.h>
#include <Ansi/stdlib.h>
#include <Ansi/stdio.h>
#include <Ansi/ctype.h>
#include <file.h>
#include <system.h>
#include <graphics.h>
#include <gstring.h>
#include <meta.h>
#include <float.h>

#include "SVG/svg.h"

/* tiny helpers specific to path handling */
static void SvgPathAddPt(SVGScratch *sc, word *np, sword x, sword y)
{
#ifdef DEBUG_LOG
    char dbgbuf[80];
#endif

    if (*np < MAX_SVG_POINTS) {
        sc->pts[*np].P_x = x;
        sc->pts[*np].P_y = y;
        (*np)++;
    }
#ifdef DEBUG_LOG
    else {
        sprintf(dbgbuf, "SvgPathAddPt: overflow drop x=%d y=%d", (int)x, (int)y);
        LOG_STR("[PATH]", dbgbuf);
    }
#endif
}

static void SvgPathFlattenQuad(SVGScratch *sc, word *np,
                               sword x0, sword y0, sword cx, sword cy, sword x1, sword y1,
                               word segs)
{
    word i;
#ifdef DEBUG_LOG
    char dbgbuf[96];
    sprintf(dbgbuf, "FlattenQuad segs=%u x0=%d y0=%d cx=%d cy=%d x1=%d y1=%d",
            (unsigned)segs, (int)x0, (int)y0, (int)cx, (int)cy, (int)x1, (int)y1);
    LOG_STR("[PATH]", dbgbuf);
#endif
    for (i = 1; i <= segs; i++) {
        WWFixedAsDWord t  = (WWFixedAsDWord)(((dword)i << 16) / segs);
        WWFixedAsDWord it = WWFIXED_ONE - t;

        WWFixedAsDWord X =
            GrMulWWFixed(GrMulWWFixed(it, it), ((sdword)x0 << 16)) +
            GrMulWWFixed(GrMulWWFixed(MakeWWFixed(2), GrMulWWFixed(it, t)), ((sdword)cx << 16)) +
            GrMulWWFixed(GrMulWWFixed(t, t), ((sdword)x1 << 16));

        WWFixedAsDWord Y =
            GrMulWWFixed(GrMulWWFixed(it, it), ((sdword)y0 << 16)) +
            GrMulWWFixed(GrMulWWFixed(MakeWWFixed(2), GrMulWWFixed(it, t)), ((sdword)cy << 16)) +
            GrMulWWFixed(GrMulWWFixed(t, t), ((sdword)y1 << 16));

        SvgPathAddPt(sc, np, (sword)((sdword)X >> 16), (sword)((sdword)Y >> 16));
    }
}

static void SvgPathFlattenCubic(SVGScratch *sc, word *np,
                                sword x0, sword y0, sword c1x, sword c1y, sword c2x, sword c2y, sword x1, sword y1,
                                word segs)
{
    word i;
#ifdef DEBUG_LOG
    char dbgbuf[112];
    sprintf(dbgbuf, "FlattenCubic segs=%u x0=%d y0=%d c1=%d,%d c2=%d,%d x1=%d y1=%d",
            (unsigned)segs, (int)x0, (int)y0, (int)c1x, (int)c1y, (int)c2x, (int)c2y, (int)x1, (int)y1);
    LOG_STR("[PATH]", dbgbuf);
#endif
    for (i = 1; i <= segs; i++) {
        WWFixedAsDWord t   = (WWFixedAsDWord)(((dword)i << 16) / segs);
        WWFixedAsDWord it  = WWFIXED_ONE - t;
        WWFixedAsDWord it2 = GrMulWWFixed(it, it);
        WWFixedAsDWord t2  = GrMulWWFixed(t, t);

        WWFixedAsDWord k0 = GrMulWWFixed(it2, it);                                /* (1-t)^3 */
        WWFixedAsDWord k1 = GrMulWWFixed(MakeWWFixed(3), GrMulWWFixed(it2, t));    /* 3(1-t)^2 t */
        WWFixedAsDWord k2 = GrMulWWFixed(MakeWWFixed(3), GrMulWWFixed(it, t2));    /* 3(1-t) t^2 */
        WWFixedAsDWord k3 = GrMulWWFixed(t2, t);                                   /* t^3 */

        WWFixedAsDWord X =
            GrMulWWFixed(k0, ((sdword)x0 << 16)) +
            GrMulWWFixed(k1, ((sdword)c1x << 16)) +
            GrMulWWFixed(k2, ((sdword)c2x << 16)) +
            GrMulWWFixed(k3, ((sdword)x1  << 16));

        WWFixedAsDWord Y =
            GrMulWWFixed(k0, ((sdword)y0 << 16)) +
            GrMulWWFixed(k1, ((sdword)c1y << 16)) +
            GrMulWWFixed(k2, ((sdword)c2y << 16)) +
            GrMulWWFixed(k3, ((sdword)y1  << 16));

        SvgPathAddPt(sc, np, (sword)((sdword)X >> 16), (sword)((sdword)Y >> 16));
    }
}

/* ===== Elliptical-arc flattener (fixed-point) ===== */
static void
SvgPathFlattenArc(SVGScratch *sc, word *pNp,
                  WWFixedAsDWord x0W, WWFixedAsDWord y0W,
                  WWFixedAsDWord rxW, WWFixedAsDWord ryW,
                  WWFixedAsDWord rotW,
                  int laf, int swf,
                  WWFixedAsDWord x1W, WWFixedAsDWord y1W)
{
#ifdef DEBUG_LOG
    char dbgbuf[144];
#endif
    WWFixedAsDWord zero, one, two;
    WWFixedAsDWord cphi, sphi;
    WWFixedAsDWord dx, dy, x1p, y1p;
    WWFixedAsDWord frx, fry;
    WWFixedAsDWord u, v, u2, v2;
    WWFixedAsDWord lam, scale;
    WWFixedAsDWord s;
    WWFixedAsDWord cxp, cyp;
    WWFixedAsDWord mx, my;
    WWFixedAsDWord cx, cy;
    WWFixedAsDWord ux, uy, vx, vy;
    WWFixedAsDWord th1, dth;
    WWFixedAsDWord cross, dot, absDth;
    WWFixedAsDWord deltaMaxDeg, stepDeg, theta;
    WWFixedAsDWord xr, yr, xp, yp, x, y;
    WWFixedAsDWord nSegWW;
    WWFixedAsDWord u0, v0;
    WWFixedAsDWord num, frac;
    WWFixedAsDWord cth, sth;
    sword          xi, yi, exi, eyi;
    word           np, remaining, nSeg, k;

#ifdef DEBUG_LOG
    sprintf(dbgbuf, "FlattenArc x0=%d y0=%d rx=%d ry=%d rot=%ld laf=%d sf=%d x1=%d y1=%d",
            (int)(x0W>>16), (int)(y0W>>16),
            (int)(rxW>>16), (int)(ryW>>16),
            (long)rotW, laf, swf,
            (int)(x1W>>16), (int)(y1W>>16));
    LOG_STR("[PATH]", dbgbuf);
#endif

    zero = MakeWWFixed(0);
    one  = MakeWWFixed(1);
    two  = MakeWWFixed(2);

    if (SvgGeomWWFixedToSWordRound(rxW) == 0 || SvgGeomWWFixedToSWordRound(ryW) == 0) {
        if (*pNp < MAX_SVG_POINTS) {
            sc->pts[*pNp].P_x = SvgGeomWWFixedToSWordRound(x1W);
            sc->pts[*pNp].P_y = SvgGeomWWFixedToSWordRound(y1W);
            (*pNp)++;
        }
#ifdef DEBUG_LOG
        LOG_STR("[PATH]", "FlattenArc: zero radius -> straight line to end");
#endif
        return;
    }
    if (SvgGeomWWFixedToSWordRound(x0W) == SvgGeomWWFixedToSWordRound(x1W) &&
        SvgGeomWWFixedToSWordRound(y0W) == SvgGeomWWFixedToSWordRound(y1W)) {
#ifdef DEBUG_LOG
        LOG_STR("[PATH]", "FlattenArc: start==end -> nothing");
#endif
        return;
    }

    frx = SvgGeomWWAbs(rxW);
    fry = SvgGeomWWAbs(ryW);

    cphi = GrQuickCosine(rotW);
    sphi = GrQuickSine(rotW);

    dx = GrSDivWWFixed(GrSubWWFixed(x0W, x1W), two);
    dy = GrSDivWWFixed(GrSubWWFixed(y0W, y1W), two);

    x1p  = GrAddWWFixed(GrMulWWFixed(cphi, dx), GrMulWWFixed(sphi, dy));
    y1p  = GrAddWWFixed((WWFixedAsDWord)(-(sdword)GrMulWWFixed(sphi, dx)),
                        GrMulWWFixed(cphi, dy));

    u0  = GrSDivWWFixed(SvgGeomWWAbs(x1p), frx);
    v0  = GrSDivWWFixed(SvgGeomWWAbs(y1p), fry);
    u2  = GrMulWWFixed(u0, u0);
    v2  = GrMulWWFixed(v0, v0);
    lam = GrAddWWFixed(u2, v2);

    if ((sdword)lam > (sdword)one) {
        scale = SvgGeomWWSqrt(lam);
        frx   = GrMulWWFixed(frx, scale);
        fry   = GrMulWWFixed(fry, scale);
        u     = GrSDivWWFixed(x1p, frx);
        v     = GrSDivWWFixed(y1p, fry);
        u2    = GrMulWWFixed(u, u);
        v2    = GrMulWWFixed(v, v);
    } else {
        u  = GrSDivWWFixed(x1p, frx);
        v  = GrSDivWWFixed(y1p, fry);
        u2 = GrMulWWFixed(u, u);
        v2 = GrMulWWFixed(v, v);
    }

    num  = GrSubWWFixed(one, GrAddWWFixed(u2, v2));
    frac = GrSDivWWFixed((sdword)num < 0 ? zero : num, GrAddWWFixed(u2, v2));
    s    = SvgGeomWWSqrt(frac);
    if (laf == swf) {
        s = (WWFixedAsDWord)(-(sdword)s);
    }

    cxp = GrMulWWFixed(s, GrMulWWFixed(frx, v));
    cyp = GrMulWWFixed(s, (WWFixedAsDWord)(-(sdword)GrMulWWFixed(fry, u)));

    mx = GrSDivWWFixed(GrAddWWFixed(x0W, x1W), two);
    my = GrSDivWWFixed(GrAddWWFixed(y0W, y1W), two);

    cx = GrAddWWFixed(GrSubWWFixed(GrMulWWFixed(cphi, cxp), GrMulWWFixed(sphi, cyp)), mx);
    cy = GrAddWWFixed(GrAddWWFixed(GrMulWWFixed(sphi, cxp), GrMulWWFixed(cphi, cyp)), my);

    ux = GrSDivWWFixed(GrSubWWFixed(x1p, cxp), frx);
    uy = GrSDivWWFixed(GrSubWWFixed(y1p, cyp), fry);
    vx = GrSDivWWFixed(GrSubWWFixed((WWFixedAsDWord)(-(sdword)x1p), cxp), frx);
    vy = GrSDivWWFixed(GrSubWWFixed((WWFixedAsDWord)(-(sdword)y1p), cyp), fry);

    th1   = SvgGeomWWAtan2Deg(uy, ux);
    cross = GrSubWWFixed(GrMulWWFixed(ux, vy), GrMulWWFixed(uy, vx));
    dot   = GrAddWWFixed(GrMulWWFixed(ux, vx), GrMulWWFixed(uy, vy));
    dth   = SvgGeomWWAtan2Deg(cross, dot);

    if (!swf) {
        if ((sdword)dth > 0) {
            dth = GrSubWWFixed(dth, MakeWWFixed(360));
        }
    } else {
        if ((sdword)dth < 0) {
            dth = GrAddWWFixed(dth, MakeWWFixed(360));
        }
    }

    absDth = SvgGeomWWAbs(dth);

    deltaMaxDeg = MakeWWFixed(12);
    nSegWW      = GrSDivWWFixed(absDth, deltaMaxDeg);
    nSeg        = (word)SvgGeomWWFixedToSWordRound(nSegWW);
    if (GrMulWWFixed(MakeWWFixed(nSeg), deltaMaxDeg) < absDth) {
        nSeg++;
    }
    if (nSeg < 1) {
        nSeg = 1;
    }

#ifdef DEBUG_LOG
    sprintf(dbgbuf, "FlattenArc segs=%u th1=%ld dth=%ld", (unsigned)nSeg, (long)th1, (long)dth);
    LOG_STR("[PATH]", dbgbuf);
#endif

    np        = *pNp;
    remaining = (MAX_SVG_POINTS > np) ? (MAX_SVG_POINTS - np) : 0;
    if (remaining == 0) {
#ifdef DEBUG_LOG
        LOG_STR("[PATH]", "FlattenArc: no space for segments");
#endif
        return;
    }
    if (nSeg > remaining) {
        nSeg = remaining;
    }

    exi = SvgGeomWWFixedToSWordRound(x1W);
    eyi = SvgGeomWWFixedToSWordRound(y1W);

    stepDeg = GrSDivWWFixed(dth, MakeWWFixed(nSeg));
    for (k = 1; k <= nSeg; k++) {
        theta = GrAddWWFixed(th1, GrMulWWFixed(stepDeg, MakeWWFixed(k)));
        cth   = GrQuickCosine(theta);
        sth   = GrQuickSine(theta);

        xr = GrMulWWFixed(frx, cth);
        yr = GrMulWWFixed(fry, sth);

        xp = GrSubWWFixed(GrMulWWFixed(cphi, xr), GrMulWWFixed(sphi, yr));
        yp = GrAddWWFixed(GrMulWWFixed(sphi, xr), GrMulWWFixed(cphi, yr));

        x = GrAddWWFixed(xp, cx);
        y = GrAddWWFixed(yp, cy);

        xi = SvgGeomWWFixedToSWordRound(x);
        yi = SvgGeomWWFixedToSWordRound(y);
        if (k == nSeg) { xi = exi; yi = eyi; }

        if (np < MAX_SVG_POINTS) {
            sc->pts[np].P_x = xi;
            sc->pts[np].P_y = yi;
            np++;
        } else {
            break;
        }
    }
    *pNp = np;
}


/* ---------- per-command implementations (C89: all vars at top) ---------- */

static void
SvgPathHandleMoveTo(const char **sPP, char *lastCmdP,
                    SVGScratch *sc, word *npP,
                    sword *lastxP, sword *lastyP,
                    sword *subStartXP, sword *subStartYP,
                    Boolean *lastWasCubicP, Boolean *lastWasQuadP)
{
    const char *sP;
    sword x, y;
    WWFixedAsDWord f, fx, fy;
    sword dx, dy;
#ifdef DEBUG_LOG
    char dbgbuf[96];
#endif

    sP = *sPP;

    sP = SvgParserSkipWS(sP);
    if (*lastCmdP == 'M') {
        sP = SvgParserParseWWFixed16_16(sP, &f);  x = SvgViewMapPosX_F(f);
        if (*sP == ',') sP++;
        sP = SvgParserSkipWS(sP);
        sP = SvgParserParseWWFixed16_16(sP, &f);  y = SvgViewMapPosY_F(f);
    } else {
        sP = SvgParserSkipWS(sP);
        sP = SvgParserParseWWFixed16_16(sP, &fx); dx = SvgViewMapLenX_F(fx);
        if (*sP == ',') sP++;
        sP = SvgParserSkipWS(sP);
        sP = SvgParserParseWWFixed16_16(sP, &fy); dy = SvgViewMapLenY_F(fy);
        x = (sword)(*lastxP + dx);
        y = (sword)(*lastyP + dy);
    }

#ifdef DEBUG_LOG
    sprintf(dbgbuf, "M to x=%d y=%d", (int)x, (int)y);
    LOG_STR("[PATH]", dbgbuf);
#endif

    *lastxP = x; *lastyP = y;
    *subStartXP = x; *subStartYP = y;
    if (*npP < MAX_SVG_POINTS) {
        sc->pts[*npP].P_x = x; sc->pts[*npP].P_y = y; (*npP)++;
    }

    *lastCmdP = (*lastCmdP == 'M') ? 'L' : 'l';
    *lastWasCubicP = FALSE;
    *lastWasQuadP  = FALSE;

    *sPP = sP;
}

static void
SvgPathHandleLineTo(const char **sPP, char lastCmd,
                    SVGScratch *sc, word *npP,
                    sword *lastxP, sword *lastyP,
                    Boolean *lastWasCubicP, Boolean *lastWasQuadP)
{
    const char *sP;
    sword lx, ly;
    WWFixedAsDWord f, fx, fy;
    sword dx, dy;
#ifdef DEBUG_LOG
    char dbgbuf[96];
#endif

    sP = *sPP;

    sP = SvgParserSkipWS(sP);
    if (lastCmd == 'L') {
        sP = SvgParserParseWWFixed16_16(sP, &f);  lx = SvgViewMapPosX_F(f);
        if (*sP == ',') sP++;
        sP = SvgParserSkipWS(sP);
        sP = SvgParserParseWWFixed16_16(sP, &f);  ly = SvgViewMapPosY_F(f);
    } else {
        sP = SvgParserSkipWS(sP);
        sP = SvgParserParseWWFixed16_16(sP, &fx); dx = SvgViewMapLenX_F(fx);
        if (*sP == ',') sP++;
        sP = SvgParserSkipWS(sP);
        sP = SvgParserParseWWFixed16_16(sP, &fy); dy = SvgViewMapLenY_F(fy);
        lx = (sword)(*lastxP + dx);
        ly = (sword)(*lastyP + dy);
    }

#ifdef DEBUG_LOG
    sprintf(dbgbuf, "L to x=%d y=%d", (int)lx, (int)ly);
    LOG_STR("[PATH]", dbgbuf);
#endif

    if (*npP < MAX_SVG_POINTS) { sc->pts[*npP].P_x = lx; sc->pts[*npP].P_y = ly; (*npP)++; }
    *lastxP = lx; *lastyP = ly;
    *lastWasCubicP = FALSE;
    *lastWasQuadP  = FALSE;

    *sPP = sP;
}

static void
SvgPathHandleHLineTo(const char **sPP, char lastCmd,
                     SVGScratch *sc, word *npP,
                     sword *lastxP, sword *lastyP,
                     Boolean *lastWasCubicP, Boolean *lastWasQuadP)
{
    const char *sP;
    sword lx;
    WWFixedAsDWord f, fx;
    sword dx;
#ifdef DEBUG_LOG
    char dbgbuf[80];
#endif

    sP = *sPP;

    sP = SvgParserSkipWS(sP);
    if (lastCmd == 'H') {
        sP = SvgParserParseWWFixed16_16(sP, &f);  lx = SvgViewMapPosX_F(f);
    } else {
        sP = SvgParserSkipWS(sP);
        sP = SvgParserParseWWFixed16_16(sP, &fx); dx = SvgViewMapLenX_F(fx);
        lx = (sword)(*lastxP + dx);
    }

#ifdef DEBUG_LOG
    sprintf(dbgbuf, "H to x=%d y=%d", (int)lx, (int)(*lastyP));
    LOG_STR("[PATH]", dbgbuf);
#endif

    if (*npP < MAX_SVG_POINTS) { sc->pts[*npP].P_x = lx; sc->pts[*npP].P_y = *lastyP; (*npP)++; }
    *lastxP = lx;
    *lastWasCubicP = FALSE;
    *lastWasQuadP  = FALSE;

    *sPP = sP;
}

static void
SvgPathHandleVLineTo(const char **sPP, char lastCmd,
                     SVGScratch *sc, word *npP,
                     sword *lastxP, sword *lastyP,
                     Boolean *lastWasCubicP, Boolean *lastWasQuadP)
{
    const char *sP;
    sword ly;
    WWFixedAsDWord f, fy;
    sword dy;
#ifdef DEBUG_LOG
    char dbgbuf[80];
#endif

    sP = *sPP;

    sP = SvgParserSkipWS(sP);
    if (lastCmd == 'V') {
        sP = SvgParserParseWWFixed16_16(sP, &f);  ly = SvgViewMapPosY_F(f);
    } else {
        sP = SvgParserSkipWS(sP);
        sP = SvgParserParseWWFixed16_16(sP, &fy); dy = SvgViewMapLenY_F(fy);
        ly = (sword)(*lastyP + dy);
    }

#ifdef DEBUG_LOG
    sprintf(dbgbuf, "V to x=%d y=%d", (int)(*lastxP), (int)ly);
    LOG_STR("[PATH]", dbgbuf);
#endif

    if (*npP < MAX_SVG_POINTS) { sc->pts[*npP].P_x = *lastxP; sc->pts[*npP].P_y = ly; (*npP)++; }
    *lastyP = ly;
    *lastWasCubicP = FALSE;
    *lastWasQuadP  = FALSE;

    *sPP = sP;
}

static void
SvgPathHandleQuadratic(const char **sPP, char lastCmd,
                       SVGScratch *sc, word *npP,
                       sword *lastxP, sword *lastyP,
                       Boolean *lastWasCubicP, Boolean *lastWasQuadP,
                       sword *lastQcxP, sword *lastQcyP)
{
    const char *sP;
    sword cx, cy, ex, ey;
    WWFixedAsDWord f;
    sword dcx, dcy, dex, dey;
#ifdef DEBUG_LOG
    char dbgbuf[112];
#endif

    sP = *sPP;

    for (;;) {
        sP = SvgParserSkipWS(sP);
        if (!*sP || isalpha(*sP) || *sP=='Z' || *sP=='z') break;

        if (lastCmd == 'Q') {
            sP = SvgParserParseWWFixed16_16(sP, &f); cx = SvgViewMapPosX_F(f);
            if (*sP == ',') sP++;
            sP = SvgParserSkipWS(sP);
            sP = SvgParserParseWWFixed16_16(sP, &f); cy = SvgViewMapPosY_F(f);
            if (*sP == ',') sP++;
            sP = SvgParserSkipWS(sP);
            sP = SvgParserParseWWFixed16_16(sP, &f); ex = SvgViewMapPosX_F(f);
            if (*sP == ',') sP++;
            sP = SvgParserSkipWS(sP);
            sP = SvgParserParseWWFixed16_16(sP, &f); ey = SvgViewMapPosY_F(f);
        } else {
            sP = SvgParserParseWWFixed16_16(sP, &f); dcx = SvgViewMapLenX_F(f);
            if (*sP == ',') sP++;
            sP = SvgParserSkipWS(sP);
            sP = SvgParserParseWWFixed16_16(sP, &f); dcy = SvgViewMapLenY_F(f);
            if (*sP == ',') sP++;
            sP = SvgParserSkipWS(sP);
            sP = SvgParserParseWWFixed16_16(sP, &f); dex = SvgViewMapLenX_F(f);
            if (*sP == ',') sP++;
            sP = SvgParserSkipWS(sP);
            sP = SvgParserParseWWFixed16_16(sP, &f); dey = SvgViewMapLenY_F(f);
            cx = (sword)(*lastxP + dcx); cy = (sword)(*lastyP + dcy);
            ex = (sword)(*lastxP + dex); ey = (sword)(*lastyP + dey);
        }

#ifdef DEBUG_LOG
        sprintf(dbgbuf, "Q c=%d,%d e=%d,%d", (int)cx,(int)cy,(int)ex,(int)ey);
        LOG_STR("[PATH]", dbgbuf);
#endif

        SvgPathFlattenQuad(sc, npP, *lastxP, *lastyP, cx, cy, ex, ey, 8);

        *lastxP = ex; *lastyP = ey;
        *lastWasQuadP = TRUE;  *lastQcxP = cx; *lastQcyP = cy;
        *lastWasCubicP = FALSE;
    }

    *sPP = sP;
}

static void
SvgPathHandleSmoothQuadratic(const char **sPP, char lastCmd,
                             SVGScratch *sc, word *npP,
                             sword *lastxP, sword *lastyP,
                             Boolean *lastWasCubicP, Boolean *lastWasQuadP,
                             sword *lastQcxP, sword *lastQcyP)
{
    const char *sP;
    sword ex, ey, cx, cy;
    WWFixedAsDWord f;
    sword dex, dey;
#ifdef DEBUG_LOG
    char dbgbuf[112];
#endif

    sP = *sPP;

    for (;;) {
        sP = SvgParserSkipWS(sP);
        if (!*sP || isalpha(*sP) || *sP=='Z' || *sP=='z') break;

        if (lastCmd == 'T') {
            sP = SvgParserParseWWFixed16_16(sP, &f); ex = SvgViewMapPosX_F(f);
            if (*sP == ',') sP++;
            sP = SvgParserSkipWS(sP);
            sP = SvgParserParseWWFixed16_16(sP, &f); ey = SvgViewMapPosY_F(f);
        } else {
            sP = SvgParserParseWWFixed16_16(sP, &f); dex = SvgViewMapLenX_F(f);
            if (*sP == ',') sP++;
            sP = SvgParserSkipWS(sP);
            sP = SvgParserParseWWFixed16_16(sP, &f); dey = SvgViewMapLenY_F(f);
            ex = (sword)(*lastxP + dex); ey = (sword)(*lastyP + dey);
        }

        if (*lastWasQuadP) {
            cx = (sword)(*lastxP + (*lastxP - *lastQcxP));
            cy = (sword)(*lastyP + (*lastyP - *lastQcyP));
        } else {
            cx = *lastxP; cy = *lastyP;
        }

#ifdef DEBUG_LOG
        sprintf(dbgbuf, "T c=%d,%d e=%d,%d", (int)cx,(int)cy,(int)ex,(int)ey);
        LOG_STR("[PATH]", dbgbuf);
#endif

        SvgPathFlattenQuad(sc, npP, *lastxP, *lastyP, cx, cy, ex, ey, 8);

        *lastxP = ex; *lastyP = ey;
        *lastWasQuadP = TRUE;  *lastQcxP = cx; *lastQcyP = cy;
        *lastWasCubicP = FALSE;
    }

    *sPP = sP;
}

static void
SvgPathHandleCubic(const char **sPP, char lastCmd,
                   SVGScratch *sc, word *npP,
                   sword *lastxP, sword *lastyP,
                   Boolean *lastWasCubicP, Boolean *lastWasQuadP,
                   sword *lastC2xP, sword *lastC2yP)
{
    const char *sP;
    sword c1x, c1y, c2x, c2y, ex, ey;
    WWFixedAsDWord f;
    sword dc1x, dc1y, dc2x, dc2y, dex, dey;
#ifdef DEBUG_LOG
    char dbgbuf[128];
#endif

    sP = *sPP;

    for (;;) {
        sP = SvgParserSkipWS(sP);
        if (!*sP || isalpha(*sP) || *sP=='Z' || *sP=='z') break;

        if (lastCmd == 'C') {
            sP = SvgParserParseWWFixed16_16(sP, &f); c1x = SvgViewMapPosX_F(f);
            if (*sP == ',') sP++;
            sP = SvgParserSkipWS(sP);
            sP = SvgParserParseWWFixed16_16(sP, &f); c1y = SvgViewMapPosY_F(f);
            if (*sP == ',') sP++;
            sP = SvgParserSkipWS(sP);
            sP = SvgParserParseWWFixed16_16(sP, &f); c2x = SvgViewMapPosX_F(f);
            if (*sP == ',') sP++;
            sP = SvgParserSkipWS(sP);
            sP = SvgParserParseWWFixed16_16(sP, &f); c2y = SvgViewMapPosY_F(f);
            if (*sP == ',') sP++;
            sP = SvgParserSkipWS(sP);
            sP = SvgParserParseWWFixed16_16(sP, &f); ex = SvgViewMapPosX_F(f);
            if (*sP == ',') sP++;
            sP = SvgParserSkipWS(sP);
            sP = SvgParserParseWWFixed16_16(sP, &f); ey = SvgViewMapPosY_F(f);
        } else {
            sP = SvgParserParseWWFixed16_16(sP, &f); dc1x = SvgViewMapLenX_F(f);
            if (*sP == ',') sP++;
            sP = SvgParserSkipWS(sP);
            sP = SvgParserParseWWFixed16_16(sP, &f); dc1y = SvgViewMapLenY_F(f);
            if (*sP == ',') sP++;
            sP = SvgParserSkipWS(sP);
            sP = SvgParserParseWWFixed16_16(sP, &f); dc2x = SvgViewMapLenX_F(f);
            if (*sP == ',') sP++;
            sP = SvgParserSkipWS(sP);
            sP = SvgParserParseWWFixed16_16(sP, &f); dc2y = SvgViewMapLenY_F(f);
            if (*sP == ',') sP++;
            sP = SvgParserSkipWS(sP);
            sP = SvgParserParseWWFixed16_16(sP, &f); dex  = SvgViewMapLenX_F(f);
            if (*sP == ',') sP++;
            sP = SvgParserSkipWS(sP);
            sP = SvgParserParseWWFixed16_16(sP, &f); dey  = SvgViewMapLenY_F(f);
            c1x = (sword)(*lastxP + dc1x); c1y = (sword)(*lastyP + dc1y);
            c2x = (sword)(*lastxP + dc2x); c2y = (sword)(*lastyP + dc2y);
            ex  = (sword)(*lastxP + dex);  ey  = (sword)(*lastyP + dey);
        }

#ifdef DEBUG_LOG
        sprintf(dbgbuf, "C c1=%d,%d c2=%d,%d e=%d,%d",
                (int)c1x,(int)c1y,(int)c2x,(int)c2y,(int)ex,(int)ey);
        LOG_STR("[PATH]", dbgbuf);
#endif

        SvgPathFlattenCubic(sc, npP, *lastxP, *lastyP, c1x, c1y, c2x, c2y, ex, ey, 10);

        *lastxP = ex; *lastyP = ey;
        *lastC2xP = c2x; *lastC2yP = c2y;
        *lastWasCubicP = TRUE;
        *lastWasQuadP  = FALSE;
    }

    *sPP = sP;
}

static void
SvgPathHandleSmoothCubic(const char **sPP, char lastCmd,
                         SVGScratch *sc, word *npP,
                         sword *lastxP, sword *lastyP,
                         Boolean *lastWasCubicP, Boolean *lastWasQuadP,
                         sword *lastC2xP, sword *lastC2yP)
{
    const char *sP;
    sword c1x, c1y, c2x, c2y, ex, ey;
    WWFixedAsDWord f;
    sword dc2x, dc2y, dex, dey;
#ifdef DEBUG_LOG
    char dbgbuf[128];
#endif

    sP = *sPP;

    for (;;) {
        sP = SvgParserSkipWS(sP);
        if (!*sP || isalpha(*sP) || *sP=='Z' || *sP=='z') break;

        if (*lastWasCubicP) {
            c1x = (sword)(*lastxP + (*lastxP - *lastC2xP));
            c1y = (sword)(*lastyP + (*lastyP - *lastC2yP));
        } else {
            c1x = *lastxP; c1y = *lastyP;
        }

        if (lastCmd == 'S') {
            sP = SvgParserParseWWFixed16_16(sP, &f); c2x = SvgViewMapPosX_F(f);
            if (*sP == ',') sP++;
            sP = SvgParserSkipWS(sP);
            sP = SvgParserParseWWFixed16_16(sP, &f); c2y = SvgViewMapPosY_F(f);
            if (*sP == ',') sP++;
            sP = SvgParserSkipWS(sP);
            sP = SvgParserParseWWFixed16_16(sP, &f); ex  = SvgViewMapPosX_F(f);
            if (*sP == ',') sP++;
            sP = SvgParserSkipWS(sP);
            sP = SvgParserParseWWFixed16_16(sP, &f); ey  = SvgViewMapPosY_F(f);
        } else {
            sP = SvgParserParseWWFixed16_16(sP, &f); dc2x = SvgViewMapLenX_F(f);
            if (*sP == ',') sP++;
            sP = SvgParserSkipWS(sP);
            sP = SvgParserParseWWFixed16_16(sP, &f); dc2y = SvgViewMapLenY_F(f);
            if (*sP == ',') sP++;
            sP = SvgParserSkipWS(sP);
            sP = SvgParserParseWWFixed16_16(sP, &f); dex  = SvgViewMapLenX_F(f);
            if (*sP == ',') sP++;
            sP = SvgParserSkipWS(sP);
            sP = SvgParserParseWWFixed16_16(sP, &f); dey  = SvgViewMapLenY_F(f);
            c2x = (sword)(*lastxP + dc2x); c2y = (sword)(*lastyP + dc2y);
            ex  = (sword)(*lastxP + dex);  ey  = (sword)(*lastyP + dey);
        }

#ifdef DEBUG_LOG
        sprintf(dbgbuf, "S c1=%d,%d c2=%d,%d e=%d,%d",
                (int)c1x,(int)c1y,(int)c2x,(int)c2y,(int)ex,(int)ey);
        LOG_STR("[PATH]", dbgbuf);
#endif

        SvgPathFlattenCubic(sc, npP, *lastxP, *lastyP, c1x, c1y, c2x, c2y, ex, ey, 10);

        *lastxP = ex; *lastyP = ey;
        *lastC2xP = c2x; *lastC2yP = c2y;
        *lastWasCubicP = TRUE;
        *lastWasQuadP  = FALSE;
    }

    *sPP = sP;
}

static void
SvgPathHandleArc(const char **sPP, char lastCmd,
                 SVGScratch *sc, word *npP,
                 sword *lastxP, sword *lastyP,
                 Boolean *lastWasCubicP, Boolean *lastWasQuadP)
{
    const char *sP;
    WWFixedAsDWord rxW, ryW, rotW, tmpW;
    WWFixedAsDWord exW, eyW, dxW, dyW;
    WWFixedAsDWord x0W, y0W;
    int laf, swf;
    Boolean done;
#ifdef DEBUG_LOG
    char dbgbuf[128];
#endif

    sP = *sPP;

    done = FALSE;
    while (!done) {
        sP = SvgParserSkipWS(sP);
        if (!*sP || isalpha(*sP) || *sP=='Z' || *sP=='z') {
            done = TRUE;
            continue;
        }

        sP = SvgParserParseWWFixed16_16(sP, &rxW);
        if (*sP == ',') sP++;
        sP = SvgParserSkipWS(sP);
        sP = SvgParserParseWWFixed16_16(sP, &ryW);
        sP = SvgParserSkipWS(sP);
        sP = SvgParserParseWWFixed16_16(sP, &rotW);
        if (*sP == ',') sP++;
        sP = SvgParserSkipWS(sP);

        sP = SvgParserParseWWFixed16_16(sP, &tmpW);
        laf = (SvgGeomWWFixedToSWordRound(tmpW) != 0);
        if (*sP == ',') sP++;
        sP = SvgParserSkipWS(sP);
        sP = SvgParserParseWWFixed16_16(sP, &tmpW);
        swf = (SvgGeomWWFixedToSWordRound(tmpW) != 0);
        if (*sP == ',') sP++;
        sP = SvgParserSkipWS(sP);

        if (lastCmd == 'A') {
            sP = SvgParserParseWWFixed16_16(sP, &exW);
            if (*sP == ',') sP++;
            sP = SvgParserSkipWS(sP);
            sP = SvgParserParseWWFixed16_16(sP, &eyW);
        } else {
            sP = SvgParserParseWWFixed16_16(sP, &dxW);
            if (*sP == ',') sP++;
            sP = SvgParserSkipWS(sP);
            sP = SvgParserParseWWFixed16_16(sP, &dyW);
            exW = SvgGeomMakeWWFixedFromInt(*lastxP) + dxW;
            eyW = SvgGeomMakeWWFixedFromInt(*lastyP) + dyW;
        }

#ifdef DEBUG_LOG
        sprintf(dbgbuf, "A rx=%d ry=%d rot=%ld laf=%d sf=%d ex=%d ey=%d",
                (int)(rxW>>16),(int)(ryW>>16),(long)rotW, laf, swf,
                (int)(exW>>16),(int)(eyW>>16));
        LOG_STR("[PATH]", dbgbuf);
#endif

        if ((SvgGeomWWFixedToSWordRound(rxW) == 0) || (SvgGeomWWFixedToSWordRound(ryW) == 0)) {
            if (*npP < MAX_SVG_POINTS) {
                sc->pts[*npP].P_x = SvgGeomWWFixedToSWordRound(exW);
                sc->pts[*npP].P_y = SvgGeomWWFixedToSWordRound(eyW);
                (*npP)++;
            }
            *lastxP = SvgGeomWWFixedToSWordRound(exW);
            *lastyP = SvgGeomWWFixedToSWordRound(eyW);
#ifdef DEBUG_LOG
            LOG_STR("[PATH]", "A: zero radius -> straight line");
#endif
            continue;
        }
        if ((SvgGeomWWFixedToSWordRound(exW) == *lastxP) && (SvgGeomWWFixedToSWordRound(eyW) == *lastyP)) {
#ifdef DEBUG_LOG
            LOG_STR("[PATH]", "A: end equals current -> skip");
#endif
            continue;
        }

        x0W = ((WWFixedAsDWord)(*lastxP)) << 16;
        y0W = ((WWFixedAsDWord)(*lastyP)) << 16;

        SvgPathFlattenArc(sc, npP, x0W, y0W, rxW, ryW, rotW, laf, swf, exW, eyW);

        *lastxP = SvgGeomWWFixedToSWordRound(exW);
        *lastyP = SvgGeomWWFixedToSWordRound(eyW);

        *lastWasCubicP = FALSE;
        *lastWasQuadP  = FALSE;
    }

    *sPP = sP;
}

static void
SvgPathHandleClose(const char **sPP,
                   Boolean *closedP,
                   sword *lastxP, sword *lastyP,
                   sword subStartX, sword subStartY,
                   Boolean *lastWasCubicP, Boolean *lastWasQuadP)
{
#ifdef DEBUG_LOG
    char dbgbuf[80];
#endif

    const char *sP = *sPP;

    *closedP = TRUE;
    /* Do not advance sP here; command letter was already consumed */
    *lastxP = subStartX;
    *lastyP = subStartY;
    *lastWasCubicP = FALSE;
    *lastWasQuadP  = FALSE;

#ifdef DEBUG_LOG
    sprintf(dbgbuf, "Z close to x=%d y=%d", (int)subStartX, (int)subStartY);
    LOG_STR("[PATH]", dbgbuf);
#endif

    *sPP = sP;
}


static void
SvgPathHandleUnknown(const char **sPP,
                     Boolean *lastWasCubicP, Boolean *lastWasQuadP)
{
    const char *sP;
#ifdef DEBUG_LOG
    char dbgbuf[64];
#endif

    sP = *sPP;

#ifdef DEBUG_LOG
    sprintf(dbgbuf, "unknown cmd 0x%02X", (unsigned char)(*sP));
    LOG_STR("[PATH]", dbgbuf);
#endif

    *lastWasCubicP = FALSE;
    *lastWasQuadP  = FALSE;

    *sPP = sP;
}


/* ---- sub path emitter ---- */

/* svgPath.goc */

static void
SvgPathEmitSubpath(const char *tag,
                   SVGScratch *sc,
                   word *npP,
                   Boolean closed,
                   Boolean inCompound)
{
    word i;
    word np;
    word w;
    sword px;
    sword py;
    sword firstx;
    sword firsty;
    sword lastx;
    sword lasty;
    Boolean hasFill;
    Boolean hasStroke;
    Boolean needFillClose;
    Boolean needStrokeClose;
    SvgMatrix elemOnWorld;

    /* C89 init */
    firstx = 0;
    firsty = 0;
    lastx  = 0;
    lasty  = 0;

    np = *npP;
    *npP = 0;
    if (np <= 1)
    {
        return;
    }

    hasFill   = SvgStyleHasFill(tag);
    hasStroke = SvgStyleHasStroke(tag);

    /* Transform to world + dedup adjacent duplicates */
    SvgXformBuildElemOnWorld(tag, &elemOnWorld);
    w = 0;
    for (i = 0; i < np; i++)
    {
        px = sc->pts[i].P_x;
        py = sc->pts[i].P_y;
        SvgXformApplyPoint(&px, &py, &elemOnWorld);

        if (w == 0 || px != lastx || py != lasty)
        {
            sc->pts[w].P_x = px;
            sc->pts[w].P_y = py;
            w++;
            if (w == 1)
            {
                firstx = px;
                firsty = py;
            }
            lastx = px;
            lasty = py;
        }
    }

    np = w;
    if (np <= 1)
    {
        return;
    }

    /*
     * Degenerate open subpath (exactly one straight segment) contributes
     * NO AREA to fill. If there is no stroke either, skip it entirely
     * to avoid confusing the compound fill path.
     * (This catches the Python logo’s trailing “M .. v 1” bit.)
     */
    if (!closed && inCompound && hasFill && !hasStroke && np == 2)
    {
        return;
    }

    /*
     * A) Explicitly closed with 'Z' -> emit closing edge so stroke sees it.
     */
    needStrokeClose = (closed &&
                       ((firstx != lastx) || (firsty != lasty)));

    if (needStrokeClose && (np < MAX_SVG_POINTS))
    {
        sc->pts[np].P_x = firstx;
        sc->pts[np].P_y = firsty;
        np++;
    }

    /*
     * B) Open subpath with fill -> fill implicitly closes,
     * but do NOT synthesize during compound build, or the stroke
     * would pick it up (regression we fixed earlier).
     */
    if (!closed)
    {
        needFillClose = (hasFill &&
                         ((firstx != lastx) || (firsty != lasty)));
        if (needFillClose && !inCompound && (np < MAX_SVG_POINTS))
        {
            sc->pts[np].P_x = firstx;
            sc->pts[np].P_y = firsty;
            np++;
        }
    }

    /* Append outline (open or closed) to the current meta path */
    Meta_Polyline(sc->pts, np);
}


void SvgPathHandle(const char *tag, SVGScratch *sc)
{
    const char     *sP;
    word            np;
    Boolean         closed;
    sword           lastx, lasty;
    sword           subStartX, subStartY;
    Boolean         lastWasCubic, lastWasQuad;
    sword           lastC2x, lastC2y;
    sword           lastQcx, lastQcy;
    char            lastCmd;
    Boolean         haveCmd;

    /* snapshot per-<path> style to decide compound path behavior */
    Boolean         pathHasFill, pathHasStroke, buildingCompound;

#ifdef DEBUG_LOG
    char            tmp[96];
#endif

    sc->db[0] = 0;
    if (!SvgParserGetAttrBounded(tag, "d", sc->db, sizeof(sc->db))) {
        return;
    }

#ifdef DEBUG_LOG
    LOG_STR_HEAD("[PATH d]", sc->db, 120);
#endif

    /* styles once per <path> */
    SvgStyleApplyStrokeAndFill(tag);
    SvgStyleApplyFillRule(tag);
    SvgStyleApplyStrokeWidth(tag);

    /* decide upfront whether we’ll accumulate a compound path for fill */
    pathHasFill   = SvgStyleHasFill(tag);
    pathHasStroke = SvgStyleHasStroke(tag);
#ifdef DEBUG_LOG
    sprintf(tmp, "style: fill=%d stroke=%d", (int)pathHasFill, (int)pathHasStroke);
    LOG_STR("[STYLE]", tmp);
#endif

    buildingCompound = FALSE;
    if (pathHasFill) {
        Meta_BeginPath();           /* all subpaths will be appended here */
        buildingCompound = TRUE;
#ifdef DEBUG_LOG
        LOG_STR("[META]", "BeginPath (compound fill)");
#endif
    }

    np            = 0;
    closed        = FALSE;
    lastx         = 0;
    lasty         = 0;
    subStartX     = 0;
    subStartY     = 0;
    lastCmd       = 0;
    haveCmd       = FALSE;
    lastWasCubic  = FALSE;
    lastWasQuad   = FALSE;
    lastC2x       = 0;
    lastC2y       = 0;
    lastQcx       = 0;
    lastQcy       = 0;

    sP = sc->db;

    while (*sP)
    {
        sP = SvgParserSkipWS(sP);
        if (!*sP) break;

#ifdef DEBUG_LOG
        {
            char dbg[64];
            sprintf(dbg, "haveCmd=%d next='%c'(0x%02x)",
                    (int)haveCmd, *sP ? *sP : '.', (unsigned)(byte)(*sP));
            LOG_STR("[LOOP]", dbg);
        }
#endif

        if (isalpha((unsigned char)*sP)) {
            char nextCmd = *sP++;   /* consume the command letter */

            /* starting a new subpath? flush the previous one first */
            if ((nextCmd == 'M' || nextCmd == 'm') && (np > 1)) {
#ifdef DEBUG_LOG
                LOG_STR("[FLUSH]", "flush-before-M");
#endif
                /* capture count for logging before it gets reset inside emit */
                {
                    word emitN = np;
                    SvgPathEmitSubpath(tag, sc, &np, closed, buildingCompound);
#ifdef DEBUG_LOG
                    sprintf(tmp, "emit n=%u closed=%d", emitN, (int)closed);
                    LOG_STR("[EMIT]", tmp);
#endif
                }
                closed = FALSE;
            }

#ifdef DEBUG_LOG
            {
                char cmdStr[4]; cmdStr[0] = nextCmd; cmdStr[1] = 0;
                LOG_STR("[CMD]", cmdStr);
            }
#endif
            lastCmd = nextCmd;
            haveCmd = TRUE;
        } else if (!haveCmd) {
            break;
        }

        switch (lastCmd) {
        case 'M': case 'm':
            SvgPathHandleMoveTo(&sP, &lastCmd, sc, &np, &lastx, &lasty,
                                &subStartX, &subStartY, &lastWasCubic, &lastWasQuad);
            break;

        case 'L': case 'l':
            SvgPathHandleLineTo(&sP, lastCmd, sc, &np, &lastx, &lasty,
                                &lastWasCubic, &lastWasQuad);
            break;

        case 'H': case 'h':
            SvgPathHandleHLineTo(&sP, lastCmd, sc, &np, &lastx, &lasty,
                                 &lastWasCubic, &lastWasQuad);
            break;

        case 'V': case 'v':
            SvgPathHandleVLineTo(&sP, lastCmd, sc, &np, &lastx, &lasty,
                                 &lastWasCubic, &lastWasQuad);
            break;

        case 'Q': case 'q':
            SvgPathHandleQuadratic(&sP, lastCmd, sc, &np, &lastx, &lasty,
                                   &lastWasCubic, &lastWasQuad, &lastQcx, &lastQcy);
            break;

        case 'T': case 't':
            SvgPathHandleSmoothQuadratic(&sP, lastCmd, sc, &np, &lastx, &lasty,
                                         &lastWasCubic, &lastWasQuad, &lastQcx, &lastQcy);
            break;

        case 'C': case 'c':
            SvgPathHandleCubic(&sP, lastCmd, sc, &np, &lastx, &lasty,
                               &lastWasCubic, &lastWasQuad, &lastC2x, &lastC2y);
            break;

        case 'S': case 's':
            SvgPathHandleSmoothCubic(&sP, lastCmd, sc, &np, &lastx, &lasty,
                                     &lastWasCubic, &lastWasQuad, &lastC2x, &lastC2y);
            break;

        case 'A': case 'a':
            SvgPathHandleArc(&sP, lastCmd, sc, &np, &lastx, &lasty,
                             &lastWasCubic, &lastWasQuad);
            break;

        case 'Z':
        case 'z':
        {
#ifdef DEBUG_LOG
            sprintf(tmp, "close-subpath np=%u", np);
            LOG_STR("[CLOSE]", tmp);
#endif
            SvgPathHandleClose(&sP, &closed, &lastx, &lasty,
                               subStartX, subStartY, &lastWasCubic, &lastWasQuad);

            if (np > 1) {
                word emitN = np;
                SvgPathEmitSubpath(tag, sc, &np, TRUE, buildingCompound);
#ifdef DEBUG_LOG
                sprintf(tmp, "emit n=%u closed=1", emitN);
                LOG_STR("[EMIT]", tmp);
#endif
            }
            closed  = FALSE;
            haveCmd = FALSE;   /* fetch next real command at top of loop */
            lastCmd = 0;
            break;
        }

        default:
            SvgPathHandleUnknown(&sP, &lastWasCubic, &lastWasQuad);
            haveCmd = FALSE;
            lastCmd = 0;
            break;
        }
    }

    if (np > 1) {
        word emitN = np;
        SvgPathEmitSubpath(tag, sc, &np, closed, buildingCompound);
#ifdef DEBUG_LOG
        {
            char fin[64];
            sprintf(fin, "final-emit n=%u closed=%d", emitN, (int)closed);
            LOG_STR("[EMIT]", fin);
        }
#endif
    }

    if (buildingCompound) {
        Meta_EndPath(/*in=*/pathHasFill, /*edges=*/pathHasStroke);
#ifdef DEBUG_LOG
        sprintf(tmp, "EndPath in=%d edges=%d", (int)pathHasFill, (int)pathHasStroke);
        LOG_STR("[META]", tmp);
#endif
    }
}



