/***********************************************************************
 * svgPath.goc — <path> handler + subcommands + flatteners
 ***********************************************************************/
@include <stdapp.goh>

#include <Ansi/string.h>
#include <Ansi/stdlib.h>
#include <Ansi/ctype.h>
#include <file.h>
#include <system.h>
#include <graphics.h>
#include <gstring.h>
#include <meta.h>
#include <float.h>
#include <dbglogmc.h>

#include "SVG/svg.h"

/* tiny helpers specific to path handling */
static void SvgPathAddPt(SVGScratch *sc, word *np, sword x, sword y)
{
    if (*np < MAX_SVG_POINTS) {
        sc->pts[*np].P_x = x;
        sc->pts[*np].P_y = y;
        (*np)++;
    }
}

static void SvgPathFlattenQuad(SVGScratch *sc, word *np,
                               sword x0, sword y0, sword cx, sword cy, sword x1, sword y1,
                               word segs)
{
    word i;
    for (i = 1; i <= segs; i++) {
        WWFixedAsDWord t  = (WWFixedAsDWord)(((dword)i << 16) / segs);
        WWFixedAsDWord it = WWFIXED_ONE - t;

        WWFixedAsDWord X =
            GrMulWWFixed(GrMulWWFixed(it, it), ((sdword)x0 << 16)) +
            GrMulWWFixed(GrMulWWFixed(MakeWWFixed(2), GrMulWWFixed(it, t)), ((sdword)cx << 16)) +
            GrMulWWFixed(GrMulWWFixed(t, t), ((sdword)x1 << 16));

        WWFixedAsDWord Y =
            GrMulWWFixed(GrMulWWFixed(it, it), ((sdword)y0 << 16)) +
            GrMulWWFixed(GrMulWWFixed(MakeWWFixed(2), GrMulWWFixed(it, t)), ((sdword)cy << 16)) +
            GrMulWWFixed(GrMulWWFixed(t, t), ((sdword)y1 << 16));

        SvgPathAddPt(sc, np, (sword)((sdword)X >> 16), (sword)((sdword)Y >> 16));
    }
}

static void SvgPathFlattenCubic(SVGScratch *sc, word *np,
                                sword x0, sword y0, sword c1x, sword c1y, sword c2x, sword c2y, sword x1, sword y1,
                                word segs)
{
    word i;
    for (i = 1; i <= segs; i++) {
        WWFixedAsDWord t   = (WWFixedAsDWord)(((dword)i << 16) / segs);
        WWFixedAsDWord it  = WWFIXED_ONE - t;
        WWFixedAsDWord it2 = GrMulWWFixed(it, it);
        WWFixedAsDWord t2  = GrMulWWFixed(t, t);

        WWFixedAsDWord k0 = GrMulWWFixed(it2, it);                            /* (1-t)^3 */
        WWFixedAsDWord k1 = GrMulWWFixed(MakeWWFixed(3), GrMulWWFixed(it2, t)); /* 3(1-t)^2 t */
        WWFixedAsDWord k2 = GrMulWWFixed(MakeWWFixed(3), GrMulWWFixed(it, t2));  /* 3(1-t) t^2 */
        WWFixedAsDWord k3 = GrMulWWFixed(t2, t);                              /* t^3 */

        WWFixedAsDWord X =
            GrMulWWFixed(k0, ((sdword)x0 << 16)) +
            GrMulWWFixed(k1, ((sdword)c1x << 16)) +
            GrMulWWFixed(k2, ((sdword)c2x << 16)) +
            GrMulWWFixed(k3, ((sdword)x1  << 16));

        WWFixedAsDWord Y =
            GrMulWWFixed(k0, ((sdword)y0 << 16)) +
            GrMulWWFixed(k1, ((sdword)c1y << 16)) +
            GrMulWWFixed(k2, ((sdword)c2y << 16)) +
            GrMulWWFixed(k3, ((sdword)y1  << 16));

        SvgPathAddPt(sc, np, (sword)((sdword)X >> 16), (sword)((sdword)Y >> 16));
    }
}

/* ===== Elliptical-arc flattener (fixed-point) ===== */
static void
SvgPathFlattenArc(SVGScratch *sc, word *pNp,
                  WWFixedAsDWord x0W, WWFixedAsDWord y0W,
                  WWFixedAsDWord rxW, WWFixedAsDWord ryW,
                  WWFixedAsDWord rotW,
                  int laf, int swf,
                  WWFixedAsDWord x1W, WWFixedAsDWord y1W)
{
    WWFixedAsDWord zero, one, two;
    WWFixedAsDWord cphi, sphi;
    WWFixedAsDWord dx, dy, x1p, y1p;
    WWFixedAsDWord frx, fry;
    WWFixedAsDWord u, v, u2, v2;
    WWFixedAsDWord lam, scale;
    WWFixedAsDWord s;
    WWFixedAsDWord cxp, cyp;
    WWFixedAsDWord mx, my;
    WWFixedAsDWord cx, cy;
    WWFixedAsDWord ux, uy, vx, vy;
    WWFixedAsDWord th1, dth;
    WWFixedAsDWord cross, dot, absDth;
    WWFixedAsDWord deltaMaxDeg, stepDeg, theta;
    WWFixedAsDWord xr, yr, xp, yp, x, y;
    WWFixedAsDWord nSegWW;
    WWFixedAsDWord u0, v0;
    WWFixedAsDWord num, frac;
    WWFixedAsDWord cth, sth;
    sword          xi, yi, exi, eyi;
    word           np, remaining, nSeg, k;

    zero = MakeWWFixed(0);
    one  = MakeWWFixed(1);
    two  = MakeWWFixed(2);

    if (SvgGeomWWFixedToSWordRound(rxW) == 0 || SvgGeomWWFixedToSWordRound(ryW) == 0) {
        if (*pNp < MAX_SVG_POINTS) {
            sc->pts[*pNp].P_x = SvgGeomWWFixedToSWordRound(x1W);
            sc->pts[*pNp].P_y = SvgGeomWWFixedToSWordRound(y1W);
            (*pNp)++;
        }
        return;
    }
    if (SvgGeomWWFixedToSWordRound(x0W) == SvgGeomWWFixedToSWordRound(x1W) &&
        SvgGeomWWFixedToSWordRound(y0W) == SvgGeomWWFixedToSWordRound(y1W)) {
        return;
    }

    frx = SvgGeomWWAbs(rxW);
    fry = SvgGeomWWAbs(ryW);

    cphi = GrQuickCosine(rotW);
    sphi = GrQuickSine(rotW);

    dx = GrSDivWWFixed(GrSubWWFixed(x0W, x1W), two);
    dy = GrSDivWWFixed(GrSubWWFixed(y0W, y1W), two);

    x1p  = GrAddWWFixed(GrMulWWFixed(cphi, dx), GrMulWWFixed(sphi, dy));
    y1p  = GrAddWWFixed((WWFixedAsDWord)(-(sdword)GrMulWWFixed(sphi, dx)),
                        GrMulWWFixed(cphi, dy));

    u0  = GrSDivWWFixed(SvgGeomWWAbs(x1p), frx);
    v0  = GrSDivWWFixed(SvgGeomWWAbs(y1p), fry);
    u2  = GrMulWWFixed(u0, u0);
    v2  = GrMulWWFixed(v0, v0);
    lam = GrAddWWFixed(u2, v2);

    if ((sdword)lam > (sdword)one) {
        scale = SvgGeomWWSqrt(lam);
        frx   = GrMulWWFixed(frx, scale);
        fry   = GrMulWWFixed(fry, scale);
        u     = GrSDivWWFixed(x1p, frx);
        v     = GrSDivWWFixed(y1p, fry);
        u2    = GrMulWWFixed(u, u);
        v2    = GrMulWWFixed(v, v);
    } else {
        u  = GrSDivWWFixed(x1p, frx);
        v  = GrSDivWWFixed(y1p, fry);
        u2 = GrMulWWFixed(u, u);
        v2 = GrMulWWFixed(v, v);
    }

    num  = GrSubWWFixed(one, GrAddWWFixed(u2, v2));
    frac = GrSDivWWFixed((sdword)num < 0 ? zero : num, GrAddWWFixed(u2, v2));
    s    = SvgGeomWWSqrt(frac);
    if (laf == swf) {
        s = (WWFixedAsDWord)(-(sdword)s);
    }

    cxp = GrMulWWFixed(s, GrMulWWFixed(frx, v));
    cyp = GrMulWWFixed(s, (WWFixedAsDWord)(-(sdword)GrMulWWFixed(fry, u)));

    mx = GrSDivWWFixed(GrAddWWFixed(x0W, x1W), two);
    my = GrSDivWWFixed(GrAddWWFixed(y0W, y1W), two);

    cx = GrAddWWFixed(GrSubWWFixed(GrMulWWFixed(cphi, cxp), GrMulWWFixed(sphi, cyp)), mx);
    cy = GrAddWWFixed(GrAddWWFixed(GrMulWWFixed(sphi, cxp), GrMulWWFixed(cphi, cyp)), my);

    ux = GrSDivWWFixed(GrSubWWFixed(x1p, cxp), frx);
    uy = GrSDivWWFixed(GrSubWWFixed(y1p, cyp), fry);
    vx = GrSDivWWFixed(GrSubWWFixed((WWFixedAsDWord)(-(sdword)x1p), cxp), frx);
    vy = GrSDivWWFixed(GrSubWWFixed((WWFixedAsDWord)(-(sdword)y1p), cyp), fry);

    th1   = SvgGeomWWAtan2Deg(uy, ux);
    cross = GrSubWWFixed(GrMulWWFixed(ux, vy), GrMulWWFixed(uy, vx));
    dot   = GrAddWWFixed(GrMulWWFixed(ux, vx), GrMulWWFixed(uy, vy));
    dth   = SvgGeomWWAtan2Deg(cross, dot);

    if (!swf) {
        if ((sdword)dth > 0) {
            dth = GrSubWWFixed(dth, MakeWWFixed(360));
        }
    } else {
        if ((sdword)dth < 0) {
            dth = GrAddWWFixed(dth, MakeWWFixed(360));
        }
    }

    absDth = SvgGeomWWAbs(dth);

    deltaMaxDeg = MakeWWFixed(12);
    nSegWW      = GrSDivWWFixed(absDth, deltaMaxDeg);
    nSeg        = (word)SvgGeomWWFixedToSWordRound(nSegWW);
    if (GrMulWWFixed(MakeWWFixed(nSeg), deltaMaxDeg) < absDth) {
        nSeg++;
    }
    if (nSeg < 1) {
        nSeg = 1;
    }

    np        = *pNp;
    remaining = (MAX_SVG_POINTS > np) ? (MAX_SVG_POINTS - np) : 0;
    if (remaining == 0) {
        return;
    }
    if (nSeg > remaining) {
        nSeg = remaining;
    }

    exi = SvgGeomWWFixedToSWordRound(x1W);
    eyi = SvgGeomWWFixedToSWordRound(y1W);

    stepDeg = GrSDivWWFixed(dth, MakeWWFixed(nSeg));
    for (k = 1; k <= nSeg; k++) {
        theta = GrAddWWFixed(th1, GrMulWWFixed(stepDeg, MakeWWFixed(k)));
        cth   = GrQuickCosine(theta);
        sth   = GrQuickSine(theta);

        xr = GrMulWWFixed(frx, cth);
        yr = GrMulWWFixed(fry, sth);

        xp = GrSubWWFixed(GrMulWWFixed(cphi, xr), GrMulWWFixed(sphi, yr));
        yp = GrAddWWFixed(GrMulWWFixed(sphi, xr), GrMulWWFixed(cphi, yr));

        x = GrAddWWFixed(xp, cx);
        y = GrAddWWFixed(yp, cy);

        xi = SvgGeomWWFixedToSWordRound(x);
        yi = SvgGeomWWFixedToSWordRound(y);
        if (k == nSeg) {
            xi = exi;
            yi = eyi;
        }

        if (np < MAX_SVG_POINTS) {
            sc->pts[np].P_x = xi;
            sc->pts[np].P_y = yi;
            np++;
        } else {
            break;
        }
    }
    *pNp = np;
}


/* ---------- per-command implementations (C89: all vars at top) ---------- */

static void
SvgPathHandleMoveTo(const char **sPP, char *lastCmdP,
                    SVGScratch *sc, word *npP,
                    sword *lastxP, sword *lastyP,
                    sword *subStartXP, sword *subStartYP,
                    Boolean *lastWasCubicP, Boolean *lastWasQuadP)
{
    const char *sP;
    sword x, y;
    WWFixedAsDWord f, fx, fy;
    sword dx, dy;

    sP = *sPP;

    sP = SvgParserSkipWS(sP);
    if (*lastCmdP == 'M') {
        sP = SvgParserParseWWFixed16_16(sP, &f);  x = SvgViewMapPosX_F(f);
        if (*sP == ',') sP++;
        sP = SvgParserSkipWS(sP);
        sP = SvgParserParseWWFixed16_16(sP, &f);  y = SvgViewMapPosY_F(f);
    } else {
        sP = SvgParserSkipWS(sP);
        sP = SvgParserParseWWFixed16_16(sP, &fx); dx = SvgViewMapLenX_F(fx);
        if (*sP == ',') sP++;
        sP = SvgParserSkipWS(sP);
        sP = SvgParserParseWWFixed16_16(sP, &fy); dy = SvgViewMapLenY_F(fy);
        x = (sword)(*lastxP + dx);
        y = (sword)(*lastyP + dy);
    }

    *lastxP = x; *lastyP = y;
    *subStartXP = x; *subStartYP = y;
    if (*npP < MAX_SVG_POINTS) {
        sc->pts[*npP].P_x = x; sc->pts[*npP].P_y = y; (*npP)++;
    }

    *lastCmdP = (*lastCmdP == 'M') ? 'L' : 'l';
    *lastWasCubicP = FALSE;
    *lastWasQuadP  = FALSE;

    *sPP = sP;
}

static void
SvgPathHandleLineTo(const char **sPP, char lastCmd,
                    SVGScratch *sc, word *npP,
                    sword *lastxP, sword *lastyP,
                    Boolean *lastWasCubicP, Boolean *lastWasQuadP)
{
    const char *sP;
    sword lx, ly;
    WWFixedAsDWord f, fx, fy;
    sword dx, dy;

    sP = *sPP;

    sP = SvgParserSkipWS(sP);
    if (lastCmd == 'L') {
        sP = SvgParserParseWWFixed16_16(sP, &f);  lx = SvgViewMapPosX_F(f);
        if (*sP == ',') sP++;
        sP = SvgParserSkipWS(sP);
        sP = SvgParserParseWWFixed16_16(sP, &f);  ly = SvgViewMapPosY_F(f);
    } else {
        sP = SvgParserSkipWS(sP);
        sP = SvgParserParseWWFixed16_16(sP, &fx); dx = SvgViewMapLenX_F(fx);
        if (*sP == ',') sP++;
        sP = SvgParserSkipWS(sP);
        sP = SvgParserParseWWFixed16_16(sP, &fy); dy = SvgViewMapLenY_F(fy);
        lx = (sword)(*lastxP + dx);
        ly = (sword)(*lastyP + dy);
    }

    if (*npP < MAX_SVG_POINTS) { sc->pts[*npP].P_x = lx; sc->pts[*npP].P_y = ly; (*npP)++; }
    *lastxP = lx; *lastyP = ly;
    *lastWasCubicP = FALSE;
    *lastWasQuadP  = FALSE;

    *sPP = sP;
}

static void
SvgPathHandleHLineTo(const char **sPP, char lastCmd,
                     SVGScratch *sc, word *npP,
                     sword *lastxP, sword *lastyP,
                     Boolean *lastWasCubicP, Boolean *lastWasQuadP)
{
    const char *sP;
    sword lx;
    WWFixedAsDWord f, fx;
    sword dx;

    sP = *sPP;

    sP = SvgParserSkipWS(sP);
    if (lastCmd == 'H') {
        sP = SvgParserParseWWFixed16_16(sP, &f);  lx = SvgViewMapPosX_F(f);
    } else {
        sP = SvgParserSkipWS(sP);
        sP = SvgParserParseWWFixed16_16(sP, &fx); dx = SvgViewMapLenX_F(fx);
        lx = (sword)(*lastxP + dx);
    }

    if (*npP < MAX_SVG_POINTS) { sc->pts[*npP].P_x = lx; sc->pts[*npP].P_y = *lastyP; (*npP)++; }
    *lastxP = lx;
    *lastWasCubicP = FALSE;
    *lastWasQuadP  = FALSE;

    *sPP = sP;
}

static void
SvgPathHandleVLineTo(const char **sPP, char lastCmd,
                     SVGScratch *sc, word *npP,
                     sword *lastxP, sword *lastyP,
                     Boolean *lastWasCubicP, Boolean *lastWasQuadP)
{
    const char *sP;
    sword ly;
    WWFixedAsDWord f, fy;
    sword dy;

    sP = *sPP;

    sP = SvgParserSkipWS(sP);
    if (lastCmd == 'V') {
        sP = SvgParserParseWWFixed16_16(sP, &f);  ly = SvgViewMapPosY_F(f);
    } else {
        sP = SvgParserSkipWS(sP);
        sP = SvgParserParseWWFixed16_16(sP, &fy); dy = SvgViewMapLenY_F(fy);
        ly = (sword)(*lastyP + dy);
    }

    if (*npP < MAX_SVG_POINTS) { sc->pts[*npP].P_x = *lastxP; sc->pts[*npP].P_y = ly; (*npP)++; }
    *lastyP = ly;
    *lastWasCubicP = FALSE;
    *lastWasQuadP  = FALSE;

    *sPP = sP;
}

static void
SvgPathHandleQuadratic(const char **sPP, char lastCmd,
                       SVGScratch *sc, word *npP,
                       sword *lastxP, sword *lastyP,
                       Boolean *lastWasCubicP, Boolean *lastWasQuadP,
                       sword *lastQcxP, sword *lastQcyP)
{
    const char *sP;
    sword cx, cy, ex, ey;
    WWFixedAsDWord f;
    sword dcx, dcy, dex, dey;

    sP = *sPP;

    for (;;) {
        sP = SvgParserSkipWS(sP);
        if (!*sP || isalpha(*sP) || *sP=='Z' || *sP=='z') break;

        if (lastCmd == 'Q') {
            sP = SvgParserParseWWFixed16_16(sP, &f); cx = SvgViewMapPosX_F(f);
            if (*sP == ',') sP++;
            sP = SvgParserSkipWS(sP);
            sP = SvgParserParseWWFixed16_16(sP, &f); cy = SvgViewMapPosY_F(f);
            if (*sP == ',') sP++;
            sP = SvgParserSkipWS(sP);
            sP = SvgParserParseWWFixed16_16(sP, &f); ex = SvgViewMapPosX_F(f);
            if (*sP == ',') sP++;
            sP = SvgParserSkipWS(sP);
            sP = SvgParserParseWWFixed16_16(sP, &f); ey = SvgViewMapPosY_F(f);
        } else {
            sP = SvgParserParseWWFixed16_16(sP, &f); dcx = SvgViewMapLenX_F(f);
            if (*sP == ',') sP++;
            sP = SvgParserSkipWS(sP);
            sP = SvgParserParseWWFixed16_16(sP, &f); dcy = SvgViewMapLenY_F(f);
            if (*sP == ',') sP++;
            sP = SvgParserSkipWS(sP);
            sP = SvgParserParseWWFixed16_16(sP, &f); dex = SvgViewMapLenX_F(f);
            if (*sP == ',') sP++;
            sP = SvgParserSkipWS(sP);
            sP = SvgParserParseWWFixed16_16(sP, &f); dey = SvgViewMapLenY_F(f);
            cx = (sword)(*lastxP + dcx); cy = (sword)(*lastyP + dcy);
            ex = (sword)(*lastxP + dex); ey = (sword)(*lastyP + dey);
        }

        SvgPathFlattenQuad(sc, npP, *lastxP, *lastyP, cx, cy, ex, ey, 8);

        *lastxP = ex; *lastyP = ey;
        *lastWasQuadP = TRUE;  *lastQcxP = cx; *lastQcyP = cy;
        *lastWasCubicP = FALSE;
    }

    *sPP = sP;
}

static void
SvgPathHandleSmoothQuadratic(const char **sPP, char lastCmd,
                             SVGScratch *sc, word *npP,
                             sword *lastxP, sword *lastyP,
                             Boolean *lastWasCubicP, Boolean *lastWasQuadP,
                             sword *lastQcxP, sword *lastQcyP)
{
    const char *sP;
    sword ex, ey, cx, cy;
    WWFixedAsDWord f;
    sword dex, dey;

    sP = *sPP;

    for (;;) {
        sP = SvgParserSkipWS(sP);
        if (!*sP || isalpha(*sP) || *sP=='Z' || *sP=='z') break;

        if (lastCmd == 'T') {
            sP = SvgParserParseWWFixed16_16(sP, &f); ex = SvgViewMapPosX_F(f);
            if (*sP == ',') sP++;
            sP = SvgParserSkipWS(sP);
            sP = SvgParserParseWWFixed16_16(sP, &f); ey = SvgViewMapPosY_F(f);
        } else {
            sP = SvgParserParseWWFixed16_16(sP, &f); dex = SvgViewMapLenX_F(f);
            if (*sP == ',') sP++;
            sP = SvgParserSkipWS(sP);
            sP = SvgParserParseWWFixed16_16(sP, &f); dey = SvgViewMapLenY_F(f);
            ex = (sword)(*lastxP + dex); ey = (sword)(*lastyP + dey);
        }

        if (*lastWasQuadP) {
            cx = (sword)(*lastxP + (*lastxP - *lastQcxP));
            cy = (sword)(*lastyP + (*lastyP - *lastQcyP));
        } else {
            cx = *lastxP; cy = *lastyP;
        }

        SvgPathFlattenQuad(sc, npP, *lastxP, *lastyP, cx, cy, ex, ey, 8);

        *lastxP = ex; *lastyP = ey;
        *lastWasQuadP = TRUE;  *lastQcxP = cx; *lastQcyP = cy;
        *lastWasCubicP = FALSE;
    }

    *sPP = sP;
}

static void
SvgPathHandleCubic(const char **sPP, char lastCmd,
                   SVGScratch *sc, word *npP,
                   sword *lastxP, sword *lastyP,
                   Boolean *lastWasCubicP, Boolean *lastWasQuadP,
                   sword *lastC2xP, sword *lastC2yP)
{
    const char *sP;
    sword c1x, c1y, c2x, c2y, ex, ey;
    WWFixedAsDWord f;
    sword dc1x, dc1y, dc2x, dc2y, dex, dey;

    sP = *sPP;

    for (;;) {
        sP = SvgParserSkipWS(sP);
        if (!*sP || isalpha(*sP) || *sP=='Z' || *sP=='z') break;

        if (lastCmd == 'C') {
            sP = SvgParserParseWWFixed16_16(sP, &f); c1x = SvgViewMapPosX_F(f);
            if (*sP == ',') sP++;
            sP = SvgParserSkipWS(sP);
            sP = SvgParserParseWWFixed16_16(sP, &f); c1y = SvgViewMapPosY_F(f);
            if (*sP == ',') sP++;
            sP = SvgParserSkipWS(sP);
            sP = SvgParserParseWWFixed16_16(sP, &f); c2x = SvgViewMapPosX_F(f);
            if (*sP == ',') sP++;
            sP = SvgParserSkipWS(sP);
            sP = SvgParserParseWWFixed16_16(sP, &f); c2y = SvgViewMapPosY_F(f);
            if (*sP == ',') sP++;
            sP = SvgParserSkipWS(sP);
            sP = SvgParserParseWWFixed16_16(sP, &f); ex = SvgViewMapPosX_F(f);
            if (*sP == ',') sP++;
            sP = SvgParserSkipWS(sP);
            sP = SvgParserParseWWFixed16_16(sP, &f); ey = SvgViewMapPosY_F(f);
        } else {
            sP = SvgParserParseWWFixed16_16(sP, &f); dc1x = SvgViewMapLenX_F(f);
            if (*sP == ',') sP++;
            sP = SvgParserSkipWS(sP);
            sP = SvgParserParseWWFixed16_16(sP, &f); dc1y = SvgViewMapLenY_F(f);
            if (*sP == ',') sP++;
            sP = SvgParserSkipWS(sP);
            sP = SvgParserParseWWFixed16_16(sP, &f); dc2x = SvgViewMapLenX_F(f);
            if (*sP == ',') sP++;
            sP = SvgParserSkipWS(sP);
            sP = SvgParserParseWWFixed16_16(sP, &f); dc2y = SvgViewMapLenY_F(f);
            if (*sP == ',') sP++;
            sP = SvgParserSkipWS(sP);
            sP = SvgParserParseWWFixed16_16(sP, &f); dex  = SvgViewMapLenX_F(f);
            if (*sP == ',') sP++;
            sP = SvgParserSkipWS(sP);
            sP = SvgParserParseWWFixed16_16(sP, &f); dey  = SvgViewMapLenY_F(f);
            c1x = (sword)(*lastxP + dc1x); c1y = (sword)(*lastyP + dc1y);
            c2x = (sword)(*lastxP + dc2x); c2y = (sword)(*lastyP + dc2y);
            ex  = (sword)(*lastxP + dex);  ey  = (sword)(*lastyP + dey);
        }

        SvgPathFlattenCubic(sc, npP, *lastxP, *lastyP, c1x, c1y, c2x, c2y, ex, ey, 10);

        *lastxP = ex; *lastyP = ey;
        *lastC2xP = c2x; *lastC2yP = c2y;
        *lastWasCubicP = TRUE;
        *lastWasQuadP  = FALSE;
    }

    *sPP = sP;
}

static void
SvgPathHandleSmoothCubic(const char **sPP, char lastCmd,
                         SVGScratch *sc, word *npP,
                         sword *lastxP, sword *lastyP,
                         Boolean *lastWasCubicP, Boolean *lastWasQuadP,
                         sword *lastC2xP, sword *lastC2yP)
{
    const char *sP;
    sword c1x, c1y, c2x, c2y, ex, ey;
    WWFixedAsDWord f;
    sword dc2x, dc2y, dex, dey;

    sP = *sPP;

    for (;;) {
        sP = SvgParserSkipWS(sP);
        if (!*sP || isalpha(*sP) || *sP=='Z' || *sP=='z') break;

        if (*lastWasCubicP) {
            c1x = (sword)(*lastxP + (*lastxP - *lastC2xP));
            c1y = (sword)(*lastyP + (*lastyP - *lastC2yP));
        } else {
            c1x = *lastxP; c1y = *lastyP;
        }

        if (lastCmd == 'S') {
            sP = SvgParserParseWWFixed16_16(sP, &f); c2x = SvgViewMapPosX_F(f);
            if (*sP == ',') sP++;
            sP = SvgParserSkipWS(sP);
            sP = SvgParserParseWWFixed16_16(sP, &f); c2y = SvgViewMapPosY_F(f);
            if (*sP == ',') sP++;
            sP = SvgParserSkipWS(sP);
            sP = SvgParserParseWWFixed16_16(sP, &f); ex  = SvgViewMapPosX_F(f);
            if (*sP == ',') sP++;
            sP = SvgParserSkipWS(sP);
            sP = SvgParserParseWWFixed16_16(sP, &f); ey  = SvgViewMapPosY_F(f);
        } else {
            sP = SvgParserParseWWFixed16_16(sP, &f); dc2x = SvgViewMapLenX_F(f);
            if (*sP == ',') sP++;
            sP = SvgParserSkipWS(sP);
            sP = SvgParserParseWWFixed16_16(sP, &f); dc2y = SvgViewMapLenY_F(f);
            if (*sP == ',') sP++;
            sP = SvgParserSkipWS(sP);
            sP = SvgParserParseWWFixed16_16(sP, &f); dex  = SvgViewMapLenX_F(f);
            if (*sP == ',') sP++;
            sP = SvgParserSkipWS(sP);
            sP = SvgParserParseWWFixed16_16(sP, &f); dey  = SvgViewMapLenY_F(f);
            c2x = (sword)(*lastxP + dc2x); c2y = (sword)(*lastyP + dc2y);
            ex  = (sword)(*lastxP + dex);  ey  = (sword)(*lastyP + dey);
        }

        SvgPathFlattenCubic(sc, npP, *lastxP, *lastyP, c1x, c1y, c2x, c2y, ex, ey, 10);

        *lastxP = ex; *lastyP = ey;
        *lastC2xP = c2x; *lastC2yP = c2y;
        *lastWasCubicP = TRUE;
        *lastWasQuadP  = FALSE;
    }

    *sPP = sP;
}

static void
SvgPathHandleArc(const char **sPP, char lastCmd,
                 SVGScratch *sc, word *npP,
                 sword *lastxP, sword *lastyP,
                 Boolean *lastWasCubicP, Boolean *lastWasQuadP)
{
    const char *sP;
    WWFixedAsDWord rxW, ryW, rotW, tmpW;
    WWFixedAsDWord exW, eyW, dxW, dyW;
    WWFixedAsDWord x0W, y0W;
    int laf, swf;
    Boolean done;

    sP = *sPP;

    done = FALSE;
    while (!done) {
        sP = SvgParserSkipWS(sP);
        if (!*sP || isalpha(*sP) || *sP=='Z' || *sP=='z') {
            done = TRUE;
            continue;
        }

        sP = SvgParserParseWWFixed16_16(sP, &rxW);
        if (*sP == ',') sP++;
        sP = SvgParserSkipWS(sP);
        sP = SvgParserParseWWFixed16_16(sP, &ryW);
        sP = SvgParserSkipWS(sP);
        sP = SvgParserParseWWFixed16_16(sP, &rotW);
        if (*sP == ',') sP++;
        sP = SvgParserSkipWS(sP);

        sP = SvgParserParseWWFixed16_16(sP, &tmpW);
        laf = (SvgGeomWWFixedToSWordRound(tmpW) != 0);
        if (*sP == ',') sP++;
        sP = SvgParserSkipWS(sP);
        sP = SvgParserParseWWFixed16_16(sP, &tmpW);
        swf = (SvgGeomWWFixedToSWordRound(tmpW) != 0);
        if (*sP == ',') sP++;
        sP = SvgParserSkipWS(sP);

        if (lastCmd == 'A') {
            sP = SvgParserParseWWFixed16_16(sP, &exW);
            if (*sP == ',') sP++;
            sP = SvgParserSkipWS(sP);
            sP = SvgParserParseWWFixed16_16(sP, &eyW);
        } else {
            sP = SvgParserParseWWFixed16_16(sP, &dxW);
            if (*sP == ',') sP++;
            sP = SvgParserSkipWS(sP);
            sP = SvgParserParseWWFixed16_16(sP, &dyW);
            exW = SvgGeomMakeWWFixedFromInt(*lastxP) + dxW;
            eyW = SvgGeomMakeWWFixedFromInt(*lastyP) + dyW;
        }

        if ((SvgGeomWWFixedToSWordRound(rxW) == 0) || (SvgGeomWWFixedToSWordRound(ryW) == 0)) {
            if (*npP < MAX_SVG_POINTS) {
                sc->pts[*npP].P_x = SvgGeomWWFixedToSWordRound(exW);
                sc->pts[*npP].P_y = SvgGeomWWFixedToSWordRound(eyW);
                (*npP)++;
            }
            *lastxP = SvgGeomWWFixedToSWordRound(exW);
            *lastyP = SvgGeomWWFixedToSWordRound(eyW);
            continue;
        }
        if ((SvgGeomWWFixedToSWordRound(exW) == *lastxP) && (SvgGeomWWFixedToSWordRound(eyW) == *lastyP)) {
            continue;
        }

        x0W = ((WWFixedAsDWord)(*lastxP)) << 16;
        y0W = ((WWFixedAsDWord)(*lastyP)) << 16;

        SvgPathFlattenArc(sc, npP, x0W, y0W, rxW, ryW, rotW, laf, swf, exW, eyW);

        *lastxP = SvgGeomWWFixedToSWordRound(exW);
        *lastyP = SvgGeomWWFixedToSWordRound(eyW);

        *lastWasCubicP = FALSE;
        *lastWasQuadP  = FALSE;
    }

    *sPP = sP;
}

static void
SvgPathHandleClose(const char **sPP,
                   Boolean *closedP,
                   sword *lastxP, sword *lastyP,
                   sword subStartX, sword subStartY,
                   Boolean *lastWasCubicP, Boolean *lastWasQuadP)
{
    const char *sP;

    sP = *sPP;

    *closedP = TRUE;
    sP++;
    *lastxP = subStartX;
    *lastyP = subStartY;
    *lastWasCubicP = FALSE;
    *lastWasQuadP  = FALSE;

    *sPP = sP;
}

static void
SvgPathHandleUnknown(const char **sPP,
                     Boolean *lastWasCubicP, Boolean *lastWasQuadP)
{
    const char *sP;

    sP = *sPP;

    sP++;
    *lastWasCubicP = FALSE;
    *lastWasQuadP  = FALSE;

    *sPP = sP;
}


/* ---- main <path> handler (coordinator) ---- */

/* Emit current subpath; handles implicit close-on-fill per SVG spec */
/* Emit current subpath; close-on-fill without duplicating the first point */
/* Emit current subpath; always fill if 'fill' is present, even if not closed.
   Stroke the closing edge only when 'Z/z' was used (closed==TRUE). */
static void
SvgPathEmitSubpath(const char *tag,
                   SVGScratch *sc, word *npP,
                   Boolean closed,
                   WWFixedAsDWord sx2, WWFixedAsDWord sy2)
{
    word      i, np;
    sword     px, py;
    SvgMatrix elemOnWorld;
    Boolean   hasFill, hasStroke;

    (void)sx2; (void)sy2;

    np = *npP;
    *npP = 0;                     /* we’re going to flush no matter what */
    if (np <= 1) return;

    hasFill   = SvgStyleHasFill(tag);
    hasStroke = SvgStyleHasStroke(tag);

    /* Transform points from world→world using element-on-world CTM */
    SvgXformBuildElemOnWorld(tag, &elemOnWorld);
    for (i = 0; i < np; i++) {
        px = sc->pts[i].P_x;
        py = sc->pts[i].P_y;
        SvgXformApplyPoint(&px, &py, &elemOnWorld);
        sc->pts[i].P_x = px;
        sc->pts[i].P_y = py;
    }

    /* FILL: SVG fills *all* subpaths (implicitly closed). */
    if (hasFill) {
        /* Edges parameter: only draw a closing stroke when the author used Z/z. */
        Meta_Polygon(sc->pts, np, /*in=*/TRUE, /*edges=*/(hasStroke && closed));
        /* If stroke exists but subpath wasn’t explicitly closed, we still need
           the outline without the implicit close: draw the polyline stroke now. */
        if (hasStroke && !closed) {
            Meta_Polyline(sc->pts, np);
        }
        return;
    }

    /* No fill: stroke only. Respect Z/z for closed outlines. */
    if (hasStroke) {
        if (closed) {
            Meta_Polygon(sc->pts, np, /*in=*/FALSE, /*edges=*/TRUE);
        } else {
            Meta_Polyline(sc->pts, np);
        }
    }
}


void SvgPathHandle(const char *tag, SVGScratch *sc)
{
    const char     *sP;
    word            np;
    Boolean         closed;
    sword           lastx;
    sword           lasty;
    sword           subStartX;
    sword           subStartY;
    Boolean         lastWasCubic;
    Boolean         lastWasQuad;
    sword           lastC2x;
    sword           lastC2y;
    sword           lastQcx;
    sword           lastQcy;
    char            lastCmd;
    Boolean         haveCmd;

    sc->db[0] = 0;
    if (!SvgParserGetAttrBounded(tag, "d", sc->db, sizeof(sc->db))) {
        return;
    }

    /* styles once per <path> (each flushed subpath inherits these) */
    SvgStyleApplyStrokeAndFill(tag);
    SvgStyleApplyFillRule(tag);
    SvgStyleApplyStrokeWidth(tag);

    np            = 0;
    closed        = FALSE;
    lastx         = 0;
    lasty         = 0;
    subStartX     = 0;
    subStartY     = 0;
    lastCmd       = 0;
    haveCmd       = FALSE;
    lastWasCubic  = FALSE;
    lastWasQuad   = FALSE;
    lastC2x       = 0;
    lastC2y       = 0;
    lastQcx       = 0;
    lastQcy       = 0;

    sP = sc->db;

    while (*sP)
    {
        sP = SvgParserSkipWS(sP);
        if (!*sP) {
            break;
        }

        if (isalpha(*sP)) {
            /* starting a new command token */
            char nextCmd;
            nextCmd = *sP++;

            /* if a new subpath begins, flush any pending one */
            if ((nextCmd == 'M' || nextCmd == 'm') && (np > 1)) {
                SvgPathEmitSubpath(tag, sc, &np, closed, WWFIXED_ONE, WWFIXED_ONE);
                closed = FALSE;
            }

            lastCmd = nextCmd;
            haveCmd = TRUE;
        } else if (!haveCmd) {
            break;
        }

        switch (lastCmd) {
        case 'M':
        case 'm':
            SvgPathHandleMoveTo(&sP, &lastCmd, sc, &np, &lastx, &lasty,
                                &subStartX, &subStartY, &lastWasCubic, &lastWasQuad);
            break;

        case 'L':
        case 'l':
            SvgPathHandleLineTo(&sP, lastCmd, sc, &np, &lastx, &lasty,
                                &lastWasCubic, &lastWasQuad);
            break;

        case 'H':
        case 'h':
            SvgPathHandleHLineTo(&sP, lastCmd, sc, &np, &lastx, &lasty,
                                 &lastWasCubic, &lastWasQuad);
            break;

        case 'V':
        case 'v':
            SvgPathHandleVLineTo(&sP, lastCmd, sc, &np, &lastx, &lasty,
                                 &lastWasCubic, &lastWasQuad);
            break;

        case 'Q':
        case 'q':
            SvgPathHandleQuadratic(&sP, lastCmd, sc, &np, &lastx, &lasty,
                                   &lastWasCubic, &lastWasQuad, &lastQcx, &lastQcy);
            break;

        case 'T':
        case 't':
            SvgPathHandleSmoothQuadratic(&sP, lastCmd, sc, &np, &lastx, &lasty,
                                         &lastWasCubic, &lastWasQuad, &lastQcx, &lastQcy);
            break;

        case 'C':
        case 'c':
            SvgPathHandleCubic(&sP, lastCmd, sc, &np, &lastx, &lasty,
                               &lastWasCubic, &lastWasQuad, &lastC2x, &lastC2y);
            break;

        case 'S':
        case 's':
            SvgPathHandleSmoothCubic(&sP, lastCmd, sc, &np, &lastx, &lasty,
                                     &lastWasCubic, &lastWasQuad, &lastC2x, &lastC2y);
            break;

        case 'A':
        case 'a':
            SvgPathHandleArc(&sP, lastCmd, sc, &np, &lastx, &lasty,
                             &lastWasCubic, &lastWasQuad);
            break;

        case 'Z':
        case 'z':
            /* mark closed, then flush immediately; start fresh subpath */
            SvgPathHandleClose(&sP, &closed, &lastx, &lasty,
                               subStartX, subStartY, &lastWasCubic, &lastWasQuad);
            if (np > 1) {
                SvgPathEmitSubpath(tag, sc, &np, TRUE, WWFIXED_ONE, WWFIXED_ONE);
            }
            closed = FALSE;
            break;

        default:
            SvgPathHandleUnknown(&sP, &lastWasCubic, &lastWasQuad);
            break;
        }
    }

    /* Flush any remaining open subpath */
    if (np > 1) {
        SvgPathEmitSubpath(tag, sc, &np, closed, WWFIXED_ONE, WWFIXED_ONE);
    }
}

