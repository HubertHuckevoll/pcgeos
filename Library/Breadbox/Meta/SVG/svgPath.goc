/***********************************************************************
 * svgPath.goc — <path> handler + subcommands + flatteners
 ***********************************************************************/
@include <stdapp.goh>

#include <Ansi/string.h>
#include <Ansi/stdlib.h>
#include <Ansi/stdio.h>
#include <Ansi/ctype.h>
#include <file.h>
#include <system.h>
#include <graphics.h>
#include <gstring.h>
#include <meta.h>
#include <float.h>

#include "SVG/svg.h"
#include "SVG/dbglog.h"

/* -------- tiny helpers specific to path handling --------- */
static void SvgPathAddPt(SVGScratch *sc, word *np, sword x, sword y)
{
    if (*np < MAX_SVG_POINTS) {
        sc->pts[*np].P_x = x;
        sc->pts[*np].P_y = y;
        (*np)++;
    }
    else {
        LOGF(("[PATH]", "SvgPathAddPt: overflow drop x=%d y=%d", (int)x, (int)y));
    }
}

/* -------- svgPath.goc : local helpers for A/a parsing (file-local) -------- */
static const char*
SvgSkipCommaWS(const char *s)
{
    while (*s==' ' || *s=='\t' || *s=='\r' || *s=='\n') { s++; }
    if (*s==',')
    {
        s++;
        while (*s==' ' || *s=='\t' || *s=='\r' || *s=='\n') { s++; }
    }
    return s;
}

static Boolean
SvgIsNumStart(char c)
{
    return (c=='+' || c=='-' || c=='.' || (c>='0' && c<='9'));
}

static Boolean
SvgReadFlag(const char **sPP, byte *out)
{
    const char *s;
    s = SvgSkipCommaWS(*sPP);
    if (*s=='0' || *s=='1')
    {
        *out = (byte)(*s - '0');
        s++;
        *sPP = SvgSkipCommaWS(s);
        return TRUE;
    }
    return FALSE; /* do not consume on failure */
}


/* -------- the flatterners --------- */
static void SvgPathFlattenQuad(SVGScratch *sc, word *np,
                               sword x0, sword y0, sword cx, sword cy, sword x1, sword y1,
                               word segs)
{
    word i;

    LOGF(("[PATH]", "FlattenQuad segs=%u x0=%d y0=%d cx=%d cy=%d x1=%d y1=%d",
            (unsigned)segs, (int)x0, (int)y0, (int)cx, (int)cy, (int)x1, (int)y1));

    for (i = 1; i <= segs; i++) {
        WWFixedAsDWord t  = (WWFixedAsDWord)(((dword)i << 16) / segs);
        WWFixedAsDWord it = WWFIXED_ONE - t;

        WWFixedAsDWord X =
            GrMulWWFixed(GrMulWWFixed(it, it), ((sdword)x0 << 16)) +
            GrMulWWFixed(GrMulWWFixed(MakeWWFixed(2), GrMulWWFixed(it, t)), ((sdword)cx << 16)) +
            GrMulWWFixed(GrMulWWFixed(t, t), ((sdword)x1 << 16));

        WWFixedAsDWord Y =
            GrMulWWFixed(GrMulWWFixed(it, it), ((sdword)y0 << 16)) +
            GrMulWWFixed(GrMulWWFixed(MakeWWFixed(2), GrMulWWFixed(it, t)), ((sdword)cy << 16)) +
            GrMulWWFixed(GrMulWWFixed(t, t), ((sdword)y1 << 16));

        SvgPathAddPt(sc, np, (sword)((sdword)X >> 16), (sword)((sdword)Y >> 16));
    }
}

static void SvgPathFlattenCubic(SVGScratch *sc, word *np,
                                sword x0, sword y0, sword c1x, sword c1y, sword c2x, sword c2y, sword x1, sword y1,
                                word segs)
{
    word i;

    LOGF(("[PATH]", "FlattenCubic segs=%u x0=%d y0=%d c1=%d,%d c2=%d,%d x1=%d y1=%d",
            (unsigned)segs, (int)x0, (int)y0, (int)c1x, (int)c1y, (int)c2x, (int)c2y, (int)x1, (int)y1));

    for (i = 1; i <= segs; i++) {
        WWFixedAsDWord t   = (WWFixedAsDWord)(((dword)i << 16) / segs);
        WWFixedAsDWord it  = WWFIXED_ONE - t;
        WWFixedAsDWord it2 = GrMulWWFixed(it, it);
        WWFixedAsDWord t2  = GrMulWWFixed(t, t);

        WWFixedAsDWord k0 = GrMulWWFixed(it2, it);                                /* (1-t)^3 */
        WWFixedAsDWord k1 = GrMulWWFixed(MakeWWFixed(3), GrMulWWFixed(it2, t));    /* 3(1-t)^2 t */
        WWFixedAsDWord k2 = GrMulWWFixed(MakeWWFixed(3), GrMulWWFixed(it, t2));    /* 3(1-t) t^2 */
        WWFixedAsDWord k3 = GrMulWWFixed(t2, t);                                   /* t^3 */

        WWFixedAsDWord X =
            GrMulWWFixed(k0, ((sdword)x0 << 16)) +
            GrMulWWFixed(k1, ((sdword)c1x << 16)) +
            GrMulWWFixed(k2, ((sdword)c2x << 16)) +
            GrMulWWFixed(k3, ((sdword)x1  << 16));

        WWFixedAsDWord Y =
            GrMulWWFixed(k0, ((sdword)y0 << 16)) +
            GrMulWWFixed(k1, ((sdword)c1y << 16)) +
            GrMulWWFixed(k2, ((sdword)c2y << 16)) +
            GrMulWWFixed(k3, ((sdword)y1  << 16));

        SvgPathAddPt(sc, np, (sword)((sdword)X >> 16), (sword)((sdword)Y >> 16));
    }
}

/* C89-safe; keeps existing logging keys. */
static void
SvgPathFlattenArc(SVGScratch *sc, word *pNp,
                  WWFixedAsDWord x0W, WWFixedAsDWord y0W,
                  WWFixedAsDWord rxW, WWFixedAsDWord ryW,
                  WWFixedAsDWord rotW,
                  int laf, int swf,
                  WWFixedAsDWord x1W, WWFixedAsDWord y1W)
{

    WWFixedAsDWord zero = MakeWWFixed(0);
    WWFixedAsDWord one  = MakeWWFixed(1);
    WWFixedAsDWord two  = MakeWWFixed(2);

    WWFixedAsDWord cphi, sphi;
    WWFixedAsDWord dx, dy, x1p, y1p;
    WWFixedAsDWord frx, fry;
    WWFixedAsDWord u2, v2, lam, scale;
    WWFixedAsDWord num, den, s;
    WWFixedAsDWord cxp, cyp, mx, my, cx, cy;
    WWFixedAsDWord ux, uy, vx, vy;
    WWFixedAsDWord th1, dth, dth_raw, absDth;
    WWFixedAsDWord deg360 = MakeWWFixed(360);
    WWFixedAsDWord ddx, ddy, manhattan;
    WWFixedAsDWord deltaMaxDeg = MakeWWFixed(12);
    WWFixedAsDWord nSegWW, stepDeg, theta;
    WWFixedAsDWord xr, yr, xp, yp, x, y;
    WWFixedAsDWord cth, sth;

    /* Patch vars */
    WWFixedAsDWord epsLam, eps360, minR, tinyThresh;
    Boolean nearCoinc, isFull;

    /* snap last vertex to start for near-full arcs */
    sword sxi, syi;
    Boolean snappedToStart;

    sword xi, yi, exi, eyi;
    word  np, remaining, nSeg, k;

    LOGF(("[PATH]", "FlattenArc x0=%d y0=%d rx=%d ry=%d rot=%ld laf=%d sf=%d x1=%d y1=%d",
            (int)(x0W>>16), (int)(y0W>>16),
            (int)(rxW>>16), (int)(ryW>>16),
            (long)rotW, laf, swf,
            (int)(x1W>>16), (int)(y1W>>16)));

    /* Identical endpoints => nothing to draw (spec) */
    if (x0W == x1W && y0W == y1W)
    {
        LOG_STR("[PATH]", "A: end equals current (exact) -> skip");
        return;
    }

    /* Degenerate radii => straight line */
    if ((SvgGeomWWFixedToSWordRound(rxW) == 0) ||
        (SvgGeomWWFixedToSWordRound(ryW) == 0))
    {
        if (*pNp < MAX_SVG_POINTS)
        {
            sc->pts[*pNp].P_x = SvgGeomWWFixedToSWordRound(x1W);
            sc->pts[*pNp].P_y = SvgGeomWWFixedToSWordRound(y1W);
            (*pNp)++;
        }
        LOG_STR("[PATH]", "A: zero radius -> straight line");
        return;
    }

    frx  = SvgGeomWWAbs(rxW);
    fry  = SvgGeomWWAbs(ryW);
    cphi = GrQuickCosine(rotW);
    sphi = GrQuickSine(rotW);

    /* Endpoint delta & quick chord metrics (for logs only) */
    ddx = SvgGeomWWAbs(GrSubWWFixed(x1W, x0W));
    ddy = SvgGeomWWAbs(GrSubWWFixed(y1W, y0W));
    manhattan = GrAddWWFixed(ddx, ddy);

    LOGF(("[PATH]", "ArcChord dx=%.5f dy=%.5f L1=%.5f",
            (double)ddx/65536.0, (double)ddy/65536.0, (double)manhattan/65536.0));

    /* Transform into ellipse-aligned frame (primed) — back to original sign */
    dx  = GrSDivWWFixed(GrSubWWFixed(x0W, x1W), two);
    dy  = GrSDivWWFixed(GrSubWWFixed(y0W, y1W), two);
    x1p = GrAddWWFixed(GrMulWWFixed(cphi, dx),  GrMulWWFixed(sphi, dy));
    y1p = GrAddWWFixed((WWFixedAsDWord)(-(sdword)GrMulWWFixed(sphi, dx)),
                       GrMulWWFixed(cphi, dy));

    LOGF(("[PATH]", "PrimedFrame x1p=%.5f y1p=%.5f",
            (double)x1p/65536.0, (double)y1p/65536.0));

    /* Radius correction (λ = u^2 + v^2) */
    u2  = GrSDivWWFixed(SvgGeomWWAbs(x1p), frx); u2 = GrMulWWFixed(u2, u2);
    v2  = GrSDivWWFixed(SvgGeomWWAbs(y1p), fry); v2 = GrMulWWFixed(v2, v2);
    lam = GrAddWWFixed(u2, v2);

    LOGF(("[PATH]", "Lam before=%ld (%.6f) u2=%.6f v2=%.6f",
            (long)lam,(double)lam/65536.0,(double)u2/65536.0,(double)v2/65536.0));

    if ((sdword)lam > (sdword)one)
    {
        scale = SvgGeomWWSqrt(lam);
        frx   = GrMulWWFixed(frx, scale);
        fry   = GrMulWWFixed(fry, scale);

        LOGF(("[PATH]", "RadiusCorrect scale=%.6f -> frx=%.5f fry=%.5f",
                (double)scale/65536.0, (double)frx/65536.0, (double)fry/65536.0));
    }

    /* Center in primed frame (sign encodes large/small + sweep) */
    u2  = GrSDivWWFixed(x1p, frx); u2 = GrMulWWFixed(u2, u2);
    v2  = GrSDivWWFixed(y1p, fry); v2 = GrMulWWFixed(v2, v2);
    lam = GrAddWWFixed(u2, v2);

    /* Patch 1: clamp lam away from zero (smaller floor to avoid center bias) */
    epsLam = GrSDivWWFixed(MakeWWFixed(1), MakeWWFixed(16384)); /* 1/16384 ≈ 0.000061 */
    if ((sdword)lam <= 0)
    {
        lam = epsLam;
    }
    else if ((sdword)lam < (sdword)epsLam)
    {
        lam = epsLam;
    }

    num = GrSubWWFixed(one, lam); if ((sdword)num < 0) num = zero;
    den = lam; /* non-zero due to clamp above */
    s   = SvgGeomWWSqrt(GrSDivWWFixed(num, den));
    if (laf == swf) { s = (WWFixedAsDWord)(-(sdword)s); }

    cxp = GrMulWWFixed(s, GrMulWWFixed(frx, GrSDivWWFixed(y1p, fry)));
    cyp = GrMulWWFixed(s, (WWFixedAsDWord)(-(sdword)GrMulWWFixed(fry, GrSDivWWFixed(x1p, frx))));

    /* Back to original frame */
    mx = GrSDivWWFixed(GrAddWWFixed(x0W, x1W), two);
    my = GrSDivWWFixed(GrAddWWFixed(y0W, y1W), two);
    cx = GrAddWWFixed(GrSubWWFixed(GrMulWWFixed(cphi, cxp), GrMulWWFixed(sphi, cyp)), mx);
    cy = GrAddWWFixed(GrAddWWFixed(GrMulWWFixed(sphi, cxp), GrMulWWFixed(cphi, cyp)), my);

    LOGF(("[PATH]", "Centers cxp=%.5f cyp=%.5f  ->  cx=%.5f cy=%.5f",
            (double)cxp/65536.0,(double)cyp/65536.0,(double)cx/65536.0,(double)cy/65536.0));

    /* u, v vectors per SVG spec */
    ux = GrSDivWWFixed(GrSubWWFixed(x1p, cxp), frx);
    uy = GrSDivWWFixed(GrSubWWFixed(y1p, cyp), fry);
    vx = GrSDivWWFixed(GrSubWWFixed((WWFixedAsDWord)(-(sdword)x1p), cxp), frx);
    vy = GrSDivWWFixed(GrSubWWFixed((WWFixedAsDWord)(-(sdword)y1p), cyp), fry);

    th1     = SvgGeomWWAtan2Deg(uy, ux);
    dth_raw = SvgGeomWWAtan2Deg(
                  GrSubWWFixed(GrMulWWFixed(ux, vy), GrMulWWFixed(uy, vx)),
                  GrAddWWFixed(GrMulWWFixed(ux, vx), GrMulWWFixed(uy, vy)));

    LOGF(("[ARCDBG]", "Angles th1=%ld (%.3f°) dth_raw=%ld (%.3f°)",
            (long)th1,(double)th1/65536.0,(long)dth_raw,(double)dth_raw/65536.0));

    /* Normalize sweep sign ONLY (do not clamp to 180 or 360) */
    dth = dth_raw;
    if (!swf) { if ((sdword)dth > 0) dth = GrSubWWFixed(dth, deg360); }
    else      { if ((sdword)dth < 0) dth = GrAddWWFixed(dth, deg360); }

    LOGF(("[ARCSEL]", "AfterSweep dth=%ld (%.3f°) sf=%d",
            (long)dth, (double)dth/65536.0, swf));

    /* Patch 2: near-coincident chord ⇒ near-full sweep (center untouched) */
    minR = ((sdword)frx < (sdword)fry) ? frx : fry;
    tinyThresh = GrSDivWWFixed(minR, MakeWWFixed(64));        /* 1/64 of min radius */
    nearCoinc = ((sdword)manhattan <= (sdword)tinyThresh) ? TRUE : FALSE;

    eps360 = GrSDivWWFixed(MakeWWFixed(1), MakeWWFixed(10));  /* 0.1° */
    if (nearCoinc)
    {
        if ((sdword)dth >= 0) {
            dth = GrSubWWFixed(deg360, eps360);
        } else {
            dth = (WWFixedAsDWord)(-(sdword)GrSubWWFixed(deg360, eps360));
        }
    }

    absDth = SvgGeomWWAbs(dth);

    LOGF(("[PATH]", "Chord manhattan=%ld minR=%ld tinyChord=%ld nearCoinc=%u",
            (long)manhattan, (long)minR, (long)tinyThresh, (unsigned)nearCoinc));

    isFull = ((sdword)absDth >= (sdword)GrSubWWFixed(deg360, eps360)) ? TRUE : FALSE;

    LOG_STR("[PATH]", isFull ? "Decision isFull=1 (why: nearCoinc/eps360)"
                             : "Decision isFull=0 (why: none)");

    LOGF(("[ARCDBG]", "FinalAngles th1=%ld (%.3f°) dth=%ld (%.3f°) laf=%d sf=%d",
            (long)th1,(double)th1/65536.0,(long)dth,(double)dth/65536.0, laf, swf));

    /* Segment count (<= ~12° per segment) */
    nSegWW = GrSDivWWFixed(absDth, deltaMaxDeg);
    nSeg   = (word)SvgGeomWWFixedToSWordRound(nSegWW);
    if (GrMulWWFixed(MakeWWFixed(nSeg), deltaMaxDeg) < absDth) nSeg++;
    if (nSeg < 1) nSeg = 1;

    LOGF(("[ARCDBG]", "Segmentation absDth=%.3f° nSeg=%u (cap=12°)",
            (double)absDth/65536.0, (unsigned)nSeg));
    if (nSeg == 1) LOG_STR("[WARN]", "nSeg==1 (very short arc) — may look like a chord");

    /* Prepare snap-to-start info (device space) */
    sxi = SvgGeomWWFixedToSWordRound(x0W);
    syi = SvgGeomWWFixedToSWordRound(y0W);
    snappedToStart = FALSE;

    /* Emit */
    np        = *pNp;
    remaining = (MAX_SVG_POINTS > np) ? (MAX_SVG_POINTS - np) : 0;
    if (remaining == 0)
    {
        LOG_STR("[PATH]", "FlattenArc: no buffer space");
        return;
    }
    if (nSeg > remaining) nSeg = remaining;

    exi = SvgGeomWWFixedToSWordRound(x1W);
    eyi = SvgGeomWWFixedToSWordRound(y1W);

    stepDeg = GrSDivWWFixed(dth, MakeWWFixed(nSeg));
    for (k = 1; k <= nSeg; k++)
    {
        theta = GrAddWWFixed(th1, GrMulWWFixed(stepDeg, MakeWWFixed(k)));
        cth   = GrQuickCosine(theta);
        sth   = GrQuickSine(theta);

        xr = GrMulWWFixed(frx, cth);
        yr = GrMulWWFixed(fry, sth);

        xp = GrSubWWFixed(GrMulWWFixed(cphi, xr), GrMulWWFixed(sphi, yr));
        yp = GrAddWWFixed(GrMulWWFixed(sphi, xr), GrMulWWFixed(cphi, yr));

        x = GrAddWWFixed(xp, cx);
        y = GrAddWWFixed(yp, cy);

        xi = SvgGeomWWFixedToSWordRound(x);
        yi = SvgGeomWWFixedToSWordRound(y);

        /* eliminate tiny closing chord for near-full arcs */
        if (nearCoinc && (k == nSeg))
        {
            xi = sxi;
            yi = syi;
            snappedToStart = TRUE;
        }

        if (np < MAX_SVG_POINTS)
        {
            sc->pts[np].P_x = xi;
            sc->pts[np].P_y = yi;
            np++;
        }
        else
        {
            break;
        }
    }
    *pNp = np;

    LOGF(("[PATH]", "Emit done: last=(%d,%d) endRound=(%d,%d) segs=%u%s",
            (int)xi,(int)yi,(int)exi,(int)eyi,(unsigned)nSeg,
            snappedToStart ? " snappedToStart=1" : ""));

}


/* ---------- per-command implementations ---------- */

static void
SvgPathHandleMoveTo(const char **sPP, char *lastCmdP,
                    SVGScratch *sc, word *npP,
                    sword *lastxP, sword *lastyP,
                    sword *subStartXP, sword *subStartYP,
                    Boolean *lastWasCubicP, Boolean *lastWasQuadP)
{
    const char     *sP;
    sword           x, y;
    WWFixedAsDWord  f, fx, fy;
    sword           dx, dy;

    sP = *sPP;

    /* Allow optional comma before numbers (spec permits it) */
    sP = SvgSkipCommaWS(sP);

    if (*lastCmdP == 'M')
    {
        sP = SvgParserParseWWFixed16_16(sP, &f);
        x  = SvgViewMapPosX_F(f);

        sP = SvgSkipCommaWS(sP);
        sP = SvgParserParseWWFixed16_16(sP, &f);
        y  = SvgViewMapPosY_F(f);
    }
    else /* 'm' */
    {
        sP = SvgSkipCommaWS(sP);
        sP = SvgParserParseWWFixed16_16(sP, &fx);
        dx = SvgViewMapLenX_F(fx);

        sP = SvgSkipCommaWS(sP);
        sP = SvgParserParseWWFixed16_16(sP, &fy);
        dy = SvgViewMapLenY_F(fy);

        x = (sword)(*lastxP + dx);
        y = (sword)(*lastyP + dy);
    }

    LOGF(("[PATH]", "M to x=%d y=%d", (int)x, (int)y));

    *lastxP = x;
    *lastyP = y;
    *subStartXP = x;
    *subStartYP = y;

    if (*npP < MAX_SVG_POINTS)
    {
        sc->pts[*npP].P_x = x;
        sc->pts[*npP].P_y = y;
        (*npP)++;
    }

    /* Per SVG spec, any additional coordinate pairs after M/m are L/l */
    *lastCmdP = (*lastCmdP == 'M') ? 'L' : 'l';
    *lastWasCubicP = FALSE;
    *lastWasQuadP  = FALSE;

    *sPP = sP;
}


static void
SvgPathHandleLineTo(const char **sPP, char lastCmd,
                    SVGScratch *sc, word *npP,
                    sword *lastxP, sword *lastyP,
                    Boolean *lastWasCubicP, Boolean *lastWasQuadP)
{
    const char     *sP;
    const char     *probeP;
    Boolean         isAbs;
    sword           lx, ly;
    WWFixedAsDWord  f, fx, fy;
    sword           dx, dy;

    sP    = *sPP;
    isAbs = (lastCmd == 'L');

    for (;;)
    {
        sP = SvgSkipCommaWS(sP);
        if (!*sP) { break; }
        if (!SvgIsNumStart(*sP)) { break; }

        if (isAbs)
        {
            sP = SvgParserParseWWFixed16_16(sP, &f);
            lx = SvgViewMapPosX_F(f);

            sP = SvgSkipCommaWS(sP);
            sP = SvgParserParseWWFixed16_16(sP, &f);
            ly = SvgViewMapPosY_F(f);
        }
        else /* 'l' */
        {
            sP = SvgParserParseWWFixed16_16(sP, &fx);
            dx = SvgViewMapLenX_F(fx);

            sP = SvgSkipCommaWS(sP);
            sP = SvgParserParseWWFixed16_16(sP, &fy);
            dy = SvgViewMapLenY_F(fy);

            lx = (sword)(*lastxP + dx);
            ly = (sword)(*lastyP + dy);
        }

        LOGF(("[PATH]", "L to x=%d y=%d", (int)lx, (int)ly));

        if (*npP < MAX_SVG_POINTS)
        {
            sc->pts[*npP].P_x = lx;
            sc->pts[*npP].P_y = ly;
            (*npP)++;
        }

        *lastxP = lx;
        *lastyP = ly;
        *lastWasCubicP = FALSE;
        *lastWasQuadP  = FALSE;

        /* repeat only if another number really follows */
        probeP = SvgSkipCommaWS(sP);
        if (!SvgIsNumStart(*probeP)) { break; }
    }

    *sPP = sP;
}


static void
SvgPathHandleHLineTo(const char **sPP, char lastCmd,
                     SVGScratch *sc, word *npP,
                     sword *lastxP, sword *lastyP,
                     Boolean *lastWasCubicP, Boolean *lastWasQuadP)
{
    const char     *sP;
    const char     *probeP;
    Boolean         isAbs;
    sword           lx;
    WWFixedAsDWord  f, fx;
    sword           dx;

    sP    = *sPP;
    isAbs = (lastCmd == 'H');

    for (;;)
    {
        sP = SvgSkipCommaWS(sP);
        if (!*sP) {
            break;
        }
        if (!SvgIsNumStart(*sP)) {
            break;
        }

        if (isAbs)
        {
            sP = SvgParserParseWWFixed16_16(sP, &f);
            lx = SvgViewMapPosX_F(f);
        }
        else /* 'h' */
        {
            sP = SvgParserParseWWFixed16_16(sP, &fx);
            dx = SvgViewMapLenX_F(fx);
            lx = (sword)(*lastxP + dx);
        }

        LOGF(("[PATH]", "H to x=%d y=%d", (int)lx, (int)(*lastyP)));

        if (*npP < MAX_SVG_POINTS)
        {
            sc->pts[*npP].P_x = lx;
            sc->pts[*npP].P_y = *lastyP;
            (*npP)++;
        }

        *lastxP = lx;
        *lastWasCubicP = FALSE;
        *lastWasQuadP  = FALSE;

        /* repeat only if another number really follows */
        probeP = SvgSkipCommaWS(sP);
        if (!SvgIsNumStart(*probeP)) {
            break;
        }
    }

    *sPP = sP;
}

static void
SvgPathHandleVLineTo(const char **sPP, char lastCmd,
                     SVGScratch *sc, word *npP,
                     sword *lastxP, sword *lastyP,
                     Boolean *lastWasCubicP, Boolean *lastWasQuadP)
{
    const char     *sP;
    const char     *probeP;
    Boolean         isAbs;
    sword           ly;
    WWFixedAsDWord  f, fy;
    sword           dy;

    sP    = *sPP;
    isAbs = (lastCmd == 'V');

    for (;;)
    {
        sP = SvgSkipCommaWS(sP);
        if (!*sP) {
            break;
        }
        if (!SvgIsNumStart(*sP)) {
            break;
        }

        if (isAbs)
        {
            sP = SvgParserParseWWFixed16_16(sP, &f);
            ly = SvgViewMapPosY_F(f);
        }
        else /* 'v' */
        {
            sP = SvgParserParseWWFixed16_16(sP, &fy);
            dy = SvgViewMapLenY_F(fy);
            ly = (sword)(*lastyP + dy);
        }

        LOGF(("[PATH]", "V to x=%d y=%d", (int)(*lastxP), (int)ly));

        if (*npP < MAX_SVG_POINTS)
        {
            sc->pts[*npP].P_x = *lastxP;
            sc->pts[*npP].P_y = ly;
            (*npP)++;
        }

        *lastyP = ly;
        *lastWasCubicP = FALSE;
        *lastWasQuadP  = FALSE;

        /* repeat only if another number really follows */
        probeP = SvgSkipCommaWS(sP);
        if (!SvgIsNumStart(*probeP)) {
            break;
        }
    }

    *sPP = sP;
}

static void
SvgPathHandleQuadratic(const char **sPP, char lastCmd,
                       SVGScratch *sc, word *npP,
                       sword *lastxP, sword *lastyP,
                       Boolean *lastWasCubicP, Boolean *lastWasQuadP,
                       sword *lastQcxP, sword *lastQcyP)
{
    const char     *sP;
    const char     *probeP;
    Boolean         isAbs;
    sword           cx, cy, ex, ey;
    WWFixedAsDWord  f;
    sword           dcx, dcy, dex, dey;

    sP    = *sPP;
    isAbs = (lastCmd == 'Q');

    for (;;)
    {
        sP = SvgSkipCommaWS(sP);
        if (!*sP) { break; }
        if (!SvgIsNumStart(*sP)) { break; }

        if (isAbs)
        {
            sP = SvgParserParseWWFixed16_16(sP, &f);
            cx = SvgViewMapPosX_F(f);

            sP = SvgSkipCommaWS(sP);
            sP = SvgParserParseWWFixed16_16(sP, &f);
            cy = SvgViewMapPosY_F(f);

            sP = SvgSkipCommaWS(sP);
            sP = SvgParserParseWWFixed16_16(sP, &f);
            ex = SvgViewMapPosX_F(f);

            sP = SvgSkipCommaWS(sP);
            sP = SvgParserParseWWFixed16_16(sP, &f);
            ey = SvgViewMapPosY_F(f);
        }
        else /* 'q' */
        {
            sP = SvgParserParseWWFixed16_16(sP, &f);
            dcx = SvgViewMapLenX_F(f);

            sP = SvgSkipCommaWS(sP);
            sP = SvgParserParseWWFixed16_16(sP, &f);
            dcy = SvgViewMapLenY_F(f);

            sP = SvgSkipCommaWS(sP);
            sP = SvgParserParseWWFixed16_16(sP, &f);
            dex = SvgViewMapLenX_F(f);

            sP = SvgSkipCommaWS(sP);
            sP = SvgParserParseWWFixed16_16(sP, &f);
            dey = SvgViewMapLenY_F(f);

            cx = (sword)(*lastxP + dcx);
            cy = (sword)(*lastyP + dcy);
            ex = (sword)(*lastxP + dex);
            ey = (sword)(*lastyP + dey);
        }

        LOGF(("[PATH]", "Q c=%d,%d e=%d,%d", (int)cx, (int)cy, (int)ex, (int)ey));

        SvgPathFlattenQuad(sc, npP, *lastxP, *lastyP, cx, cy, ex, ey, 8);

        *lastxP = ex;
        *lastyP = ey;
        *lastWasQuadP  = TRUE;
        *lastQcxP      = cx;
        *lastQcyP      = cy;
        *lastWasCubicP = FALSE;

        /* repeat only if another number really follows */
        probeP = SvgSkipCommaWS(sP);
        if (!SvgIsNumStart(*probeP)) { break; }
    }

    *sPP = sP;
}

static void
SvgPathHandleSmoothQuadratic(const char **sPP, char lastCmd,
                             SVGScratch *sc, word *npP,
                             sword *lastxP, sword *lastyP,
                             Boolean *lastWasCubicP, Boolean *lastWasQuadP,
                             sword *lastQcxP, sword *lastQcyP)
{
    const char     *sP;
    const char     *probeP;
    Boolean         isAbs;
    sword           ex, ey, cx, cy;
    WWFixedAsDWord  f;
    sword           dex, dey;

    sP    = *sPP;
    isAbs = (lastCmd == 'T');

    for (;;)
    {
        sP = SvgSkipCommaWS(sP);
        if (!*sP) { break; }
        if (!SvgIsNumStart(*sP)) { break; }

        if (isAbs)
        {
            sP = SvgParserParseWWFixed16_16(sP, &f);
            ex = SvgViewMapPosX_F(f);

            sP = SvgSkipCommaWS(sP);
            sP = SvgParserParseWWFixed16_16(sP, &f);
            ey = SvgViewMapPosY_F(f);
        }
        else /* 't' */
        {
            sP = SvgParserParseWWFixed16_16(sP, &f);
            dex = SvgViewMapLenX_F(f);

            sP = SvgSkipCommaWS(sP);
            sP = SvgParserParseWWFixed16_16(sP, &f);
            dey = SvgViewMapLenY_F(f);

            ex = (sword)(*lastxP + dex);
            ey = (sword)(*lastyP + dey);
        }

        if (*lastWasQuadP)
        {
            cx = (sword)(*lastxP + (*lastxP - *lastQcxP));
            cy = (sword)(*lastyP + (*lastyP - *lastQcyP));
        }
        else
        {
            cx = *lastxP;
            cy = *lastyP;
        }

        LOGF(("[PATH]", "T c=%d,%d e=%d,%d", (int)cx, (int)cy, (int)ex, (int)ey));

        SvgPathFlattenQuad(sc, npP, *lastxP, *lastyP, cx, cy, ex, ey, 8);

        *lastxP = ex;
        *lastyP = ey;
        *lastWasQuadP  = TRUE;
        *lastQcxP      = cx;
        *lastQcyP      = cy;
        *lastWasCubicP = FALSE;

        /* repeat only if another number really follows */
        probeP = SvgSkipCommaWS(sP);
        if (!SvgIsNumStart(*probeP)) { break; }
    }

    *sPP = sP;
}

/* --- robust cubic with stall guard --- */
static void
SvgPathHandleCubic(const char **sPP, char lastCmd,
                   SVGScratch *sc, word *npP,
                   sword *lastxP, sword *lastyP,
                   Boolean *lastWasCubicP, Boolean *lastWasQuadP,
                   sword *lastC2xP, sword *lastC2yP)
{
    const char     *sP;
    const char     *probeP;
    const char     *before;
    Boolean         isAbs;
    sword           c1x, c1y, c2x, c2y, ex, ey;
    WWFixedAsDWord  f;
    sword           dc1x, dc1y, dc2x, dc2y, dex, dey;

    sP    = *sPP;
    isAbs = (lastCmd == 'C');

    for (;;)
    {
        sP = SvgSkipCommaWS(sP);
        if (!*sP) { break; }
        if (!SvgIsNumStart(*sP)) { break; }

        if (isAbs)
        {
            before = sP; sP = SvgParserParseWWFixed16_16(sP, &f); if (sP == before) { break; }
            c1x = SvgViewMapPosX_F(f);

            sP = SvgSkipCommaWS(sP);
            before = sP; sP = SvgParserParseWWFixed16_16(sP, &f); if (sP == before) { break; }
            c1y = SvgViewMapPosY_F(f);

            sP = SvgSkipCommaWS(sP);
            before = sP; sP = SvgParserParseWWFixed16_16(sP, &f); if (sP == before) { break; }
            c2x = SvgViewMapPosX_F(f);

            sP = SvgSkipCommaWS(sP);
            before = sP; sP = SvgParserParseWWFixed16_16(sP, &f); if (sP == before) { break; }
            c2y = SvgViewMapPosY_F(f);

            sP = SvgSkipCommaWS(sP);
            before = sP; sP = SvgParserParseWWFixed16_16(sP, &f); if (sP == before) { break; }
            ex  = SvgViewMapPosX_F(f);

            sP = SvgSkipCommaWS(sP);
            before = sP; sP = SvgParserParseWWFixed16_16(sP, &f); if (sP == before) { break; }
            ey  = SvgViewMapPosY_F(f);
        }
        else /* 'c' */
        {
            before = sP; sP = SvgParserParseWWFixed16_16(sP, &f); if (sP == before) { break; }
            dc1x = SvgViewMapLenX_F(f);

            sP = SvgSkipCommaWS(sP);
            before = sP; sP = SvgParserParseWWFixed16_16(sP, &f); if (sP == before) { break; }
            dc1y = SvgViewMapLenY_F(f);

            sP = SvgSkipCommaWS(sP);
            before = sP; sP = SvgParserParseWWFixed16_16(sP, &f); if (sP == before) { break; }
            dc2x = SvgViewMapLenX_F(f);

            sP = SvgSkipCommaWS(sP);
            before = sP; sP = SvgParserParseWWFixed16_16(sP, &f); if (sP == before) { break; }
            dc2y = SvgViewMapLenY_F(f);

            sP = SvgSkipCommaWS(sP);
            before = sP; sP = SvgParserParseWWFixed16_16(sP, &f); if (sP == before) { break; }
            dex  = SvgViewMapLenX_F(f);

            sP = SvgSkipCommaWS(sP);
            before = sP; sP = SvgParserParseWWFixed16_16(sP, &f); if (sP == before) { break; }
            dey  = SvgViewMapLenY_F(f);

            c1x = (sword)(*lastxP + dc1x);
            c1y = (sword)(*lastyP + dc1y);
            c2x = (sword)(*lastxP + dc2x);
            c2y = (sword)(*lastyP + dc2y);
            ex  = (sword)(*lastxP + dex);
            ey  = (sword)(*lastyP + dey);
        }

        SvgPathFlattenCubic(sc, npP, *lastxP, *lastyP, c1x, c1y, c2x, c2y, ex, ey, 10);

        *lastxP = ex;
        *lastyP = ey;
        *lastC2xP = c2x;
        *lastC2yP = c2y;
        *lastWasCubicP = TRUE;
        *lastWasQuadP  = FALSE;

        probeP = SvgSkipCommaWS(sP);
        if (!SvgIsNumStart(*probeP)) { break; }
    }

    *sPP = sP;
}

static void
SvgPathHandleSmoothCubic(const char **sPP, char lastCmd,
                         SVGScratch *sc, word *npP,
                         sword *lastxP, sword *lastyP,
                         Boolean *lastWasCubicP, Boolean *lastWasQuadP,
                         sword *lastC2xP, sword *lastC2yP)
{
    const char     *sP = *sPP, *probeP, *before;
    const Boolean   isAbs = (lastCmd == 'S');
    sword c1x, c1y, c2x, c2y, ex, ey;
    sword dc2x, dc2y, dex, dey;
    WWFixedAsDWord  f;

    for (;;) {
        sP = SvgSkipCommaWS(sP);
        if (!*sP || !SvgIsNumStart(*sP)) break;

        /* reflect previous C2 if last segment was cubic, else use current point */
        if (*lastWasCubicP) {
            c1x = (sword)(*lastxP + (*lastxP - *lastC2xP));
            c1y = (sword)(*lastyP + (*lastyP - *lastC2yP));
        } else {
            c1x = *lastxP;
            c1y = *lastyP;
        }

        if (isAbs) {
            before=sP; sP=SvgParserParseWWFixed16_16(sP,&f); if (sP==before) break; c2x = SvgViewMapPosX_F(f);
            sP=SvgSkipCommaWS(sP);
            before=sP; sP=SvgParserParseWWFixed16_16(sP,&f); if (sP==before) break; c2y = SvgViewMapPosY_F(f);
            sP=SvgSkipCommaWS(sP);
            before=sP; sP=SvgParserParseWWFixed16_16(sP,&f); if (sP==before) break; ex  = SvgViewMapPosX_F(f);
            sP=SvgSkipCommaWS(sP);
            before=sP; sP=SvgParserParseWWFixed16_16(sP,&f); if (sP==before) break; ey  = SvgViewMapPosY_F(f);
        } else {
            before=sP; sP=SvgParserParseWWFixed16_16(sP,&f); if (sP==before) break; dc2x = SvgViewMapLenX_F(f);
            sP=SvgSkipCommaWS(sP);
            before=sP; sP=SvgParserParseWWFixed16_16(sP,&f); if (sP==before) break; dc2y = SvgViewMapLenY_F(f);
            sP=SvgSkipCommaWS(sP);
            before=sP; sP=SvgParserParseWWFixed16_16(sP,&f); if (sP==before) break; dex  = SvgViewMapLenX_F(f);
            sP=SvgSkipCommaWS(sP);
            before=sP; sP=SvgParserParseWWFixed16_16(sP,&f); if (sP==before) break; dey  = SvgViewMapLenY_F(f);
            c2x = (sword)(*lastxP + dc2x);
            c2y = (sword)(*lastyP + dc2y);
            ex  = (sword)(*lastxP + dex);
            ey  = (sword)(*lastyP + dey);
        }

        SvgPathFlattenCubic(sc, npP, *lastxP, *lastyP, c1x, c1y, c2x, c2y, ex, ey, 10);

        *lastxP = ex;  *lastyP = ey;
        *lastC2xP = c2x; *lastC2yP = c2y;
        *lastWasCubicP = TRUE; *lastWasQuadP = FALSE;

        probeP = SvgSkipCommaWS(sP);
        if (!SvgIsNumStart(*probeP)) break;
    }
    *sPP = sP;
}

static void
SvgPathHandleArc(const char **sPP, char lastCmd,
                 SVGScratch *sc, word *npP,
                 sword *lastxP, sword *lastyP,
                 Boolean *lastWasCubicP, Boolean *lastWasQuadP)
{
    const char      *sP;
    WWFixedAsDWord   rxW, ryW, rotW;
    WWFixedAsDWord   exW, eyW, dxW, dyW;
    WWFixedAsDWord   x0W, y0W;
    int              laf, swf;
    byte             lafB, swfB;
    Boolean          done;
    const char      *probeP;

    sP   = *sPP;
    done = FALSE;

    while (!done)
    {
        /* Repeat-guard: only continue if the next token can start a number. */
        sP = SvgSkipCommaWS(sP);
        if (!*sP) { break; }
        if (!SvgIsNumStart(*sP))
        {
            /* Next is a command letter (e.g., h/v/z/M...) or something else. Stop repeating. */
            done = TRUE;
            continue;
        }

        /* rx, ry, rot */
        sP = SvgParserParseWWFixed16_16(sP, &rxW);
        sP = SvgSkipCommaWS(sP);
        sP = SvgParserParseWWFixed16_16(sP, &ryW);
        sP = SvgSkipCommaWS(sP);
        sP = SvgParserParseWWFixed16_16(sP, &rotW);

        /* flags (must be single '0'/'1', with comma+WS skipping) */
        if (!SvgReadFlag(&sP, &lafB)) { done = TRUE; continue; }
        if (!SvgReadFlag(&sP, &swfB)) { done = TRUE; continue; }
        laf  = (int)lafB;
        swf  = (int)swfB;

        /* end point (absolute for 'A', relative for 'a') */
        if (lastCmd == 'A')
        {
            sP = SvgSkipCommaWS(sP);
            sP = SvgParserParseWWFixed16_16(sP, &exW);
            sP = SvgSkipCommaWS(sP);
            sP = SvgParserParseWWFixed16_16(sP, &eyW);
        }
        else /* 'a' */
        {
            sP = SvgSkipCommaWS(sP);
            sP = SvgParserParseWWFixed16_16(sP, &dxW);
            sP = SvgSkipCommaWS(sP);
            sP = SvgParserParseWWFixed16_16(sP, &dyW);

            exW = SvgGeomMakeWWFixedFromInt(*lastxP);
            eyW = SvgGeomMakeWWFixedFromInt(*lastyP);
            exW = GrAddWWFixed(exW, dxW);
            eyW = GrAddWWFixed(eyW, dyW);
        }

        /* Per spec, radii are non-negative; clamp just in case. */
        if ((sdword)rxW < 0) { rxW = (WWFixedAsDWord)-(sdword)rxW; }
        if ((sdword)ryW < 0) { ryW = (WWFixedAsDWord)-(sdword)ryW; }

        LOGF(("[PATH]", "A rx=%d ry=%d rot=%ld laf=%d sf=%d ex=%d ey=%d",
                (int)(rxW>>16),(int)(ryW>>16),(long)rotW, laf, swf,
                (int)(exW>>16),(int)(eyW>>16)));

        /* Degenerate: zero radius -> straight line */
        if ((SvgGeomWWFixedToSWordRound(rxW) == 0) ||
            (SvgGeomWWFixedToSWordRound(ryW) == 0))
        {
            if (*npP < MAX_SVG_POINTS)
            {
                sc->pts[*npP].P_x = SvgGeomWWFixedToSWordRound(exW);
                sc->pts[*npP].P_y = SvgGeomWWFixedToSWordRound(eyW);
                (*npP)++;
            }
            *lastxP = SvgGeomWWFixedToSWordRound(exW);
            *lastyP = SvgGeomWWFixedToSWordRound(eyW);

            LOG_STR("[PATH]", "A: zero radius -> straight line");

            /* Decide if more arcs follow */
            probeP = SvgSkipCommaWS(sP);
            if (!SvgIsNumStart(*probeP)) { done = TRUE; }
            continue;
        }

        x0W = ((WWFixedAsDWord)(*lastxP)) << 16;
        y0W = ((WWFixedAsDWord)(*lastyP)) << 16;

        /* Skip truly degenerate arcs (exact equality in WWFixed). */
        if ((exW == x0W) && (eyW == y0W))
        {
            LOG_STR("[PATH]", "A: end equals current (exact) -> skip");

            probeP = SvgSkipCommaWS(sP);
            if (!SvgIsNumStart(*probeP)) { done = TRUE; }
            continue;
        }

        SvgPathFlattenArc(sc, npP, x0W, y0W, rxW, ryW, rotW, laf, swf, exW, eyW);

        *lastxP = SvgGeomWWFixedToSWordRound(exW);
        *lastyP = SvgGeomWWFixedToSWordRound(eyW);
        *lastWasCubicP = FALSE;
        *lastWasQuadP  = FALSE;

        /* Repeat only if another numeric set follows */
        probeP = SvgSkipCommaWS(sP);
        if (!SvgIsNumStart(*probeP)) { done = TRUE; }
    }

    *sPP = sP;
}

static void
SvgPathHandleClose(const char **sPP,
                   Boolean *closedP,
                   sword *lastxP, sword *lastyP,
                   sword subStartX, sword subStartY,
                   Boolean *lastWasCubicP, Boolean *lastWasQuadP)
{
    const char *sP = *sPP;

    *closedP = TRUE;
    /* Do not advance sP here; command letter was already consumed */
    *lastxP = subStartX;
    *lastyP = subStartY;
    *lastWasCubicP = FALSE;
    *lastWasQuadP  = FALSE;

    LOGF(("[PATH]", "Z close to x=%d y=%d", (int)subStartX, (int)subStartY));

    *sPP = sP;
}

static void
SvgPathHandleUnknown(const char **sPP,
                     Boolean *lastWasCubicP, Boolean *lastWasQuadP)
{
    const char *sP;

    sP = *sPP;

    LOGF(("[PATH]", "unknown cmd 0x%02X", (unsigned char)(*sP)));

    *lastWasCubicP = FALSE;
    *lastWasQuadP  = FALSE;

    *sPP = sP;
}


/* ---- sub path emitter ---- */
/* ---- sub path emitter ---- */
static void
SvgPathEmitSubpath(const char *tag, SVGScratch *sc, word *npP,
                   Boolean closed, Boolean inCompound)
{
    word i, np, w;
    sword px, py, firstx, firsty, lastx, lasty;
    Boolean hasStroke;
    Boolean needStrokeClose;
    SvgMatrix worldM;

    firstx = 0;
    firsty = 0;
    lastx  = 0;
    lasty  = 0;

    np = *npP;
    *npP = 0;
    if (np <= 1) {
        return;
    }

    hasStroke = SvgStyleHasStroke(tag);

    /* Build WORLD matrix = VM ∘ currentGroup ∘ element(tag) */
    SvgXformBuildWorld(tag, NULL, &worldM);   /* ← applies <g> transform too */

    w = 0;
    for (i = 0; i < np; i++) {
        px = sc->pts[i].P_x;
        py = sc->pts[i].P_y;

        /* apply full world transform to path vertices */
        SvgXformApplyPoint(&px, &py, &worldM);

        if (w == 0 || px != lastx || py != lasty) {
            sc->pts[w].P_x = px;
            sc->pts[w].P_y = py;
            w++;
            if (w == 1) {
                firstx = px;
                firsty = py;
            }
            lastx = px;
            lasty = py;
        }
    }
    np = w;
    if (np <= 1) {
        return;
    }

    /* No explicit close for fill while building the compound path. */
    needStrokeClose = (closed && hasStroke &&
                      ((firstx != lastx) || (firsty != lasty)));
    if (needStrokeClose && (np < MAX_SVG_POINTS)) {
        sc->pts[np].P_x = firstx;
        sc->pts[np].P_y = firsty;
        np++;
    }

    Meta_Polyline(sc->pts, np);
}

void SvgPathHandle(const char *tag, SVGScratch *sc)
{
    const char     *sP;
    word            np;
    Boolean         closed;
    sword           lastx, lasty;
    sword           subStartX, subStartY;
    Boolean         lastWasCubic, lastWasQuad;
    sword           lastC2x, lastC2y;
    sword           lastQcx, lastQcy;
    char            lastCmd;
    Boolean         haveCmd;
    word            emitN;
    char            nextCmd;

    /* snapshot per-<path> style to decide compound path behavior */
    Boolean         pathHasFill, pathHasStroke, buildingCompound;

    sc->db[0] = 0;
    if (!SvgParserGetAttrBounded(tag, "d", sc->db, sizeof(sc->db))) {
        return;
    }

    LOG_STR_HEAD("[PATH d]", sc->db, strlen(sc->db));

    /* styles once per <path> */
    SvgStyleApplyStrokeAndFill(tag);
    SvgStyleApplyFillRule(tag);
    SvgStyleApplyStrokeWidth(tag);

    /* decide upfront whether we’ll accumulate a compound path for fill */
    pathHasFill   = SvgStyleHasFill(tag);
    pathHasStroke = SvgStyleHasStroke(tag);

    LOGF(("[STYLE]", "style: fill=%d stroke=%d", (int)pathHasFill, (int)pathHasStroke));

    buildingCompound = FALSE;
    if (pathHasFill) {
        Meta_BeginPath();           /* all subpaths will be appended here */
        buildingCompound = TRUE;
        LOG_STR("[META]", "BeginPath (compound fill)");
    }

    np            = 0;
    closed        = FALSE;
    lastx         = 0;
    lasty         = 0;
    subStartX     = 0;
    subStartY     = 0;
    lastCmd       = 0;
    haveCmd       = FALSE;
    lastWasCubic  = FALSE;
    lastWasQuad   = FALSE;
    lastC2x       = 0;
    lastC2y       = 0;
    lastQcx       = 0;
    lastQcy       = 0;

    sP = sc->db;

    while (*sP)
    {
        sP = SvgParserSkipWS(sP);
        if (!*sP) break;

        LOGF(("[LOOP]", "haveCmd=%d next='%c'(0x%02x)",
                (int)haveCmd, *sP ? *sP : '.', (unsigned)(byte)(*sP)));

        if (isalpha((unsigned char)*sP)) {
            nextCmd = *sP++;   /* consume the command letter */

            /* starting a new subpath? flush the previous one first */
            if ((nextCmd == 'M' || nextCmd == 'm') && (np > 1))
            {
                LOG_STR("[FLUSH]", "flush-before-M");

                emitN = np;
                SvgPathEmitSubpath(tag, sc, &np, closed, buildingCompound);
                LOGF(("[EMIT]", "emit n=%u closed=%d", emitN, (int)closed));

                closed = FALSE;
            }

            lastCmd = nextCmd;
            haveCmd = TRUE;
        }
        else if (!haveCmd)
        {
            break;
        }

        switch (lastCmd) {
        case 'M': case 'm':
            SvgPathHandleMoveTo(&sP, &lastCmd, sc, &np, &lastx, &lasty,
                                &subStartX, &subStartY, &lastWasCubic, &lastWasQuad);
            break;

        case 'L': case 'l':
            SvgPathHandleLineTo(&sP, lastCmd, sc, &np, &lastx, &lasty,
                                &lastWasCubic, &lastWasQuad);
            break;

        case 'H': case 'h':
            SvgPathHandleHLineTo(&sP, lastCmd, sc, &np, &lastx, &lasty,
                                 &lastWasCubic, &lastWasQuad);
            break;

        case 'V': case 'v':
            SvgPathHandleVLineTo(&sP, lastCmd, sc, &np, &lastx, &lasty,
                                 &lastWasCubic, &lastWasQuad);
            break;

        case 'Q': case 'q':
            SvgPathHandleQuadratic(&sP, lastCmd, sc, &np, &lastx, &lasty,
                                   &lastWasCubic, &lastWasQuad, &lastQcx, &lastQcy);
            break;

        case 'T': case 't':
            SvgPathHandleSmoothQuadratic(&sP, lastCmd, sc, &np, &lastx, &lasty,
                                         &lastWasCubic, &lastWasQuad, &lastQcx, &lastQcy);
            break;

        case 'C': case 'c':
            SvgPathHandleCubic(&sP, lastCmd, sc, &np, &lastx, &lasty,
                               &lastWasCubic, &lastWasQuad, &lastC2x, &lastC2y);
            break;

        case 'S': case 's':
            SvgPathHandleSmoothCubic(&sP, lastCmd, sc, &np, &lastx, &lasty,
                                     &lastWasCubic, &lastWasQuad, &lastC2x, &lastC2y);
            break;

        case 'A': case 'a':
            SvgPathHandleArc(&sP, lastCmd, sc, &np, &lastx, &lasty,
                             &lastWasCubic, &lastWasQuad);
            break;

        case 'Z':
        case 'z':
        {
            LOGF(("[CLOSE]", "close-subpath np=%u", np));
            SvgPathHandleClose(&sP, &closed, &lastx, &lasty,
                               subStartX, subStartY, &lastWasCubic, &lastWasQuad);

            if (np > 1) {
                word emitN = np;
                SvgPathEmitSubpath(tag, sc, &np, TRUE, buildingCompound);

                LOGF(("[EMIT]", "emit n=%u closed=1", emitN));
            }
            closed  = FALSE;
            haveCmd = FALSE;   /* fetch next real command at top of loop */
            lastCmd = 0;
            break;
        }

        default:
            SvgPathHandleUnknown(&sP, &lastWasCubic, &lastWasQuad);
            haveCmd = FALSE;
            lastCmd = 0;
            break;
        }
    }

    if (np > 1) {
        word emitN = np;
        SvgPathEmitSubpath(tag, sc, &np, closed, buildingCompound);

        LOGF(("[EMIT]", "final-emit n=%u closed=%d", emitN, (int)closed));
    }

    if (buildingCompound) {
        Meta_EndPath(/*in=*/pathHasFill, /*edges=*/pathHasStroke);

        LOGF(("[META]", "EndPath in=%d edges=%d", (int)pathHasFill, (int)pathHasStroke));
    }
}



