/***********************************************************************
 *
 * PROJECT:      Meta
 * FILE:         svg.goc
 * DESCRIPTION:  Basic SVG parser for Meta library (streamed, GEOS/Watcom)
 *
 ***********************************************************************/

@include <stdapp.goh>

#include <Ansi/string.h>
#include <Ansi/stdlib.h>
#include <Ansi/ctype.h>
#include <file.h>
#include <system.h>
#include <graphics.h>
#include <gstring.h>
#include <meta.h>
#include <float.h>
#include <dbglogmc.h>


#define SVG_COLOR_NAME_LEN   32

typedef struct
{
    byte SNC_r;
    byte SNC_g;
    byte SNC_b;
    char SNC_name[SVG_COLOR_NAME_LEN + 1];   /* NUL-terminated */
} SvgNamedColor;

#define MAX_SVG_POINTS    512
#define SVG_IO_BUF_SIZE   1024
#define TAG_BUF_SIZE      256

/* ===== Fixed-point helpers (16.16) ===== */
#define WWFIXED_ONE      ((WWFixedAsDWord)(1UL << 16))

/* scanner context */
typedef struct {
    MemHandle  ioH;
    char      *ioP;
    word       bytes;
    word       pos;
    Boolean    inTag;
    Boolean    inQuote;
    char       quoteCh;
    word       tagLen;
} ScanCtx;


/* ===== viewBox / viewport & preserveAspectRatio =====
 * World mapping works in this order:
 *   1) subtract viewBox min (positions only)
 *   2) scale by Sx/Sy determined from preserveAspectRatio + width/height
 *   3) add letterbox/pillarbox offset (Ax/Ay) from alignment
 *   4) divide by 2^N (keep META underscale at 1)
 * Lengths are affected by steps (2) and (4) only.
 */
static Boolean        g_vbInited   = FALSE;
static WWFixedAsDWord g_vbMinX     = 0;
static WWFixedAsDWord g_vbMinY     = 0;
static WWFixedAsDWord g_vbW        = 0;
static WWFixedAsDWord g_vbH        = 0;
static WWFixedAsDWord g_vpW        = 0;   /* viewport width  (width attr or vb.w) */
static WWFixedAsDWord g_vpH        = 0;   /* viewport height (height attr or vb.h) */

static WWFixedAsDWord g_scaleX     = WWFIXED_ONE;   /* after preserveAspectRatio */
static WWFixedAsDWord g_scaleY     = WWFIXED_ONE;
static WWFixedAsDWord g_addX       = 0;
static WWFixedAsDWord g_addY       = 0;

/* 1 / (power-of-two reduction) so META world <= 8191 in both axes */
static WWFixedAsDWord g_invPow2    = WWFIXED_ONE;

/* preserveAspectRatio parsed state */
typedef enum { PAR_ALIGN_MIN=0, PAR_ALIGN_MID=1, PAR_ALIGN_MAX=2 } ParAlign;
static Boolean  g_parNone = FALSE;   /* preserveAspectRatio="none" */
static Boolean  g_parSlice = FALSE;  /* slice (vs meet) */
static ParAlign g_parAx = PAR_ALIGN_MID;  /* xMin/xMid/xMax */
static ParAlign g_parAy = PAR_ALIGN_MID;  /* yMin/yMid/yMax */


@start MetaSvgNamedColorRes, data;

/* 147 SVG/CSS color keywords */
@chunkArray SvgNamedColor SvgNamedColors = {
    {240,248,255,"aliceblue"},
    {250,235,215,"antiquewhite"},
    {  0,255,255,"aqua"},
    {127,255,212,"aquamarine"},
    {240,255,255,"azure"},
    {245,245,220,"beige"},
    {255,228,196,"bisque"},
    {  0,  0,  0,"black"},
    {255,235,205,"blanchedalmond"},
    {  0,  0,255,"blue"},
    {138, 43,226,"blueviolet"},
    {165, 42, 42,"brown"},
    {222,184,135,"burlywood"},
    { 95,158,160,"cadetblue"},
    {127,255,  0,"chartreuse"},
    {210,105, 30,"chocolate"},
    {255,127, 80,"coral"},
    {100,149,237,"cornflowerblue"},
    {255,248,220,"cornsilk"},
    {220, 20, 60,"crimson"},
    {  0,255,255,"cyan"},
    {  0,  0,139,"darkblue"},
    {  0,139,139,"darkcyan"},
    {184,134, 11,"darkgoldenrod"},
    {169,169,169,"darkgray"},
    {  0,100,  0,"darkgreen"},
    {169,169,169,"darkgrey"},
    {189,183,107,"darkkhaki"},
    {139,  0,139,"darkmagenta"},
    { 85,107, 47,"darkolivegreen"},
    {255,140,  0,"darkorange"},
    {153, 50,204,"darkorchid"},
    {139,  0,  0,"darkred"},
    {233,150,122,"darksalmon"},
    {143,188,143,"darkseagreen"},
    { 72, 61,139,"darkslateblue"},
    { 47, 79, 79,"darkslategray"},
    { 47, 79, 79,"darkslategrey"},
    {  0,206,209,"darkturquoise"},
    {148,  0,211,"darkviolet"},
    {255, 20,147,"deeppink"},
    {  0,191,255,"deepskyblue"},
    {105,105,105,"dimgray"},
    {105,105,105,"dimgrey"},
    { 30,144,255,"dodgerblue"},
    {178, 34, 34,"firebrick"},
    {255,250,240,"floralwhite"},
    { 34,139, 34,"forestgreen"},
    {255,  0,255,"fuchsia"},
    {220,220,220,"gainsboro"},
    {248,248,255,"ghostwhite"},
    {255,215,  0,"gold"},
    {218,165, 32,"goldenrod"},
    {128,128,128,"gray"},
    {128,128,128,"grey"},
    {  0,128,  0,"green"},
    {173,255, 47,"greenyellow"},
    {240,255,240,"honeydew"},
    {255,105,180,"hotpink"},
    {205, 92, 92,"indianred"},
    { 75,  0,130,"indigo"},
    {255,255,240,"ivory"},
    {240,230,140,"khaki"},
    {230,230,250,"lavender"},
    {255,240,245,"lavenderblush"},
    {124,252,  0,"lawngreen"},
    {255,250,205,"lemonchiffon"},
    {173,216,230,"lightblue"},
    {240,128,128,"lightcoral"},
    {224,255,255,"lightcyan"},
    {250,250,210,"lightgoldenrodyellow"},
    {211,211,211,"lightgray"},
    {144,238,144,"lightgreen"},
    {211,211,211,"lightgrey"},
    {255,182,193,"lightpink"},
    {255,160,122,"lightsalmon"},
    { 32,178,170,"lightseagreen"},
    {135,206,250,"lightskyblue"},
    {119,136,153,"lightslategray"},
    {119,136,153,"lightslategrey"},
    {176,196,222,"lightsteelblue"},
    {255,255,224,"lightyellow"},
    {  0,255,  0,"lime"},
    { 50,205, 50,"limegreen"},
    {250,240,230,"linen"},
    {255,  0,255,"magenta"},
    {128,  0,  0,"maroon"},
    {102,205,170,"mediumaquamarine"},
    {  0,  0,205,"mediumblue"},
    {186, 85,211,"mediumorchid"},
    {147,112,219,"mediumpurple"},
    { 60,179,113,"mediumseagreen"},
    {123,104,238,"mediumslateblue"},
    {  0,250,154,"mediumspringgreen"},
    { 72,209,204,"mediumturquoise"},
    {199, 21,133,"mediumvioletred"},
    { 25, 25,112,"midnightblue"},
    {245,255,250,"mintcream"},
    {255,228,225,"mistyrose"},
    {255,228,181,"moccasin"},
    {255,222,173,"navajowhite"},
    {  0,  0,128,"navy"},
    {253,245,230,"oldlace"},
    {128,128,  0,"olive"},
    {107,142, 35,"olivedrab"},
    {255,165,  0,"orange"},
    {255, 69,  0,"orangered"},
    {218,112,214,"orchid"},
    {238,232,170,"palegoldenrod"},
    {152,251,152,"palegreen"},
    {175,238,238,"paleturquoise"},
    {219,112,147,"palevioletred"},
    {255,239,213,"papayawhip"},
    {255,218,185,"peachpuff"},
    {205,133, 63,"peru"},
    {255,192,203,"pink"},
    {221,160,221,"plum"},
    {176,224,230,"powderblue"},
    {128,  0,128,"purple"},
    {255,  0,  0,"red"},
    {188,143,143,"rosybrown"},
    { 65,105,225,"royalblue"},
    {139, 69, 19,"saddlebrown"},
    {250,128,114,"salmon"},
    {244,164, 96,"sandybrown"},
    { 46,139, 87,"seagreen"},
    {255,245,238,"seashell"},
    {160, 82, 45,"sienna"},
    {192,192,192,"silver"},
    {135,206,235,"skyblue"},
    {106, 90,205,"slateblue"},
    {112,128,144,"slategray"},
    {112,128,144,"slategrey"},
    {255,250,250,"snow"},
    {  0,255,127,"springgreen"},
    { 70,130,180,"steelblue"},
    {210,180,140,"tan"},
    {  0,128,128,"teal"},
    {216,191,216,"thistle"},
    {255, 99, 71,"tomato"},
    { 64,224,208,"turquoise"},
    {238,130,238,"violet"},
    {245,222,179,"wheat"},
    {255,255,255,"white"},
    {245,245,245,"whitesmoke"},
    {255,255,  0,"yellow"},
    {154,205, 50,"yellowgreen"}
};

@end MetaSvgNamedColorRes;



/* ---------- forward prototypes (avoid implicit int / symbol surprises) ---------- */
static WWFixedAsDWord MakeWWFixedFromInt(int v);
static const char *   ParseWWFixed16_16(const char *s, WWFixedAsDWord *out);
static word           HexNibble(char c);
static word           HexByte(const char *p);
static Boolean        TagIs(const char *tag, const char *name);
static Boolean        GetAttrBounded(const char *tag, const char *name, char *out, word outSize);
static void           ApplyStrokeAndFill(const char *tag);
static void           ApplyStrokeWidth(const char *tag);
static void           ParseFillRule(const char *tag);

/* viewBox / viewport mapping */
static void           SVG_InitWorldFromSvgTag(const char *tag);
static void           SVG_InitWorldDefault(void);
static void           SVG_ComputePar(const char *parStr);
static sword          VB_MapPosX_F(WWFixedAsDWord fx);
static sword          VB_MapPosY_F(WWFixedAsDWord fy);
static sword          VB_MapLenX_F(WWFixedAsDWord fx);
static sword          VB_MapLenY_F(WWFixedAsDWord fy);

static void           SVG_ParsePoints(const char *points, Point *pointsP, word *numPointsP);
static void           SVG_GetScale(const char *tag, WWFixedAsDWord *sxOut, WWFixedAsDWord *syOut);
static void           SVG_ApplyScalePoint(sword *x, sword *y, WWFixedAsDWord sx, WWFixedAsDWord sy);
static sword          SVG_ScaleLength(sword v, WWFixedAsDWord s);
static Boolean        SVG_HasStroke(const char *tag);
static Boolean        SVG_HasFill(const char *tag);
static void           HandleLineTag(const char *tag);
static void           HandlePolylineTag(const char *tag, struct _SVGScratch *sc);
static void           HandlePolygonTag(const char *tag, struct _SVGScratch *sc);
static void           HandleRectTag(const char *tag);
static void           HandleEllipseTag(const char *tag);
static void           HandleCircleTag(const char *tag);
static void           HandlePathTag(const char *tag, struct _SVGScratch *sc);
static Boolean        AsciiNoCaseEq(const char *a, const char *b);
static Boolean        SVG_FindNamedColor(const char *name, word *r, word *g, word *b);
static void           SVG_AddPt(struct _SVGScratch *sc, word *np, sword x, sword y);
static void           SVG_FlattenQuad(struct _SVGScratch *sc, word *np,
                            sword x0, sword y0, sword cx, sword cy, sword x1, sword y1,
                            word segs);
static void           SVG_FlattenCubic(struct _SVGScratch *sc, word *np,
                             sword x0, sword y0, sword c1x, sword c1y, sword c2x, sword c2y, sword x1, sword y1,
                             word segs);
static WWFixedAsDWord SVG_WWFSqrt(WWFixedAsDWord v);
static WWFixedAsDWord SVG_Atan2Deg_WW(WWFixedAsDWord y, WWFixedAsDWord x);
static WWFixedAsDWord SVG_WWFabs(WWFixedAsDWord v);
static void           SVG_FlattenArc(struct _SVGScratch *sc, word *np,
                           WWFixedAsDWord x0, WWFixedAsDWord y0,
                           WWFixedAsDWord rx, WWFixedAsDWord ry,
                           WWFixedAsDWord xAxisRotDegW,
                           int largeArcFlag, int sweepFlag,
                           WWFixedAsDWord x1, WWFixedAsDWord y1);

/* tiny path helpers */
static const char *   SVG_SkipWS(const char *s);
/* axis-aware scanners / parsers */
static const char *   SVG_ScanCoordX(const char *s, sword *out);
static const char *   SVG_ScanCoordY(const char *s, sword *out);
static const char *   SVG_ScanLenX(const char *s, sword *out);
static const char *   SVG_ScanLenY(const char *s, sword *out);
static sword          SVG_ParseCoordXStr(const char *s);
static sword          SVG_ParseCoordYStr(const char *s);
static sword          SVG_ParseLenXStr(const char *s);
static sword          SVG_ParseLenYStr(const char *s);

/* rounding helpers for decimal→sword (kept for internal use) */
static sword          WWFixedToSWordRound(WWFixedAsDWord w);

static void           ScanCtxInit(ScanCtx *c);
static Boolean        ScanNextTag(FileHandle fh, ScanCtx *c, struct _SVGScratch *sc);

/* ---------- impl ---------- */

static WWFixedAsDWord MakeWWFixedFromInt(int v)
{
    WWFixedAsDWord f;

    f = ((WWFixedAsDWord)((sdword)v)) << 16;
    return f;
}

static WWFixedAsDWord GrMulWWFixedSafe(WWFixedAsDWord a, WWFixedAsDWord b)
{
    return GrMulWWFixed(a, b);
}

/* Parse "-12.34" → 16.16; returns pointer after number */
static const char * ParseWWFixed16_16(const char *s, WWFixedAsDWord *out)
{
    sdword           sign;
    dword            ip;
    dword            frac;
    dword            scale;
    word             c;
    WWFixedAsDWord   result;

    sign  = 1;
    ip    = 0;
    frac  = 0;
    scale = 1;

    while (*s && isspace(*s))
    {
        s++;
    }
    if (*s == '+')
    {
        s++;
    }
    else if (*s == '-')
    {
        sign = -1;
        s++;
    }

    while ((c = (word)(byte)*s) >= '0' && c <= '9')
    {
        ip = ip * 10 + (c - '0');
        s++;
    }

    if (*s == '.')
    {
        s++;
        while ((c = (word)(byte)*s) >= '0' && c <= '9')
        {
            if (scale < 1000000UL)
            {
                frac = frac * 10 + (c - '0');
                scale *= 10;
            }
            s++;
        }
    }

    result = MakeWWFixedFromInt((int)ip);
    if (scale != 0)
    {
        dword fpart;
        fpart = ((frac << 16) / scale);
        result += (WWFixedAsDWord)fpart;
    }
    if (sign < 0)
    {
        result = (WWFixedAsDWord)(0 - (sdword)result);
    }
    *out = result;
    return s;
}

/* round signed 16.16 to signed 16-bit */
static sword WWFixedToSWordRound(WWFixedAsDWord w)
{
    sdword v;
    v = (sdword)w;
    if (v >= 0) v += 0x8000; else v -= 0x8000;   /* ±0.5 */
    return (sword)(v >> 16);
}

/* ---------- tiny hex helpers (no stdio) ---------- */
static word HexNibble(char c)
{
    if (c >= '0' && c <= '9') return (word)(c - '0');
    if (c >= 'A' && c <= 'F') return (word)(10 + (c - 'A'));
    if (c >= 'a' && c <= 'f') return (word)(10 + (c - 'a'));
    return 0;
}
static word HexByte(const char *p)
{
    return (word)((HexNibble(p[0]) << 4) | HexNibble(p[1]));
}

/* ---------- scan helpers ---------- */
static Boolean TagIs(const char *tag, const char *name)
{
    const char *s;
    const char *n;

    s = tag;
    n = name;
    while (*s && !isspace(*s) && *s != '/' && *s != '>')
    {
        if (*n == 0 || *s != *n)
        {
            return FALSE;
        }
        s++;
        n++;
    }
    return (*n == 0);
}

/* Robust, bounded attribute reader — supports ' and " */
static Boolean GetAttrBounded(const char *tag, const char *name,
                              char *out, word outSize)
{
    const char *s;
    word        nlen;

    if (outSize == 0) return FALSE;
    out[0] = 0;

    /* skip element name */
    s = tag;
    while (*s && !isspace(*s) && *s != '>' && *s != '/')
    {
        s++;
    }

    nlen = (word)strlen(name);

    while (*s && *s != '>')
    {
        const char *an;
        word        alen;

        while (*s && (isspace(*s) || *s == '/'))
        {
            s++;
        }
        if (!*s || *s == '>')
        {
            break;
        }

        an = s;
        alen = 0;

        while (*s && *s != '=' && !isspace(*s) && *s != '>' && *s != '/')
        {
            s++;
            alen++;
        }

        if (alen == nlen && !memcmp(an, name, nlen))
        {
            while (*s && isspace(*s)) s++;
            if (*s != '=') return FALSE;
            s++;
            while (*s && isspace(*s)) s++;

            if (*s == '"' || *s == '\'')
            {
                char  q;
                word  i;

                q = *s++;
                i = 0;
                while (*s && *s != q && i < (outSize - 1))
                {
                    out[i++] = *s++;
                }
                out[i] = 0;
                if (*s == q) s++;
            }
            else
            {
                word i;
                i = 0;
                while (*s && !isspace(*s) && *s != '>' && i < (outSize - 1))
                {
                    out[i++] = *s++;
                }
                out[i] = 0;
            }
            return TRUE;
        }
        else
        {
            while (*s && isspace(*s)) s++;
            if (*s == '=')
            {
                s++;
                while (*s && isspace(*s)) s++;
                if (*s == '"' || *s == '\'')
                {
                    char q = *s++;
                    while (*s && *s != q) s++;
                    if (*s == q) s++;
                }
                else
                {
                    while (*s && !isspace(*s) && *s != '>') s++;
                }
            }
        }
    }
    return FALSE;
}

/* All sizeable buffers live here to keep stack tiny */
typedef struct _SVGScratch {
    char    tag[TAG_BUF_SIZE];

    char    pb[256];
    char    db[256];
    char    xb[32], yb[32], x2b[32], y2b[32];
    char    wb[32], hb[32];
    char    cxb[32], cyb[32], rxb[32], ryb[32];
    char    rb[32];
    char    col[64];
    char    tbuf[96];

    Point   pts[MAX_SVG_POINTS];
} SVGScratch;

/* ---------- color & style helpers ---------- */

static Boolean ExpandShortHex(const char *s, word *r, word *g, word *b)
{
    if (s[0] == '#' && strlen(s) == 4) {
        char hh[7];
        hh[0] = '#';
        hh[1] = s[1]; hh[2] = s[1];
        hh[3] = s[2]; hh[4] = s[2];
        hh[5] = s[3]; hh[6] = s[3];
        *r = HexByte(hh + 1);
        *g = HexByte(hh + 3);
        *b = HexByte(hh + 5);
        return TRUE;
    }
    return FALSE;
}

static Boolean ParseRGBFunc(const char *s, word *r, word *g, word *b)
{
    /* supports: rgb(255,0,0) and rgb(50%,0%,0%) */
    const char *p;
    int v1;
    int v2;
    int v3;
    int isPct;

    p = strstr(s, "rgb(");
    if (!p) {
        return FALSE;
    }
    p += 4;

    isPct = 0;
    v1 = atoi(p);
    while (*p && *p != ',' && *p != ')' && *p != '%') p++;
    if (*p == '%') { isPct = 1; p++; }
    if (*p == ',') p++;
    v2 = atoi(p);
    while (*p && *p != ',' && *p != ')' && *p != '%') p++;
    if (*p == '%') { isPct = 1; p++; }
    if (*p == ',') p++;
    v3 = atoi(p);
    while (*p && *p != ')' && *p != '%') p++;
    if (*p == '%') { isPct = 1; }

    if (isPct) {
        if (v1 < 0) v1 = 0; if (v1 > 100) v1 = 100;
        if (v2 < 0) v2 = 0; if (v2 > 100) v2 = 100;
        if (v3 < 0) v3 = 0; if (v3 > 100) v3 = 100;
        *r = (word)((v1 * 255) / 100);
        *g = (word)((v2 * 255) / 100);
        *b = (word)((v3 * 255) / 100);
    } else {
        if (v1 < 0) v1 = 0; if (v1 > 255) v1 = 255;
        if (v2 < 0) v2 = 0; if (v2 > 255) v2 = 255;
        if (v3 < 0) v3 = 0; if (v3 > 255) v3 = 255;
        *r = (word)v1; *g = (word)v2; *b = (word)v3;
    }
    return TRUE;
}

/* small ASCII case-insensitive compare */
static Boolean AsciiNoCaseEq(const char *a, const char *b)
{
    byte ca, cb;
    while (*a || *b) {
        ca = (byte)*a++; cb = (byte)*b++;
        if (ca >= 'A' && ca <= 'Z') ca = (byte)(ca + ('a' - 'A'));
        if (cb >= 'A' && cb <= 'Z') cb = (byte)(cb + ('a' - 'A'));
        if (ca != cb) return FALSE;
        if (ca == 0)  return TRUE;
    }
    return TRUE;
}

/* GEOS-idiomatic SVG color names lookup */
static Boolean SVG_FindNamedColor(const char *name, word *r, word *g, word *b)
{
    MemHandle       mh;
    SvgNamedColor  *rec;
    word            i, count, elemSize;

    mh = OptrToHandle(@SvgNamedColors);
    ObjLockObjBlock(mh);                             /* lock owning LMem block */

    count = ChunkArrayGetCount(@SvgNamedColors);     /* number of records */
    for (i = 0; i < count; i++) {
        rec = (SvgNamedColor*) ChunkArrayElementToPtr(@SvgNamedColors, i, &elemSize);

        if (rec && AsciiNoCaseEq(rec->SNC_name, name)) {
            *r = rec->SNC_r; *g = rec->SNC_g; *b = rec->SNC_b;
            MemUnlock(mh);
            return TRUE;
        }
    }

    MemUnlock(mh);
    return FALSE;
}

static void ApplyStrokeAndFill(const char *tag)
{
    static char sFill[64];
    static char sStroke[64];
    word r;
    word g;
    word b;

    sFill[0] = 0;
    sStroke[0] = 0;

    /* stroke */
    if (GetAttrBounded(tag, "stroke", sStroke, sizeof(sStroke))) {
        if (strcmp(sStroke, "none") != 0) {
            if (sStroke[0] == '#' && strlen(sStroke) >= 7) {
                Meta_SetLineColor(CF_RGB, HexByte(sStroke+1), HexByte(sStroke+3), HexByte(sStroke+5));
            }
            else if (ExpandShortHex(sStroke, &r,&g,&b) ||
                    ParseRGBFunc(sStroke, &r,&g,&b)   ||
                    SVG_FindNamedColor(sStroke, &r,&g,&b))
            {
                Meta_SetLineColor(CF_RGB, r, g, b);
            }
        }
    }

    /* fill */
    if (GetAttrBounded(tag, "fill", sFill, sizeof(sFill))) {
        if (strcmp(sFill, "none") != 0) {
            if (sFill[0] == '#' && strlen(sFill) >= 7) {
                Meta_SetAreaColor(CF_RGB, HexByte(sFill+1), HexByte(sFill+3), HexByte(sFill+5));
            } else if (ExpandShortHex(sFill, &r,&g,&b) ||
                    ParseRGBFunc(sFill, &r,&g,&b)   ||
                    SVG_FindNamedColor(sFill, &r,&g,&b))
            {
                Meta_SetAreaColor(CF_RGB, r, g, b);
            }
        }
    }
}

static void ParseFillRule(const char *tag)
{
    static char buf[16];

    buf[0] = 0;
    if (GetAttrBounded(tag, "fill-rule", buf, sizeof(buf)))
    {
        if (!strcmp(buf, "evenodd")) {
            Meta_SetFillRule(ODD_EVEN);
        } else {
            Meta_SetFillRule(WINDING); /* SVG default: nonzero */
        }
    }
}

static void ApplyStrokeWidth(const char *tag)
{
    static char b[20];
    if (GetAttrBounded(tag, "stroke-width", b, sizeof(b)))
    {
        WWFixedAsDWord lw;
        (void)ParseWWFixed16_16(b, &lw);          /* allow decimals */
        Meta_SetLineWidth(lw);
    }
}

/* ===== viewBox / preserveAspectRatio implementation ===== */

static void SVG_ComputePar(const char *parStr)
{
    const char *s;
    char buf[64];
    word n;

    g_parNone = FALSE;
    g_parSlice = FALSE;
    g_parAx = PAR_ALIGN_MID;
    g_parAy = PAR_ALIGN_MID;

    if (!parStr || !*parStr) {
        return; /* default already xMidYMid meet */
    }

    /* copy & lowercase into buf */
    n = 0; s = parStr;
    while (*s && n < (sizeof(buf)-1)) {
        char c = *s++;
        if (c >= 'A' && c <= 'Z') c = (char)(c + ('a' - 'A'));
        buf[n++] = c;
    }
    buf[n] = 0;

    /* quick "none" */
    if (!strncmp(buf, "none", 4)) {
        g_parNone = TRUE;
        return;
    }

    /* alignment token at start */
    if      (!strncmp(buf, "xminymin", 8)) { g_parAx = PAR_ALIGN_MIN; g_parAy = PAR_ALIGN_MIN; s = parStr + 8; }
    else if (!strncmp(buf, "xmidymin", 8)) { g_parAx = PAR_ALIGN_MID; g_parAy = PAR_ALIGN_MIN; s = parStr + 8; }
    else if (!strncmp(buf, "xmaxymin", 8)) { g_parAx = PAR_ALIGN_MAX; g_parAy = PAR_ALIGN_MIN; s = parStr + 8; }
    else if (!strncmp(buf, "xminymid", 8)) { g_parAx = PAR_ALIGN_MIN; g_parAy = PAR_ALIGN_MID; s = parStr + 8; }
    else if (!strncmp(buf, "xmidymid", 8)) { g_parAx = PAR_ALIGN_MID; g_parAy = PAR_ALIGN_MID; s = parStr + 8; }
    else if (!strncmp(buf, "xmaxymid", 8)) { g_parAx = PAR_ALIGN_MAX; g_parAy = PAR_ALIGN_MID; s = parStr + 8; }
    else if (!strncmp(buf, "xminymax", 8)) { g_parAx = PAR_ALIGN_MIN; g_parAy = PAR_ALIGN_MAX; s = parStr + 8; }
    else if (!strncmp(buf, "xmidymax", 8)) { g_parAx = PAR_ALIGN_MID; g_parAy = PAR_ALIGN_MAX; s = parStr + 8; }
    else if (!strncmp(buf, "xmaxymax", 8)) { g_parAx = PAR_ALIGN_MAX; g_parAy = PAR_ALIGN_MAX; s = parStr + 8; }
    else {
        s = parStr; /* keep defaults if unknown */
    }

    /* skip whitespace, then optional meet/slice */
    while (*s && isspace(*s)) s++;
    if (!strncmp(s, "slice", 5)) g_parSlice = TRUE;
    /* "meet" is the default; nothing to store */
}

/* --- replace the whole function with this --- */
static void SVG_InitWorldFromSvgTag(const char *tag)
{
    static char vb[96];
    static char wb[32], hb[32];
    static char par[64];
    const char *s;
    WWFixedAsDWord rawSx, rawSy, uni, leftoverX, leftoverY;
    sdword w0, h0;       /* viewport size as 32-bit ints */
    word   reduce;       /* power-of-two reduction */
    sword  worldW, worldH;

    if (g_vbInited) return;

    g_vbMinX = 0; g_vbMinY = 0; g_vbW = 0; g_vbH = 0;
    g_vpW = 0; g_vpH = 0;
    g_scaleX = WWFIXED_ONE; g_scaleY = WWFIXED_ONE;
    g_addX = 0; g_addY = 0;
    g_invPow2 = WWFIXED_ONE;

    /* preserveAspectRatio (defaults to xMidYMid meet) */
    par[0] = 0;
    if (GetAttrBounded(tag, "preserveAspectRatio", par, sizeof(par))) {
        SVG_ComputePar(par);
    } else {
        SVG_ComputePar("");
    }

    /* viewBox */
    if (GetAttrBounded(tag, "viewBox", vb, sizeof(vb))) {
        s = vb;
        s = ParseWWFixed16_16(s, &g_vbMinX);
        s = SVG_SkipWS(s); s = ParseWWFixed16_16(s, &g_vbMinY);
        s = SVG_SkipWS(s); s = ParseWWFixed16_16(s, &g_vbW);
        s = SVG_SkipWS(s); s = ParseWWFixed16_16(s, &g_vbH);
    }
    if ((sdword)g_vbW <= 0 || (sdword)g_vbH <= 0) {
        /* No viewBox => synthesize from width/height (or 100x100 fallback) */
        if (GetAttrBounded(tag, "width",  wb, sizeof(wb)))  (void)ParseWWFixed16_16(wb, &g_vpW);
        if (GetAttrBounded(tag, "height", hb, sizeof(hb)))  (void)ParseWWFixed16_16(hb, &g_vpH);
        if ((sdword)g_vpW <= 0) g_vpW = MakeWWFixedFromInt(100);
        if ((sdword)g_vpH <= 0) g_vpH = MakeWWFixedFromInt(100);
        g_vbMinX = 0; g_vbMinY = 0;
        g_vbW = g_vpW; g_vbH = g_vpH;
    }

    /* viewport defaults to CSS width/height or viewBox size */
    if ((sdword)g_vpW == 0) g_vpW = g_vbW;
    if ((sdword)g_vpH == 0) g_vpH = g_vbH;

    /* raw scale viewBox -> viewport */
    rawSx = GrSDivWWFixed(g_vpW, g_vbW);
    rawSy = GrSDivWWFixed(g_vpH, g_vbH);

    if (g_parNone) {
        g_scaleX = rawSx;
        g_scaleY = rawSy;
        g_addX = 0;
        g_addY = 0;
    } else {
        /* meet/slice uniform */
        uni = g_parSlice ? ((rawSx > rawSy) ? rawSx : rawSy)
                         : ((rawSx < rawSy) ? rawSx : rawSy);
        g_scaleX = uni;
        g_scaleY = uni;

        leftoverX = g_vpW - GrMulWWFixed(g_vbW, uni);
        leftoverY = g_vpH - GrMulWWFixed(g_vbH, uni);
        if ((sdword)leftoverX < 0) leftoverX = 0;
        if ((sdword)leftoverY < 0) leftoverY = 0;

        g_addX = (g_parAx == PAR_ALIGN_MIN) ? 0
              : (g_parAx == PAR_ALIGN_MID) ? GrSDivWWFixed(leftoverX, MakeWWFixed(2))
                                            : leftoverX;
        g_addY = (g_parAy == PAR_ALIGN_MIN) ? 0
              : (g_parAy == PAR_ALIGN_MID) ? GrSDivWWFixed(leftoverY, MakeWWFixed(2))
                                            : leftoverY;
    }

    /* Reduce world so it fits in sword (≤ 32760), then use unity META scale */
    w0 = ((sdword)g_vpW) >> 16;  if (w0 <= 0) w0 = 1;
    h0 = ((sdword)g_vpH) >> 16;  if (h0 <= 0) h0 = 1;

    reduce = 1;
    while ((w0 / (sdword)reduce) > 32760 || (h0 / (sdword)reduce) > 32760) {
        if (reduce >= 32768) break;     /* safety */
        reduce <<= 1;
    }
    g_invPow2 = (reduce > 1) ? GrSDivWWFixed(MakeWWFixed(1), MakeWWFixed(reduce))
                             : WWFIXED_ONE;

    worldW = (sword)(w0 / (sdword)reduce);
    worldH = (sword)(h0 / (sdword)reduce);
    if (worldW < 1) worldW = 1;
    if (worldH < 1) worldH = 1;

    /* unity META scale: g_x == worldW, g_y == worldH */
    Meta_SetScaling(0, 0, worldW, worldH, worldW, worldH);

    g_vbInited = TRUE;
}

static void SVG_InitWorldDefault(void)
{
    if (g_vbInited) return;

    g_vbMinX = 0; g_vbMinY = 0;
    g_vbW = MakeWWFixedFromInt(1024);
    g_vbH = MakeWWFixedFromInt(1024);
    g_vpW = g_vbW; g_vpH = g_vbH;

    g_scaleX = WWFIXED_ONE;
    g_scaleY = WWFIXED_ONE;
    g_addX   = 0;
    g_addY   = 0;
    g_invPow2= WWFIXED_ONE;

    /* unity META scale */
    Meta_SetScaling(0, 0, 1024, 1024, 1024, 1024);
    g_vbInited = TRUE;
}

/* ===== mappers: viewBox space -> world space (sword) ===== */
static sword VB_MapPosX_F(WWFixedAsDWord fx)
{
    WWFixedAsDWord v;
    v  = fx - g_vbMinX;                    /* rebase to viewBox min */
    v  = GrMulWWFixed(v, g_scaleX);        /* scale to viewport */
    v += g_addX;                           /* align offset (meet/slice) */
    v  = GrMulWWFixed(v, g_invPow2);
    return WWFixedToSWordRound(v);
}

static sword VB_MapPosY_F(WWFixedAsDWord fy)
{
    WWFixedAsDWord v;
    v  = fy - g_vbMinY;
    v  = GrMulWWFixed(v, g_scaleY);
    v += g_addY;
    v  = GrMulWWFixed(v, g_invPow2);
    return WWFixedToSWordRound(v);
}

static sword VB_MapLenX_F(WWFixedAsDWord fx)
{
    WWFixedAsDWord v;
    v = GrMulWWFixed(fx, g_scaleX);        /* lengths don’t add offset */
    v = GrMulWWFixed(v, g_invPow2);
    return WWFixedToSWordRound(v);
}

static sword VB_MapLenY_F(WWFixedAsDWord fy)
{
    WWFixedAsDWord v;
    v = GrMulWWFixed(fy, g_scaleY);
    v = GrMulWWFixed(v, g_invPow2);
    return WWFixedToSWordRound(v);
}

/* ---------- points parser (axis-aware) ---------- */

static const char * SVG_SkipWS(const char *s)
{
    while (*s && isspace(*s)) {
        s++;
    }
    return s;
}

static const char * SVG_ScanCoordX(const char *s, sword *out)
{
    WWFixedAsDWord f;
    const char *p;

    p = ParseWWFixed16_16(s, &f);
    *out = VB_MapPosX_F(f);

    while (*p) {
        if (*p == ' ' || *p == ',' || *p == '\t' ||
            *p == '\r' || *p == '\n' ||
            *p == 'Z' || *p == 'z' ||
            isalpha((byte)*p)) {
            break;
        }
        p++;
    }
    return p;
}

static const char * SVG_ScanCoordY(const char *s, sword *out)
{
    WWFixedAsDWord f;
    const char *p;

    p = ParseWWFixed16_16(s, &f);
    *out = VB_MapPosY_F(f);

    while (*p) {
        if (*p == ' ' || *p == ',' || *p == '\t' ||
            *p == '\r' || *p == '\n' ||
            *p == 'Z' || *p == 'z' ||
            isalpha((byte)*p)) {
            break;
        }
        p++;
    }
    return p;
}

static const char * SVG_ScanLenX(const char *s, sword *out)
{
    WWFixedAsDWord f;
    const char *p;

    p = ParseWWFixed16_16(s, &f);
    *out = VB_MapLenX_F(f);

    while (*p) {
        if (*p == ' ' || *p == ',' || *p == '\t' ||
            *p == '\r' || *p == '\n' ||
            *p == 'Z' || *p == 'z' ||
            isalpha((byte)*p)) {
            break;
        }
        p++;
    }
    return p;
}

static const char * SVG_ScanLenY(const char *s, sword *out)
{
    WWFixedAsDWord f;
    const char *p;

    p = ParseWWFixed16_16(s, &f);
    *out = VB_MapLenY_F(f);

    while (*p) {
        if (*p == ' ' || *p == ',' || *p == '\t' ||
            *p == '\r' || *p == '\n' ||
            *p == 'Z' || *p == 'z' ||
            isalpha((byte)*p)) {
            break;
        }
        p++;
    }
    return p;
}

/* convenient attribute versions */
static sword SVG_ParseCoordXStr(const char *s) { WWFixedAsDWord f; (void)ParseWWFixed16_16(s,&f); return VB_MapPosX_F(f); }
static sword SVG_ParseCoordYStr(const char *s) { WWFixedAsDWord f; (void)ParseWWFixed16_16(s,&f); return VB_MapPosY_F(f); }
static sword SVG_ParseLenXStr  (const char *s) { WWFixedAsDWord f; (void)ParseWWFixed16_16(s,&f); return VB_MapLenX_F(f); }
static sword SVG_ParseLenYStr  (const char *s) { WWFixedAsDWord f; (void)ParseWWFixed16_16(s,&f); return VB_MapLenY_F(f); }

/* Parse "x,y x,y ..." -> world points */
static void SVG_ParsePoints(const char *points, Point *pointsP, word *numPointsP)
{
    const char *s;
    sword       x;
    sword       y;

    s = points;
    *numPointsP = 0;

    while (*s && *numPointsP < MAX_SVG_POINTS)
    {
        s = SVG_SkipWS(s);
        if (!*s) break;

        s = SVG_ScanCoordX(s, &x);
        if (*s == ',') s++;
        s = SVG_SkipWS(s);
        s = SVG_ScanCoordY(s, &y);

        pointsP[*numPointsP].P_x = x;
        pointsP[*numPointsP].P_y = y;
        (*numPointsP)++;

        while (*s && (isspace(*s) || *s == ',')) s++;
    }
}

/* element-local transform="scale(...)" (kept) */
static void SVG_GetScale(const char *tag, WWFixedAsDWord *sxOut, WWFixedAsDWord *syOut)
{
    static char buf[96];
    char *p; const char *s; WWFixedAsDWord sx, sy;

    sx = WWFIXED_ONE; sy = WWFIXED_ONE;
    if (!GetAttrBounded(tag, "transform", buf, sizeof(buf))) { *sxOut=sx; *syOut=sy; return; }
    p = strstr(buf, "scale"); if (!p) { *sxOut=sx; *syOut=sy; return; }
    p = strchr(p, '('); if (!p) { *sxOut=sx; *syOut=sy; return; }
    s = p + 1;
    s = ParseWWFixed16_16(s, &sx);
    while (*s && isspace(*s)) s++;
    if (*s == ',') { s++; (void)ParseWWFixed16_16(s, &sy); } else { sy = sx; }
    if ((sdword)sx == 0) sx = (WWFixedAsDWord)1;   /* avoid vanishing */
    if ((sdword)sy == 0) sy = (WWFixedAsDWord)1;
    *sxOut = sx; *syOut = sy;
}

static void SVG_ApplyScalePoint(sword *x, sword *y, WWFixedAsDWord sx, WWFixedAsDWord sy)
{
    WWFixedAsDWord X = (WWFixedAsDWord)((sdword)(*x) << 16);
    WWFixedAsDWord Y = (WWFixedAsDWord)((sdword)(*y) << 16);
    X = GrMulWWFixed(X, sx);
    Y = GrMulWWFixed(Y, sy);
    *x = (sword)((sdword)X >> 16);
    *y = (sword)((sdword)Y >> 16);
}

static sword SVG_ScaleLength(sword v, WWFixedAsDWord s)
{
    WWFixedAsDWord V = (WWFixedAsDWord)((sdword)v << 16);
    WWFixedAsDWord R = GrMulWWFixed(V, s);
    sword out = (sword)((sdword)R >> 16);
    if (out < 0) out = (sword)(-out);
    return out;
}

static Boolean SVG_HasStroke(const char *tag)
{
    char b[32];
    /* SVG default: stroke is none unless present and not "none" */
    return GetAttrBounded(tag, "stroke", b, sizeof(b)) && strcmp(b, "none") != 0;
}
static Boolean SVG_HasFill(const char *tag)
{
    char b[32];
    /* SVG default: most shapes are filled if 'fill' is absent */
    if (GetAttrBounded(tag, "fill", b, sizeof(b))) {
        return strcmp(b, "none") != 0;
    }
    return TRUE; /* default fill applies to rect/circle/ellipse/polygon/path */
}

static void SVG_AddPt(SVGScratch *sc, word *np, sword x, sword y)
{
    if (*np < MAX_SVG_POINTS) {
        sc->pts[*np].P_x = x;
        sc->pts[*np].P_y = y;
        (*np)++;
    }
}

static void SVG_FlattenQuad(SVGScratch *sc, word *np,
                            sword x0, sword y0, sword cx, sword cy, sword x1, sword y1,
                            word segs)
{
    word i;
    for (i = 1; i <= segs; i++) {
        WWFixedAsDWord t  = (WWFixedAsDWord)(((dword)i << 16) / segs);
        WWFixedAsDWord it = WWFIXED_ONE - t;

        WWFixedAsDWord X =
            GrMulWWFixed(GrMulWWFixed(it, it), ((sdword)x0 << 16)) +
            GrMulWWFixed(GrMulWWFixed(MakeWWFixed(2), GrMulWWFixed(it, t)), ((sdword)cx << 16)) +
            GrMulWWFixed(GrMulWWFixed(t, t), ((sdword)x1 << 16));

        WWFixedAsDWord Y =
            GrMulWWFixed(GrMulWWFixed(it, it), ((sdword)y0 << 16)) +
            GrMulWWFixed(GrMulWWFixed(MakeWWFixed(2), GrMulWWFixed(it, t)), ((sdword)cy << 16)) +
            GrMulWWFixed(GrMulWWFixed(t, t), ((sdword)y1 << 16));

        SVG_AddPt(sc, np, (sword)((sdword)X >> 16), (sword)((sdword)Y >> 16));
    }
}

static void SVG_FlattenCubic(SVGScratch *sc, word *np,
                             sword x0, sword y0, sword c1x, sword c1y, sword c2x, sword c2y, sword x1, sword y1,
                             word segs)
{
    word i;
    for (i = 1; i <= segs; i++) {
        WWFixedAsDWord t   = (WWFixedAsDWord)(((dword)i << 16) / segs);
        WWFixedAsDWord it  = WWFIXED_ONE - t;
        WWFixedAsDWord it2 = GrMulWWFixed(it, it);
        WWFixedAsDWord t2  = GrMulWWFixed(t, t);

        WWFixedAsDWord k0 = GrMulWWFixed(it2, it);                            /* (1-t)^3 */
        WWFixedAsDWord k1 = GrMulWWFixed(MakeWWFixed(3), GrMulWWFixed(it2, t)); /* 3(1-t)^2 t */
        WWFixedAsDWord k2 = GrMulWWFixed(MakeWWFixed(3), GrMulWWFixed(it, t2));  /* 3(1-t) t^2 */
        WWFixedAsDWord k3 = GrMulWWFixed(t2, t);                              /* t^3 */

        WWFixedAsDWord X =
            GrMulWWFixed(k0, ((sdword)x0 << 16)) +
            GrMulWWFixed(k1, ((sdword)c1x << 16)) +
            GrMulWWFixed(k2, ((sdword)c2x << 16)) +
            GrMulWWFixed(k3, ((sdword)x1  << 16));

        WWFixedAsDWord Y =
            GrMulWWFixed(k0, ((sdword)y0 << 16)) +
            GrMulWWFixed(k1, ((sdword)c1y << 16)) +
            GrMulWWFixed(k2, ((sdword)c2y << 16)) +
            GrMulWWFixed(k3, ((sdword)y1  << 16));

        SVG_AddPt(sc, np, (sword)((sdword)X >> 16), (sword)((sdword)Y >> 16));
    }
}

/* ===== Fixed-point helpers (WWFixed 16.16) ===== */

/* WWFixed 16.16 add/sub helpers (C89). */
#ifndef SVG_WWFIX_ADD_SUB_DEFINED
#define SVG_WWFIX_ADD_SUB_DEFINED

#define GrAddWWFixed(a,b) \
    ((WWFixedAsDWord)((sdword)(a) + (sdword)(b)))

#define GrSubWWFixed(a,b) \
    ((WWFixedAsDWord)((sdword)(a) - (sdword)(b)))

#endif /* SVG_WWFIX_ADD_SUB_DEFINED */



static WWFixedAsDWord
WWSqrt(WWFixedAsDWord a)
{
    /* Newton-Raphson for 16.16 fixed.
     * g_{n+1} = (g + a/g) / 2
     */
    WWFixedAsDWord g;
    WWFixedAsDWord prev;
    int i;

    if ((sdword)a <= 0) {
        return MakeWWFixed(0);
    }

    /* crude initial guess: max(1, a) but scaled into 16.16 */
    g = a;
    /* clamp starting guess to something reasonable to avoid overflow in a/g */
    if ((sdword)g <= 0) {
        g = MakeWWFixed(1);
    }

    prev = 0;
    for (i = 0; i < 16; i++) {
        WWFixedAsDWord q;

        if (g == 0) {
            g = MakeWWFixed(1);
        }
        q = GrSDivWWFixed(a, g);                    /* a/g */
        g = GrSDivWWFixed(GrAddWWFixed(g, q), MakeWWFixed(2)); /* (g + a/g)/2 */

        if (g == prev) {
            break;
        }
        prev = g;
    }
    return g;
}

static WWFixedAsDWord
WWAbs(WWFixedAsDWord x)
{
    return ( (sdword)x < 0 ) ? (WWFixedAsDWord)(-(sdword)x) : x;
}

static WWFixedAsDWord
WWMin(WWFixedAsDWord a, WWFixedAsDWord b)
{
    return ((sdword)a < (sdword)b) ? a : b;
}

static WWFixedAsDWord
WWMax(WWFixedAsDWord a, WWFixedAsDWord b)
{
    return ((sdword)a > (sdword)b) ? a : b;
}

/* Fast atan2 approximation in **degrees** (16.16 WWFixed).
 * Eberly’s trick with two linear maps; good enough for segmentation.
 * Range: [-180°, +180°]
 */
static WWFixedAsDWord
WWAtan2Deg(WWFixedAsDWord y, WWFixedAsDWord x)
{
    WWFixedAsDWord absY, r, angle;
    WWFixedAsDWord k45, k135;
    WWFixedAsDWord denom;

    absY = WWAbs(y);
    k45  = MakeWWFixed(45);
    k135 = MakeWWFixed(135);

    if ((sdword)x >= 0) {
        /* r = (x - |y|) / (x + |y|) */
        denom = GrAddWWFixed(x, absY);
        if ((sdword)denom == 0) {
            r = 0; /* x==y==0 won't really happen here, but keep safe */
        } else {
            r = GrSDivWWFixed(GrSubWWFixed(x, absY), denom);
        }
        angle = GrSubWWFixed(k45, GrMulWWFixed(k45, r));
    } else {
        /* r = (x + |y|) / (|y| - x) */
        denom = GrSubWWFixed(absY, x);
        if ((sdword)denom == 0) {
            r = 0;
        } else {
            r = GrSDivWWFixed(GrAddWWFixed(x, absY), denom);
        }
        angle = GrSubWWFixed(k135, GrMulWWFixed(k45, r));
    }

    if ((sdword)y < 0) {
        angle = (WWFixedAsDWord)(-(sdword)angle);
    }
    return angle;
}

/* ===== Elliptical-arc flattener (fixed-point) =====
 *
 * Inputs (all 16.16):
 *   x0W,y0W : start point
 *   rxW,ryW : radii (>=0)
 *   rotW    : x-axis-rotation in **degrees**
 *   laf,swf : large-arc-flag (0/1), sweep-flag (0/1)
 *   x1W,y1W : end point
 *
 * Appends integer Points to sc->pts and advances *pNp.
 * Emits no duplicate of the start point (same contract as your Quad/Cubic flatteners).
 */

/* define once in a common header or above, as you prefer */
#define SVG_ARC_DEBUG 1

static void
SVG_FlattenArc(SVGScratch *sc, word *pNp,
               WWFixedAsDWord x0W, WWFixedAsDWord y0W,
               WWFixedAsDWord rxW, WWFixedAsDWord ryW,
               WWFixedAsDWord rotW,
               int laf, int swf,
               WWFixedAsDWord x1W, WWFixedAsDWord y1W)
{
    /* ----- variables (C89: declare first) ----- */
    WWFixedAsDWord zero, one, two, half;
    WWFixedAsDWord pi180;             /* 180° (deg) if needed */
    WWFixedAsDWord cphi, sphi;        /* cosφ, sinφ (φ in degrees) */
    WWFixedAsDWord dx, dy, x1p, y1p;  /* primed coordinates */
    WWFixedAsDWord frx, fry;          /* |rx|, |ry| */
    WWFixedAsDWord rx2, ry2;          /* rx^2, ry^2 */
    WWFixedAsDWord x1p2, y1p2;        /* x1'^2, y1'^2 */
    WWFixedAsDWord lam, scale;        /* λ (radii correction), scale=sqrt(λ) */
    WWFixedAsDWord num, den, frac, s; /* reused temps + s */
    WWFixedAsDWord cxp, cyp;          /* center in primed frame */
    WWFixedAsDWord mx, my;            /* midpoint */
    WWFixedAsDWord cx, cy;            /* center in original frame */
    WWFixedAsDWord ux, uy, vx, vy;    /* unit vectors */
    WWFixedAsDWord th1, dth;          /* start angle, delta angle (degrees) */
    WWFixedAsDWord cross, dot, absDth;
    WWFixedAsDWord deltaMaxDeg, stepDeg, theta;
    WWFixedAsDWord tmp, tmp2;
    WWFixedAsDWord xr, yr, xp, yp, x, y;
    WWFixedAsDWord nSegWW;
    sword xi, yi;
    word np, remaining, nSeg, k;

    /* --- debug locals --- */
#ifdef SVG_ARC_DEBUG
    word  np0;
    sword sx, sy, ex, ey;
    sword ccx, ccy, sth1, sdth, sStep;
    sword fxi, fyi, mxi, myi, lxi, lyi;
    word  midK;
    Boolean haveMid;
    char   dbuf[160];
#endif

    /* ----- constants ----- */
    zero = MakeWWFixed(0);
    one  = MakeWWFixed(1);
    two  = MakeWWFixed(2);
    half = GrSDivWWFixed(one, two);
    pi180 = MakeWWFixed(180); /* degrees representation */

    /* --- debug: inputs --- */
#ifdef SVG_ARC_DEBUG
    np0 = *pNp;
    sx  = WWFixedToSWordRound(x0W);
    sy  = WWFixedToSWordRound(y0W);
    ex  = WWFixedToSWordRound(x1W);
    ey  = WWFixedToSWordRound(y1W);
    sprintf(dbuf,
        "ARC in: start=(%d,%d) end=(%d,%d) rx=%d ry=%d rot=%d laf=%d swf=%d np=%u",
        (int)sx,(int)sy,(int)ex,(int)ey,
        (int)WWFixedToSWordRound(rxW),(int)WWFixedToSWordRound(ryW),
        (int)WWFixedToSWordRound(rotW), laf, swf, (unsigned)(*pNp));
    _WRITE_TO_FILE(dbuf);
#endif

    /* degenerates */
    if (WWFixedToSWordRound(rxW) == 0 || WWFixedToSWordRound(ryW) == 0) {
        if (*pNp < MAX_SVG_POINTS) {
            sc->pts[*pNp].P_x = WWFixedToSWordRound(x1W);
            sc->pts[*pNp].P_y = WWFixedToSWordRound(y1W);
            (*pNp)++;
        }
#ifdef SVG_ARC_DEBUG
        sprintf(dbuf, "ARC degenerate: line-to end=(%d,%d) new_np=%u",
                (int)WWFixedToSWordRound(x1W), (int)WWFixedToSWordRound(y1W), (unsigned)(*pNp));
        _WRITE_TO_FILE(dbuf);
#endif
        return;
    }
    if (WWFixedToSWordRound(x0W) == WWFixedToSWordRound(x1W) &&
        WWFixedToSWordRound(y0W) == WWFixedToSWordRound(y1W)) {
#ifdef SVG_ARC_DEBUG
        _WRITE_TO_FILE("ARC degenerate: identical endpoints");
#endif
        return;
    }

    /* |rx|, |ry| */
    frx = WWAbs(rxW);
    fry = WWAbs(ryW);

    /* cosφ, sinφ (φ in **degrees**) */
    cphi = GrQuickCosine(rotW);
    sphi = GrQuickSine(rotW);

    /* midpoint diff in original frame: (x0 - x1)/2, (y0 - y1)/2 */
    dx = GrSDivWWFixed(GrSubWWFixed(x0W, x1W), two);
    dy = GrSDivWWFixed(GrSubWWFixed(y0W, y1W), two);

    /* x1' =  cosφ*dx + sinφ*dy
     * y1' = -sinφ*dx + cosφ*dy
     */
    tmp  = GrMulWWFixed(cphi, dx);
    tmp2 = GrMulWWFixed(sphi, dy);
    x1p  = GrAddWWFixed(tmp, tmp2);

    tmp  = GrMulWWFixed(sphi, dx);
    tmp  = (WWFixedAsDWord)(-(sdword)tmp);
    tmp2 = GrMulWWFixed(cphi, dy);
    y1p  = GrAddWWFixed(tmp, tmp2);

    /* squares */
    x1p2 = GrMulWWFixed(x1p, x1p);
    y1p2 = GrMulWWFixed(y1p, y1p);
    rx2  = GrMulWWFixed(frx, frx);
    ry2  = GrMulWWFixed(fry, fry);

    /* Radii correction λ = x1'^2/rx^2 + y1'^2/ry^2 ; if λ>1, scale rx,ry *= sqrt(λ) */
    tmp  = GrSDivWWFixed(x1p2, rx2);
    tmp2 = GrSDivWWFixed(y1p2, ry2);
    lam  = GrAddWWFixed(tmp, tmp2);

    if ((sdword)lam > (sdword)one) {
        scale = WWSqrt(lam);
        frx = GrMulWWFixed(frx, scale);
        fry = GrMulWWFixed(fry, scale);
        rx2 = GrMulWWFixed(frx, frx);
        ry2 = GrMulWWFixed(fry, fry);

        /* recompute λ with scaled radii */
        tmp  = GrSDivWWFixed(x1p2, rx2);
        tmp2 = GrSDivWWFixed(y1p2, ry2);
        lam  = GrAddWWFixed(tmp, tmp2);
    }

    /* ----- robust s using λ; avoids rx2*ry2 overflow ----- */
    if ((sdword)lam == 0) {
        s = zero;
    } else {
        /* num = 1/λ ; frac = num - 1 = (1/λ)-1 */
        num  = GrSDivWWFixed(one, lam);
        frac = GrSubWWFixed(num, one);
        if ((sdword)frac < 0) {
            frac = zero;
        }
        s = WWSqrt(frac);
    }
    if (laf == swf) {
        s = (WWFixedAsDWord)(-(sdword)s);
    }

#ifdef SVG_ARC_DEBUG
    {
        sword slam = WWFixedToSWordRound(lam);
        sword sinv1 = WWFixedToSWordRound(frac); /* actually (1/λ)-1 */
        sword ss    = WWFixedToSWordRound(s);
        sprintf(dbuf, "ARC s-via-lam: lam=%d invLam-1=%d s=%d",
                (int)slam, (int)sinv1, (int)ss);
        _WRITE_TO_FILE(dbuf);
    }
#endif

    /* cx' / cy' */
    tmp  = GrMulWWFixed(frx, y1p);
    tmp  = GrSDivWWFixed(tmp, fry);
    cxp  = GrMulWWFixed(s, tmp);

    tmp  = GrMulWWFixed(fry, x1p);
    tmp  = GrSDivWWFixed(tmp, frx);
    tmp  = (WWFixedAsDWord)(-(sdword)tmp);
    cyp  = GrMulWWFixed(s, tmp);

    /* mx,my = (x0+x1)/2, (y0+y1)/2 */
    mx = GrSDivWWFixed(GrAddWWFixed(x0W, x1W), two);
    my = GrSDivWWFixed(GrAddWWFixed(y0W, y1W), two);

    /* back to original frame */
    tmp  = GrMulWWFixed(cphi, cxp);
    tmp2 = GrMulWWFixed(sphi, cyp);
    tmp2 = (WWFixedAsDWord)(-(sdword)tmp2);
    cx   = GrAddWWFixed(GrAddWWFixed(tmp, tmp2), mx);

    tmp  = GrMulWWFixed(sphi, cxp);
    tmp2 = GrMulWWFixed(cphi, cyp);
    cy   = GrAddWWFixed(GrAddWWFixed(tmp, tmp2), my);

    /* unit vectors u and v */
    ux = GrSDivWWFixed(GrSubWWFixed(x1p, cxp), frx);
    uy = GrSDivWWFixed(GrSubWWFixed(y1p, cyp), fry);

    vx = GrSDivWWFixed(GrSubWWFixed((WWFixedAsDWord)(-(sdword)x1p), cxp), frx);
    vy = GrSDivWWFixed(GrSubWWFixed((WWFixedAsDWord)(-(sdword)y1p), cyp), fry);

    /* θ1 and Δθ (degrees) */
    th1 = WWAtan2Deg(uy, ux);

    tmp  = GrMulWWFixed(ux, vy);
    tmp2 = GrMulWWFixed(uy, vx);
    cross = GrSubWWFixed(tmp, tmp2);

    tmp  = GrMulWWFixed(ux, vx);
    tmp2 = GrMulWWFixed(uy, vy);
    dot   = GrAddWWFixed(tmp, tmp2);

    dth = WWAtan2Deg(cross, dot); /* signed */

    /* sweep normalize */
    if (!swf) {
        if ((sdword)dth > 0) {
            dth = GrSubWWFixed(dth, MakeWWFixed(360));
        }
    } else {
        if ((sdword)dth < 0) {
            dth = GrAddWWFixed(dth, MakeWWFixed(360));
        }
    }

    /* segments: ~12° per segment */
    absDth = WWAbs(dth);
    deltaMaxDeg = MakeWWFixed(12);

    /* nSeg = ceil(absΔθ / deltaMaxDeg) */
    nSegWW = GrSDivWWFixed(absDth, deltaMaxDeg);
    nSeg = (word)WWFixedToSWordRound(nSegWW);
    if (GrMulWWFixed(MakeWWFixed(nSeg), deltaMaxDeg) < absDth) {
        nSeg++;
    }
    if (nSeg < 1) {
        nSeg = 1;
    }

    /* clamp slots */
    np = *pNp;
    remaining = (MAX_SVG_POINTS > np) ? (MAX_SVG_POINTS - np) : 0;
    if (remaining == 0) {
#ifdef SVG_ARC_DEBUG
        _WRITE_TO_FILE("ARC abort: no remaining point slots");
#endif
        return;
    }
    if (nSeg > remaining) {
        nSeg = remaining;
    }

    /* step in degrees */
    stepDeg = GrSDivWWFixed(dth, MakeWWFixed(nSeg));

    /* --- debug: center/angles/segmentation --- */
#ifdef SVG_ARC_DEBUG
    ccx  = WWFixedToSWordRound(cx);
    ccy  = WWFixedToSWordRound(cy);
    sth1 = WWFixedToSWordRound(th1);
    sdth = WWFixedToSWordRound(dth);
    sStep= WWFixedToSWordRound(stepDeg);
    sprintf(dbuf,
        "ARC core: center=(%d,%d) th1=%d dth=%d nSeg=%u step=%d",
        (int)ccx,(int)ccy,(int)sth1,(int)sdth,(unsigned)nSeg,(int)sStep);
    _WRITE_TO_FILE(dbuf);
    /* prepare sample debug */
    fxi=fyi=lxi=lyi=0; mxi=myi=0; haveMid=FALSE;
    midK = (nSeg >= 3) ? (word)((nSeg+1)/2) : 0;
#endif

    /* Emit k = 1..nSeg points */
    for (k = 1; k <= nSeg; k++) {
        WWFixedAsDWord cth, sth;
        /* θ = θ1 + k*stepDeg */
        theta = GrAddWWFixed(th1, GrMulWWFixed(stepDeg, MakeWWFixed(k)));

        /* x' = rx*cosθ ; y' = ry*sinθ  (θ in degrees) */
        cth = GrQuickCosine(theta);
        sth = GrQuickSine(theta);

        xr = GrMulWWFixed(frx, cth);
        yr = GrMulWWFixed(fry, sth);

        /* rotate back & translate: x = cosφ*x' - sinφ*y' + cx; y = sinφ*x' + cosφ*y' + cy */
        xp = GrSubWWFixed(GrMulWWFixed(cphi, xr), GrMulWWFixed(sphi, yr));
        yp = GrAddWWFixed(GrMulWWFixed(sphi, xr), GrMulWWFixed(cphi, yr));

        x = GrAddWWFixed(xp, cx);
        y = GrAddWWFixed(yp, cy);

        xi = WWFixedToSWordRound(x);
        yi = WWFixedToSWordRound(y);

#ifdef SVG_ARC_DEBUG
        if (k == 1) { fxi = xi; fyi = yi; }
        if (midK && k == midK) { mxi = xi; myi = yi; haveMid = TRUE; }
        lxi = xi; lyi = yi;
#endif

        if (np < MAX_SVG_POINTS) {
            sc->pts[np].P_x = xi;
            sc->pts[np].P_y = yi;
            np++;
        } else {
            break;
        }
    }

    *pNp = np;

    /* --- debug: emission summary --- */
#ifdef SVG_ARC_DEBUG
    {
        word added = (word)(np - np0);
        if (!haveMid) { mxi = fxi; myi = fyi; }
        sprintf(dbuf,
            "ARC out: added=%u new_np=%u first=(%d,%d) mid=(%d,%d) last=(%d,%d) target=(%d,%d)",
            (unsigned)added, (unsigned)np,
            (int)fxi,(int)fyi,(int)mxi,(int)myi,(int)lxi,(int)lyi,
            (int)WWFixedToSWordRound(x1W),(int)WWFixedToSWordRound(y1W));
        _WRITE_TO_FILE(dbuf);
    }
#endif
}





/* -------------------------------------- */
/* ---------- element handlers ---------- */
/* -------------------------------------- */


/* ---- path (axis-aware, abs vs rel) ---- */


#define SVG_ARC_LOG

static void HandlePathTag(const char *tag, SVGScratch *sc)
{
    const char     *sP;
    word            np;
    Boolean         closed;
    sword           lastx;
    sword           lasty;
    sword           subStartX;
    sword           subStartY;
    /* reflection state */
    Boolean         lastWasCubic;
    Boolean         lastWasQuad;
    sword           lastC2x, lastC2y;   /* previous cubic's 2nd control */
    sword           lastQcx, lastQcy;   /* previous quad's control point */

    char            lastCmd;
    Boolean         haveCmd;
    word            i;

    WWFixedAsDWord  sx2, sy2;

    sc->db[0] = 0;
    if (!GetAttrBounded(tag, "d", sc->db, sizeof(sc->db))) return;

    ApplyStrokeAndFill(tag);
    ParseFillRule(tag);
    ApplyStrokeWidth(tag);

    np            = 0;
    closed        = FALSE;
    lastx         = 0;
    lasty         = 0;
    subStartX     = 0;
    subStartY     = 0;
    lastCmd       = 0;
    haveCmd       = FALSE;
    lastWasCubic  = FALSE;
    lastWasQuad   = FALSE;
    lastC2x = lastC2y = lastQcx = lastQcy = 0;

    sP = sc->db;

    while (*sP)
    {
        sword x, y;

        sP = SVG_SkipWS(sP);
        if (!*sP) break;

        if (isalpha(*sP)) {
            lastCmd = *sP++;
            haveCmd = TRUE;
        } else if (!haveCmd) {
            break;
        }

        switch (lastCmd) {
        /* ----- moveto (subsequent pairs are lineto) ----- */
        case 'M': case 'm': {
            sP = SVG_SkipWS(sP);
            if (lastCmd == 'M') {
                sP = SVG_ScanCoordX(sP, &x);
                if (*sP == ',') sP++;
                sP = SVG_SkipWS(sP);
                sP = SVG_ScanCoordY(sP, &y);
            } else {
                sword dx, dy;
                sP = SVG_SkipWS(sP);
                sP = SVG_ScanLenX(sP, &dx);
                if (*sP == ',') sP++;
                sP = SVG_SkipWS(sP);
                sP = SVG_ScanLenY(sP, &dy);
                x = (sword)(lastx + dx);
                y = (sword)(lasty + dy);
            }

            lastx = x; lasty = y;
            subStartX = x; subStartY = y;
            if (np < MAX_SVG_POINTS) { sc->pts[np].P_x = x; sc->pts[np].P_y = y; np++; }

            lastCmd = (lastCmd == 'M') ? 'L' : 'l';
            lastWasCubic = lastWasQuad = FALSE;
            break;
        }

        /* ----- lineto (supports repeated pairs) ----- */
        case 'L': case 'l': {
            sword lx, ly;
            sP = SVG_SkipWS(sP);
            if (lastCmd == 'L') {
                sP = SVG_ScanCoordX(sP, &lx);
                if (*sP == ',') sP++;
                sP = SVG_SkipWS(sP);
                sP = SVG_ScanCoordY(sP, &ly);
            } else {
                sword dx, dy;
                sP = SVG_SkipWS(sP);
                sP = SVG_ScanLenX(sP, &dx);
                if (*sP == ',') sP++;
                sP = SVG_SkipWS(sP);
                sP = SVG_ScanLenY(sP, &dy);
                lx = (sword)(lastx + dx);
                ly = (sword)(lasty + dy);
            }
            if (np < MAX_SVG_POINTS) { sc->pts[np].P_x = lx; sc->pts[np].P_y = ly; np++; }
            lastx = lx; lasty = ly;
            lastWasCubic = lastWasQuad = FALSE;
            break;
        }

        /* ----- horizontal lineto (supports repeated numbers) ----- */
        case 'H': case 'h': {
            sword lx;
            sP = SVG_SkipWS(sP);
            if (lastCmd == 'H') {
                sP = SVG_ScanCoordX(sP, &lx);
            } else {
                sword dx;
                sP = SVG_SkipWS(sP);
                sP = SVG_ScanLenX(sP, &dx);
                lx = (sword)(lastx + dx);
            }
            if (np < MAX_SVG_POINTS) { sc->pts[np].P_x = lx; sc->pts[np].P_y = lasty; np++; }
            lastx = lx;
            lastWasCubic = lastWasQuad = FALSE;
            break;
        }

        /* ----- vertical lineto (supports repeated numbers) ----- */
        case 'V': case 'v': {
            sword ly;
            sP = SVG_SkipWS(sP);
            if (lastCmd == 'V') {
                sP = SVG_ScanCoordY(sP, &ly);
            } else {
                sword dy;
                sP = SVG_SkipWS(sP);
                sP = SVG_ScanLenY(sP, &dy);
                ly = (sword)(lasty + dy);
            }
            if (np < MAX_SVG_POINTS) { sc->pts[np].P_x = lastx; sc->pts[np].P_y = ly; np++; }
            lasty = ly;
            lastWasCubic = lastWasQuad = FALSE;
            break;
        }

        /* ----- quadratic Bézier (repeating groups) ----- */
        case 'Q': case 'q': {
            sword cx, cy, ex, ey;
            for (;;) {
                sP = SVG_SkipWS(sP);
                if (!*sP || isalpha(*sP) || *sP=='Z' || *sP=='z') break;

                if (lastCmd == 'Q') {
                    sP = SVG_ScanCoordX(sP, &cx);
                    if (*sP == ',') sP++;
                    sP = SVG_SkipWS(sP);
                    sP = SVG_ScanCoordY(sP, &cy);
                    if (*sP == ',') sP++;
                    sP = SVG_SkipWS(sP);
                    sP = SVG_ScanCoordX(sP, &ex);
                    if (*sP == ',') sP++;
                    sP = SVG_SkipWS(sP);
                    sP = SVG_ScanCoordY(sP, &ey);
                } else {
                    sword dcx, dcy, dex, dey;
                    sP = SVG_ScanLenX(sP, &dcx);
                    if (*sP == ',') sP++;
                    sP = SVG_SkipWS(sP);
                    sP = SVG_ScanLenY(sP, &dcy);
                    if (*sP == ',') sP++;
                    sP = SVG_SkipWS(sP);
                    sP = SVG_ScanLenX(sP, &dex);
                    if (*sP == ',') sP++;
                    sP = SVG_SkipWS(sP);
                    sP = SVG_ScanLenY(sP, &dey);
                    cx = (sword)(lastx + dcx); cy = (sword)(lasty + dcy);
                    ex = (sword)(lastx + dex); ey = (sword)(lasty + dey);
                }

                SVG_FlattenQuad(sc, &np, lastx, lasty, cx, cy, ex, ey, 8);

                lastx = ex; lasty = ey;
                lastWasQuad = TRUE; lastQcx = cx; lastQcy = cy;
                lastWasCubic = FALSE;
            }
            break;
        }

        /* ----- smooth quadratic (T/t): reflect last Q control or use current point ----- */
        case 'T': case 't': {
            sword ex, ey, cx, cy;
            for (;;) {
                sP = SVG_SkipWS(sP);
                if (!*sP || isalpha(*sP) || *sP=='Z' || *sP=='z') break;

                if (lastCmd == 'T') {
                    sP = SVG_ScanCoordX(sP, &ex);
                    if (*sP == ',') sP++;
                    sP = SVG_SkipWS(sP);
                    sP = SVG_ScanCoordY(sP, &ey);
                } else {
                    sword dex, dey;
                    sP = SVG_ScanLenX(sP, &dex);
                    if (*sP == ',') sP++;
                    sP = SVG_SkipWS(sP);
                    sP = SVG_ScanLenY(sP, &dey);
                    ex = (sword)(lastx + dex); ey = (sword)(lasty + dey);
                }

                if (lastWasQuad) {
                    cx = (sword)(lastx + (lastx - lastQcx));
                    cy = (sword)(lasty + (lasty - lastQcy));
                } else {
                    cx = lastx; cy = lasty;
                }

                SVG_FlattenQuad(sc, &np, lastx, lasty, cx, cy, ex, ey, 8);

                lastx = ex; lasty = ey;
                lastWasQuad = TRUE; lastQcx = cx; lastQcy = cy;
                lastWasCubic = FALSE;
            }
            break;
        }

        /* ----- cubic Bézier (repeating groups) ----- */
        case 'C': case 'c': {
            sword c1x, c1y, c2x, c2y, ex, ey;
            for (;;) {
                sP = SVG_SkipWS(sP);
                if (!*sP || isalpha(*sP) || *sP=='Z' || *sP=='z') break;

                if (lastCmd == 'C') {
                    sP = SVG_ScanCoordX(sP, &c1x);
                    if (*sP == ',') sP++;
                    sP = SVG_SkipWS(sP);
                    sP = SVG_ScanCoordY(sP, &c1y);
                    if (*sP == ',') sP++;
                    sP = SVG_SkipWS(sP);
                    sP = SVG_ScanCoordX(sP, &c2x);
                    if (*sP == ',') sP++;
                    sP = SVG_SkipWS(sP);
                    sP = SVG_ScanCoordY(sP, &c2y);
                    if (*sP == ',') sP++;
                    sP = SVG_SkipWS(sP);
                    sP = SVG_ScanCoordX(sP, &ex);
                    if (*sP == ',') sP++;
                    sP = SVG_SkipWS(sP);
                    sP = SVG_ScanCoordY(sP, &ey);
                } else {
                    sword dc1x, dc1y, dc2x, dc2y, dex, dey;
                    sP = SVG_ScanLenX(sP, &dc1x);
                    if (*sP == ',') sP++;
                    sP = SVG_SkipWS(sP);
                    sP = SVG_ScanLenY(sP, &dc1y);
                    if (*sP == ',') sP++;
                    sP = SVG_SkipWS(sP);
                    sP = SVG_ScanLenX(sP, &dc2x);
                    if (*sP == ',') sP++;
                    sP = SVG_SkipWS(sP);
                    sP = SVG_ScanLenY(sP, &dc2y);
                    if (*sP == ',') sP++;
                    sP = SVG_SkipWS(sP);
                    sP = SVG_ScanLenX(sP, &dex);
                    if (*sP == ',') sP++;
                    sP = SVG_SkipWS(sP);
                    sP = SVG_ScanLenY(sP, &dey);
                    c1x = (sword)(lastx + dc1x); c1y = (sword)(lasty + dc1y);
                    c2x = (sword)(lastx + dc2x); c2y = (sword)(lasty + dc2y);
                    ex  = (sword)(lastx + dex);  ey  = (sword)(lasty + dey);
                }

                SVG_FlattenCubic(sc, &np, lastx, lasty, c1x, c1y, c2x, c2y, ex, ey, 10);

                lastx = ex; lasty = ey;
                lastC2x = c2x; lastC2y = c2y;
                lastWasCubic = TRUE;
                lastWasQuad  = FALSE;
            }
            break;
        }

        /* ----- elliptical arc (repeating groups) ----- */
        case 'A': case 'a':
        {
            WWFixedAsDWord rxW, ryW, rotW, tmpW;
            WWFixedAsDWord exW, eyW, dxW, dyW;
            WWFixedAsDWord x0W, y0W;
            int            laf, swf;
            Boolean        done;

            done = FALSE;
            while (!done)
            {
                sP = SVG_SkipWS(sP);
                if (!*sP || isalpha(*sP) || *sP=='Z' || *sP=='z') {
                    done = TRUE;
                    continue;
                }

                /* rx, ry, x-axis-rotation (all 16.16, still in path space) */
                sP = ParseWWFixed16_16(sP, &rxW);
                if (*sP == ',') sP++;
                sP = SVG_SkipWS(sP);
                sP = ParseWWFixed16_16(sP, &ryW);
                sP = SVG_SkipWS(sP);
                sP = ParseWWFixed16_16(sP, &rotW);
                if (*sP == ',') sP++;
                sP = SVG_SkipWS(sP);

                /* flags (large-arc, sweep) */
                sP = ParseWWFixed16_16(sP, &tmpW);
                laf = (WWFixedToSWordRound(tmpW) != 0);
                if (*sP == ',') sP++;
                sP = SVG_SkipWS(sP);
                sP = ParseWWFixed16_16(sP, &tmpW);
                swf = (WWFixedToSWordRound(tmpW) != 0);
                if (*sP == ',') sP++;
                sP = SVG_SkipWS(sP);

                /* endpoint (abs/rel) — still in un-mapped path space */
                if (lastCmd == 'A') {
                    sP = ParseWWFixed16_16(sP, &exW);
                    if (*sP == ',') sP++;
                    sP = SVG_SkipWS(sP);
                    sP = ParseWWFixed16_16(sP, &eyW);
                } else {
                    sP = ParseWWFixed16_16(sP, &dxW);
                    if (*sP == ',') sP++;
                    sP = SVG_SkipWS(sP);
                    sP = ParseWWFixed16_16(sP, &dyW);
                    exW = MakeWWFixed(lastx) + dxW;
                    eyW = MakeWWFixed(lasty) + dyW;
                }

                /* SVG degenerates */
                if ((WWFixedToSWordRound(rxW) == 0) || (WWFixedToSWordRound(ryW) == 0)) {
#ifdef SVG_ARC_LOG
                    {
                        char buf[160];
                        sprintf(buf,
                            "A/a degenerate (radius=0): start=(%d,%d) end=(%d,%d)",
                            (int)lastx, (int)lasty,
                            (int)WWFixedToSWordRound(exW),
                            (int)WWFixedToSWordRound(eyW));
                        _WRITE_TO_FILE(buf);
                    }
#endif
                    /* radius zero -> straight line to end point */
                    if (np < MAX_SVG_POINTS) {
                        sc->pts[np].P_x = WWFixedToSWordRound(exW);
                        sc->pts[np].P_y = WWFixedToSWordRound(eyW);
                        np++;
                    }
                    lastx = WWFixedToSWordRound(exW);
                    lasty = WWFixedToSWordRound(eyW);
                    continue;
                }
                if ((WWFixedToSWordRound(exW) == lastx) && (WWFixedToSWordRound(eyW) == lasty)) {
#ifdef SVG_ARC_LOG
                    {
                        char buf[160];
                        sprintf(buf,
                            "A/a noop (identical endpoints): start=(%d,%d)",
                            (int)lastx, (int)lasty);
                        _WRITE_TO_FILE(buf);
                    }
#endif
                    /* identical endpoints -> no-op */
                    continue;
                }

                /* current point in the same space (16.16 for the flattener) */
                x0W = ((WWFixedAsDWord)lastx) << 16;
                y0W = ((WWFixedAsDWord)lasty) << 16;

#ifdef SVG_ARC_LOG
                {
                    word  npBefore;
                    char  buf[192];
                    sword sx_i, sy_i, ex_i, ey_i, rx_i, ry_i, rot_i;

                    npBefore = np;

                    sx_i  = lastx;
                    sy_i  = lasty;
                    ex_i  = WWFixedToSWordRound(exW);
                    ey_i  = WWFixedToSWordRound(eyW);
                    rx_i  = WWFixedToSWordRound(rxW);
                    ry_i  = WWFixedToSWordRound(ryW);
                    rot_i = WWFixedToSWordRound(rotW);

                    sprintf(buf,
                        "A/a in: start=(%d,%d) end=(%d,%d) rx=%d ry=%d rot=%d laf=%d swf=%d np=%u",
                        (int)sx_i,(int)sy_i,(int)ex_i,(int)ey_i,
                        (int)rx_i,(int)ry_i,(int)rot_i, laf, swf, (unsigned)npBefore);
                    _WRITE_TO_FILE(buf);

                    /* ---- actual flattener ---- */
                    SVG_FlattenArc(sc, &np, x0W, y0W, rxW, ryW, rotW, laf, swf, exW, eyW);

                    {
                        word npAfter, added;
                        npAfter = np;
                        added   = (npAfter > npBefore) ? (npAfter - npBefore) : 0;
                        sprintf(buf, "A/a out: added=%u new_np=%u",
                                (unsigned)added, (unsigned)npAfter);
                        _WRITE_TO_FILE(buf);
                        if (added > 0) {
                            sprintf(buf, "  first=(%d,%d) last=(%d,%d)",
                                    (int)sc->pts[npBefore].P_x, (int)sc->pts[npBefore].P_y,
                                    (int)sc->pts[npAfter-1].P_x, (int)sc->pts[npAfter-1].P_y);
                            _WRITE_TO_FILE(buf);

                            /* Uncomment to dump every emitted point
                            {
                                word i;
                                for (i = npBefore; i < npAfter; ++i) {
                                    sprintf(buf, "  pt[%u]=(%d,%d)",
                                            (unsigned)i,
                                            (int)sc->pts[i].P_x, (int)sc->pts[i].P_y);
                                    _WRITE_TO_FILE(buf);
                                }
                            }
                            */
                        }
                    }
                }
#else
                /* flatten to polyline in *path space* (no VB_Map* here) */
                SVG_FlattenArc(sc, &np,
                               x0W, y0W,      /* start (16.16) */
                               rxW, ryW,      /* radii (16.16) */
                               rotW,          /* x-axis rotation (deg, 16.16) */
                               laf, swf,
                               exW, eyW);     /* end (16.16) */
#endif

                /* update current point (un-mapped) */
                lastx = WWFixedToSWordRound(exW);
                lasty = WWFixedToSWordRound(eyW);

                lastWasCubic = FALSE;
                lastWasQuad  = FALSE;
            }
            break;
        }



        /* ----- smooth cubic (S/s): reflect lastC2 across current point ----- */
        case 'S': case 's': {
            sword c1x, c1y, c2x, c2y, ex, ey;
            for (;;) {
                sP = SVG_SkipWS(sP);
                if (!*sP || isalpha(*sP) || *sP=='Z' || *sP=='z') break;

                if (lastWasCubic) {
                    c1x = (sword)(lastx + (lastx - lastC2x));
                    c1y = (sword)(lasty + (lasty - lastC2y));
                } else {
                    c1x = lastx; c1y = lasty;
                }

                if (lastCmd == 'S') {
                    sP = SVG_ScanCoordX(sP, &c2x);
                    if (*sP == ',') sP++;
                    sP = SVG_SkipWS(sP);
                    sP = SVG_ScanCoordY(sP, &c2y);
                    if (*sP == ',') sP++;
                    sP = SVG_SkipWS(sP);
                    sP = SVG_ScanCoordX(sP, &ex);
                    if (*sP == ',') sP++;
                    sP = SVG_SkipWS(sP);
                    sP = SVG_ScanCoordY(sP, &ey);
                } else {
                    sword dc2x, dc2y, dex, dey;
                    sP = SVG_ScanLenX(sP, &dc2x);
                    if (*sP == ',') sP++;
                    sP = SVG_SkipWS(sP);
                    sP = SVG_ScanLenY(sP, &dc2y);
                    if (*sP == ',') sP++;
                    sP = SVG_SkipWS(sP);
                    sP = SVG_ScanLenX(sP, &dex);
                    if (*sP == ',') sP++;
                    sP = SVG_SkipWS(sP);
                    sP = SVG_ScanLenY(sP, &dey);
                    c2x = (sword)(lastx + dc2x); c2y = (sword)(lasty + dc2y);
                    ex  = (sword)(lastx + dex);  ey  = (sword)(lasty + dey);
                }

                SVG_FlattenCubic(sc, &np, lastx, lasty, c1x, c1y, c2x, c2y, ex, ey, 10);

                lastx = ex; lasty = ey;
                lastC2x = c2x; lastC2y = c2y;
                lastWasCubic = TRUE;
                lastWasQuad  = FALSE;
            }
            break;
        }

        /* ----- closepath ----- */
        case 'Z': case 'z':
            closed = TRUE;
            sP++;
            lastx = subStartX; lasty = subStartY;
            lastWasCubic = lastWasQuad = FALSE;
            break;

        default:
            /* (path command not implemented yet; skip char) */
            sP++;
            lastWasCubic = lastWasQuad = FALSE;
            break;
        }
    }

    if (np > 1)
    {
        SVG_GetScale(tag, &sx2, &sy2);
        for (i = 0; i < np; i++) {
            sword px = sc->pts[i].P_x;
            sword py = sc->pts[i].P_y;
            SVG_ApplyScalePoint(&px, &py, sx2, sy2);
            sc->pts[i].P_x = px;
            sc->pts[i].P_y = py;
        }
        if (closed) Meta_Polygon(sc->pts, np, SVG_HasFill(tag), SVG_HasStroke(tag));
        else        Meta_Polyline(sc->pts, np);
    }
}


static void HandleLineTag(const char *tag)
{
    static char     xb[32], yb[32], x2b[32], y2b[32];
    WWFixedAsDWord  sx;
    WWFixedAsDWord  sy;
    sword           x1;
    sword           y1;
    sword           x2;
    sword           y2;

    if (GetAttrBounded(tag, "x1", xb, sizeof(xb)) &&
        GetAttrBounded(tag, "y1", yb, sizeof(yb)) &&
        GetAttrBounded(tag, "x2", x2b, sizeof(x2b)) &&
        GetAttrBounded(tag, "y2", y2b, sizeof(y2b)))
    {
        ApplyStrokeAndFill(tag);
        ApplyStrokeWidth(tag);

        x1 = SVG_ParseCoordXStr(xb);
        y1 = SVG_ParseCoordYStr(yb);
        x2 = SVG_ParseCoordXStr(x2b);
        y2 = SVG_ParseCoordYStr(y2b);

        SVG_GetScale(tag, &sx, &sy);
        SVG_ApplyScalePoint(&x1, &y1, sx, sy);
        SVG_ApplyScalePoint(&x2, &y2, sx, sy);

        Meta_Line(x1, y1, x2, y2);
    }
}

static void HandlePolylineTag(const char *tag, SVGScratch *sc)
{
    word            np;
    WWFixedAsDWord  sx;
    WWFixedAsDWord  sy;
    word            i;

    sc->pb[0] = 0;
    if (GetAttrBounded(tag, "points", sc->pb, sizeof(sc->pb)))
    {
        ApplyStrokeAndFill(tag);
        ApplyStrokeWidth(tag);

        SVG_ParsePoints(sc->pb, sc->pts, &np);
        if (np > 0)
        {
            SVG_GetScale(tag, &sx, &sy);
            for (i = 0; i < np; i++)
            {
                sword px;
                sword py;

                px = sc->pts[i].P_x;
                py = sc->pts[i].P_y;
                SVG_ApplyScalePoint(&px, &py, sx, sy);
                sc->pts[i].P_x = px;
                sc->pts[i].P_y = py;
            }
            Meta_Polyline(sc->pts, np);
        }
    }
}

static void HandlePolygonTag(const char *tag, SVGScratch *sc)
{
    word            np;
    WWFixedAsDWord  sx;
    WWFixedAsDWord  sy;
    word            i;

    sc->pb[0] = 0;
    if (GetAttrBounded(tag, "points", sc->pb, sizeof(sc->pb)))
    {
        ApplyStrokeAndFill(tag);
        ParseFillRule(tag);
        ApplyStrokeWidth(tag);

        SVG_ParsePoints(sc->pb, sc->pts, &np);
        if (np > 0)
        {
            SVG_GetScale(tag, &sx, &sy);
            for (i = 0; i < np; i++)
            {
                sword px;
                sword py;

                px = sc->pts[i].P_x;
                py = sc->pts[i].P_y;
                SVG_ApplyScalePoint(&px, &py, sx, sy);
                sc->pts[i].P_x = px;
                sc->pts[i].P_y = py;
            }
            Meta_Polygon(sc->pts, np, SVG_HasFill(tag), SVG_HasStroke(tag));
        }
    }
}

static void HandleRectTag(const char *tag)
{
    static char     xb[32], yb[32], wb[32], hb[32];
    sword           x;
    sword           y;
    sword           x2;
    sword           y2;
    WWFixedAsDWord  sx;
    WWFixedAsDWord  sy;

    if (GetAttrBounded(tag, "x", xb, sizeof(xb)) &&
        GetAttrBounded(tag, "y", yb, sizeof(yb)) &&
        GetAttrBounded(tag, "width", wb, sizeof(wb)) &&
        GetAttrBounded(tag, "height", hb, sizeof(hb)))
    {
        ApplyStrokeAndFill(tag);
        ApplyStrokeWidth(tag);

        x  = SVG_ParseCoordXStr(xb);
        y  = SVG_ParseCoordYStr(yb);
        x2 = (sword)(x + SVG_ParseLenXStr(wb));
        y2 = (sword)(y + SVG_ParseLenYStr(hb));

        SVG_GetScale(tag, &sx, &sy);
        SVG_ApplyScalePoint(&x,  &y,  sx, sy);
        SVG_ApplyScalePoint(&x2, &y2, sx, sy);

        if (y > y2) { sword t = y; y = y2; y2 = t; }
        if (x > x2) { sword t = x; x = x2; x2 = t; }

        Meta_Rect(x, y, x2, y2, SVG_HasFill(tag), SVG_HasStroke(tag));
    }
}

static void HandleEllipseTag(const char *tag)
{
    static char     cxb[32], cyb[32], rxb[32], ryb[32];
    sword           cx;
    sword           cy;
    sword           rx;
    sword           ry;
    WWFixedAsDWord  sx;
    WWFixedAsDWord  sy;

    if (GetAttrBounded(tag, "cx", cxb, sizeof(cxb)) &&
        GetAttrBounded(tag, "cy", cyb, sizeof(cyb)) &&
        GetAttrBounded(tag, "rx", rxb, sizeof(rxb)) &&
        GetAttrBounded(tag, "ry", ryb, sizeof(ryb)))
    {
        ApplyStrokeAndFill(tag);
        ApplyStrokeWidth(tag);

        cx = SVG_ParseCoordXStr(cxb);
        cy = SVG_ParseCoordYStr(cyb);
        rx = SVG_ParseLenXStr(rxb);
        ry = SVG_ParseLenYStr(ryb);

        SVG_GetScale(tag, &sx, &sy);

        SVG_ApplyScalePoint(&cx, &cy, sx, sy);
        rx = SVG_ScaleLength(rx, sx);
        ry = SVG_ScaleLength(ry, sy);

        Meta_Ellipse(cx, cy, rx, ry, 0, SVG_HasFill(tag), SVG_HasStroke(tag));
    }
}

static void HandleCircleTag(const char *tag)
{
    static char     cxb[32], cyb[32], rb[32];
    sword           cx;
    sword           cy;
    sword           r;
    sword           rx;
    sword           ry;
    WWFixedAsDWord  sx;
    WWFixedAsDWord  sy;

    if (GetAttrBounded(tag, "cx", cxb, sizeof(cxb)) &&
        GetAttrBounded(tag, "cy", cyb, sizeof(cyb)) &&
        GetAttrBounded(tag, "r",  rb,  sizeof(rb)))
    {
        ApplyStrokeAndFill(tag);
        ApplyStrokeWidth(tag);

        cx = SVG_ParseCoordXStr(cxb);
        cy = SVG_ParseCoordYStr(cyb);
        r  = SVG_ParseLenXStr(rb);

        SVG_GetScale(tag, &sx, &sy);

        SVG_ApplyScalePoint(&cx, &cy, sx, sy);
        rx = SVG_ScaleLength(r, sx);
        ry = SVG_ScaleLength(r, sy);

        Meta_Ellipse(cx, cy, rx, ry, 0, SVG_HasFill(tag), SVG_HasStroke(tag));
    }
}



/* ---------- streaming scanner ---------- */
static void ScanCtxInit(ScanCtx *c)
{
    c->ioH = 0;
    c->ioP = NULL;
    c->bytes = 0;
    c->pos = 0;
    c->inTag = FALSE;
    c->inQuote = FALSE;
    c->quoteCh = 0;
    c->tagLen = 0;
}

/* Pull next complete tag into sc->tag; returns FALSE on EOF/error with no tag */
static Boolean ScanNextTag(FileHandle fh, ScanCtx *c, SVGScratch *sc)
{
    for (;;)
    {
        if (c->pos >= c->bytes)
        {
            word r;

            if (!c->ioP) return FALSE;
            r = FileRead(fh, (void*)c->ioP, SVG_IO_BUF_SIZE, FALSE);
            if (r == (word)-1 || r == 0) return FALSE;
            c->bytes = r;
            c->pos   = 0;
        }

        {
            char ch;
            ch = c->ioP[c->pos++];

            if (!c->inTag)
            {
                if (ch == '<')
                {
                    c->inTag = TRUE;
                    c->inQuote = FALSE;
                    c->quoteCh = 0;
                    c->tagLen = 0;
                }
                continue;
            }

            if (c->inQuote)
            {
                if (ch == c->quoteCh) c->inQuote = FALSE;
                if (c->tagLen < (TAG_BUF_SIZE-1)) sc->tag[c->tagLen++] = ch;
                continue;
            }
            else
            {
                if (ch == '"' || ch == '\'')
                {
                    c->inQuote = TRUE;
                    c->quoteCh = ch;
                    if (c->tagLen < (TAG_BUF_SIZE-1)) sc->tag[c->tagLen++] = ch;
                    continue;
                }
                if (ch != '>')
                {
                    if (c->tagLen < (TAG_BUF_SIZE-1)) sc->tag[c->tagLen++] = ch;
                    continue;
                }

                sc->tag[c->tagLen] = 0;
                c->inTag = FALSE;
                return TRUE;
            }
        }
    }
}

/*---------------------------------------------------------------
 * ReadSVG -- streamed, SAX-like; callback(last param) is percent
 *---------------------------------------------------------------*/
TransError _export _pascal ReadSVG(FileHandle srcFile, word settings,
                                   ProgressCallback *callback)
{
    ScanCtx       scan;
    SVGScratch   *scP;
    MemHandle     scH;
    dword         total;
    dword         done;
    word          lastPct;
    MemHandle     ioH;
    char         *ioP;
    Boolean       sawSvg;

    (void)settings;

    scH     = 0;
    scP     = NULL;
    ioH     = 0;
    ioP     = NULL;
    lastPct = 0;
    done    = 0;
    sawSvg  = FALSE;

    /* defer Meta_SetScaling until we see <svg>, else default later */

    total = FilePos(srcFile, 0, FILE_POS_END);
    FilePos(srcFile, 0, FILE_POS_START);

    scH = MemAlloc((word)sizeof(SVGScratch), HF_DYNAMIC, HAF_ZERO_INIT);
    if (!scH)
    {
        return TE_OUT_OF_MEMORY;
    }
    scP = (SVGScratch*) MemLock(scH);
    if (!scP)
    {
        MemFree(scH);
        return TE_OUT_OF_MEMORY;
    }

    ioH = MemAlloc(SVG_IO_BUF_SIZE, HF_DYNAMIC, HAF_ZERO_INIT);
    if (!ioH)
    {
        MemUnlock(scH);
        MemFree(scH);
        return TE_OUT_OF_MEMORY;
    }
    ioP = (char*) MemLock(ioH);
    if (!ioP)
    {
        MemFree(ioH);
        MemUnlock(scH);
        MemFree(scH);
        return TE_OUT_OF_MEMORY;
    }

    ScanCtxInit(&scan);
    scan.ioH = ioH;
    scan.ioP = ioP;
    g_vbInited = FALSE;

    for (;;)
    {
        if (!ScanNextTag(srcFile, &scan, scP))
        {
            break;
        }

        if (callback && total >= 2048)
        {
            done = (dword)FilePos(srcFile, 0, FILE_POS_RELATIVE);
            if (done > total) done = total;

            {
                word pct;
                pct = (word)((done * 100UL) / total);
                if (pct != lastPct)
                {
                    lastPct = pct;
                    /* if ((*callback)(pct)) break; */
                }
            }
        }

        if (scP->tag[0] == '/' || scP->tag[0] == '!' || scP->tag[0] == '?')
        {
            continue;
        }

        if (TagIs(scP->tag, "svg"))
        {
            SVG_InitWorldFromSvgTag(scP->tag);
            sawSvg = TRUE;
            continue;
        }

        if (!g_vbInited)
        {
            /* in case this is a fragment without an <svg> root */
            SVG_InitWorldDefault();
        }

        if (TagIs(scP->tag, "line"))
        {
            HandleLineTag(scP->tag);
        }
        else if (TagIs(scP->tag, "polyline"))
        {
            HandlePolylineTag(scP->tag, scP);
        }
        else if (TagIs(scP->tag, "polygon"))
        {
            HandlePolygonTag(scP->tag, scP);
        }
        else if (TagIs(scP->tag, "rect"))
        {
            HandleRectTag(scP->tag);
        }
        else if (TagIs(scP->tag, "ellipse"))
        {
            HandleEllipseTag(scP->tag);
        }
        else if (TagIs(scP->tag, "circle"))
        {
            HandleCircleTag(scP->tag);
        }
        else if (TagIs(scP->tag, "path"))
        {
            HandlePathTag(scP->tag, scP);
        }
        else
        {
            /* unhandled: <g>, <title>, etc. */
        }
    }

    if (!sawSvg && !g_vbInited)
    {
        SVG_InitWorldDefault();
    }

    if (ioP) MemUnlock(ioH);
    if (ioH) MemFree(ioH);
    if (scP) MemUnlock(scH);
    if (scH) MemFree(scH);

    return TE_NO_ERROR;
}
