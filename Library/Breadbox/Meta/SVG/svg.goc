/***********************************************************************
 *
 * PROJECT:      Meta
 * FILE:         svg.goc
 * DESCRIPTION:  Basic SVG parser for Meta library (streamed, GEOS/Watcom)
 *
 ***********************************************************************/

@include <stdapp.goh>

#include <Ansi/string.h>
#include <Ansi/stdlib.h>
#include <Ansi/ctype.h>
#include <file.h>
#include <system.h>
#include <graphics.h>
#include <gstring.h>
#include <meta.h>

#define MAX_SVG_POINTS    512
#define SVG_IO_BUF_SIZE   1024
#define TAG_BUF_SIZE      256

/* ===== Fixed-point helpers (16.16) ===== */
#define WWFIXED_ONE      ((WWFixedAsDWord)(1UL << 16))

/* ---------- forward prototypes (avoid implicit int / symbol surprises) ---------- */
static WWFixedAsDWord MakeWWFixedFromInt(int v);
static const char *   ParseWWFixed16_16(const char *s, WWFixedAsDWord *out);
static word           HexNibble(char c);
static word           HexByte(const char *p);
static Boolean        TagIs(const char *tag, const char *name);
static Boolean        GetAttrBounded(const char *tag, const char *name, char *out, word outSize);
static void           ApplyStrokeAndFill(const char *tag);
static void           ApplyStrokeWidth(const char *tag);
static void           ParseFillRule(const char *tag);
static void           SVG_ParsePoints(const char *points, Point *pointsP, word *numPointsP);
static void           SVG_GetScale(const char *tag, WWFixedAsDWord *sxOut, WWFixedAsDWord *syOut);
static void           SVG_ApplyScalePoint(sword *x, sword *y, WWFixedAsDWord sx, WWFixedAsDWord sy);
static sword          SVG_ScaleLength(sword v, WWFixedAsDWord s);
static void           NormalizeRect(sword *x1, sword *y1, sword *x2, sword *y2);
static void           HandleLineTag(const char *tag);
static void           HandlePolylineTag(const char *tag, struct _SVGScratch *sc);
static void           HandlePolygonTag(const char *tag, struct _SVGScratch *sc);
static void           HandleRectTag(const char *tag);
static void           HandleEllipseTag(const char *tag);
static void           HandleCircleTag(const char *tag);
static void           HandlePathTag(const char *tag, struct _SVGScratch *sc);

/* tiny path helpers */
static const char *   SVG_SkipWS(const char *s);
static const char *   SVG_ScanInt(const char *s, sword *out);

/* scanner context */
typedef struct {
    MemHandle  ioH;
    char      *ioP;
    word       bytes;
    word       pos;
    Boolean    inTag;
    Boolean    inQuote;
    char       quoteCh;
    word       tagLen;
} ScanCtx;

static void           ScanCtxInit(ScanCtx *c);
static Boolean        ScanNextTag(FileHandle fh, ScanCtx *c, struct _SVGScratch *sc);

/* ---------- impl ---------- */

static WWFixedAsDWord MakeWWFixedFromInt(int v)
{
    WWFixedAsDWord f;

    f = ((WWFixedAsDWord)((sdword)v)) << 16;
    return f;
}

static WWFixedAsDWord GrMulWWFixedSafe(WWFixedAsDWord a, WWFixedAsDWord b)
{
    return GrMulWWFixed(a, b);
}

/* Parse "-12.34" → 16.16; returns pointer after number */
static const char * ParseWWFixed16_16(const char *s, WWFixedAsDWord *out)
{
    sdword           sign;
    dword            ip;
    dword            frac;
    dword            scale;
    word             c;
    WWFixedAsDWord   result;

    sign  = 1;
    ip    = 0;
    frac  = 0;
    scale = 1;

    while (*s && isspace(*s))
    {
        s++;
    }
    if (*s == '+')
    {
        s++;
    }
    else if (*s == '-')
    {
        sign = -1;
        s++;
    }

    while ((c = (word)(byte)*s) >= '0' && c <= '9')
    {
        ip = ip * 10 + (c - '0');
        s++;
    }

    if (*s == '.')
    {
        s++;
        while ((c = (word)(byte)*s) >= '0' && c <= '9')
        {
            if (scale < 1000000UL)
            {
                frac = frac * 10 + (c - '0');
                scale *= 10;
            }
            s++;
        }
    }

    result = MakeWWFixedFromInt((int)ip);
    if (scale != 0)
    {
        dword fpart;
        fpart = ((frac << 16) / scale);
        result += (WWFixedAsDWord)fpart;
    }
    if (sign < 0)
    {
        result = (WWFixedAsDWord)(0 - (sdword)result);
    }
    *out = result;
    return s;
}

/* ---------- tiny hex helpers (no stdio) ---------- */
static word HexNibble(char c)
{
    if (c >= '0' && c <= '9') return (word)(c - '0');
    if (c >= 'A' && c <= 'F') return (word)(10 + (c - 'A'));
    if (c >= 'a' && c <= 'f') return (word)(10 + (c - 'a'));
    return 0;
}
static word HexByte(const char *p)
{
    return (word)((HexNibble(p[0]) << 4) | HexNibble(p[1]));
}

/* ---------- scan helpers ---------- */
static Boolean TagIs(const char *tag, const char *name)
{
    const char *s;
    const char *n;

    s = tag;
    n = name;
    while (*s && !isspace(*s) && *s != '/' && *s != '>')
    {
        if (*n == 0 || *s != *n)
        {
            return FALSE;
        }
        s++;
        n++;
    }
    return (*n == 0);
}

/* Robust, bounded attribute reader — supports ' and " */
static Boolean GetAttrBounded(const char *tag, const char *name,
                              char *out, word outSize)
{
    const char *s;
    word        nlen;

    if (outSize == 0) return FALSE;
    out[0] = 0;

    /* skip element name */
    s = tag;
    while (*s && !isspace(*s) && *s != '>' && *s != '/')
    {
        s++;
    }

    nlen = (word)strlen(name);

    while (*s && *s != '>')
    {
        const char *an;
        word        alen;

        while (*s && (isspace(*s) || *s == '/'))
        {
            s++;
        }
        if (!*s || *s == '>')
        {
            break;
        }

        an = s;
        alen = 0;

        while (*s && *s != '=' && !isspace(*s) && *s != '>' && *s != '/')
        {
            s++;
            alen++;
        }

        if (alen == nlen && !memcmp(an, name, nlen))
        {
            while (*s && isspace(*s)) s++;
            if (*s != '=') return FALSE;
            s++;
            while (*s && isspace(*s)) s++;

            if (*s == '"' || *s == '\'')
            {
                char  q;
                word  i;

                q = *s++;
                i = 0;
                while (*s && *s != q && i < (outSize - 1))
                {
                    out[i++] = *s++;
                }
                out[i] = 0;
                if (*s == q) s++;
            }
            else
            {
                word i;
                i = 0;
                while (*s && !isspace(*s) && *s != '>' && i < (outSize - 1))
                {
                    out[i++] = *s++;
                }
                out[i] = 0;
            }
            return TRUE;
        }
        else
        {
            while (*s && isspace(*s)) s++;
            if (*s == '=')
            {
                s++;
                while (*s && isspace(*s)) s++;
                if (*s == '"' || *s == '\'')
                {
                    char q = *s++;
                    while (*s && *s != q) s++;
                    if (*s == q) s++;
                }
                else
                {
                    while (*s && !isspace(*s) && *s != '>') s++;
                }
            }
        }
    }
    return FALSE;
}

/* All sizeable buffers live here to keep stack tiny */
typedef struct _SVGScratch {
    char    tag[TAG_BUF_SIZE];

    char    pb[256];
    char    db[256];
    char    xb[32], yb[32], x2b[32], y2b[32];
    char    wb[32], hb[32];
    char    cxb[32], cyb[32], rxb[32], ryb[32];
    char    rb[32];
    char    col[64];
    char    tbuf[96];

    Point   pts[MAX_SVG_POINTS];
} SVGScratch;

/* ---------- color & style helpers ---------- */

static Boolean ExpandShortHex(const char *s, word *r, word *g, word *b)
{
    if (s[0] == '#' && strlen(s) == 4) {
        char hh[7];
        hh[0] = '#';
        hh[1] = s[1]; hh[2] = s[1];
        hh[3] = s[2]; hh[4] = s[2];
        hh[5] = s[3]; hh[6] = s[3];
        *r = HexByte(hh + 1);
        *g = HexByte(hh + 3);
        *b = HexByte(hh + 5);
        return TRUE;
    }
    return FALSE;
}

static Boolean ParseRGBFunc(const char *s, word *r, word *g, word *b)
{
    /* supports: rgb(255,0,0) and rgb(50%,0%,0%) */
    const char *p;
    int v1;
    int v2;
    int v3;
    int isPct;

    p = strstr(s, "rgb(");
    if (!p) {
        return FALSE;
    }
    p += 4;

    isPct = 0;
    v1 = atoi(p);
    while (*p && *p != ',' && *p != ')' && *p != '%') p++;
    if (*p == '%') { isPct = 1; p++; }
    if (*p == ',') p++;
    v2 = atoi(p);
    while (*p && *p != ',' && *p != ')' && *p != '%') p++;
    if (*p == '%') { isPct = 1; p++; }
    if (*p == ',') p++;
    v3 = atoi(p);
    while (*p && *p != ')' && *p != '%') p++;
    if (*p == '%') { isPct = 1; }

    if (isPct) {
        if (v1 < 0) v1 = 0; if (v1 > 100) v1 = 100;
        if (v2 < 0) v2 = 0; if (v2 > 100) v2 = 100;
        if (v3 < 0) v3 = 0; if (v3 > 100) v3 = 100;
        *r = (word)((v1 * 255) / 100);
        *g = (word)((v2 * 255) / 100);
        *b = (word)((v3 * 255) / 100);
    } else {
        if (v1 < 0) v1 = 0; if (v1 > 255) v1 = 255;
        if (v2 < 0) v2 = 0; if (v2 > 255) v2 = 255;
        if (v3 < 0) v3 = 0; if (v3 > 255) v3 = 255;
        *r = (word)v1; *g = (word)v2; *b = (word)v3;
    }
    return TRUE;
}

static void ApplyStrokeAndFill(const char *tag)
{
    static char sFill[64];
    static char sStroke[64];
    word r;
    word g;
    word b;

    sFill[0] = 0;
    sStroke[0] = 0;

    if (GetAttrBounded(tag, "stroke", sStroke, sizeof(sStroke)))
    {
        if (strcmp(sStroke, "none") != 0) {
            if (sStroke[0] == '#' && strlen(sStroke) >= 7) {
                Meta_SetLineColor(CF_RGB, HexByte(sStroke+1), HexByte(sStroke+3), HexByte(sStroke+5));
            } else if (ExpandShortHex(sStroke, &r, &g, &b)) {
                Meta_SetLineColor(CF_RGB, r, g, b);
            } else if (ParseRGBFunc(sStroke, &r, &g, &b)) {
                Meta_SetLineColor(CF_RGB, r, g, b);
            }
        }
    }
    if (GetAttrBounded(tag, "fill", sFill, sizeof(sFill)))
    {
        if (strcmp(sFill, "none") != 0) {
            if (sFill[0] == '#' && strlen(sFill) >= 7) {
                Meta_SetAreaColor(CF_RGB, HexByte(sFill+1), HexByte(sFill+3), HexByte(sFill+5));
            } else if (ExpandShortHex(sFill, &r, &g, &b)) {
                Meta_SetAreaColor(CF_RGB, r, g, b);
            } else if (ParseRGBFunc(sFill, &r, &g, &b)) {
                Meta_SetAreaColor(CF_RGB, r, g, b);
            }
        }
    }
}

static void ParseFillRule(const char *tag)
{
    static char buf[16];

    buf[0] = 0;
    if (GetAttrBounded(tag, "fill-rule", buf, sizeof(buf)))
    {
        if (!strcmp(buf, "evenodd")) {
            Meta_SetFillRule(ODD_EVEN);
        } else {
            Meta_SetFillRule(WINDING); /* SVG default: nonzero */
        }
    }
}

static void ApplyStrokeWidth(const char *tag)
{
    static char b[20];

    if (GetAttrBounded(tag, "stroke-width", b, sizeof(b)))
    {
        Meta_SetLineWidth(MakeWWFixed(atoi(b)));
    }
}

/* ---------- points parser (renamed to avoid collisions) ---------- */
static void SVG_ParsePoints(const char *points, Point *pointsP, word *numPointsP)
{
    const char *s;
    sword       x;
    sword       y;
    int         xi;
    int         yi;

    s = points;
    *numPointsP = 0;
    xi = yi = 0;

    while (*s && *numPointsP < MAX_SVG_POINTS)
    {
        while (*s && isspace(*s)) s++;
        if (!*s) break;

        xi = atoi(s);
        while (*s && *s != ',' && !isspace(*s)) s++;
        if (*s == ',') s++;
        while (*s && isspace(*s)) s++;
        yi = atoi(s);
        while (*s && *s != ' ' && *s != ',' && *s != '\0') s++;

        x = (sword)xi;
        y = (sword)yi;
        pointsP[*numPointsP].P_x = x;
        pointsP[*numPointsP].P_y = y;
        (*numPointsP)++;

        while (*s && (isspace(*s) || *s == ',')) s++;
    }
}

static void SVG_GetScale(const char *tag, WWFixedAsDWord *sxOut, WWFixedAsDWord *syOut)
{
    static char buf[96];
    char *p; const char *s; WWFixedAsDWord sx, sy;

    sx = WWFIXED_ONE; sy = WWFIXED_ONE;
    if (!GetAttrBounded(tag, "transform", buf, sizeof(buf))) { *sxOut=sx; *syOut=sy; return; }
    p = strstr(buf, "scale"); if (!p) { *sxOut=sx; *syOut=sy; return; }
    p = strchr(p, '('); if (!p) { *sxOut=sx; *syOut=sy; return; }
    s = p + 1;
    s = ParseWWFixed16_16(s, &sx);
    while (*s && isspace(*s)) s++;
    if (*s == ',') { s++; (void)ParseWWFixed16_16(s, &sy); } else { sy = sx; }
    if ((sdword)sx == 0) sx = (WWFixedAsDWord)1;   /* avoid vanishing */
    if ((sdword)sy == 0) sy = (WWFixedAsDWord)1;
    *sxOut = sx; *syOut = sy;
}

static void SVG_ApplyScalePoint(sword *x, sword *y, WWFixedAsDWord sx, WWFixedAsDWord sy)
{
    WWFixedAsDWord X = (WWFixedAsDWord)((sdword)(*x) << 16);
    WWFixedAsDWord Y = (WWFixedAsDWord)((sdword)(*y) << 16);
    X = GrMulWWFixed(X, sx);
    Y = GrMulWWFixed(Y, sy);
    *x = (sword)((sdword)X >> 16);
    *y = (sword)((sdword)Y >> 16);
}

static sword SVG_ScaleLength(sword v, WWFixedAsDWord s)
{
    WWFixedAsDWord V = (WWFixedAsDWord)((sdword)v << 16);
    WWFixedAsDWord R = GrMulWWFixed(V, s);
    sword out = (sword)((sdword)R >> 16);
    if (out < 0) out = (sword)(-out);
    return out;
}


/* ensure non-negative width/height after transforms */
static void NormalizeRect(sword *x1, sword *y1, sword *x2, sword *y2)
{
    sword t;
    if (*x1 > *x2) { t = *x1; *x1 = *x2; *x2 = t; }
    if (*y1 > *y2) { t = *y1; *y1 = *y2; *y2 = t; }
}

/* ---------- element handlers ---------- */
static void HandleLineTag(const char *tag)
{
    static char     xb[32], yb[32], x2b[32], y2b[32];
    WWFixedAsDWord  sx;
    WWFixedAsDWord  sy;
    sword           x1;
    sword           y1;
    sword           x2;
    sword           y2;

    if (GetAttrBounded(tag, "x1", xb, sizeof(xb)) &&
        GetAttrBounded(tag, "y1", yb, sizeof(yb)) &&
        GetAttrBounded(tag, "x2", x2b, sizeof(x2b)) &&
        GetAttrBounded(tag, "y2", y2b, sizeof(y2b)))
    {
        ApplyStrokeAndFill(tag);
        ApplyStrokeWidth(tag);

        x1 = (sword)atoi(xb);
        y1 = (sword)atoi(yb);
        x2 = (sword)atoi(x2b);
        y2 = (sword)atoi(y2b);

        SVG_GetScale(tag, &sx, &sy);
        SVG_ApplyScalePoint(&x1, &y1, sx, sy);
        SVG_ApplyScalePoint(&x2, &y2, sx, sy);

        Meta_Line(x1, y1, x2, y2);
    }
}

static void HandlePolylineTag(const char *tag, SVGScratch *sc)
{
    word            np;
    WWFixedAsDWord  sx;
    WWFixedAsDWord  sy;
    word            i;

    sc->pb[0] = 0;
    if (GetAttrBounded(tag, "points", sc->pb, sizeof(sc->pb)))
    {
        ApplyStrokeAndFill(tag);
        ApplyStrokeWidth(tag);

        SVG_ParsePoints(sc->pb, sc->pts, &np);
        if (np > 0)
        {
            SVG_GetScale(tag, &sx, &sy);
            for (i = 0; i < np; i++)
            {
                sword px;
                sword py;

                px = sc->pts[i].P_x;
                py = sc->pts[i].P_y;
                SVG_ApplyScalePoint(&px, &py, sx, sy);
                sc->pts[i].P_x = px;
                sc->pts[i].P_y = py;
            }
            Meta_Polyline(sc->pts, np);
        }
    }
}

static void HandlePolygonTag(const char *tag, SVGScratch *sc)
{
    word            np;
    WWFixedAsDWord  sx;
    WWFixedAsDWord  sy;
    word            i;

    sc->pb[0] = 0;
    if (GetAttrBounded(tag, "points", sc->pb, sizeof(sc->pb)))
    {
        ApplyStrokeAndFill(tag);
        ParseFillRule(tag);
        ApplyStrokeWidth(tag);

        SVG_ParsePoints(sc->pb, sc->pts, &np);
        if (np > 0)
        {
            SVG_GetScale(tag, &sx, &sy);
            for (i = 0; i < np; i++)
            {
                sword px;
                sword py;

                px = sc->pts[i].P_x;
                py = sc->pts[i].P_y;
                SVG_ApplyScalePoint(&px, &py, sx, sy);
                sc->pts[i].P_x = px;
                sc->pts[i].P_y = py;
            }
            Meta_Polygon(sc->pts, np, TRUE, TRUE);
        }
    }
}

static void HandleRectTag(const char *tag)
{
    static char     xb[32], yb[32], wb[32], hb[32];
    sword           x;
    sword           y;
    sword           x2;
    sword           y2;
    WWFixedAsDWord  sx;
    WWFixedAsDWord  sy;

    if (GetAttrBounded(tag, "x", xb, sizeof(xb)) &&
        GetAttrBounded(tag, "y", yb, sizeof(yb)) &&
        GetAttrBounded(tag, "width", wb, sizeof(wb)) &&
        GetAttrBounded(tag, "height", hb, sizeof(hb)))
    {
        ApplyStrokeAndFill(tag);
        ApplyStrokeWidth(tag);

        x  = (sword)atoi(xb);
        y  = (sword)atoi(yb);
        x2 = (sword)(x + (sword)atoi(wb));
        y2 = (sword)(y + (sword)atoi(hb));

        SVG_GetScale(tag, &sx, &sy);
        SVG_ApplyScalePoint(&x,  &y,  sx, sy);
        SVG_ApplyScalePoint(&x2, &y2, sx, sy);

        if (y > y2) { sword t = y; y = y2; y2 = t; }
        if (x > x2) { sword t = x; x = x2; x2 = t; }

        Meta_Rect(x, y, x2, y2, TRUE, TRUE);
    }
}

static void HandleEllipseTag(const char *tag)
{
    static char     cxb[32], cyb[32], rxb[32], ryb[32];
    sword           cx;
    sword           cy;
    sword           rx;
    sword           ry;
    WWFixedAsDWord  sx;
    WWFixedAsDWord  sy;

    if (GetAttrBounded(tag, "cx", cxb, sizeof(cxb)) &&
        GetAttrBounded(tag, "cy", cyb, sizeof(cyb)) &&
        GetAttrBounded(tag, "rx", rxb, sizeof(rxb)) &&
        GetAttrBounded(tag, "ry", ryb, sizeof(ryb)))
    {
        ApplyStrokeAndFill(tag);
        ApplyStrokeWidth(tag);

        cx = (sword)atoi(cxb);
        cy = (sword)atoi(cyb);
        rx = (sword)atoi(rxb);
        ry = (sword)atoi(ryb);

        SVG_GetScale(tag, &sx, &sy);

        SVG_ApplyScalePoint(&cx, &cy, sx, sy);
        rx = SVG_ScaleLength(rx, sx);
        ry = SVG_ScaleLength(ry, sy);

        Meta_Ellipse(cx, cy, rx, ry, 0, TRUE, TRUE);
    }
}

static void HandleCircleTag(const char *tag)
{
    static char     cxb[32], cyb[32], rb[32];
    sword           cx;
    sword           cy;
    sword           r;
    sword           rx;
    sword           ry;
    WWFixedAsDWord  sx;
    WWFixedAsDWord  sy;

    if (GetAttrBounded(tag, "cx", cxb, sizeof(cxb)) &&
        GetAttrBounded(tag, "cy", cyb, sizeof(cyb)) &&
        GetAttrBounded(tag, "r",  rb,  sizeof(rb)))
    {
        ApplyStrokeAndFill(tag);
        ApplyStrokeWidth(tag);

        cx = (sword)atoi(cxb);
        cy = (sword)atoi(cyb);
        r  = (sword)atoi(rb);

        SVG_GetScale(tag, &sx, &sy);

        SVG_ApplyScalePoint(&cx, &cy, sx, sy);
        rx = SVG_ScaleLength(r, sx);
        ry = SVG_ScaleLength(r, sy);

        Meta_Ellipse(cx, cy, rx, ry, 0, TRUE, TRUE);
    }
}

/* ---- tiny path helpers ---- */
static const char * SVG_SkipWS(const char *s)
{
    while (*s && isspace(*s)) {
        s++;
    }
    return s;
}

static const char * SVG_ScanInt(const char *s, sword *out)
{
    int v;

    v = atoi(s);
    *out = (sword)v;
    while (*s && *s != ' ' && *s != ',' && *s != '\t' && *s != '\r' && *s != '\n' && *s != 'Z' && *s != 'z') {
        s++;
    }
    return s;
}

static void HandlePathTag(const char *tag, SVGScratch *sc)
{
    const char     *sP;
    word            np;
    Boolean         closed;
    sword           lastx;
    sword           lasty;
    char            lastCmd;
    Boolean         haveCmd;
    WWFixedAsDWord  sx;
    WWFixedAsDWord  sy;
    word            i;

    sc->db[0] = 0;
    if (!GetAttrBounded(tag, "d", sc->db, sizeof(sc->db))) return;

    ApplyStrokeAndFill(tag);
    ParseFillRule(tag);
    ApplyStrokeWidth(tag);

    np      = 0;
    closed  = FALSE;
    lastx   = 0;
    lasty   = 0;
    lastCmd = 0;
    haveCmd = FALSE;
    sP      = sc->db;

    while (*sP)
    {
        sword x;
        sword y;

        sP = SVG_SkipWS(sP);
        if (!*sP) {
            break;
        }

        if (isalpha(*sP)) {
            lastCmd = *sP++;
            haveCmd = TRUE;
        } else if (!haveCmd) {
            /* malformed path starting with numbers but no prior command */
            break;
        }

        switch (lastCmd) {
        case 'M': case 'm': {
            /* first pair is move-to; subsequent pairs imply line-to with same rel/abs mode */
            sP = SVG_SkipWS(sP);
            sP = SVG_ScanInt(sP, &x);
            if (*sP == ',') sP++;
            sP = SVG_SkipWS(sP);
            sP = SVG_ScanInt(sP, &y);

            if (lastCmd == 'm') { x += lastx; y += lasty; }
            lastx = x; lasty = y;
            if (np < MAX_SVG_POINTS) { sc->pts[np].P_x = x; sc->pts[np].P_y = y; np++; }

            /* After an M, any additional coordinate pairs should be treated as L with same rel/abs */
            lastCmd = (lastCmd == 'M') ? 'L' : 'l';
            haveCmd = TRUE;
            break;
        }
        case 'L': case 'l': {
            sword lx;
            sword ly;

            sP = SVG_SkipWS(sP);
            sP = SVG_ScanInt(sP, &lx);
            if (*sP == ',') sP++;
            sP = SVG_SkipWS(sP);
            sP = SVG_ScanInt(sP, &ly);

            if (lastCmd == 'l') { lx += lastx; ly += lasty; }
            if (np < MAX_SVG_POINTS) { sc->pts[np].P_x = lx; sc->pts[np].P_y = ly; np++; }
            lastx = lx; lasty = ly;
            break;
        }
        case 'H': case 'h': {
            sword lx;

            sP = SVG_SkipWS(sP);
            sP = SVG_ScanInt(sP, &lx);
            if (lastCmd == 'h') lx += lastx;
            if (np < MAX_SVG_POINTS) { sc->pts[np].P_x = lx; sc->pts[np].P_y = lasty; np++; }
            lastx = lx;
            break;
        }
        case 'V': case 'v': {
            sword ly;

            sP = SVG_SkipWS(sP);
            sP = SVG_ScanInt(sP, &ly);
            if (lastCmd == 'v') ly += lasty;
            if (np < MAX_SVG_POINTS) { sc->pts[np].P_x = lastx; sc->pts[np].P_y = ly; np++; }
            lasty = ly;
            break;
        }
        case 'Z': case 'z':
            closed = TRUE;
            sP++;
            /* do not reset haveCmd; path may end here */
            break;

        default:
            /* skip unhandled (curves/arcs/others) one char at a time */
            sP++;
            break;
        }
    }

    if (np > 1)
    {
        WWFixedAsDWord sx, sy;
        word i;

        SVG_GetScale(tag, &sx, &sy);
        for (i = 0; i < np; i++) {
            sword px = sc->pts[i].P_x;
            sword py = sc->pts[i].P_y;
            SVG_ApplyScalePoint(&px, &py, sx, sy);
            sc->pts[i].P_x = px;
            sc->pts[i].P_y = py;
        }

        if (closed) Meta_Polygon(sc->pts, np, TRUE, TRUE);
        else        Meta_Polyline(sc->pts, np);
    }
}

/* ---------- streaming scanner ---------- */
static void ScanCtxInit(ScanCtx *c)
{
    c->ioH = 0;
    c->ioP = NULL;
    c->bytes = 0;
    c->pos = 0;
    c->inTag = FALSE;
    c->inQuote = FALSE;
    c->quoteCh = 0;
    c->tagLen = 0;
}

/* Pull next complete tag into sc->tag; returns FALSE on EOF/error with no tag */
static Boolean ScanNextTag(FileHandle fh, ScanCtx *c, SVGScratch *sc)
{
    for (;;)
    {
        if (c->pos >= c->bytes)
        {
            word r;

            if (!c->ioP) return FALSE;
            r = FileRead(fh, (void*)c->ioP, SVG_IO_BUF_SIZE, FALSE);
            if (r == (word)-1 || r == 0) return FALSE;
            c->bytes = r;
            c->pos   = 0;
        }

        {
            char ch;
            ch = c->ioP[c->pos++];

            if (!c->inTag)
            {
                if (ch == '<')
                {
                    c->inTag = TRUE;
                    c->inQuote = FALSE;
                    c->quoteCh = 0;
                    c->tagLen = 0;
                }
                continue;
            }

            if (c->inQuote)
            {
                if (ch == c->quoteCh) c->inQuote = FALSE;
                if (c->tagLen < (TAG_BUF_SIZE-1)) sc->tag[c->tagLen++] = ch;
                continue;
            }
            else
            {
                if (ch == '"' || ch == '\'')
                {
                    c->inQuote = TRUE;
                    c->quoteCh = ch;
                    if (c->tagLen < (TAG_BUF_SIZE-1)) sc->tag[c->tagLen++] = ch;
                    continue;
                }
                if (ch != '>')
                {
                    if (c->tagLen < (TAG_BUF_SIZE-1)) sc->tag[c->tagLen++] = ch;
                    continue;
                }

                /* finished a tag; if it overflowed, it was truncated safely */
                sc->tag[c->tagLen] = 0;
                c->inTag = FALSE;
                return TRUE;
            }
        }
    }
}

/*---------------------------------------------------------------
 * ReadSVG -- streamed, SAX-like; callback(last param) is percent
 *---------------------------------------------------------------*/
TransError _export _pascal ReadSVG(FileHandle srcFile, word settings,
                                   ProgressCallback *callback)
{
    ScanCtx       scan;
    SVGScratch   *scP;
    MemHandle     scH;
    dword         total;
    dword         done;
    word          lastPct;
    MemHandle     ioH;
    char         *ioP;

    (void)settings;

    scH     = 0;
    scP     = NULL;
    ioH     = 0;
    ioP     = NULL;
    lastPct = 0;
    done    = 0;

    /* world 0..32767 in both axes; uniform scale derives from X extent */
    Meta_SetScaling(0, 0, 32767, 32767, 32767, 32767);

    total = FilePos(srcFile, 0, FILE_POS_END);
    FilePos(srcFile, 0, FILE_POS_START);

    /* progress disabled for safety while ABI is verified */
    /* if (callback) (void)(*callback)(0); */

    scH = MemAlloc((word)sizeof(SVGScratch), HF_DYNAMIC, HAF_ZERO_INIT);
    if (!scH)
    {
        /* if (callback) (void)(*callback)(100); */
        return TE_OUT_OF_MEMORY;
    }
    scP = (SVGScratch*) MemLock(scH);
    if (!scP)
    {
        MemFree(scH);
        /* if (callback) (void)(*callback)(100); */
        return TE_OUT_OF_MEMORY;
    }

    ioH = MemAlloc(SVG_IO_BUF_SIZE, HF_DYNAMIC, HAF_ZERO_INIT);
    if (!ioH)
    {
        MemUnlock(scH);
        MemFree(scH);
        /* if (callback) (void)(*callback)(100); */
        return TE_OUT_OF_MEMORY;
    }
    ioP = (char*) MemLock(ioH);
    if (!ioP)
    {
        MemFree(ioH);
        MemUnlock(scH);
        MemFree(scH);
        /* if (callback) (void)(*callback)(100); */
        return TE_OUT_OF_MEMORY;
    }

    ScanCtxInit(&scan);
    scan.ioH = ioH;
    scan.ioP = ioP;

    for (;;)
    {
        if (!ScanNextTag(srcFile, &scan, scP))
        {
            break;
        }

        /* progress (throttled; avoid tiny files) — disabled for now */
        if (callback && total >= 2048)
        {
            done = (dword)FilePos(srcFile, 0, FILE_POS_RELATIVE);
            if (done > total) done = total;

            {
                word pct;
                pct = (word)((done * 100UL) / total);
                if (pct != lastPct)
                {
                    lastPct = pct;
                    /* if ((*callback)(pct)) break; */
                }
            }
        }

        if (scP->tag[0] == '/' || scP->tag[0] == '!' || scP->tag[0] == '?')
        {
            continue;
        }

        if (TagIs(scP->tag, "line"))
        {
            HandleLineTag(scP->tag);
        }
        else if (TagIs(scP->tag, "polyline"))
        {
            HandlePolylineTag(scP->tag, scP);
        }
        else if (TagIs(scP->tag, "polygon"))
        {
            HandlePolygonTag(scP->tag, scP);
        }
        else if (TagIs(scP->tag, "rect"))
        {
            HandleRectTag(scP->tag);
        }
        else if (TagIs(scP->tag, "ellipse"))
        {
            HandleEllipseTag(scP->tag);
        }
        else if (TagIs(scP->tag, "circle"))
        {
            HandleCircleTag(scP->tag);
        }
        else if (TagIs(scP->tag, "path"))
        {
            HandlePathTag(scP->tag, scP);
        }
        else
        {
            /* unhandled: <svg>, <g>, etc. */
        }
    }

    if (ioP) MemUnlock(ioH);
    if (ioH) MemFree(ioH);
    if (scP) MemUnlock(scH);
    if (scH) MemFree(scH);
    /* if (callback) (void)(*callback)(100); */

    return TE_NO_ERROR;
}
