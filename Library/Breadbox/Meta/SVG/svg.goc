/***********************************************************************
 * svgParser.goc — streamed SAX-like parser, tag/attr utilities, ReadSVG
 ***********************************************************************/
@include <stdapp.goh>

#include <Ansi/string.h>
#include <Ansi/stdlib.h>
#include <Ansi/ctype.h>
#include <file.h>
#include <system.h>
#include <graphics.h>
#include <gstring.h>
#include <meta.h>
#include <float.h>

#include "SVG/svg.h"
#include "SVG/dbglog.h"

/*---------------------------------------------------------------
 * ReadSVG -- streamed, SAX-like; callback(last param) is percent
 *---------------------------------------------------------------*/
TransError _export _pascal ReadSVG(FileHandle srcFile, word settings, ProgressCallback *callback)
{
    SvgScanCtx scan;
    SVGScratch *scP;
    MemHandle scH;
    dword total;
    dword done;
    word lastPct;
    MemHandle ioH;
    char *ioP;
    Boolean sawSvg;
    word pct;
    Boolean abort=FALSE;
    TransError status;

    (void)settings;

    scH = 0;
    scP = NULL;
    ioH = 0;
    ioP = NULL;
    lastPct = 0;
    done = 0;
    sawSvg = FALSE;
    status = TE_NO_ERROR;

    LOG_INIT();
    LOG_START();

    total = FilePos(srcFile, 0, FILE_POS_END);
    FilePos(srcFile, 0, FILE_POS_START);

    LOG_STR("ReadSVG", "begin");
    LOG_FILE("srcFile", srcFile);
    LOG_DWORD("totalBytes", total);

    if (!SvgXformStackInit()) { status = TE_OUT_OF_MEMORY; goto cleanup; }
    if (!SvgStyleStackInit()) { status = TE_OUT_OF_MEMORY; goto cleanup; }

    scH = MemAlloc((word)sizeof(SVGScratch), HF_DYNAMIC, HAF_ZERO_INIT);
    if (!scH) { status = TE_OUT_OF_MEMORY; goto cleanup; }
    scP = (SVGScratch*) MemLock(scH);
    if (!scP) { status = TE_OUT_OF_MEMORY; goto cleanup; }

    ioH = MemAlloc(SVG_IO_BUF_SIZE, HF_DYNAMIC, HAF_ZERO_INIT);
    if (!ioH) { status = TE_OUT_OF_MEMORY; goto cleanup; }
    ioP = (char*) MemLock(ioH);
    if (!ioP) { status = TE_OUT_OF_MEMORY; goto cleanup; }

    SvgParserScanInit(&scan);
    scan.ioH = ioH;
    scan.ioP = ioP;

    for (;;)
    {
        if (!SvgParserScanNextTag(srcFile, &scan, scP)) { break; }

        LOG_STR_HEAD("[TAG] head", (char*) scP->tag, 96);

        if (callback && total >= 2048)
        {
            done = (dword)FilePos(srcFile, 0, FILE_POS_RELATIVE);
            if (done > total) done = total;
            {
                pct = (word)((done * 100UL) / total);
                if (pct != lastPct) { lastPct = pct; /* if ((*callback)(pct)) break; */ }

                if (((pcfm_ProgressCallback *)ProcCallFixedOrMovable_pascal)(pct, callback))
                {
                  abort = TRUE;               /* aborted? set flag... */
                  break;
                }
            }
        }

        /* handle comments/declarations, but DO NOT drop close tags blindly */
        if (scP->tag[0] == '!' || scP->tag[0] == '?')
        {
            continue;
        }

        /* root close: </svg> */
        if (scP->tag[0] == '/' && SvgParserTagIs(scP->tag + 1, "svg"))
        {
            LOG_STR("[DISPATCH]", "/svg");
            SvgStyleGroupPop();
            continue;
        }

        /* group close: </g> */
        if (scP->tag[0] == '/' && SvgParserTagIs(scP->tag + 1, "g"))
        {
            LOG_STR("[DISPATCH]", "/g");
            SvgXformGroupPop();
            SvgStyleGroupPop();
            continue;
        }

        if (SvgParserTagIs(scP->tag, "svg"))
        {
            LOG_STR("[SVG]", "root");
            /* inherit root style like a group */
            SvgStyleGroupPush(scP->tag);
            SvgViewInitFromSvgTag(scP->tag);
            sawSvg = TRUE;
            continue;
        }

        if (!sawSvg)
        {
            SvgViewInitDefault();
            sawSvg = TRUE;
        }

        /* group open: <g ...> — no drawing */
        if (SvgParserTagIs(scP->tag, "g"))
        {
            LOG_STR("[DISPATCH]", "g");
            SvgStyleGroupPush(scP->tag);
            SvgXformGroupPush(scP->tag);
            continue;
        }

        if (SvgParserTagIs(scP->tag, "line"))
        {
            LOG_STR("[DISPATCH]", "line");
            SvgShapeHandleLine(scP->tag);
        }
        else if (SvgParserTagIs(scP->tag, "polyline"))
        {
            LOG_STR("[DISPATCH]", "polyline");
            SvgShapeHandlePolyline(scP->tag, scP);
        }
        else if (SvgParserTagIs(scP->tag, "polygon"))
        {
            LOG_STR("[DISPATCH]", "polygon");
            SvgShapeHandlePolygon(scP->tag, scP);
        }
        else if (SvgParserTagIs(scP->tag, "rect"))
        {
            LOG_STR("[DISPATCH]", "rect");
            SvgShapeHandleRect(scP->tag);
        }
        else if (SvgParserTagIs(scP->tag, "ellipse"))
        {
            LOG_STR("[DISPATCH]", "ellipse");
            SvgShapeHandleEllipse(scP->tag);
        }
        else if (SvgParserTagIs(scP->tag, "circle"))
        {
            LOG_STR("[DISPATCH]", "circle");
            SvgShapeHandleCircle(scP->tag);
        }
        else if (SvgParserTagIs(scP->tag, "path"))
        {
            LOG_STR("[DISPATCH]", "path");
            SvgPathHandle(scP->tag, scP);
        }
        else
        {
            LOG_STR_HEAD("[UNHANDLED_TAG]", scP->tag, 96);
        }
    }

    if (!sawSvg)
    {
        SvgViewInitDefault();
    }

cleanup:
    if (ioP) MemUnlock(ioH);
    if (ioH) MemFree(ioH);
    if (scP) MemUnlock(scH);
    if (scH) MemFree(scH);
    SvgStyleStackFree();
    SvgXformStackFree();

    if (abort && status == TE_NO_ERROR) {
      LOG_STR("ReadSVG", "User aborted!");
      status = TE_ERROR;
    }

    LOG_END();
    return status;
}
