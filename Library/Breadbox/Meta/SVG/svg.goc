/***********************************************************************
 *
 * PROJECT:      Meta
 * FILE:         svg.goc
 * DESCRIPTION:  Basic SVG parser for Meta library (streamed, GEOS/Watcom)
 *
 ***********************************************************************/

@include <stdapp.goh>

#include <Ansi/string.h>
#include <Ansi/stdlib.h>
#include <Ansi/ctype.h>
#include <file.h>
#include <system.h>
#include <graphics.h>
#include <gstring.h>
#include <meta.h>
#include <float.h>


#define SVG_COLOR_NAME_LEN   32

typedef struct
{
    byte SNC_r;
    byte SNC_g;
    byte SNC_b;
    char SNC_name[SVG_COLOR_NAME_LEN + 1];   /* NUL-terminated */
} SvgNamedColor;

#define MAX_SVG_POINTS    512
#define SVG_IO_BUF_SIZE   1024
#define TAG_BUF_SIZE      256

/* ===== Fixed-point helpers (16.16) ===== */
#define WWFIXED_ONE      ((WWFixedAsDWord)(1UL << 16))

/* scanner context */
typedef struct {
    MemHandle  ioH;
    char      *ioP;
    word       bytes;
    word       pos;
    Boolean    inTag;
    Boolean    inQuote;
    char       quoteCh;
    word       tagLen;
} ScanCtx;


/* ===== viewBox / viewport & preserveAspectRatio =====
 * World mapping works in this order:
 *   1) subtract viewBox min (positions only)
 *   2) scale by Sx/Sy determined from preserveAspectRatio + width/height
 *   3) add letterbox/pillarbox offset (Ax/Ay) from alignment
 *   4) divide by 2^N (keep META underscale at 1)
 * Lengths are affected by steps (2) and (4) only.
 */
static Boolean        g_vbInited   = FALSE;
static WWFixedAsDWord g_vbMinX     = 0;
static WWFixedAsDWord g_vbMinY     = 0;
static WWFixedAsDWord g_vbW        = 0;
static WWFixedAsDWord g_vbH        = 0;
static WWFixedAsDWord g_vpW        = 0;   /* viewport width  (width attr or vb.w) */
static WWFixedAsDWord g_vpH        = 0;   /* viewport height (height attr or vb.h) */

static WWFixedAsDWord g_scaleX     = WWFIXED_ONE;   /* after preserveAspectRatio */
static WWFixedAsDWord g_scaleY     = WWFIXED_ONE;
static WWFixedAsDWord g_addX       = 0;
static WWFixedAsDWord g_addY       = 0;

/* 1 / (power-of-two reduction) so META world <= 8191 in both axes */
static WWFixedAsDWord g_invPow2    = WWFIXED_ONE;

/* preserveAspectRatio parsed state */
typedef enum { PAR_ALIGN_MIN=0, PAR_ALIGN_MID=1, PAR_ALIGN_MAX=2 } ParAlign;
static Boolean  g_parNone = FALSE;   /* preserveAspectRatio="none" */
static Boolean  g_parSlice = FALSE;  /* slice (vs meet) */
static ParAlign g_parAx = PAR_ALIGN_MID;  /* xMin/xMid/xMax */
static ParAlign g_parAy = PAR_ALIGN_MID;  /* yMin/yMid/yMax */


@start MetaSvgNamedColorRes, data;

/* 147 SVG/CSS color keywords */
@chunkArray SvgNamedColor SvgNamedColors = {
    {240,248,255,"aliceblue"},
    {250,235,215,"antiquewhite"},
    {  0,255,255,"aqua"},
    {127,255,212,"aquamarine"},
    {240,255,255,"azure"},
    {245,245,220,"beige"},
    {255,228,196,"bisque"},
    {  0,  0,  0,"black"},
    {255,235,205,"blanchedalmond"},
    {  0,  0,255,"blue"},
    {138, 43,226,"blueviolet"},
    {165, 42, 42,"brown"},
    {222,184,135,"burlywood"},
    { 95,158,160,"cadetblue"},
    {127,255,  0,"chartreuse"},
    {210,105, 30,"chocolate"},
    {255,127, 80,"coral"},
    {100,149,237,"cornflowerblue"},
    {255,248,220,"cornsilk"},
    {220, 20, 60,"crimson"},
    {  0,255,255,"cyan"},
    {  0,  0,139,"darkblue"},
    {  0,139,139,"darkcyan"},
    {184,134, 11,"darkgoldenrod"},
    {169,169,169,"darkgray"},
    {  0,100,  0,"darkgreen"},
    {169,169,169,"darkgrey"},
    {189,183,107,"darkkhaki"},
    {139,  0,139,"darkmagenta"},
    { 85,107, 47,"darkolivegreen"},
    {255,140,  0,"darkorange"},
    {153, 50,204,"darkorchid"},
    {139,  0,  0,"darkred"},
    {233,150,122,"darksalmon"},
    {143,188,143,"darkseagreen"},
    { 72, 61,139,"darkslateblue"},
    { 47, 79, 79,"darkslategray"},
    { 47, 79, 79,"darkslategrey"},
    {  0,206,209,"darkturquoise"},
    {148,  0,211,"darkviolet"},
    {255, 20,147,"deeppink"},
    {  0,191,255,"deepskyblue"},
    {105,105,105,"dimgray"},
    {105,105,105,"dimgrey"},
    { 30,144,255,"dodgerblue"},
    {178, 34, 34,"firebrick"},
    {255,250,240,"floralwhite"},
    { 34,139, 34,"forestgreen"},
    {255,  0,255,"fuchsia"},
    {220,220,220,"gainsboro"},
    {248,248,255,"ghostwhite"},
    {255,215,  0,"gold"},
    {218,165, 32,"goldenrod"},
    {128,128,128,"gray"},
    {128,128,128,"grey"},
    {  0,128,  0,"green"},
    {173,255, 47,"greenyellow"},
    {240,255,240,"honeydew"},
    {255,105,180,"hotpink"},
    {205, 92, 92,"indianred"},
    { 75,  0,130,"indigo"},
    {255,255,240,"ivory"},
    {240,230,140,"khaki"},
    {230,230,250,"lavender"},
    {255,240,245,"lavenderblush"},
    {124,252,  0,"lawngreen"},
    {255,250,205,"lemonchiffon"},
    {173,216,230,"lightblue"},
    {240,128,128,"lightcoral"},
    {224,255,255,"lightcyan"},
    {250,250,210,"lightgoldenrodyellow"},
    {211,211,211,"lightgray"},
    {144,238,144,"lightgreen"},
    {211,211,211,"lightgrey"},
    {255,182,193,"lightpink"},
    {255,160,122,"lightsalmon"},
    { 32,178,170,"lightseagreen"},
    {135,206,250,"lightskyblue"},
    {119,136,153,"lightslategray"},
    {119,136,153,"lightslategrey"},
    {176,196,222,"lightsteelblue"},
    {255,255,224,"lightyellow"},
    {  0,255,  0,"lime"},
    { 50,205, 50,"limegreen"},
    {250,240,230,"linen"},
    {255,  0,255,"magenta"},
    {128,  0,  0,"maroon"},
    {102,205,170,"mediumaquamarine"},
    {  0,  0,205,"mediumblue"},
    {186, 85,211,"mediumorchid"},
    {147,112,219,"mediumpurple"},
    { 60,179,113,"mediumseagreen"},
    {123,104,238,"mediumslateblue"},
    {  0,250,154,"mediumspringgreen"},
    { 72,209,204,"mediumturquoise"},
    {199, 21,133,"mediumvioletred"},
    { 25, 25,112,"midnightblue"},
    {245,255,250,"mintcream"},
    {255,228,225,"mistyrose"},
    {255,228,181,"moccasin"},
    {255,222,173,"navajowhite"},
    {  0,  0,128,"navy"},
    {253,245,230,"oldlace"},
    {128,128,  0,"olive"},
    {107,142, 35,"olivedrab"},
    {255,165,  0,"orange"},
    {255, 69,  0,"orangered"},
    {218,112,214,"orchid"},
    {238,232,170,"palegoldenrod"},
    {152,251,152,"palegreen"},
    {175,238,238,"paleturquoise"},
    {219,112,147,"palevioletred"},
    {255,239,213,"papayawhip"},
    {255,218,185,"peachpuff"},
    {205,133, 63,"peru"},
    {255,192,203,"pink"},
    {221,160,221,"plum"},
    {176,224,230,"powderblue"},
    {128,  0,128,"purple"},
    {255,  0,  0,"red"},
    {188,143,143,"rosybrown"},
    { 65,105,225,"royalblue"},
    {139, 69, 19,"saddlebrown"},
    {250,128,114,"salmon"},
    {244,164, 96,"sandybrown"},
    { 46,139, 87,"seagreen"},
    {255,245,238,"seashell"},
    {160, 82, 45,"sienna"},
    {192,192,192,"silver"},
    {135,206,235,"skyblue"},
    {106, 90,205,"slateblue"},
    {112,128,144,"slategray"},
    {112,128,144,"slategrey"},
    {255,250,250,"snow"},
    {  0,255,127,"springgreen"},
    { 70,130,180,"steelblue"},
    {210,180,140,"tan"},
    {  0,128,128,"teal"},
    {216,191,216,"thistle"},
    {255, 99, 71,"tomato"},
    { 64,224,208,"turquoise"},
    {238,130,238,"violet"},
    {245,222,179,"wheat"},
    {255,255,255,"white"},
    {245,245,245,"whitesmoke"},
    {255,255,  0,"yellow"},
    {154,205, 50,"yellowgreen"}
};

@end MetaSvgNamedColorRes;



/* ---------- forward prototypes (avoid implicit int / symbol surprises) ---------- */
static WWFixedAsDWord MakeWWFixedFromInt(int v);
static const char *   ParseWWFixed16_16(const char *s, WWFixedAsDWord *out);
static word           HexNibble(char c);
static word           HexByte(const char *p);
static Boolean        TagIs(const char *tag, const char *name);
static Boolean        GetAttrBounded(const char *tag, const char *name, char *out, word outSize);
static void           ApplyStrokeAndFill(const char *tag);
static void           ApplyStrokeWidth(const char *tag);
static void           ParseFillRule(const char *tag);

/* viewBox / viewport mapping */
static void           SVG_InitWorldFromSvgTag(const char *tag);
static void           SVG_InitWorldDefault(void);
static void           SVG_ComputePar(const char *parStr);
static sword          VB_MapPosX_F(WWFixedAsDWord fx);
static sword          VB_MapPosY_F(WWFixedAsDWord fy);
static sword          VB_MapLenX_F(WWFixedAsDWord fx);
static sword          VB_MapLenY_F(WWFixedAsDWord fy);

static void           SVG_ParsePoints(const char *points, Point *pointsP, word *numPointsP);
static void           SVG_GetScale(const char *tag, WWFixedAsDWord *sxOut, WWFixedAsDWord *syOut);
static void           SVG_ApplyScalePoint(sword *x, sword *y, WWFixedAsDWord sx, WWFixedAsDWord sy);
static sword          SVG_ScaleLength(sword v, WWFixedAsDWord s);
static Boolean        SVG_HasStroke(const char *tag);
static Boolean        SVG_HasFill(const char *tag);
static void           HandleLineTag(const char *tag);
static void           HandlePolylineTag(const char *tag, struct _SVGScratch *sc);
static void           HandlePolygonTag(const char *tag, struct _SVGScratch *sc);
static void           HandleRectTag(const char *tag);
static void           HandleEllipseTag(const char *tag);
static void           HandleCircleTag(const char *tag);
static void           HandlePathTag(const char *tag, struct _SVGScratch *sc);
static Boolean        AsciiNoCaseEq(const char *a, const char *b);
static Boolean        SVG_FindNamedColor(const char *name, word *r, word *g, word *b);
static void           SVG_AddPt(struct _SVGScratch *sc, word *np, sword x, sword y);
static void           SVG_FlattenQuad(struct _SVGScratch *sc, word *np,
                            sword x0, sword y0, sword cx, sword cy, sword x1, sword y1,
                            word segs);
static void           SVG_FlattenCubic(struct _SVGScratch *sc, word *np,
                             sword x0, sword y0, sword c1x, sword c1y, sword c2x, sword c2y, sword x1, sword y1,
                             word segs);
static WWFixedAsDWord SVG_WWFSqrt(WWFixedAsDWord v);
static WWFixedAsDWord SVG_Atan2Deg_WW(WWFixedAsDWord y, WWFixedAsDWord x);
static WWFixedAsDWord SVG_WWFabs(WWFixedAsDWord v);
static void           SVG_FlattenArc(struct _SVGScratch *sc, word *np,
                           WWFixedAsDWord x0, WWFixedAsDWord y0,
                           WWFixedAsDWord rx, WWFixedAsDWord ry,
                           WWFixedAsDWord xAxisRotDegW,
                           int largeArcFlag, int sweepFlag,
                           WWFixedAsDWord x1, WWFixedAsDWord y1);

/* tiny path helpers */
static const char *   SVG_SkipWS(const char *s);
/* axis-aware scanners / parsers */
static const char *   SVG_ScanCoordX(const char *s, sword *out);
static const char *   SVG_ScanCoordY(const char *s, sword *out);
static const char *   SVG_ScanLenX(const char *s, sword *out);
static const char *   SVG_ScanLenY(const char *s, sword *out);
static sword          SVG_ParseCoordXStr(const char *s);
static sword          SVG_ParseCoordYStr(const char *s);
static sword          SVG_ParseLenXStr(const char *s);
static sword          SVG_ParseLenYStr(const char *s);

/* rounding helpers for decimal→sword (kept for internal use) */
static sword          WWFixedToSWordRound(WWFixedAsDWord w);

static void           ScanCtxInit(ScanCtx *c);
static Boolean        ScanNextTag(FileHandle fh, ScanCtx *c, struct _SVGScratch *sc);

/* ---------- impl ---------- */

static WWFixedAsDWord MakeWWFixedFromInt(int v)
{
    WWFixedAsDWord f;

    f = ((WWFixedAsDWord)((sdword)v)) << 16;
    return f;
}

static WWFixedAsDWord GrMulWWFixedSafe(WWFixedAsDWord a, WWFixedAsDWord b)
{
    return GrMulWWFixed(a, b);
}

/* Parse "-12.34" → 16.16; returns pointer after number */
static const char * ParseWWFixed16_16(const char *s, WWFixedAsDWord *out)
{
    sdword           sign;
    dword            ip;
    dword            frac;
    dword            scale;
    word             c;
    WWFixedAsDWord   result;

    sign  = 1;
    ip    = 0;
    frac  = 0;
    scale = 1;

    while (*s && isspace(*s))
    {
        s++;
    }
    if (*s == '+')
    {
        s++;
    }
    else if (*s == '-')
    {
        sign = -1;
        s++;
    }

    while ((c = (word)(byte)*s) >= '0' && c <= '9')
    {
        ip = ip * 10 + (c - '0');
        s++;
    }

    if (*s == '.')
    {
        s++;
        while ((c = (word)(byte)*s) >= '0' && c <= '9')
        {
            if (scale < 1000000UL)
            {
                frac = frac * 10 + (c - '0');
                scale *= 10;
            }
            s++;
        }
    }

    result = MakeWWFixedFromInt((int)ip);
    if (scale != 0)
    {
        dword fpart;
        fpart = ((frac << 16) / scale);
        result += (WWFixedAsDWord)fpart;
    }
    if (sign < 0)
    {
        result = (WWFixedAsDWord)(0 - (sdword)result);
    }
    *out = result;
    return s;
}

/* round signed 16.16 to signed 16-bit */
static sword WWFixedToSWordRound(WWFixedAsDWord w)
{
    sdword v;
    v = (sdword)w;
    if (v >= 0) v += 0x8000; else v -= 0x8000;   /* ±0.5 */
    return (sword)(v >> 16);
}

/* ---------- tiny hex helpers (no stdio) ---------- */
static word HexNibble(char c)
{
    if (c >= '0' && c <= '9') return (word)(c - '0');
    if (c >= 'A' && c <= 'F') return (word)(10 + (c - 'A'));
    if (c >= 'a' && c <= 'f') return (word)(10 + (c - 'a'));
    return 0;
}
static word HexByte(const char *p)
{
    return (word)((HexNibble(p[0]) << 4) | HexNibble(p[1]));
}

/* ---------- scan helpers ---------- */
static Boolean TagIs(const char *tag, const char *name)
{
    const char *s;
    const char *n;

    s = tag;
    n = name;
    while (*s && !isspace(*s) && *s != '/' && *s != '>')
    {
        if (*n == 0 || *s != *n)
        {
            return FALSE;
        }
        s++;
        n++;
    }
    return (*n == 0);
}

/* Robust, bounded attribute reader — supports ' and " */
static Boolean GetAttrBounded(const char *tag, const char *name,
                              char *out, word outSize)
{
    const char *s;
    word        nlen;

    if (outSize == 0) return FALSE;
    out[0] = 0;

    /* skip element name */
    s = tag;
    while (*s && !isspace(*s) && *s != '>' && *s != '/')
    {
        s++;
    }

    nlen = (word)strlen(name);

    while (*s && *s != '>')
    {
        const char *an;
        word        alen;

        while (*s && (isspace(*s) || *s == '/'))
        {
            s++;
        }
        if (!*s || *s == '>')
        {
            break;
        }

        an = s;
        alen = 0;

        while (*s && *s != '=' && !isspace(*s) && *s != '>' && *s != '/')
        {
            s++;
            alen++;
        }

        if (alen == nlen && !memcmp(an, name, nlen))
        {
            while (*s && isspace(*s)) s++;
            if (*s != '=') return FALSE;
            s++;
            while (*s && isspace(*s)) s++;

            if (*s == '"' || *s == '\'')
            {
                char  q;
                word  i;

                q = *s++;
                i = 0;
                while (*s && *s != q && i < (outSize - 1))
                {
                    out[i++] = *s++;
                }
                out[i] = 0;
                if (*s == q) s++;
            }
            else
            {
                word i;
                i = 0;
                while (*s && !isspace(*s) && *s != '>' && i < (outSize - 1))
                {
                    out[i++] = *s++;
                }
                out[i] = 0;
            }
            return TRUE;
        }
        else
        {
            while (*s && isspace(*s)) s++;
            if (*s == '=')
            {
                s++;
                while (*s && isspace(*s)) s++;
                if (*s == '"' || *s == '\'')
                {
                    char q = *s++;
                    while (*s && *s != q) s++;
                    if (*s == q) s++;
                }
                else
                {
                    while (*s && !isspace(*s) && *s != '>') s++;
                }
            }
        }
    }
    return FALSE;
}

/* All sizeable buffers live here to keep stack tiny */
typedef struct _SVGScratch {
    char    tag[TAG_BUF_SIZE];

    char    pb[256];
    char    db[256];
    char    xb[32], yb[32], x2b[32], y2b[32];
    char    wb[32], hb[32];
    char    cxb[32], cyb[32], rxb[32], ryb[32];
    char    rb[32];
    char    col[64];
    char    tbuf[96];

    Point   pts[MAX_SVG_POINTS];
} SVGScratch;

/* ---------- color & style helpers ---------- */

static Boolean ExpandShortHex(const char *s, word *r, word *g, word *b)
{
    if (s[0] == '#' && strlen(s) == 4) {
        char hh[7];
        hh[0] = '#';
        hh[1] = s[1]; hh[2] = s[1];
        hh[3] = s[2]; hh[4] = s[2];
        hh[5] = s[3]; hh[6] = s[3];
        *r = HexByte(hh + 1);
        *g = HexByte(hh + 3);
        *b = HexByte(hh + 5);
        return TRUE;
    }
    return FALSE;
}

static Boolean ParseRGBFunc(const char *s, word *r, word *g, word *b)
{
    /* supports: rgb(255,0,0) and rgb(50%,0%,0%) */
    const char *p;
    int v1;
    int v2;
    int v3;
    int isPct;

    p = strstr(s, "rgb(");
    if (!p) {
        return FALSE;
    }
    p += 4;

    isPct = 0;
    v1 = atoi(p);
    while (*p && *p != ',' && *p != ')' && *p != '%') p++;
    if (*p == '%') { isPct = 1; p++; }
    if (*p == ',') p++;
    v2 = atoi(p);
    while (*p && *p != ',' && *p != ')' && *p != '%') p++;
    if (*p == '%') { isPct = 1; p++; }
    if (*p == ',') p++;
    v3 = atoi(p);
    while (*p && *p != ')' && *p != '%') p++;
    if (*p == '%') { isPct = 1; }

    if (isPct) {
        if (v1 < 0) v1 = 0; if (v1 > 100) v1 = 100;
        if (v2 < 0) v2 = 0; if (v2 > 100) v2 = 100;
        if (v3 < 0) v3 = 0; if (v3 > 100) v3 = 100;
        *r = (word)((v1 * 255) / 100);
        *g = (word)((v2 * 255) / 100);
        *b = (word)((v3 * 255) / 100);
    } else {
        if (v1 < 0) v1 = 0; if (v1 > 255) v1 = 255;
        if (v2 < 0) v2 = 0; if (v2 > 255) v2 = 255;
        if (v3 < 0) v3 = 0; if (v3 > 255) v3 = 255;
        *r = (word)v1; *g = (word)v2; *b = (word)v3;
    }
    return TRUE;
}

/* small ASCII case-insensitive compare */
static Boolean AsciiNoCaseEq(const char *a, const char *b)
{
    byte ca, cb;
    while (*a || *b) {
        ca = (byte)*a++; cb = (byte)*b++;
        if (ca >= 'A' && ca <= 'Z') ca = (byte)(ca + ('a' - 'A'));
        if (cb >= 'A' && cb <= 'Z') cb = (byte)(cb + ('a' - 'A'));
        if (ca != cb) return FALSE;
        if (ca == 0)  return TRUE;
    }
    return TRUE;
}

/* GEOS-idiomatic SVG color names lookup */
static Boolean SVG_FindNamedColor(const char *name, word *r, word *g, word *b)
{
    MemHandle       mh;
    SvgNamedColor  *rec;
    word            i, count, elemSize;

    mh = OptrToHandle(@SvgNamedColors);
    ObjLockObjBlock(mh);                             /* lock owning LMem block */

    count = ChunkArrayGetCount(@SvgNamedColors);     /* number of records */
    for (i = 0; i < count; i++) {
        rec = (SvgNamedColor*) ChunkArrayElementToPtr(@SvgNamedColors, i, &elemSize);

        if (rec && AsciiNoCaseEq(rec->SNC_name, name)) {
            *r = rec->SNC_r; *g = rec->SNC_g; *b = rec->SNC_b;
            MemUnlock(mh);
            return TRUE;
        }
    }

    MemUnlock(mh);
    return FALSE;
}

static void ApplyStrokeAndFill(const char *tag)
{
    static char sFill[64];
    static char sStroke[64];
    word r;
    word g;
    word b;

    sFill[0] = 0;
    sStroke[0] = 0;

    /* stroke */
    if (GetAttrBounded(tag, "stroke", sStroke, sizeof(sStroke))) {
        if (strcmp(sStroke, "none") != 0) {
            if (sStroke[0] == '#' && strlen(sStroke) >= 7) {
                Meta_SetLineColor(CF_RGB, HexByte(sStroke+1), HexByte(sStroke+3), HexByte(sStroke+5));
            }
            else if (ExpandShortHex(sStroke, &r,&g,&b) ||
                    ParseRGBFunc(sStroke, &r,&g,&b)   ||
                    SVG_FindNamedColor(sStroke, &r,&g,&b))
            {
                Meta_SetLineColor(CF_RGB, r, g, b);
            }
        }
    }

    /* fill */
    if (GetAttrBounded(tag, "fill", sFill, sizeof(sFill))) {
        if (strcmp(sFill, "none") != 0) {
            if (sFill[0] == '#' && strlen(sFill) >= 7) {
                Meta_SetAreaColor(CF_RGB, HexByte(sFill+1), HexByte(sFill+3), HexByte(sFill+5));
            } else if (ExpandShortHex(sFill, &r,&g,&b) ||
                    ParseRGBFunc(sFill, &r,&g,&b)   ||
                    SVG_FindNamedColor(sFill, &r,&g,&b))
            {
                Meta_SetAreaColor(CF_RGB, r, g, b);
            }
        }
    }
}

static void ParseFillRule(const char *tag)
{
    static char buf[16];

    buf[0] = 0;
    if (GetAttrBounded(tag, "fill-rule", buf, sizeof(buf)))
    {
        if (!strcmp(buf, "evenodd")) {
            Meta_SetFillRule(ODD_EVEN);
        } else {
            Meta_SetFillRule(WINDING); /* SVG default: nonzero */
        }
    }
}

static void ApplyStrokeWidth(const char *tag)
{
    static char b[20];
    if (GetAttrBounded(tag, "stroke-width", b, sizeof(b)))
    {
        WWFixedAsDWord lw;
        (void)ParseWWFixed16_16(b, &lw);          /* allow decimals */
        Meta_SetLineWidth(lw);
    }
}

/* ===== viewBox / preserveAspectRatio implementation ===== */

static void SVG_ComputePar(const char *parStr)
{
    const char *s;
    char buf[64];
    word n;

    g_parNone = FALSE;
    g_parSlice = FALSE;
    g_parAx = PAR_ALIGN_MID;
    g_parAy = PAR_ALIGN_MID;

    if (!parStr || !*parStr) {
        return; /* default already xMidYMid meet */
    }

    /* copy & lowercase into buf */
    n = 0; s = parStr;
    while (*s && n < (sizeof(buf)-1)) {
        char c = *s++;
        if (c >= 'A' && c <= 'Z') c = (char)(c + ('a' - 'A'));
        buf[n++] = c;
    }
    buf[n] = 0;

    /* quick "none" */
    if (!strncmp(buf, "none", 4)) {
        g_parNone = TRUE;
        return;
    }

    /* alignment token at start */
    if      (!strncmp(buf, "xminymin", 8)) { g_parAx = PAR_ALIGN_MIN; g_parAy = PAR_ALIGN_MIN; s = parStr + 8; }
    else if (!strncmp(buf, "xmidymin", 8)) { g_parAx = PAR_ALIGN_MID; g_parAy = PAR_ALIGN_MIN; s = parStr + 8; }
    else if (!strncmp(buf, "xmaxymin", 8)) { g_parAx = PAR_ALIGN_MAX; g_parAy = PAR_ALIGN_MIN; s = parStr + 8; }
    else if (!strncmp(buf, "xminymid", 8)) { g_parAx = PAR_ALIGN_MIN; g_parAy = PAR_ALIGN_MID; s = parStr + 8; }
    else if (!strncmp(buf, "xmidymid", 8)) { g_parAx = PAR_ALIGN_MID; g_parAy = PAR_ALIGN_MID; s = parStr + 8; }
    else if (!strncmp(buf, "xmaxymid", 8)) { g_parAx = PAR_ALIGN_MAX; g_parAy = PAR_ALIGN_MID; s = parStr + 8; }
    else if (!strncmp(buf, "xminymax", 8)) { g_parAx = PAR_ALIGN_MIN; g_parAy = PAR_ALIGN_MAX; s = parStr + 8; }
    else if (!strncmp(buf, "xmidymax", 8)) { g_parAx = PAR_ALIGN_MID; g_parAy = PAR_ALIGN_MAX; s = parStr + 8; }
    else if (!strncmp(buf, "xmaxymax", 8)) { g_parAx = PAR_ALIGN_MAX; g_parAy = PAR_ALIGN_MAX; s = parStr + 8; }
    else {
        s = parStr; /* keep defaults if unknown */
    }

    /* skip whitespace, then optional meet/slice */
    while (*s && isspace(*s)) s++;
    if (!strncmp(s, "slice", 5)) g_parSlice = TRUE;
    /* "meet" is the default; nothing to store */
}

/* --- replace the whole function with this --- */
static void SVG_InitWorldFromSvgTag(const char *tag)
{
    static char vb[96];
    static char wb[32], hb[32];
    static char par[64];
    const char *s;
    WWFixedAsDWord rawSx, rawSy, uni, leftoverX, leftoverY;
    sdword w0, h0;       /* viewport size as 32-bit ints */
    word   reduce;       /* power-of-two reduction */
    sword  worldW, worldH;

    if (g_vbInited) return;

    g_vbMinX = 0; g_vbMinY = 0; g_vbW = 0; g_vbH = 0;
    g_vpW = 0; g_vpH = 0;
    g_scaleX = WWFIXED_ONE; g_scaleY = WWFIXED_ONE;
    g_addX = 0; g_addY = 0;
    g_invPow2 = WWFIXED_ONE;

    /* preserveAspectRatio (defaults to xMidYMid meet) */
    par[0] = 0;
    if (GetAttrBounded(tag, "preserveAspectRatio", par, sizeof(par))) {
        SVG_ComputePar(par);
    } else {
        SVG_ComputePar("");
    }

    /* viewBox */
    if (GetAttrBounded(tag, "viewBox", vb, sizeof(vb))) {
        s = vb;
        s = ParseWWFixed16_16(s, &g_vbMinX);
        s = SVG_SkipWS(s); s = ParseWWFixed16_16(s, &g_vbMinY);
        s = SVG_SkipWS(s); s = ParseWWFixed16_16(s, &g_vbW);
        s = SVG_SkipWS(s); s = ParseWWFixed16_16(s, &g_vbH);
    }
    if ((sdword)g_vbW <= 0 || (sdword)g_vbH <= 0) {
        /* No viewBox => synthesize from width/height (or 100x100 fallback) */
        if (GetAttrBounded(tag, "width",  wb, sizeof(wb)))  (void)ParseWWFixed16_16(wb, &g_vpW);
        if (GetAttrBounded(tag, "height", hb, sizeof(hb)))  (void)ParseWWFixed16_16(hb, &g_vpH);
        if ((sdword)g_vpW <= 0) g_vpW = MakeWWFixedFromInt(100);
        if ((sdword)g_vpH <= 0) g_vpH = MakeWWFixedFromInt(100);
        g_vbMinX = 0; g_vbMinY = 0;
        g_vbW = g_vpW; g_vbH = g_vpH;
    }

    /* viewport defaults to CSS width/height or viewBox size */
    if ((sdword)g_vpW == 0) g_vpW = g_vbW;
    if ((sdword)g_vpH == 0) g_vpH = g_vbH;

    /* raw scale viewBox -> viewport */
    rawSx = GrSDivWWFixed(g_vpW, g_vbW);
    rawSy = GrSDivWWFixed(g_vpH, g_vbH);

    if (g_parNone) {
        g_scaleX = rawSx;
        g_scaleY = rawSy;
        g_addX = 0;
        g_addY = 0;
    } else {
        /* meet/slice uniform */
        uni = g_parSlice ? ((rawSx > rawSy) ? rawSx : rawSy)
                         : ((rawSx < rawSy) ? rawSx : rawSy);
        g_scaleX = uni;
        g_scaleY = uni;

        leftoverX = g_vpW - GrMulWWFixed(g_vbW, uni);
        leftoverY = g_vpH - GrMulWWFixed(g_vbH, uni);
        if ((sdword)leftoverX < 0) leftoverX = 0;
        if ((sdword)leftoverY < 0) leftoverY = 0;

        g_addX = (g_parAx == PAR_ALIGN_MIN) ? 0
              : (g_parAx == PAR_ALIGN_MID) ? GrSDivWWFixed(leftoverX, MakeWWFixed(2))
                                            : leftoverX;
        g_addY = (g_parAy == PAR_ALIGN_MIN) ? 0
              : (g_parAy == PAR_ALIGN_MID) ? GrSDivWWFixed(leftoverY, MakeWWFixed(2))
                                            : leftoverY;
    }

    /* Reduce world so it fits in sword (≤ 32760), then use unity META scale */
    w0 = ((sdword)g_vpW) >> 16;  if (w0 <= 0) w0 = 1;
    h0 = ((sdword)g_vpH) >> 16;  if (h0 <= 0) h0 = 1;

    reduce = 1;
    while ((w0 / (sdword)reduce) > 32760 || (h0 / (sdword)reduce) > 32760) {
        if (reduce >= 32768) break;     /* safety */
        reduce <<= 1;
    }
    g_invPow2 = (reduce > 1) ? GrSDivWWFixed(MakeWWFixed(1), MakeWWFixed(reduce))
                             : WWFIXED_ONE;

    worldW = (sword)(w0 / (sdword)reduce);
    worldH = (sword)(h0 / (sdword)reduce);
    if (worldW < 1) worldW = 1;
    if (worldH < 1) worldH = 1;

    /* unity META scale: g_x == worldW, g_y == worldH */
    Meta_SetScaling(0, 0, worldW, worldH, worldW, worldH);

    g_vbInited = TRUE;
}

static void SVG_InitWorldDefault(void)
{
    if (g_vbInited) return;

    g_vbMinX = 0; g_vbMinY = 0;
    g_vbW = MakeWWFixedFromInt(1024);
    g_vbH = MakeWWFixedFromInt(1024);
    g_vpW = g_vbW; g_vpH = g_vbH;

    g_scaleX = WWFIXED_ONE;
    g_scaleY = WWFIXED_ONE;
    g_addX   = 0;
    g_addY   = 0;
    g_invPow2= WWFIXED_ONE;

    /* unity META scale */
    Meta_SetScaling(0, 0, 1024, 1024, 1024, 1024);
    g_vbInited = TRUE;
}

/* ===== mappers: viewBox space -> world space (sword) ===== */
static sword VB_MapPosX_F(WWFixedAsDWord fx)
{
    WWFixedAsDWord v;
    v  = fx - g_vbMinX;                    /* rebase to viewBox min */
    v  = GrMulWWFixed(v, g_scaleX);        /* scale to viewport */
    v += g_addX;                           /* align offset (meet/slice) */
    v  = GrMulWWFixed(v, g_invPow2);
    return WWFixedToSWordRound(v);
}

static sword VB_MapPosY_F(WWFixedAsDWord fy)
{
    WWFixedAsDWord v;
    v  = fy - g_vbMinY;
    v  = GrMulWWFixed(v, g_scaleY);
    v += g_addY;
    v  = GrMulWWFixed(v, g_invPow2);
    return WWFixedToSWordRound(v);
}

static sword VB_MapLenX_F(WWFixedAsDWord fx)
{
    WWFixedAsDWord v;
    v = GrMulWWFixed(fx, g_scaleX);        /* lengths don’t add offset */
    v = GrMulWWFixed(v, g_invPow2);
    return WWFixedToSWordRound(v);
}

static sword VB_MapLenY_F(WWFixedAsDWord fy)
{
    WWFixedAsDWord v;
    v = GrMulWWFixed(fy, g_scaleY);
    v = GrMulWWFixed(v, g_invPow2);
    return WWFixedToSWordRound(v);
}

/* ---------- points parser (axis-aware) ---------- */

static const char * SVG_SkipWS(const char *s)
{
    while (*s && isspace(*s)) {
        s++;
    }
    return s;
}

static const char * SVG_ScanCoordX(const char *s, sword *out)
{
    WWFixedAsDWord f;
    const char *p;

    p = ParseWWFixed16_16(s, &f);
    *out = VB_MapPosX_F(f);

    while (*p) {
        if (*p == ' ' || *p == ',' || *p == '\t' ||
            *p == '\r' || *p == '\n' ||
            *p == 'Z' || *p == 'z' ||
            isalpha((byte)*p)) {
            break;
        }
        p++;
    }
    return p;
}

static const char * SVG_ScanCoordY(const char *s, sword *out)
{
    WWFixedAsDWord f;
    const char *p;

    p = ParseWWFixed16_16(s, &f);
    *out = VB_MapPosY_F(f);

    while (*p) {
        if (*p == ' ' || *p == ',' || *p == '\t' ||
            *p == '\r' || *p == '\n' ||
            *p == 'Z' || *p == 'z' ||
            isalpha((byte)*p)) {
            break;
        }
        p++;
    }
    return p;
}

static const char * SVG_ScanLenX(const char *s, sword *out)
{
    WWFixedAsDWord f;
    const char *p;

    p = ParseWWFixed16_16(s, &f);
    *out = VB_MapLenX_F(f);

    while (*p) {
        if (*p == ' ' || *p == ',' || *p == '\t' ||
            *p == '\r' || *p == '\n' ||
            *p == 'Z' || *p == 'z' ||
            isalpha((byte)*p)) {
            break;
        }
        p++;
    }
    return p;
}

static const char * SVG_ScanLenY(const char *s, sword *out)
{
    WWFixedAsDWord f;
    const char *p;

    p = ParseWWFixed16_16(s, &f);
    *out = VB_MapLenY_F(f);

    while (*p) {
        if (*p == ' ' || *p == ',' || *p == '\t' ||
            *p == '\r' || *p == '\n' ||
            *p == 'Z' || *p == 'z' ||
            isalpha((byte)*p)) {
            break;
        }
        p++;
    }
    return p;
}

/* convenient attribute versions */
static sword SVG_ParseCoordXStr(const char *s) { WWFixedAsDWord f; (void)ParseWWFixed16_16(s,&f); return VB_MapPosX_F(f); }
static sword SVG_ParseCoordYStr(const char *s) { WWFixedAsDWord f; (void)ParseWWFixed16_16(s,&f); return VB_MapPosY_F(f); }
static sword SVG_ParseLenXStr  (const char *s) { WWFixedAsDWord f; (void)ParseWWFixed16_16(s,&f); return VB_MapLenX_F(f); }
static sword SVG_ParseLenYStr  (const char *s) { WWFixedAsDWord f; (void)ParseWWFixed16_16(s,&f); return VB_MapLenY_F(f); }

/* Parse "x,y x,y ..." -> world points */
static void SVG_ParsePoints(const char *points, Point *pointsP, word *numPointsP)
{
    const char *s;
    sword       x;
    sword       y;

    s = points;
    *numPointsP = 0;

    while (*s && *numPointsP < MAX_SVG_POINTS)
    {
        s = SVG_SkipWS(s);
        if (!*s) break;

        s = SVG_ScanCoordX(s, &x);
        if (*s == ',') s++;
        s = SVG_SkipWS(s);
        s = SVG_ScanCoordY(s, &y);

        pointsP[*numPointsP].P_x = x;
        pointsP[*numPointsP].P_y = y;
        (*numPointsP)++;

        while (*s && (isspace(*s) || *s == ',')) s++;
    }
}

/* element-local transform="scale(...)" (kept) */
static void SVG_GetScale(const char *tag, WWFixedAsDWord *sxOut, WWFixedAsDWord *syOut)
{
    static char buf[96];
    char *p; const char *s; WWFixedAsDWord sx, sy;

    sx = WWFIXED_ONE; sy = WWFIXED_ONE;
    if (!GetAttrBounded(tag, "transform", buf, sizeof(buf))) { *sxOut=sx; *syOut=sy; return; }
    p = strstr(buf, "scale"); if (!p) { *sxOut=sx; *syOut=sy; return; }
    p = strchr(p, '('); if (!p) { *sxOut=sx; *syOut=sy; return; }
    s = p + 1;
    s = ParseWWFixed16_16(s, &sx);
    while (*s && isspace(*s)) s++;
    if (*s == ',') { s++; (void)ParseWWFixed16_16(s, &sy); } else { sy = sx; }
    if ((sdword)sx == 0) sx = (WWFixedAsDWord)1;   /* avoid vanishing */
    if ((sdword)sy == 0) sy = (WWFixedAsDWord)1;
    *sxOut = sx; *syOut = sy;
}

static void SVG_ApplyScalePoint(sword *x, sword *y, WWFixedAsDWord sx, WWFixedAsDWord sy)
{
    WWFixedAsDWord X = (WWFixedAsDWord)((sdword)(*x) << 16);
    WWFixedAsDWord Y = (WWFixedAsDWord)((sdword)(*y) << 16);
    X = GrMulWWFixed(X, sx);
    Y = GrMulWWFixed(Y, sy);
    *x = (sword)((sdword)X >> 16);
    *y = (sword)((sdword)Y >> 16);
}

static sword SVG_ScaleLength(sword v, WWFixedAsDWord s)
{
    WWFixedAsDWord V = (WWFixedAsDWord)((sdword)v << 16);
    WWFixedAsDWord R = GrMulWWFixed(V, s);
    sword out = (sword)((sdword)R >> 16);
    if (out < 0) out = (sword)(-out);
    return out;
}

static Boolean SVG_HasStroke(const char *tag)
{
    char b[32];
    /* SVG default: stroke is none unless present and not "none" */
    return GetAttrBounded(tag, "stroke", b, sizeof(b)) && strcmp(b, "none") != 0;
}
static Boolean SVG_HasFill(const char *tag)
{
    char b[32];
    /* SVG default: most shapes are filled if 'fill' is absent */
    if (GetAttrBounded(tag, "fill", b, sizeof(b))) {
        return strcmp(b, "none") != 0;
    }
    return TRUE; /* default fill applies to rect/circle/ellipse/polygon/path */
}

static void SVG_AddPt(SVGScratch *sc, word *np, sword x, sword y)
{
    if (*np < MAX_SVG_POINTS) {
        sc->pts[*np].P_x = x;
        sc->pts[*np].P_y = y;
        (*np)++;
    }
}

static void SVG_FlattenQuad(SVGScratch *sc, word *np,
                            sword x0, sword y0, sword cx, sword cy, sword x1, sword y1,
                            word segs)
{
    word i;
    for (i = 1; i <= segs; i++) {
        WWFixedAsDWord t  = (WWFixedAsDWord)(((dword)i << 16) / segs);
        WWFixedAsDWord it = WWFIXED_ONE - t;

        WWFixedAsDWord X =
            GrMulWWFixed(GrMulWWFixed(it, it), ((sdword)x0 << 16)) +
            GrMulWWFixed(GrMulWWFixed(MakeWWFixed(2), GrMulWWFixed(it, t)), ((sdword)cx << 16)) +
            GrMulWWFixed(GrMulWWFixed(t, t), ((sdword)x1 << 16));

        WWFixedAsDWord Y =
            GrMulWWFixed(GrMulWWFixed(it, it), ((sdword)y0 << 16)) +
            GrMulWWFixed(GrMulWWFixed(MakeWWFixed(2), GrMulWWFixed(it, t)), ((sdword)cy << 16)) +
            GrMulWWFixed(GrMulWWFixed(t, t), ((sdword)y1 << 16));

        SVG_AddPt(sc, np, (sword)((sdword)X >> 16), (sword)((sdword)Y >> 16));
    }
}

static void SVG_FlattenCubic(SVGScratch *sc, word *np,
                             sword x0, sword y0, sword c1x, sword c1y, sword c2x, sword c2y, sword x1, sword y1,
                             word segs)
{
    word i;
    for (i = 1; i <= segs; i++) {
        WWFixedAsDWord t   = (WWFixedAsDWord)(((dword)i << 16) / segs);
        WWFixedAsDWord it  = WWFIXED_ONE - t;
        WWFixedAsDWord it2 = GrMulWWFixed(it, it);
        WWFixedAsDWord t2  = GrMulWWFixed(t, t);

        WWFixedAsDWord k0 = GrMulWWFixed(it2, it);                            /* (1-t)^3 */
        WWFixedAsDWord k1 = GrMulWWFixed(MakeWWFixed(3), GrMulWWFixed(it2, t)); /* 3(1-t)^2 t */
        WWFixedAsDWord k2 = GrMulWWFixed(MakeWWFixed(3), GrMulWWFixed(it, t2));  /* 3(1-t) t^2 */
        WWFixedAsDWord k3 = GrMulWWFixed(t2, t);                              /* t^3 */

        WWFixedAsDWord X =
            GrMulWWFixed(k0, ((sdword)x0 << 16)) +
            GrMulWWFixed(k1, ((sdword)c1x << 16)) +
            GrMulWWFixed(k2, ((sdword)c2x << 16)) +
            GrMulWWFixed(k3, ((sdword)x1  << 16));

        WWFixedAsDWord Y =
            GrMulWWFixed(k0, ((sdword)y0 << 16)) +
            GrMulWWFixed(k1, ((sdword)c1y << 16)) +
            GrMulWWFixed(k2, ((sdword)c2y << 16)) +
            GrMulWWFixed(k3, ((sdword)y1  << 16));

        SVG_AddPt(sc, np, (sword)((sdword)X >> 16), (sword)((sdword)Y >> 16));
    }
}

/* Convert 16.16 fixed -> sqrt in 16.16 via GEOS Float stack */
static WWFixedAsDWord SVG_WWFSqrt(WWFixedAsDWord v)
{
    if ((sdword)v <= 0) return 0;
    FloatDwordToFloat((dword)v);        /* v (fixed) */
    FloatDwordToFloat(65536);           /* 65536 */
    FloatDivide();                      /* v/65536 -> real */
    FloatSqrt();                        /* sqrt(real) */
    FloatDwordToFloat(65536);
    FloatMultiply();                    /* back to 16.16 */
    return (WWFixedAsDWord)FloatFloatToDword();
}

/* atan2(y,x) -> degrees (16.16) using GEOS Float stack */
static WWFixedAsDWord SVG_Atan2Deg_WW(WWFixedAsDWord y, WWFixedAsDWord x)
{
    /* push x (signed 16.16 → real) FIRST, like META.goc’s phi() */
    FloatDwordToFloat((sdword)x);
    FloatDwordToFloat(65536);
    FloatDivide();

    /* push y (signed 16.16 → real) SECOND (on top) */
    FloatDwordToFloat((sdword)y);
    FloatDwordToFloat(65536);
    FloatDivide();

    /* atan2(y, x) in radians (expects x then y on the stack) */
    FloatArcTan2();

    /* radians → degrees */
    FloatWordToFloat(180);
    FloatMultiply();
    FloatPi();
    FloatDivide();

    /* back to 16.16 */
    FloatDwordToFloat(65536);
    FloatMultiply();
    return (WWFixedAsDWord)FloatFloatToDword();
}



static WWFixedAsDWord SVG_WWFabs(WWFixedAsDWord v)
{
    return ((sdword)v < 0) ? (WWFixedAsDWord)(0 - (sdword)v) : v;
}

static void SVG_FlattenArc(struct _SVGScratch *sc, word *np,
                           WWFixedAsDWord x0, WWFixedAsDWord y0,
                           WWFixedAsDWord rx, WWFixedAsDWord ry,
                           WWFixedAsDWord xAxisRotDegW,
                           int largeArcFlag, int sweepFlag,
                           WWFixedAsDWord x1, WWFixedAsDWord y1)
{
    WWFixedAsDWord cRot, sRot;
    WWFixedAsDWord dx2, dy2, x1p, y1p;
    WWFixedAsDWord rx2, ry2, t1, t2, rchk, scale;
    WWFixedAsDWord num, den, ratio, coef, cxp, cyp;
    WWFixedAsDWord midX, midY, cx, cy;
    WWFixedAsDWord vx1, vy1, vx2, vy2, theta1, delta;
    WWFixedAsDWord angDeg, cA, sA;
    WWFixedAsDWord termX, termY;
    sword px, py;
    int segs, i;

    /* trivial cases */
    if ((sdword)rx == 0 || (sdword)ry == 0 ||
        ((sdword)(x0 - x1) == 0 && (sdword)(y0 - y1) == 0)) {
        SVG_AddPt(sc, np, WWFixedToSWordRound(x1), WWFixedToSWordRound(y1));
        return;
    }

    if ((sdword)rx < 0) rx = -rx;
    if ((sdword)ry < 0) ry = -ry;

    /* rotation: pass DEGREES directly to the quick trig */
    cRot = GrQuickCosine(xAxisRotDegW);
    sRot = GrQuickSine(xAxisRotDegW);

    /* midpoint between points in rotated system */
    dx2 = GrSDivWWFixed(x0 - x1, MakeWWFixed(2));
    dy2 = GrSDivWWFixed(y0 - y1, MakeWWFixed(2));
    x1p = GrMulWWFixed(cRot, dx2) + GrMulWWFixed(sRot, dy2);
    y1p = -GrMulWWFixed(sRot, dx2) + GrMulWWFixed(cRot, dy2);

    /* ensure radii large enough */
    rx2 = GrMulWWFixed(rx, rx);
    ry2 = GrMulWWFixed(ry, ry);
    t1  = GrSDivWWFixed(GrMulWWFixed(x1p, x1p), rx2);
    t2  = GrSDivWWFixed(GrMulWWFixed(y1p, y1p), ry2);
    rchk = t1 + t2;
    if ((sdword)rchk > (sdword)WWFIXED_ONE) {
        scale = SVG_WWFSqrt(rchk);
        rx    = GrMulWWFixed(rx, scale);
        ry    = GrMulWWFixed(ry, scale);
        rx2   = GrMulWWFixed(rx, rx);
        ry2   = GrMulWWFixed(ry, ry);
    }

    /* choose center sign (largeArc/sweep) */
    num = GrMulWWFixed(rx2, ry2) - GrMulWWFixed(rx2, GrMulWWFixed(y1p, y1p))
        - GrMulWWFixed(ry2, GrMulWWFixed(x1p, x1p));
    den = GrMulWWFixed(rx2, GrMulWWFixed(y1p, y1p))
        + GrMulWWFixed(ry2, GrMulWWFixed(x1p, x1p));
    if ((sdword)num <= 0 || (sdword)den <= 0) {
        coef = 0;
    } else {
        ratio = GrSDivWWFixed(num, den);
        coef  = SVG_WWFSqrt(ratio);
        if (largeArcFlag == sweepFlag)
            coef = (WWFixedAsDWord)(0 - (sdword)coef);
    }

    /* center in original coords */
    cxp = GrMulWWFixed(coef, GrSDivWWFixed(GrMulWWFixed(rx, y1p), ry));
    cyp = GrMulWWFixed(-coef, GrSDivWWFixed(GrMulWWFixed(ry, x1p), rx));
    midX = GrSDivWWFixed(x0 + x1, MakeWWFixed(2));
    midY = GrSDivWWFixed(y0 + y1, MakeWWFixed(2));
    cx = GrMulWWFixed(cRot, cxp) - GrMulWWFixed(sRot, cyp) + midX;
    cy = GrMulWWFixed(sRot, cxp) + GrMulWWFixed(cRot, cyp) + midY;

    /* unit vectors to start/end on the ellipse */
    vx1 = GrSDivWWFixed((x1p - cxp), rx);
    vy1 = GrSDivWWFixed((y1p - cyp), ry);
    vx2 = GrSDivWWFixed((-x1p - cxp), rx);
    vy2 = GrSDivWWFixed((-y1p - cyp), ry);

    /* angles in degrees */
    theta1 = SVG_Atan2Deg_WW(vy1, vx1);
    {
        WWFixedAsDWord cross = GrMulWWFixed(vx1, vy2) - GrMulWWFixed(vy1, vx2);
        WWFixedAsDWord dot   = GrMulWWFixed(vx1, vx2) + GrMulWWFixed(vy1, vy2);
        delta = SVG_Atan2Deg_WW(cross, dot);   /* [-180,180] */
    }

    /* enforce sweep ONLY */
    if (!sweepFlag && (sdword)delta > 0)
        delta -= MakeWWFixed(360);
    else if (sweepFlag && (sdword)delta < 0)
        delta += MakeWWFixed(360);

    /* segment count */
    {
        sword dAbsDeg = WWFixedToSWordRound(SVG_WWFabs(delta));
        segs = dAbsDeg / 11;
        if (segs * 11 < dAbsDeg) segs++;
        if (segs < 1)  segs = 1;
        if (segs > 60) segs = 60;
    }

    /* generate points – degrees to trig, no Y-negation */
    for (i = 1; i <= segs; i++) {
        angDeg = theta1 + GrSDivWWFixed(GrMulWWFixed(delta, MakeWWFixed(i)),
                                        MakeWWFixed(segs));
        cA = GrQuickCosine(angDeg);
        sA = GrQuickSine(angDeg);

        termX =  GrMulWWFixed(cRot, GrMulWWFixed(rx, cA))
               - GrMulWWFixed(sRot, GrMulWWFixed(ry, sA));
        termY =  GrMulWWFixed(sRot, GrMulWWFixed(rx, cA))
               + GrMulWWFixed(cRot, GrMulWWFixed(ry, sA));

        px = WWFixedToSWordRound(cx + termX);
        py = WWFixedToSWordRound(cy + termY);
        SVG_AddPt(sc, np, px, py);
    }
}




/* -------------------------------------- */
/* ---------- element handlers ---------- */
/* -------------------------------------- */


/* ---- path (axis-aware, abs vs rel) ---- */

static void HandlePathTag(const char *tag, SVGScratch *sc)
{
    const char     *sP;
    word            np;
    Boolean         closed;
    sword           lastx;
    sword           lasty;
    sword           subStartX;
    sword           subStartY;
    /* reflection state */
    Boolean         lastWasCubic;
    Boolean         lastWasQuad;
    sword           lastC2x, lastC2y;   /* previous cubic's 2nd control */
    sword           lastQcx, lastQcy;   /* previous quad's control point */

    char            lastCmd;
    Boolean         haveCmd;
    word            i;

    WWFixedAsDWord  sx2, sy2;

    sc->db[0] = 0;
    if (!GetAttrBounded(tag, "d", sc->db, sizeof(sc->db))) return;

    ApplyStrokeAndFill(tag);
    ParseFillRule(tag);
    ApplyStrokeWidth(tag);

    np            = 0;
    closed        = FALSE;
    lastx         = 0;
    lasty         = 0;
    subStartX     = 0;
    subStartY     = 0;
    lastCmd       = 0;
    haveCmd       = FALSE;
    lastWasCubic  = FALSE;
    lastWasQuad   = FALSE;
    lastC2x = lastC2y = lastQcx = lastQcy = 0;

    sP = sc->db;

    while (*sP)
    {
        sword x, y;

        sP = SVG_SkipWS(sP);
        if (!*sP) break;

        if (isalpha(*sP)) {
            lastCmd = *sP++;
            haveCmd = TRUE;
        } else if (!haveCmd) {
            break;
        }

        switch (lastCmd) {
        /* ----- moveto (subsequent pairs are lineto) ----- */
        case 'M': case 'm': {
            sP = SVG_SkipWS(sP);
            if (lastCmd == 'M') {
                sP = SVG_ScanCoordX(sP, &x);
                if (*sP == ',') sP++;
                sP = SVG_SkipWS(sP);
                sP = SVG_ScanCoordY(sP, &y);
            } else {
                sword dx, dy;
                sP = SVG_SkipWS(sP);
                sP = SVG_ScanLenX(sP, &dx);
                if (*sP == ',') sP++;
                sP = SVG_SkipWS(sP);
                sP = SVG_ScanLenY(sP, &dy);
                x = (sword)(lastx + dx);
                y = (sword)(lasty + dy);
            }

            lastx = x; lasty = y;
            subStartX = x; subStartY = y;
            if (np < MAX_SVG_POINTS) { sc->pts[np].P_x = x; sc->pts[np].P_y = y; np++; }

            lastCmd = (lastCmd == 'M') ? 'L' : 'l';
            lastWasCubic = lastWasQuad = FALSE;
            break;
        }

        /* ----- lineto (supports repeated pairs) ----- */
        case 'L': case 'l': {
            sword lx, ly;
            sP = SVG_SkipWS(sP);
            if (lastCmd == 'L') {
                sP = SVG_ScanCoordX(sP, &lx);
                if (*sP == ',') sP++;
                sP = SVG_SkipWS(sP);
                sP = SVG_ScanCoordY(sP, &ly);
            } else {
                sword dx, dy;
                sP = SVG_SkipWS(sP);
                sP = SVG_ScanLenX(sP, &dx);
                if (*sP == ',') sP++;
                sP = SVG_SkipWS(sP);
                sP = SVG_ScanLenY(sP, &dy);
                lx = (sword)(lastx + dx);
                ly = (sword)(lasty + dy);
            }
            if (np < MAX_SVG_POINTS) { sc->pts[np].P_x = lx; sc->pts[np].P_y = ly; np++; }
            lastx = lx; lasty = ly;
            lastWasCubic = lastWasQuad = FALSE;
            break;
        }

        /* ----- horizontal lineto (supports repeated numbers) ----- */
        case 'H': case 'h': {
            sword lx;
            sP = SVG_SkipWS(sP);
            if (lastCmd == 'H') {
                sP = SVG_ScanCoordX(sP, &lx);
            } else {
                sword dx;
                sP = SVG_SkipWS(sP);
                sP = SVG_ScanLenX(sP, &dx);
                lx = (sword)(lastx + dx);
            }
            if (np < MAX_SVG_POINTS) { sc->pts[np].P_x = lx; sc->pts[np].P_y = lasty; np++; }
            lastx = lx;
            lastWasCubic = lastWasQuad = FALSE;
            break;
        }

        /* ----- vertical lineto (supports repeated numbers) ----- */
        case 'V': case 'v': {
            sword ly;
            sP = SVG_SkipWS(sP);
            if (lastCmd == 'V') {
                sP = SVG_ScanCoordY(sP, &ly);
            } else {
                sword dy;
                sP = SVG_SkipWS(sP);
                sP = SVG_ScanLenY(sP, &dy);
                ly = (sword)(lasty + dy);
            }
            if (np < MAX_SVG_POINTS) { sc->pts[np].P_x = lastx; sc->pts[np].P_y = ly; np++; }
            lasty = ly;
            lastWasCubic = lastWasQuad = FALSE;
            break;
        }

        /* ----- quadratic Bézier (repeating groups) ----- */
        case 'Q': case 'q': {
            sword cx, cy, ex, ey;
            for (;;) {
                sP = SVG_SkipWS(sP);
                if (!*sP || isalpha(*sP) || *sP=='Z' || *sP=='z') break;

                if (lastCmd == 'Q') {
                    sP = SVG_ScanCoordX(sP, &cx);
                    if (*sP == ',') sP++;
                    sP = SVG_SkipWS(sP);
                    sP = SVG_ScanCoordY(sP, &cy);
                    if (*sP == ',') sP++;
                    sP = SVG_SkipWS(sP);
                    sP = SVG_ScanCoordX(sP, &ex);
                    if (*sP == ',') sP++;
                    sP = SVG_SkipWS(sP);
                    sP = SVG_ScanCoordY(sP, &ey);
                } else {
                    sword dcx, dcy, dex, dey;
                    sP = SVG_ScanLenX(sP, &dcx);
                    if (*sP == ',') sP++;
                    sP = SVG_SkipWS(sP);
                    sP = SVG_ScanLenY(sP, &dcy);
                    if (*sP == ',') sP++;
                    sP = SVG_SkipWS(sP);
                    sP = SVG_ScanLenX(sP, &dex);
                    if (*sP == ',') sP++;
                    sP = SVG_SkipWS(sP);
                    sP = SVG_ScanLenY(sP, &dey);
                    cx = (sword)(lastx + dcx); cy = (sword)(lasty + dcy);
                    ex = (sword)(lastx + dex); ey = (sword)(lasty + dey);
                }

                SVG_FlattenQuad(sc, &np, lastx, lasty, cx, cy, ex, ey, 8);

                lastx = ex; lasty = ey;
                lastWasQuad = TRUE; lastQcx = cx; lastQcy = cy;
                lastWasCubic = FALSE;
            }
            break;
        }

        /* ----- smooth quadratic (T/t): reflect last Q control or use current point ----- */
        case 'T': case 't': {
            sword ex, ey, cx, cy;
            for (;;) {
                sP = SVG_SkipWS(sP);
                if (!*sP || isalpha(*sP) || *sP=='Z' || *sP=='z') break;

                if (lastCmd == 'T') {
                    sP = SVG_ScanCoordX(sP, &ex);
                    if (*sP == ',') sP++;
                    sP = SVG_SkipWS(sP);
                    sP = SVG_ScanCoordY(sP, &ey);
                } else {
                    sword dex, dey;
                    sP = SVG_ScanLenX(sP, &dex);
                    if (*sP == ',') sP++;
                    sP = SVG_SkipWS(sP);
                    sP = SVG_ScanLenY(sP, &dey);
                    ex = (sword)(lastx + dex); ey = (sword)(lasty + dey);
                }

                if (lastWasQuad) {
                    cx = (sword)(lastx + (lastx - lastQcx));
                    cy = (sword)(lasty + (lasty - lastQcy));
                } else {
                    cx = lastx; cy = lasty;
                }

                SVG_FlattenQuad(sc, &np, lastx, lasty, cx, cy, ex, ey, 8);

                lastx = ex; lasty = ey;
                lastWasQuad = TRUE; lastQcx = cx; lastQcy = cy;
                lastWasCubic = FALSE;
            }
            break;
        }

        /* ----- cubic Bézier (repeating groups) ----- */
        case 'C': case 'c': {
            sword c1x, c1y, c2x, c2y, ex, ey;
            for (;;) {
                sP = SVG_SkipWS(sP);
                if (!*sP || isalpha(*sP) || *sP=='Z' || *sP=='z') break;

                if (lastCmd == 'C') {
                    sP = SVG_ScanCoordX(sP, &c1x);
                    if (*sP == ',') sP++;
                    sP = SVG_SkipWS(sP);
                    sP = SVG_ScanCoordY(sP, &c1y);
                    if (*sP == ',') sP++;
                    sP = SVG_SkipWS(sP);
                    sP = SVG_ScanCoordX(sP, &c2x);
                    if (*sP == ',') sP++;
                    sP = SVG_SkipWS(sP);
                    sP = SVG_ScanCoordY(sP, &c2y);
                    if (*sP == ',') sP++;
                    sP = SVG_SkipWS(sP);
                    sP = SVG_ScanCoordX(sP, &ex);
                    if (*sP == ',') sP++;
                    sP = SVG_SkipWS(sP);
                    sP = SVG_ScanCoordY(sP, &ey);
                } else {
                    sword dc1x, dc1y, dc2x, dc2y, dex, dey;
                    sP = SVG_ScanLenX(sP, &dc1x);
                    if (*sP == ',') sP++;
                    sP = SVG_SkipWS(sP);
                    sP = SVG_ScanLenY(sP, &dc1y);
                    if (*sP == ',') sP++;
                    sP = SVG_SkipWS(sP);
                    sP = SVG_ScanLenX(sP, &dc2x);
                    if (*sP == ',') sP++;
                    sP = SVG_SkipWS(sP);
                    sP = SVG_ScanLenY(sP, &dc2y);
                    if (*sP == ',') sP++;
                    sP = SVG_SkipWS(sP);
                    sP = SVG_ScanLenX(sP, &dex);
                    if (*sP == ',') sP++;
                    sP = SVG_SkipWS(sP);
                    sP = SVG_ScanLenY(sP, &dey);
                    c1x = (sword)(lastx + dc1x); c1y = (sword)(lasty + dc1y);
                    c2x = (sword)(lastx + dc2x); c2y = (sword)(lasty + dc2y);
                    ex  = (sword)(lastx + dex);  ey  = (sword)(lasty + dey);
                }

                SVG_FlattenCubic(sc, &np, lastx, lasty, c1x, c1y, c2x, c2y, ex, ey, 10);

                lastx = ex; lasty = ey;
                lastC2x = c2x; lastC2y = c2y;
                lastWasCubic = TRUE;
                lastWasQuad  = FALSE;
            }
            break;
        }

        case 'A': case 'a': {
            WWFixedAsDWord rxW, ryW, rotW, tmpW;
            WWFixedAsDWord exW, eyW, dxW, dyW;
            WWFixedAsDWord x0W, y0W, rxMap, ryMap, exMap, eyMap;
            int laf, swf;
            Boolean done = FALSE;

            while (!done) {
                sP = SVG_SkipWS(sP);
                if (!*sP || isalpha(*sP) || *sP=='Z' || *sP=='z') { done = TRUE; continue; }

                /* rx, ry, rotation (all 16.16) */
                sP = ParseWWFixed16_16(sP, &rxW);
                if (*sP == ',') sP++; sP = SVG_SkipWS(sP);
                sP = ParseWWFixed16_16(sP, &ryW);
                sP = SVG_SkipWS(sP);
                sP = ParseWWFixed16_16(sP, &rotW);
                if (*sP == ',') sP++; sP = SVG_SkipWS(sP);

                /* flags */
                sP = ParseWWFixed16_16(sP, &tmpW); laf = (WWFixedToSWordRound(tmpW) != 0);
                if (*sP == ',') sP++; sP = SVG_SkipWS(sP);
                sP = ParseWWFixed16_16(sP, &tmpW); swf = (WWFixedToSWordRound(tmpW) != 0);
                if (*sP == ',') sP++; sP = SVG_SkipWS(sP);

                /* endpoint (abs/rel) */
                if (lastCmd == 'A') {
                    sP = ParseWWFixed16_16(sP, &exW);
                    if (*sP == ',') sP++; sP = SVG_SkipWS(sP);
                    sP = ParseWWFixed16_16(sP, &eyW);
                } else {
                    sP = ParseWWFixed16_16(sP, &dxW);
                    if (*sP == ',') sP++; sP = SVG_SkipWS(sP);
                    sP = ParseWWFixed16_16(sP, &dyW);
                    exW = MakeWWFixed(lastx) + dxW;
                    eyW = MakeWWFixed(lasty) + dyW;
                }

                /* map to the same device coords as other path commands */
                x0W   = ((WWFixedAsDWord)lastx) << 16;
                y0W   = ((WWFixedAsDWord)lasty) << 16;
                rxMap = ((WWFixedAsDWord)VB_MapLenX_F(rxW)) << 16;
                ryMap = ((WWFixedAsDWord)VB_MapLenY_F(ryW)) << 16;
                exMap = ((WWFixedAsDWord)VB_MapPosX_F(exW)) << 16;
                eyMap = ((WWFixedAsDWord)VB_MapPosY_F(eyW)) << 16;

                /* append arc points; do not draw/scale now */
                SVG_FlattenArc(sc, &np,
                            x0W, y0W, rxMap, ryMap,
                            rotW, laf, swf,      /* swf as-is */
                            exMap, eyMap);

                /* update current point (mapped) */
                lastx = WWFixedToSWordRound(exMap);
                lasty = WWFixedToSWordRound(eyMap);
            }
            break;
        }



        /* ----- smooth cubic (S/s): reflect lastC2 across current point ----- */
        case 'S': case 's': {
            sword c1x, c1y, c2x, c2y, ex, ey;
            for (;;) {
                sP = SVG_SkipWS(sP);
                if (!*sP || isalpha(*sP) || *sP=='Z' || *sP=='z') break;

                if (lastWasCubic) {
                    c1x = (sword)(lastx + (lastx - lastC2x));
                    c1y = (sword)(lasty + (lasty - lastC2y));
                } else {
                    c1x = lastx; c1y = lasty;
                }

                if (lastCmd == 'S') {
                    sP = SVG_ScanCoordX(sP, &c2x);
                    if (*sP == ',') sP++;
                    sP = SVG_SkipWS(sP);
                    sP = SVG_ScanCoordY(sP, &c2y);
                    if (*sP == ',') sP++;
                    sP = SVG_SkipWS(sP);
                    sP = SVG_ScanCoordX(sP, &ex);
                    if (*sP == ',') sP++;
                    sP = SVG_SkipWS(sP);
                    sP = SVG_ScanCoordY(sP, &ey);
                } else {
                    sword dc2x, dc2y, dex, dey;
                    sP = SVG_ScanLenX(sP, &dc2x);
                    if (*sP == ',') sP++;
                    sP = SVG_SkipWS(sP);
                    sP = SVG_ScanLenY(sP, &dc2y);
                    if (*sP == ',') sP++;
                    sP = SVG_SkipWS(sP);
                    sP = SVG_ScanLenX(sP, &dex);
                    if (*sP == ',') sP++;
                    sP = SVG_SkipWS(sP);
                    sP = SVG_ScanLenY(sP, &dey);
                    c2x = (sword)(lastx + dc2x); c2y = (sword)(lasty + dc2y);
                    ex  = (sword)(lastx + dex);  ey  = (sword)(lasty + dey);
                }

                SVG_FlattenCubic(sc, &np, lastx, lasty, c1x, c1y, c2x, c2y, ex, ey, 10);

                lastx = ex; lasty = ey;
                lastC2x = c2x; lastC2y = c2y;
                lastWasCubic = TRUE;
                lastWasQuad  = FALSE;
            }
            break;
        }

        /* ----- closepath ----- */
        case 'Z': case 'z':
            closed = TRUE;
            sP++;
            lastx = subStartX; lasty = subStartY;
            lastWasCubic = lastWasQuad = FALSE;
            break;

        default:
            /* (path command not implemented yet; skip char) */
            sP++;
            lastWasCubic = lastWasQuad = FALSE;
            break;
        }
    }

    if (np > 1)
    {
        SVG_GetScale(tag, &sx2, &sy2);
        for (i = 0; i < np; i++) {
            sword px = sc->pts[i].P_x;
            sword py = sc->pts[i].P_y;
            SVG_ApplyScalePoint(&px, &py, sx2, sy2);
            sc->pts[i].P_x = px;
            sc->pts[i].P_y = py;
        }
        if (closed) Meta_Polygon(sc->pts, np, SVG_HasFill(tag), SVG_HasStroke(tag));
        else        Meta_Polyline(sc->pts, np);
    }
}


static void HandleLineTag(const char *tag)
{
    static char     xb[32], yb[32], x2b[32], y2b[32];
    WWFixedAsDWord  sx;
    WWFixedAsDWord  sy;
    sword           x1;
    sword           y1;
    sword           x2;
    sword           y2;

    if (GetAttrBounded(tag, "x1", xb, sizeof(xb)) &&
        GetAttrBounded(tag, "y1", yb, sizeof(yb)) &&
        GetAttrBounded(tag, "x2", x2b, sizeof(x2b)) &&
        GetAttrBounded(tag, "y2", y2b, sizeof(y2b)))
    {
        ApplyStrokeAndFill(tag);
        ApplyStrokeWidth(tag);

        x1 = SVG_ParseCoordXStr(xb);
        y1 = SVG_ParseCoordYStr(yb);
        x2 = SVG_ParseCoordXStr(x2b);
        y2 = SVG_ParseCoordYStr(y2b);

        SVG_GetScale(tag, &sx, &sy);
        SVG_ApplyScalePoint(&x1, &y1, sx, sy);
        SVG_ApplyScalePoint(&x2, &y2, sx, sy);

        Meta_Line(x1, y1, x2, y2);
    }
}

static void HandlePolylineTag(const char *tag, SVGScratch *sc)
{
    word            np;
    WWFixedAsDWord  sx;
    WWFixedAsDWord  sy;
    word            i;

    sc->pb[0] = 0;
    if (GetAttrBounded(tag, "points", sc->pb, sizeof(sc->pb)))
    {
        ApplyStrokeAndFill(tag);
        ApplyStrokeWidth(tag);

        SVG_ParsePoints(sc->pb, sc->pts, &np);
        if (np > 0)
        {
            SVG_GetScale(tag, &sx, &sy);
            for (i = 0; i < np; i++)
            {
                sword px;
                sword py;

                px = sc->pts[i].P_x;
                py = sc->pts[i].P_y;
                SVG_ApplyScalePoint(&px, &py, sx, sy);
                sc->pts[i].P_x = px;
                sc->pts[i].P_y = py;
            }
            Meta_Polyline(sc->pts, np);
        }
    }
}

static void HandlePolygonTag(const char *tag, SVGScratch *sc)
{
    word            np;
    WWFixedAsDWord  sx;
    WWFixedAsDWord  sy;
    word            i;

    sc->pb[0] = 0;
    if (GetAttrBounded(tag, "points", sc->pb, sizeof(sc->pb)))
    {
        ApplyStrokeAndFill(tag);
        ParseFillRule(tag);
        ApplyStrokeWidth(tag);

        SVG_ParsePoints(sc->pb, sc->pts, &np);
        if (np > 0)
        {
            SVG_GetScale(tag, &sx, &sy);
            for (i = 0; i < np; i++)
            {
                sword px;
                sword py;

                px = sc->pts[i].P_x;
                py = sc->pts[i].P_y;
                SVG_ApplyScalePoint(&px, &py, sx, sy);
                sc->pts[i].P_x = px;
                sc->pts[i].P_y = py;
            }
            Meta_Polygon(sc->pts, np, SVG_HasFill(tag), SVG_HasStroke(tag));
        }
    }
}

static void HandleRectTag(const char *tag)
{
    static char     xb[32], yb[32], wb[32], hb[32];
    sword           x;
    sword           y;
    sword           x2;
    sword           y2;
    WWFixedAsDWord  sx;
    WWFixedAsDWord  sy;

    if (GetAttrBounded(tag, "x", xb, sizeof(xb)) &&
        GetAttrBounded(tag, "y", yb, sizeof(yb)) &&
        GetAttrBounded(tag, "width", wb, sizeof(wb)) &&
        GetAttrBounded(tag, "height", hb, sizeof(hb)))
    {
        ApplyStrokeAndFill(tag);
        ApplyStrokeWidth(tag);

        x  = SVG_ParseCoordXStr(xb);
        y  = SVG_ParseCoordYStr(yb);
        x2 = (sword)(x + SVG_ParseLenXStr(wb));
        y2 = (sword)(y + SVG_ParseLenYStr(hb));

        SVG_GetScale(tag, &sx, &sy);
        SVG_ApplyScalePoint(&x,  &y,  sx, sy);
        SVG_ApplyScalePoint(&x2, &y2, sx, sy);

        if (y > y2) { sword t = y; y = y2; y2 = t; }
        if (x > x2) { sword t = x; x = x2; x2 = t; }

        Meta_Rect(x, y, x2, y2, SVG_HasFill(tag), SVG_HasStroke(tag));
    }
}

static void HandleEllipseTag(const char *tag)
{
    static char     cxb[32], cyb[32], rxb[32], ryb[32];
    sword           cx;
    sword           cy;
    sword           rx;
    sword           ry;
    WWFixedAsDWord  sx;
    WWFixedAsDWord  sy;

    if (GetAttrBounded(tag, "cx", cxb, sizeof(cxb)) &&
        GetAttrBounded(tag, "cy", cyb, sizeof(cyb)) &&
        GetAttrBounded(tag, "rx", rxb, sizeof(rxb)) &&
        GetAttrBounded(tag, "ry", ryb, sizeof(ryb)))
    {
        ApplyStrokeAndFill(tag);
        ApplyStrokeWidth(tag);

        cx = SVG_ParseCoordXStr(cxb);
        cy = SVG_ParseCoordYStr(cyb);
        rx = SVG_ParseLenXStr(rxb);
        ry = SVG_ParseLenYStr(ryb);

        SVG_GetScale(tag, &sx, &sy);

        SVG_ApplyScalePoint(&cx, &cy, sx, sy);
        rx = SVG_ScaleLength(rx, sx);
        ry = SVG_ScaleLength(ry, sy);

        Meta_Ellipse(cx, cy, rx, ry, 0, SVG_HasFill(tag), SVG_HasStroke(tag));
    }
}

static void HandleCircleTag(const char *tag)
{
    static char     cxb[32], cyb[32], rb[32];
    sword           cx;
    sword           cy;
    sword           r;
    sword           rx;
    sword           ry;
    WWFixedAsDWord  sx;
    WWFixedAsDWord  sy;

    if (GetAttrBounded(tag, "cx", cxb, sizeof(cxb)) &&
        GetAttrBounded(tag, "cy", cyb, sizeof(cyb)) &&
        GetAttrBounded(tag, "r",  rb,  sizeof(rb)))
    {
        ApplyStrokeAndFill(tag);
        ApplyStrokeWidth(tag);

        cx = SVG_ParseCoordXStr(cxb);
        cy = SVG_ParseCoordYStr(cyb);
        r  = SVG_ParseLenXStr(rb);

        SVG_GetScale(tag, &sx, &sy);

        SVG_ApplyScalePoint(&cx, &cy, sx, sy);
        rx = SVG_ScaleLength(r, sx);
        ry = SVG_ScaleLength(r, sy);

        Meta_Ellipse(cx, cy, rx, ry, 0, SVG_HasFill(tag), SVG_HasStroke(tag));
    }
}



/* ---------- streaming scanner ---------- */
static void ScanCtxInit(ScanCtx *c)
{
    c->ioH = 0;
    c->ioP = NULL;
    c->bytes = 0;
    c->pos = 0;
    c->inTag = FALSE;
    c->inQuote = FALSE;
    c->quoteCh = 0;
    c->tagLen = 0;
}

/* Pull next complete tag into sc->tag; returns FALSE on EOF/error with no tag */
static Boolean ScanNextTag(FileHandle fh, ScanCtx *c, SVGScratch *sc)
{
    for (;;)
    {
        if (c->pos >= c->bytes)
        {
            word r;

            if (!c->ioP) return FALSE;
            r = FileRead(fh, (void*)c->ioP, SVG_IO_BUF_SIZE, FALSE);
            if (r == (word)-1 || r == 0) return FALSE;
            c->bytes = r;
            c->pos   = 0;
        }

        {
            char ch;
            ch = c->ioP[c->pos++];

            if (!c->inTag)
            {
                if (ch == '<')
                {
                    c->inTag = TRUE;
                    c->inQuote = FALSE;
                    c->quoteCh = 0;
                    c->tagLen = 0;
                }
                continue;
            }

            if (c->inQuote)
            {
                if (ch == c->quoteCh) c->inQuote = FALSE;
                if (c->tagLen < (TAG_BUF_SIZE-1)) sc->tag[c->tagLen++] = ch;
                continue;
            }
            else
            {
                if (ch == '"' || ch == '\'')
                {
                    c->inQuote = TRUE;
                    c->quoteCh = ch;
                    if (c->tagLen < (TAG_BUF_SIZE-1)) sc->tag[c->tagLen++] = ch;
                    continue;
                }
                if (ch != '>')
                {
                    if (c->tagLen < (TAG_BUF_SIZE-1)) sc->tag[c->tagLen++] = ch;
                    continue;
                }

                sc->tag[c->tagLen] = 0;
                c->inTag = FALSE;
                return TRUE;
            }
        }
    }
}

/*---------------------------------------------------------------
 * ReadSVG -- streamed, SAX-like; callback(last param) is percent
 *---------------------------------------------------------------*/
TransError _export _pascal ReadSVG(FileHandle srcFile, word settings,
                                   ProgressCallback *callback)
{
    ScanCtx       scan;
    SVGScratch   *scP;
    MemHandle     scH;
    dword         total;
    dword         done;
    word          lastPct;
    MemHandle     ioH;
    char         *ioP;
    Boolean       sawSvg;

    (void)settings;

    scH     = 0;
    scP     = NULL;
    ioH     = 0;
    ioP     = NULL;
    lastPct = 0;
    done    = 0;
    sawSvg  = FALSE;

    /* defer Meta_SetScaling until we see <svg>, else default later */

    total = FilePos(srcFile, 0, FILE_POS_END);
    FilePos(srcFile, 0, FILE_POS_START);

    scH = MemAlloc((word)sizeof(SVGScratch), HF_DYNAMIC, HAF_ZERO_INIT);
    if (!scH)
    {
        return TE_OUT_OF_MEMORY;
    }
    scP = (SVGScratch*) MemLock(scH);
    if (!scP)
    {
        MemFree(scH);
        return TE_OUT_OF_MEMORY;
    }

    ioH = MemAlloc(SVG_IO_BUF_SIZE, HF_DYNAMIC, HAF_ZERO_INIT);
    if (!ioH)
    {
        MemUnlock(scH);
        MemFree(scH);
        return TE_OUT_OF_MEMORY;
    }
    ioP = (char*) MemLock(ioH);
    if (!ioP)
    {
        MemFree(ioH);
        MemUnlock(scH);
        MemFree(scH);
        return TE_OUT_OF_MEMORY;
    }

    ScanCtxInit(&scan);
    scan.ioH = ioH;
    scan.ioP = ioP;
    g_vbInited = FALSE;

    for (;;)
    {
        if (!ScanNextTag(srcFile, &scan, scP))
        {
            break;
        }

        if (callback && total >= 2048)
        {
            done = (dword)FilePos(srcFile, 0, FILE_POS_RELATIVE);
            if (done > total) done = total;

            {
                word pct;
                pct = (word)((done * 100UL) / total);
                if (pct != lastPct)
                {
                    lastPct = pct;
                    /* if ((*callback)(pct)) break; */
                }
            }
        }

        if (scP->tag[0] == '/' || scP->tag[0] == '!' || scP->tag[0] == '?')
        {
            continue;
        }

        if (TagIs(scP->tag, "svg"))
        {
            SVG_InitWorldFromSvgTag(scP->tag);
            sawSvg = TRUE;
            continue;
        }

        if (!g_vbInited)
        {
            /* in case this is a fragment without an <svg> root */
            SVG_InitWorldDefault();
        }

        if (TagIs(scP->tag, "line"))
        {
            HandleLineTag(scP->tag);
        }
        else if (TagIs(scP->tag, "polyline"))
        {
            HandlePolylineTag(scP->tag, scP);
        }
        else if (TagIs(scP->tag, "polygon"))
        {
            HandlePolygonTag(scP->tag, scP);
        }
        else if (TagIs(scP->tag, "rect"))
        {
            HandleRectTag(scP->tag);
        }
        else if (TagIs(scP->tag, "ellipse"))
        {
            HandleEllipseTag(scP->tag);
        }
        else if (TagIs(scP->tag, "circle"))
        {
            HandleCircleTag(scP->tag);
        }
        else if (TagIs(scP->tag, "path"))
        {
            HandlePathTag(scP->tag, scP);
        }
        else
        {
            /* unhandled: <g>, <title>, etc. */
        }
    }

    if (!sawSvg && !g_vbInited)
    {
        SVG_InitWorldDefault();
    }

    if (ioP) MemUnlock(ioH);
    if (ioH) MemFree(ioH);
    if (scP) MemUnlock(scH);
    if (scH) MemFree(scH);

    return TE_NO_ERROR;
}
