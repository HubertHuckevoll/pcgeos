/***********************************************************************
 *
 * PROJECT:      Meta
 * FILE:         svg.goc
 * DESCRIPTION:  Basic SVG parser for Meta library (streamed, GEOS/Watcom)
 *
 ***********************************************************************/

@include <stdapp.goh>

#include <Ansi/string.h>
#include <Ansi/stdlib.h>
#include <Ansi/ctype.h>
#include <file.h>
#include <system.h>
#include <graphics.h>
#include <gstring.h>
#include <meta.h>


#define SVG_COLOR_NAME_LEN   32

typedef struct
{
    byte SNC_r;
    byte SNC_g;
    byte SNC_b;
    char SNC_name[SVG_COLOR_NAME_LEN + 1];   /* NUL-terminated */
} SvgNamedColor;

#define MAX_SVG_POINTS    512
#define SVG_IO_BUF_SIZE   1024
#define TAG_BUF_SIZE      256

/* ===== Fixed-point helpers (16.16) ===== */
#define WWFIXED_ONE      ((WWFixedAsDWord)(1UL << 16))

/* scanner context */
typedef struct {
    MemHandle  ioH;
    char      *ioP;
    word       bytes;
    word       pos;
    Boolean    inTag;
    Boolean    inQuote;
    char       quoteCh;
    word       tagLen;
} ScanCtx;


@start MetaSvgNamedColorRes, data;

/* 147 SVG/CSS color keywords */
@chunkArray SvgNamedColor SvgNamedColors = {
    {240,248,255,"aliceblue"},
    {250,235,215,"antiquewhite"},
    {  0,255,255,"aqua"},
    {127,255,212,"aquamarine"},
    {240,255,255,"azure"},
    {245,245,220,"beige"},
    {255,228,196,"bisque"},
    {  0,  0,  0,"black"},
    {255,235,205,"blanchedalmond"},
    {  0,  0,255,"blue"},
    {138, 43,226,"blueviolet"},
    {165, 42, 42,"brown"},
    {222,184,135,"burlywood"},
    { 95,158,160,"cadetblue"},
    {127,255,  0,"chartreuse"},
    {210,105, 30,"chocolate"},
    {255,127, 80,"coral"},
    {100,149,237,"cornflowerblue"},
    {255,248,220,"cornsilk"},
    {220, 20, 60,"crimson"},
    {  0,255,255,"cyan"},
    {  0,  0,139,"darkblue"},
    {  0,139,139,"darkcyan"},
    {184,134, 11,"darkgoldenrod"},
    {169,169,169,"darkgray"},
    {  0,100,  0,"darkgreen"},
    {169,169,169,"darkgrey"},
    {189,183,107,"darkkhaki"},
    {139,  0,139,"darkmagenta"},
    { 85,107, 47,"darkolivegreen"},
    {255,140,  0,"darkorange"},
    {153, 50,204,"darkorchid"},
    {139,  0,  0,"darkred"},
    {233,150,122,"darksalmon"},
    {143,188,143,"darkseagreen"},
    { 72, 61,139,"darkslateblue"},
    { 47, 79, 79,"darkslategray"},
    { 47, 79, 79,"darkslategrey"},
    {  0,206,209,"darkturquoise"},
    {148,  0,211,"darkviolet"},
    {255, 20,147,"deeppink"},
    {  0,191,255,"deepskyblue"},
    {105,105,105,"dimgray"},
    {105,105,105,"dimgrey"},
    { 30,144,255,"dodgerblue"},
    {178, 34, 34,"firebrick"},
    {255,250,240,"floralwhite"},
    { 34,139, 34,"forestgreen"},
    {255,  0,255,"fuchsia"},
    {220,220,220,"gainsboro"},
    {248,248,255,"ghostwhite"},
    {255,215,  0,"gold"},
    {218,165, 32,"goldenrod"},
    {128,128,128,"gray"},
    {128,128,128,"grey"},
    {  0,128,  0,"green"},
    {173,255, 47,"greenyellow"},
    {240,255,240,"honeydew"},
    {255,105,180,"hotpink"},
    {205, 92, 92,"indianred"},
    { 75,  0,130,"indigo"},
    {255,255,240,"ivory"},
    {240,230,140,"khaki"},
    {230,230,250,"lavender"},
    {255,240,245,"lavenderblush"},
    {124,252,  0,"lawngreen"},
    {255,250,205,"lemonchiffon"},
    {173,216,230,"lightblue"},
    {240,128,128,"lightcoral"},
    {224,255,255,"lightcyan"},
    {250,250,210,"lightgoldenrodyellow"},
    {211,211,211,"lightgray"},
    {144,238,144,"lightgreen"},
    {211,211,211,"lightgrey"},
    {255,182,193,"lightpink"},
    {255,160,122,"lightsalmon"},
    { 32,178,170,"lightseagreen"},
    {135,206,250,"lightskyblue"},
    {119,136,153,"lightslategray"},
    {119,136,153,"lightslategrey"},
    {176,196,222,"lightsteelblue"},
    {255,255,224,"lightyellow"},
    {  0,255,  0,"lime"},
    { 50,205, 50,"limegreen"},
    {250,240,230,"linen"},
    {255,  0,255,"magenta"},
    {128,  0,  0,"maroon"},
    {102,205,170,"mediumaquamarine"},
    {  0,  0,205,"mediumblue"},
    {186, 85,211,"mediumorchid"},
    {147,112,219,"mediumpurple"},
    { 60,179,113,"mediumseagreen"},
    {123,104,238,"mediumslateblue"},
    {  0,250,154,"mediumspringgreen"},
    { 72,209,204,"mediumturquoise"},
    {199, 21,133,"mediumvioletred"},
    { 25, 25,112,"midnightblue"},
    {245,255,250,"mintcream"},
    {255,228,225,"mistyrose"},
    {255,228,181,"moccasin"},
    {255,222,173,"navajowhite"},
    {  0,  0,128,"navy"},
    {253,245,230,"oldlace"},
    {128,128,  0,"olive"},
    {107,142, 35,"olivedrab"},
    {255,165,  0,"orange"},
    {255, 69,  0,"orangered"},
    {218,112,214,"orchid"},
    {238,232,170,"palegoldenrod"},
    {152,251,152,"palegreen"},
    {175,238,238,"paleturquoise"},
    {219,112,147,"palevioletred"},
    {255,239,213,"papayawhip"},
    {255,218,185,"peachpuff"},
    {205,133, 63,"peru"},
    {255,192,203,"pink"},
    {221,160,221,"plum"},
    {176,224,230,"powderblue"},
    {128,  0,128,"purple"},
    {255,  0,  0,"red"},
    {188,143,143,"rosybrown"},
    { 65,105,225,"royalblue"},
    {139, 69, 19,"saddlebrown"},
    {250,128,114,"salmon"},
    {244,164, 96,"sandybrown"},
    { 46,139, 87,"seagreen"},
    {255,245,238,"seashell"},
    {160, 82, 45,"sienna"},
    {192,192,192,"silver"},
    {135,206,235,"skyblue"},
    {106, 90,205,"slateblue"},
    {112,128,144,"slategray"},
    {112,128,144,"slategrey"},
    {255,250,250,"snow"},
    {  0,255,127,"springgreen"},
    { 70,130,180,"steelblue"},
    {210,180,140,"tan"},
    {  0,128,128,"teal"},
    {216,191,216,"thistle"},
    {255, 99, 71,"tomato"},
    { 64,224,208,"turquoise"},
    {238,130,238,"violet"},
    {245,222,179,"wheat"},
    {255,255,255,"white"},
    {245,245,245,"whitesmoke"},
    {255,255,  0,"yellow"},
    {154,205, 50,"yellowgreen"}
};

@end MetaSvgNamedColorRes;



/* ---------- forward prototypes (avoid implicit int / symbol surprises) ---------- */
static WWFixedAsDWord MakeWWFixedFromInt(int v);
static const char *   ParseWWFixed16_16(const char *s, WWFixedAsDWord *out);
static word           HexNibble(char c);
static word           HexByte(const char *p);
static Boolean        TagIs(const char *tag, const char *name);
static Boolean        GetAttrBounded(const char *tag, const char *name, char *out, word outSize);
static void           ApplyStrokeAndFill(const char *tag);
static void           ApplyStrokeWidth(const char *tag);
static void           ParseFillRule(const char *tag);
static void           SVG_ParsePoints(const char *points, Point *pointsP, word *numPointsP);
static void           SVG_GetScale(const char *tag, WWFixedAsDWord *sxOut, WWFixedAsDWord *syOut);
static void           SVG_ApplyScalePoint(sword *x, sword *y, WWFixedAsDWord sx, WWFixedAsDWord sy);
static sword          SVG_ScaleLength(sword v, WWFixedAsDWord s);
static Boolean        SVG_HasStroke(const char *tag);
static Boolean        SVG_HasFill(const char *tag);
static void           HandleLineTag(const char *tag);
static void           HandlePolylineTag(const char *tag, struct _SVGScratch *sc);
static void           HandlePolygonTag(const char *tag, struct _SVGScratch *sc);
static void           HandleRectTag(const char *tag);
static void           HandleEllipseTag(const char *tag);
static void           HandleCircleTag(const char *tag);
static void           HandlePathTag(const char *tag, struct _SVGScratch *sc);
static Boolean        AsciiNoCaseEq(const char *a, const char *b);
static Boolean        SVG_FindNamedColor(const char *name, word *r, word *g, word *b);
static void           SVG_AddPt(struct _SVGScratch *sc, word *np, sword x, sword y);
static void           SVG_FlattenQuad(struct _SVGScratch *sc, word *np,
                            sword x0, sword y0, sword cx, sword cy, sword x1, sword y1,
                            word segs);
static void           SVG_FlattenCubic(struct _SVGScratch *sc, word *np,
                             sword x0, sword y0, sword c1x, sword c1y, sword c2x, sword c2y, sword x1, sword y1,
                             word segs);


/* tiny path helpers */
static const char *   SVG_SkipWS(const char *s);
static const char *   SVG_ScanInt(const char *s, sword *out);

/* rounding helpers for decimal→sword */
static sword          WWFixedToSWordRound(WWFixedAsDWord w);
static sword          SVG_ParseSCoordStr(const char *s);

static void           ScanCtxInit(ScanCtx *c);
static Boolean        ScanNextTag(FileHandle fh, ScanCtx *c, struct _SVGScratch *sc);

/* ---------- impl ---------- */

static WWFixedAsDWord MakeWWFixedFromInt(int v)
{
    WWFixedAsDWord f;

    f = ((WWFixedAsDWord)((sdword)v)) << 16;
    return f;
}

static WWFixedAsDWord GrMulWWFixedSafe(WWFixedAsDWord a, WWFixedAsDWord b)
{
    return GrMulWWFixed(a, b);
}

/* Parse "-12.34" → 16.16; returns pointer after number */
static const char * ParseWWFixed16_16(const char *s, WWFixedAsDWord *out)
{
    sdword           sign;
    dword            ip;
    dword            frac;
    dword            scale;
    word             c;
    WWFixedAsDWord   result;

    sign  = 1;
    ip    = 0;
    frac  = 0;
    scale = 1;

    while (*s && isspace(*s))
    {
        s++;
    }
    if (*s == '+')
    {
        s++;
    }
    else if (*s == '-')
    {
        sign = -1;
        s++;
    }

    while ((c = (word)(byte)*s) >= '0' && c <= '9')
    {
        ip = ip * 10 + (c - '0');
        s++;
    }

    if (*s == '.')
    {
        s++;
        while ((c = (word)(byte)*s) >= '0' && c <= '9')
        {
            if (scale < 1000000UL)
            {
                frac = frac * 10 + (c - '0');
                scale *= 10;
            }
            s++;
        }
    }

    result = MakeWWFixedFromInt((int)ip);
    if (scale != 0)
    {
        dword fpart;
        fpart = ((frac << 16) / scale);
        result += (WWFixedAsDWord)fpart;
    }
    if (sign < 0)
    {
        result = (WWFixedAsDWord)(0 - (sdword)result);
    }
    *out = result;
    return s;
}

/* round signed 16.16 to signed 16-bit */
static sword WWFixedToSWordRound(WWFixedAsDWord w)
{
    sdword v;
    v = (sdword)w;
    if (v >= 0) v += 0x8000; else v -= 0x8000;   /* ±0.5 */
    return (sword)(v >> 16);
}

static sword SVG_ParseSCoordStr(const char *s)
{
    WWFixedAsDWord f;
    (void)ParseWWFixed16_16(s, &f);
    return WWFixedToSWordRound(f);
}

/* ---------- tiny hex helpers (no stdio) ---------- */
static word HexNibble(char c)
{
    if (c >= '0' && c <= '9') return (word)(c - '0');
    if (c >= 'A' && c <= 'F') return (word)(10 + (c - 'A'));
    if (c >= 'a' && c <= 'f') return (word)(10 + (c - 'a'));
    return 0;
}
static word HexByte(const char *p)
{
    return (word)((HexNibble(p[0]) << 4) | HexNibble(p[1]));
}

/* ---------- scan helpers ---------- */
static Boolean TagIs(const char *tag, const char *name)
{
    const char *s;
    const char *n;

    s = tag;
    n = name;
    while (*s && !isspace(*s) && *s != '/' && *s != '>')
    {
        if (*n == 0 || *s != *n)
        {
            return FALSE;
        }
        s++;
        n++;
    }
    return (*n == 0);
}

/* Robust, bounded attribute reader — supports ' and " */
static Boolean GetAttrBounded(const char *tag, const char *name,
                              char *out, word outSize)
{
    const char *s;
    word        nlen;

    if (outSize == 0) return FALSE;
    out[0] = 0;

    /* skip element name */
    s = tag;
    while (*s && !isspace(*s) && *s != '>' && *s != '/')
    {
        s++;
    }

    nlen = (word)strlen(name);

    while (*s && *s != '>')
    {
        const char *an;
        word        alen;

        while (*s && (isspace(*s) || *s == '/'))
        {
            s++;
        }
        if (!*s || *s == '>')
        {
            break;
        }

        an = s;
        alen = 0;

        while (*s && *s != '=' && !isspace(*s) && *s != '>' && *s != '/')
        {
            s++;
            alen++;
        }

        if (alen == nlen && !memcmp(an, name, nlen))
        {
            while (*s && isspace(*s)) s++;
            if (*s != '=') return FALSE;
            s++;
            while (*s && isspace(*s)) s++;

            if (*s == '"' || *s == '\'')
            {
                char  q;
                word  i;

                q = *s++;
                i = 0;
                while (*s && *s != q && i < (outSize - 1))
                {
                    out[i++] = *s++;
                }
                out[i] = 0;
                if (*s == q) s++;
            }
            else
            {
                word i;
                i = 0;
                while (*s && !isspace(*s) && *s != '>' && i < (outSize - 1))
                {
                    out[i++] = *s++;
                }
                out[i] = 0;
            }
            return TRUE;
        }
        else
        {
            while (*s && isspace(*s)) s++;
            if (*s == '=')
            {
                s++;
                while (*s && isspace(*s)) s++;
                if (*s == '"' || *s == '\'')
                {
                    char q = *s++;
                    while (*s && *s != q) s++;
                    if (*s == q) s++;
                }
                else
                {
                    while (*s && !isspace(*s) && *s != '>') s++;
                }
            }
        }
    }
    return FALSE;
}

/* All sizeable buffers live here to keep stack tiny */
typedef struct _SVGScratch {
    char    tag[TAG_BUF_SIZE];

    char    pb[256];
    char    db[256];
    char    xb[32], yb[32], x2b[32], y2b[32];
    char    wb[32], hb[32];
    char    cxb[32], cyb[32], rxb[32], ryb[32];
    char    rb[32];
    char    col[64];
    char    tbuf[96];

    Point   pts[MAX_SVG_POINTS];
} SVGScratch;

/* ---------- color & style helpers ---------- */

static Boolean ExpandShortHex(const char *s, word *r, word *g, word *b)
{
    if (s[0] == '#' && strlen(s) == 4) {
        char hh[7];
        hh[0] = '#';
        hh[1] = s[1]; hh[2] = s[1];
        hh[3] = s[2]; hh[4] = s[2];
        hh[5] = s[3]; hh[6] = s[3];
        *r = HexByte(hh + 1);
        *g = HexByte(hh + 3);
        *b = HexByte(hh + 5);
        return TRUE;
    }
    return FALSE;
}

static Boolean ParseRGBFunc(const char *s, word *r, word *g, word *b)
{
    /* supports: rgb(255,0,0) and rgb(50%,0%,0%) */
    const char *p;
    int v1;
    int v2;
    int v3;
    int isPct;

    p = strstr(s, "rgb(");
    if (!p) {
        return FALSE;
    }
    p += 4;

    isPct = 0;
    v1 = atoi(p);
    while (*p && *p != ',' && *p != ')' && *p != '%') p++;
    if (*p == '%') { isPct = 1; p++; }
    if (*p == ',') p++;
    v2 = atoi(p);
    while (*p && *p != ',' && *p != ')' && *p != '%') p++;
    if (*p == '%') { isPct = 1; p++; }
    if (*p == ',') p++;
    v3 = atoi(p);
    while (*p && *p != ')' && *p != '%') p++;
    if (*p == '%') { isPct = 1; }

    if (isPct) {
        if (v1 < 0) v1 = 0; if (v1 > 100) v1 = 100;
        if (v2 < 0) v2 = 0; if (v2 > 100) v2 = 100;
        if (v3 < 0) v3 = 0; if (v3 > 100) v3 = 100;
        *r = (word)((v1 * 255) / 100);
        *g = (word)((v2 * 255) / 100);
        *b = (word)((v3 * 255) / 100);
    } else {
        if (v1 < 0) v1 = 0; if (v1 > 255) v1 = 255;
        if (v2 < 0) v2 = 0; if (v2 > 255) v2 = 255;
        if (v3 < 0) v3 = 0; if (v3 > 255) v3 = 255;
        *r = (word)v1; *g = (word)v2; *b = (word)v3;
    }
    return TRUE;
}

/* small ASCII case-insensitive compare */
static Boolean AsciiNoCaseEq(const char *a, const char *b)
{
    byte ca, cb;
    while (*a || *b) {
        ca = (byte)*a++; cb = (byte)*b++;
        if (ca >= 'A' && ca <= 'Z') ca = (byte)(ca + ('a' - 'A'));
        if (cb >= 'A' && cb <= 'Z') cb = (byte)(cb + ('a' - 'A'));
        if (ca != cb) return FALSE;
        if (ca == 0)  return TRUE;
    }
    return TRUE;
}

/* GEOS-idiomatic SVG color names lookup */
static Boolean SVG_FindNamedColor(const char *name, word *r, word *g, word *b)
{
    MemHandle       mh;
    SvgNamedColor  *rec;
    word            i, count, elemSize;

    mh = OptrToHandle(@SvgNamedColors);
    ObjLockObjBlock(mh);                             /* lock owning LMem block */

    count = ChunkArrayGetCount(@SvgNamedColors);     /* number of records */
    for (i = 0; i < count; i++) {
        rec = (SvgNamedColor*) ChunkArrayElementToPtr(@SvgNamedColors, i, &elemSize);

        if (rec && AsciiNoCaseEq(rec->SNC_name, name)) {
            *r = rec->SNC_r; *g = rec->SNC_g; *b = rec->SNC_b;
            MemUnlock(mh);
            return TRUE;
        }
    }

    MemUnlock(mh);
    return FALSE;
}

static void ApplyStrokeAndFill(const char *tag)
{
    static char sFill[64];
    static char sStroke[64];
    word r;
    word g;
    word b;

    sFill[0] = 0;
    sStroke[0] = 0;

    /* stroke */
    if (GetAttrBounded(tag, "stroke", sStroke, sizeof(sStroke))) {
        if (strcmp(sStroke, "none") != 0) {
            if (sStroke[0] == '#' && strlen(sStroke) >= 7) {
                Meta_SetLineColor(CF_RGB, HexByte(sStroke+1), HexByte(sStroke+3), HexByte(sStroke+5));
            }
            else if (ExpandShortHex(sStroke, &r,&g,&b) ||
                    ParseRGBFunc(sStroke, &r,&g,&b)   ||
                    SVG_FindNamedColor(sStroke, &r,&g,&b))
            {
                Meta_SetLineColor(CF_RGB, r, g, b);
            }
        }
    }

    /* fill */
    if (GetAttrBounded(tag, "fill", sFill, sizeof(sFill))) {
        if (strcmp(sFill, "none") != 0) {
            if (sFill[0] == '#' && strlen(sFill) >= 7) {
                Meta_SetAreaColor(CF_RGB, HexByte(sFill+1), HexByte(sFill+3), HexByte(sFill+5));
            } else if (ExpandShortHex(sFill, &r,&g,&b) ||
                    ParseRGBFunc(sFill, &r,&g,&b)   ||
                    SVG_FindNamedColor(sFill, &r,&g,&b))
            {
                Meta_SetAreaColor(CF_RGB, r, g, b);
            }
        }
    }
}

static void ParseFillRule(const char *tag)
{
    static char buf[16];

    buf[0] = 0;
    if (GetAttrBounded(tag, "fill-rule", buf, sizeof(buf)))
    {
        if (!strcmp(buf, "evenodd")) {
            Meta_SetFillRule(ODD_EVEN);
        } else {
            Meta_SetFillRule(WINDING); /* SVG default: nonzero */
        }
    }
}

static void ApplyStrokeWidth(const char *tag)
{
    static char b[20];
    if (GetAttrBounded(tag, "stroke-width", b, sizeof(b)))
    {
        WWFixedAsDWord lw;
        (void)ParseWWFixed16_16(b, &lw);          /* allow decimals */
        Meta_SetLineWidth(lw);
    }
}

/* ---------- points parser (renamed to avoid collisions) ---------- */
static void SVG_ParsePoints(const char *points, Point *pointsP, word *numPointsP)
{
    const char *s;
    sword       x;
    sword       y;

    s = points;
    *numPointsP = 0;

    while (*s && *numPointsP < MAX_SVG_POINTS)
    {
        s = SVG_SkipWS(s);
        if (!*s) break;

        s = SVG_ScanInt(s, &x);
        if (*s == ',') s++;
        s = SVG_SkipWS(s);
        s = SVG_ScanInt(s, &y);

        pointsP[*numPointsP].P_x = x;
        pointsP[*numPointsP].P_y = y;
        (*numPointsP)++;

        while (*s && (isspace(*s) || *s == ',')) s++;
    }
}

static void SVG_GetScale(const char *tag, WWFixedAsDWord *sxOut, WWFixedAsDWord *syOut)
{
    static char buf[96];
    char *p; const char *s; WWFixedAsDWord sx, sy;

    sx = WWFIXED_ONE; sy = WWFIXED_ONE;
    if (!GetAttrBounded(tag, "transform", buf, sizeof(buf))) { *sxOut=sx; *syOut=sy; return; }
    p = strstr(buf, "scale"); if (!p) { *sxOut=sx; *syOut=sy; return; }
    p = strchr(p, '('); if (!p) { *sxOut=sx; *syOut=sy; return; }
    s = p + 1;
    s = ParseWWFixed16_16(s, &sx);
    while (*s && isspace(*s)) s++;
    if (*s == ',') { s++; (void)ParseWWFixed16_16(s, &sy); } else { sy = sx; }
    if ((sdword)sx == 0) sx = (WWFixedAsDWord)1;   /* avoid vanishing */
    if ((sdword)sy == 0) sy = (WWFixedAsDWord)1;
    *sxOut = sx; *syOut = sy;
}

static void SVG_ApplyScalePoint(sword *x, sword *y, WWFixedAsDWord sx, WWFixedAsDWord sy)
{
    WWFixedAsDWord X = (WWFixedAsDWord)((sdword)(*x) << 16);
    WWFixedAsDWord Y = (WWFixedAsDWord)((sdword)(*y) << 16);
    X = GrMulWWFixed(X, sx);
    Y = GrMulWWFixed(Y, sy);
    *x = (sword)((sdword)X >> 16);
    *y = (sword)((sdword)Y >> 16);
}

static sword SVG_ScaleLength(sword v, WWFixedAsDWord s)
{
    WWFixedAsDWord V = (WWFixedAsDWord)((sdword)v << 16);
    WWFixedAsDWord R = GrMulWWFixed(V, s);
    sword out = (sword)((sdword)R >> 16);
    if (out < 0) out = (sword)(-out);
    return out;
}

static Boolean SVG_HasStroke(const char *tag)
{
    char b[32];
    /* SVG default: stroke is none unless present and not "none" */
    return GetAttrBounded(tag, "stroke", b, sizeof(b)) && strcmp(b, "none") != 0;
}
static Boolean SVG_HasFill(const char *tag)
{
    char b[32];
    /* SVG default: most shapes are filled if 'fill' is absent */
    if (GetAttrBounded(tag, "fill", b, sizeof(b))) {
        return strcmp(b, "none") != 0;
    }
    return TRUE; /* default fill applies to rect/circle/ellipse/polygon/path */
}

static void SVG_AddPt(SVGScratch *sc, word *np, sword x, sword y)
{
    if (*np < MAX_SVG_POINTS) {
        sc->pts[*np].P_x = x;
        sc->pts[*np].P_y = y;
        (*np)++;
    }
}

static void SVG_FlattenQuad(SVGScratch *sc, word *np,
                            sword x0, sword y0, sword cx, sword cy, sword x1, sword y1,
                            word segs)
{
    /* P(t)=(1-t)^2 P0 + 2(1-t)t C + t^2 P1, t in (0..1] */
    word i;
    for (i = 1; i <= segs; i++) {
        /* fixed t in 0..1 mapped to 0..65536 */
        WWFixedAsDWord t  = (WWFixedAsDWord)(((dword)i << 16) / segs);
        WWFixedAsDWord it = WWFIXED_ONE - t;

        WWFixedAsDWord X =
            GrMulWWFixed(GrMulWWFixed(it, it), ((sdword)x0 << 16)) +
            GrMulWWFixed(GrMulWWFixed(MakeWWFixed(2), GrMulWWFixed(it, t)), ((sdword)cx << 16)) +
            GrMulWWFixed(GrMulWWFixed(t, t), ((sdword)x1 << 16));

        WWFixedAsDWord Y =
            GrMulWWFixed(GrMulWWFixed(it, it), ((sdword)y0 << 16)) +
            GrMulWWFixed(GrMulWWFixed(MakeWWFixed(2), GrMulWWFixed(it, t)), ((sdword)cy << 16)) +
            GrMulWWFixed(GrMulWWFixed(t, t), ((sdword)y1 << 16));

        SVG_AddPt(sc, np, (sword)((sdword)X >> 16), (sword)((sdword)Y >> 16));
    }
}

static void SVG_FlattenCubic(SVGScratch *sc, word *np,
                             sword x0, sword y0, sword c1x, sword c1y, sword c2x, sword c2y, sword x1, sword y1,
                             word segs)
{
    /* P(t)=(1-t)^3 P0 + 3(1-t)^2 t C1 + 3(1-t) t^2 C2 + t^3 P1 */
    word i;
    for (i = 1; i <= segs; i++) {
        WWFixedAsDWord t   = (WWFixedAsDWord)(((dword)i << 16) / segs);
        WWFixedAsDWord it  = WWFIXED_ONE - t;
        WWFixedAsDWord it2 = GrMulWWFixed(it, it);
        WWFixedAsDWord t2  = GrMulWWFixed(t, t);

        /* coefficients */
        WWFixedAsDWord k0 = GrMulWWFixed(it2, it);                       /* (1-t)^3 */
        WWFixedAsDWord k1 = GrMulWWFixed(MakeWWFixed(3), GrMulWWFixed(it2, t)); /* 3(1-t)^2 t */
        WWFixedAsDWord k2 = GrMulWWFixed(MakeWWFixed(3), GrMulWWFixed(it, t2));  /* 3(1-t) t^2 */
        WWFixedAsDWord k3 = GrMulWWFixed(t2, t);                         /* t^3 */

        WWFixedAsDWord X =
            GrMulWWFixed(k0, ((sdword)x0 << 16)) +
            GrMulWWFixed(k1, ((sdword)c1x << 16)) +
            GrMulWWFixed(k2, ((sdword)c2x << 16)) +
            GrMulWWFixed(k3, ((sdword)x1  << 16));

        WWFixedAsDWord Y =
            GrMulWWFixed(k0, ((sdword)y0 << 16)) +
            GrMulWWFixed(k1, ((sdword)c1y << 16)) +
            GrMulWWFixed(k2, ((sdword)c2y << 16)) +
            GrMulWWFixed(k3, ((sdword)y1  << 16));

        SVG_AddPt(sc, np, (sword)((sdword)X >> 16), (sword)((sdword)Y >> 16));
    }
}

/* ---------- element handlers ---------- */



static void HandleLineTag(const char *tag)
{
    static char     xb[32], yb[32], x2b[32], y2b[32];
    WWFixedAsDWord  sx;
    WWFixedAsDWord  sy;
    sword           x1;
    sword           y1;
    sword           x2;
    sword           y2;

    if (GetAttrBounded(tag, "x1", xb, sizeof(xb)) &&
        GetAttrBounded(tag, "y1", yb, sizeof(yb)) &&
        GetAttrBounded(tag, "x2", x2b, sizeof(x2b)) &&
        GetAttrBounded(tag, "y2", y2b, sizeof(y2b)))
    {
        ApplyStrokeAndFill(tag);
        ApplyStrokeWidth(tag);

        x1 = SVG_ParseSCoordStr(xb);
        y1 = SVG_ParseSCoordStr(yb);
        x2 = SVG_ParseSCoordStr(x2b);
        y2 = SVG_ParseSCoordStr(y2b);

        SVG_GetScale(tag, &sx, &sy);
        SVG_ApplyScalePoint(&x1, &y1, sx, sy);
        SVG_ApplyScalePoint(&x2, &y2, sx, sy);

        Meta_Line(x1, y1, x2, y2);
    }
}

static void HandlePolylineTag(const char *tag, SVGScratch *sc)
{
    word            np;
    WWFixedAsDWord  sx;
    WWFixedAsDWord  sy;
    word            i;

    sc->pb[0] = 0;
    if (GetAttrBounded(tag, "points", sc->pb, sizeof(sc->pb)))
    {
        ApplyStrokeAndFill(tag);
        ApplyStrokeWidth(tag);

        SVG_ParsePoints(sc->pb, sc->pts, &np);
        if (np > 0)
        {
            SVG_GetScale(tag, &sx, &sy);
            for (i = 0; i < np; i++)
            {
                sword px;
                sword py;

                px = sc->pts[i].P_x;
                py = sc->pts[i].P_y;
                SVG_ApplyScalePoint(&px, &py, sx, sy);
                sc->pts[i].P_x = px;
                sc->pts[i].P_y = py;
            }
            Meta_Polyline(sc->pts, np);
        }
    }
}

static void HandlePolygonTag(const char *tag, SVGScratch *sc)
{
    word            np;
    WWFixedAsDWord  sx;
    WWFixedAsDWord  sy;
    word            i;

    sc->pb[0] = 0;
    if (GetAttrBounded(tag, "points", sc->pb, sizeof(sc->pb)))
    {
        ApplyStrokeAndFill(tag);
        ParseFillRule(tag);
        ApplyStrokeWidth(tag);

        SVG_ParsePoints(sc->pb, sc->pts, &np);
        if (np > 0)
        {
            SVG_GetScale(tag, &sx, &sy);
            for (i = 0; i < np; i++)
            {
                sword px;
                sword py;

                px = sc->pts[i].P_x;
                py = sc->pts[i].P_y;
                SVG_ApplyScalePoint(&px, &py, sx, sy);
                sc->pts[i].P_x = px;
                sc->pts[i].P_y = py;
            }
            Meta_Polygon(sc->pts, np, SVG_HasFill(tag), SVG_HasStroke(tag));
        }
    }
}

static void HandleRectTag(const char *tag)
{
    static char     xb[32], yb[32], wb[32], hb[32];
    sword           x;
    sword           y;
    sword           x2;
    sword           y2;
    WWFixedAsDWord  sx;
    WWFixedAsDWord  sy;

    if (GetAttrBounded(tag, "x", xb, sizeof(xb)) &&
        GetAttrBounded(tag, "y", yb, sizeof(yb)) &&
        GetAttrBounded(tag, "width", wb, sizeof(wb)) &&
        GetAttrBounded(tag, "height", hb, sizeof(hb)))
    {
        ApplyStrokeAndFill(tag);
        ApplyStrokeWidth(tag);

        x  = SVG_ParseSCoordStr(xb);
        y  = SVG_ParseSCoordStr(yb);
        x2 = (sword)(x + SVG_ParseSCoordStr(wb));
        y2 = (sword)(y + SVG_ParseSCoordStr(hb));

        SVG_GetScale(tag, &sx, &sy);
        SVG_ApplyScalePoint(&x,  &y,  sx, sy);
        SVG_ApplyScalePoint(&x2, &y2, sx, sy);

        if (y > y2) { sword t = y; y = y2; y2 = t; }
        if (x > x2) { sword t = x; x = x2; x2 = t; }

        Meta_Rect(x, y, x2, y2, SVG_HasFill(tag), SVG_HasStroke(tag));
    }
}

static void HandleEllipseTag(const char *tag)
{
    static char     cxb[32], cyb[32], rxb[32], ryb[32];
    sword           cx;
    sword           cy;
    sword           rx;
    sword           ry;
    WWFixedAsDWord  sx;
    WWFixedAsDWord  sy;

    if (GetAttrBounded(tag, "cx", cxb, sizeof(cxb)) &&
        GetAttrBounded(tag, "cy", cyb, sizeof(cyb)) &&
        GetAttrBounded(tag, "rx", rxb, sizeof(rxb)) &&
        GetAttrBounded(tag, "ry", ryb, sizeof(ryb)))
    {
        ApplyStrokeAndFill(tag);
        ApplyStrokeWidth(tag);

        cx = SVG_ParseSCoordStr(cxb);
        cy = SVG_ParseSCoordStr(cyb);
        rx = SVG_ParseSCoordStr(rxb);
        ry = SVG_ParseSCoordStr(ryb);

        SVG_GetScale(tag, &sx, &sy);

        SVG_ApplyScalePoint(&cx, &cy, sx, sy);
        rx = SVG_ScaleLength(rx, sx);
        ry = SVG_ScaleLength(ry, sy);

        Meta_Ellipse(cx, cy, rx, ry, 0, SVG_HasFill(tag), SVG_HasStroke(tag));
    }
}

static void HandleCircleTag(const char *tag)
{
    static char     cxb[32], cyb[32], rb[32];
    sword           cx;
    sword           cy;
    sword           r;
    sword           rx;
    sword           ry;
    WWFixedAsDWord  sx;
    WWFixedAsDWord  sy;

    if (GetAttrBounded(tag, "cx", cxb, sizeof(cxb)) &&
        GetAttrBounded(tag, "cy", cyb, sizeof(cyb)) &&
        GetAttrBounded(tag, "r",  rb,  sizeof(rb)))
    {
        ApplyStrokeAndFill(tag);
        ApplyStrokeWidth(tag);

        cx = SVG_ParseSCoordStr(cxb);
        cy = SVG_ParseSCoordStr(cyb);
        r  = SVG_ParseSCoordStr(rb);

        SVG_GetScale(tag, &sx, &sy);

        SVG_ApplyScalePoint(&cx, &cy, sx, sy);
        rx = SVG_ScaleLength(r, sx);
        ry = SVG_ScaleLength(r, sy);

        Meta_Ellipse(cx, cy, rx, ry, 0, SVG_HasFill(tag), SVG_HasStroke(tag));
    }
}


/* ---- tiny path helpers ---- */


static const char * SVG_SkipWS(const char *s)
{
    while (*s && isspace(*s)) {
        s++;
    }
    return s;
}

static const char * SVG_ScanInt(const char *s, sword *out)
{
    WWFixedAsDWord f;
    const char *p;

    p = ParseWWFixed16_16(s, &f);           /* accept decimals */
    *out = WWFixedToSWordRound(f);

    while (*p && *p != ' ' && *p != ',' && *p != '\t' &&
           *p != '\r' && *p != '\n' && *p != 'Z' && *p != 'z') {
        p++;
    }
    return p;
}

static void HandlePathTag(const char *tag, SVGScratch *sc)
{
    const char     *sP;
    word            np;
    Boolean         closed;
    sword           lastx;
    sword           lasty;
    char            lastCmd;
    Boolean         haveCmd;
    WWFixedAsDWord  sx;
    WWFixedAsDWord  sy;
    word            i;

    sc->db[0] = 0;
    if (!GetAttrBounded(tag, "d", sc->db, sizeof(sc->db))) return;

    ApplyStrokeAndFill(tag);
    ParseFillRule(tag);
    ApplyStrokeWidth(tag);

    np      = 0;
    closed  = FALSE;
    lastx   = 0;
    lasty   = 0;
    lastCmd = 0;
    haveCmd = FALSE;
    sP      = sc->db;

    while (*sP)
    {
        sword x;
        sword y;

        sP = SVG_SkipWS(sP);
        if (!*sP) {
            break;
        }

        if (isalpha(*sP)) {
            lastCmd = *sP++;
            haveCmd = TRUE;
        } else if (!haveCmd) {
            /* malformed path starting with numbers but no prior command */
            break;
        }

        switch (lastCmd) {
        case 'M': case 'm': {
            /* first pair is move-to; subsequent pairs imply line-to with same rel/abs mode */
            sP = SVG_SkipWS(sP);
            sP = SVG_ScanInt(sP, &x);
            if (*sP == ',') sP++;
            sP = SVG_SkipWS(sP);
            sP = SVG_ScanInt(sP, &y);

            if (lastCmd == 'm') { x += lastx; y += lasty; }
            lastx = x; lasty = y;
            if (np < MAX_SVG_POINTS) { sc->pts[np].P_x = x; sc->pts[np].P_y = y; np++; }

            /* After an M, any additional coordinate pairs should be treated as L with same rel/abs */
            lastCmd = (lastCmd == 'M') ? 'L' : 'l';
            haveCmd = TRUE;
            break;
        }
        case 'L': case 'l': {
            sword lx;
            sword ly;

            sP = SVG_SkipWS(sP);
            sP = SVG_ScanInt(sP, &lx);
            if (*sP == ',') sP++;
            sP = SVG_SkipWS(sP);
            sP = SVG_ScanInt(sP, &ly);

            if (lastCmd == 'l') { lx += lastx; ly += lasty; }
            if (np < MAX_SVG_POINTS) { sc->pts[np].P_x = lx; sc->pts[np].P_y = ly; np++; }
            lastx = lx; lasty = ly;
            break;
        }
        case 'H': case 'h': {
            sword lx;

            sP = SVG_SkipWS(sP);
            sP = SVG_ScanInt(sP, &lx);
            if (lastCmd == 'h') lx += lastx;
            if (np < MAX_SVG_POINTS) { sc->pts[np].P_x = lx; sc->pts[np].P_y = lasty; np++; }
            lastx = lx;
            break;
        }
        case 'Q': case 'q': {
            /* quadratic Bézier: (cx,cy) (x,y) ; multiple pairs allowed */
            sword cx, cy, ex, ey;
            for (;;) {
                sP = SVG_SkipWS(sP);
                if (!*sP || isalpha(*sP) || *sP=='Z' || *sP=='z') break;

                sP = SVG_ScanInt(sP, &cx);
                if (*sP == ',') sP++;
                sP = SVG_SkipWS(sP);
                sP = SVG_ScanInt(sP, &cy);
                if (*sP == ',') sP++;
                sP = SVG_SkipWS(sP);
                sP = SVG_ScanInt(sP, &ex);
                if (*sP == ',') sP++;
                sP = SVG_SkipWS(sP);
                sP = SVG_ScanInt(sP, &ey);

                if (lastCmd == 'q') { cx += lastx; cy += lasty; ex += lastx; ey += lasty; }

                /* start at last point; add flattened curve points (no duplicate of start) */
                SVG_FlattenQuad(sc, &np, lastx, lasty, cx, cy, ex, ey, 8);

                lastx = ex; lasty = ey;
            }
            break;
        }
        case 'C': case 'c': {
            /* cubic Bézier: (c1x,c1y c2x,c2y x,y) ; multiple groups allowed */
            sword c1x, c1y, c2x, c2y, ex, ey;
            for (;;) {
                sP = SVG_SkipWS(sP);
                if (!*sP || isalpha(*sP) || *sP=='Z' || *sP=='z') break;

                sP = SVG_ScanInt(sP, &c1x);
                if (*sP == ',') sP++;
                sP = SVG_SkipWS(sP);
                sP = SVG_ScanInt(sP, &c1y);
                if (*sP == ',') sP++;
                sP = SVG_SkipWS(sP);
                sP = SVG_ScanInt(sP, &c2x);
                if (*sP == ',') sP++;
                sP = SVG_SkipWS(sP);
                sP = SVG_ScanInt(sP, &c2y);
                if (*sP == ',') sP++;
                sP = SVG_SkipWS(sP);
                sP = SVG_ScanInt(sP, &ex);
                if (*sP == ',') sP++;
                sP = SVG_SkipWS(sP);
                sP = SVG_ScanInt(sP, &ey);

                if (lastCmd == 'c') {
                    c1x += lastx; c1y += lasty;
                    c2x += lastx; c2y += lasty;
                    ex  += lastx; ey  += lasty;
                }

                SVG_FlattenCubic(sc, &np, lastx, lasty, c1x, c1y, c2x, c2y, ex, ey, 10);

                lastx = ex; lasty = ey;
            }
            break;
        }
        case 'V': case 'v': {
            sword ly;

            sP = SVG_SkipWS(sP);
            sP = SVG_ScanInt(sP, &ly);
            if (lastCmd == 'v') ly += lasty;
            if (np < MAX_SVG_POINTS) { sc->pts[np].P_x = lastx; sc->pts[np].P_y = ly; np++; }
            lasty = ly;
            break;
        }
        case 'Z': case 'z':
            closed = TRUE;
            sP++;
            /* do not reset haveCmd; path may end here */
            break;

        default:
            /* skip unhandled (curves/arcs/others) one char at a time */
            sP++;
            break;
        }
    }

    if (np > 1)
    {
        WWFixedAsDWord sx, sy;
        word i;

        SVG_GetScale(tag, &sx, &sy);
        for (i = 0; i < np; i++) {
            sword px = sc->pts[i].P_x;
            sword py = sc->pts[i].P_y;
            SVG_ApplyScalePoint(&px, &py, sx, sy);
            sc->pts[i].P_x = px;
            sc->pts[i].P_y = py;
        }

        if (closed) Meta_Polygon(sc->pts, np, SVG_HasFill(tag), SVG_HasStroke(tag));
        else        Meta_Polyline(sc->pts, np);
    }
}

/* ---------- streaming scanner ---------- */
static void ScanCtxInit(ScanCtx *c)
{
    c->ioH = 0;
    c->ioP = NULL;
    c->bytes = 0;
    c->pos = 0;
    c->inTag = FALSE;
    c->inQuote = FALSE;
    c->quoteCh = 0;
    c->tagLen = 0;
}

/* Pull next complete tag into sc->tag; returns FALSE on EOF/error with no tag */
static Boolean ScanNextTag(FileHandle fh, ScanCtx *c, SVGScratch *sc)
{
    for (;;)
    {
        if (c->pos >= c->bytes)
        {
            word r;

            if (!c->ioP) return FALSE;
            r = FileRead(fh, (void*)c->ioP, SVG_IO_BUF_SIZE, FALSE);
            if (r == (word)-1 || r == 0) return FALSE;
            c->bytes = r;
            c->pos   = 0;
        }

        {
            char ch;
            ch = c->ioP[c->pos++];

            if (!c->inTag)
            {
                if (ch == '<')
                {
                    c->inTag = TRUE;
                    c->inQuote = FALSE;
                    c->quoteCh = 0;
                    c->tagLen = 0;
                }
                continue;
            }

            if (c->inQuote)
            {
                if (ch == c->quoteCh) c->inQuote = FALSE;
                if (c->tagLen < (TAG_BUF_SIZE-1)) sc->tag[c->tagLen++] = ch;
                continue;
            }
            else
            {
                if (ch == '"' || ch == '\'')
                {
                    c->inQuote = TRUE;
                    c->quoteCh = ch;
                    if (c->tagLen < (TAG_BUF_SIZE-1)) sc->tag[c->tagLen++] = ch;
                    continue;
                }
                if (ch != '>')
                {
                    if (c->tagLen < (TAG_BUF_SIZE-1)) sc->tag[c->tagLen++] = ch;
                    continue;
                }

                /* finished a tag; if it overflowed, it was truncated safely */
                sc->tag[c->tagLen] = 0;
                c->inTag = FALSE;
                return TRUE;
            }
        }
    }
}

/*---------------------------------------------------------------
 * ReadSVG -- streamed, SAX-like; callback(last param) is percent
 *---------------------------------------------------------------*/
TransError _export _pascal ReadSVG(FileHandle srcFile, word settings,
                                   ProgressCallback *callback)
{
    ScanCtx       scan;
    SVGScratch   *scP;
    MemHandle     scH;
    dword         total;
    dword         done;
    word          lastPct;
    MemHandle     ioH;
    char         *ioP;

    (void)settings;

    scH     = 0;
    scP     = NULL;
    ioH     = 0;
    ioP     = NULL;
    lastPct = 0;
    done    = 0;

    /* world 0..32767 in both axes; uniform scale derives from X extent */
    Meta_SetScaling(0, 0, 32767, 32767, 32767, 32767);

    total = FilePos(srcFile, 0, FILE_POS_END);
    FilePos(srcFile, 0, FILE_POS_START);

    /* progress disabled for safety while ABI is verified */
    /* if (callback) (void)(*callback)(0); */

    scH = MemAlloc((word)sizeof(SVGScratch), HF_DYNAMIC, HAF_ZERO_INIT);
    if (!scH)
    {
        /* if (callback) (void)(*callback)(100); */
        return TE_OUT_OF_MEMORY;
    }
    scP = (SVGScratch*) MemLock(scH);
    if (!scP)
    {
        MemFree(scH);
        /* if (callback) (void)(*callback)(100); */
        return TE_OUT_OF_MEMORY;
    }

    ioH = MemAlloc(SVG_IO_BUF_SIZE, HF_DYNAMIC, HAF_ZERO_INIT);
    if (!ioH)
    {
        MemUnlock(scH);
        MemFree(scH);
        /* if (callback) (void)(*callback)(100); */
        return TE_OUT_OF_MEMORY;
    }
    ioP = (char*) MemLock(ioH);
    if (!ioP)
    {
        MemFree(ioH);
        MemUnlock(scH);
        MemFree(scH);
        /* if (callback) (void)(*callback)(100); */
        return TE_OUT_OF_MEMORY;
    }

    ScanCtxInit(&scan);
    scan.ioH = ioH;
    scan.ioP = ioP;

    for (;;)
    {
        if (!ScanNextTag(srcFile, &scan, scP))
        {
            break;
        }

        /* progress (throttled; avoid tiny files) — disabled for now */
        if (callback && total >= 2048)
        {
            done = (dword)FilePos(srcFile, 0, FILE_POS_RELATIVE);
            if (done > total) done = total;

            {
                word pct;
                pct = (word)((done * 100UL) / total);
                if (pct != lastPct)
                {
                    lastPct = pct;
                    /* if ((*callback)(pct)) break; */
                }
            }
        }

        if (scP->tag[0] == '/' || scP->tag[0] == '!' || scP->tag[0] == '?')
        {
            continue;
        }

        if (TagIs(scP->tag, "line"))
        {
            HandleLineTag(scP->tag);
        }
        else if (TagIs(scP->tag, "polyline"))
        {
            HandlePolylineTag(scP->tag, scP);
        }
        else if (TagIs(scP->tag, "polygon"))
        {
            HandlePolygonTag(scP->tag, scP);
        }
        else if (TagIs(scP->tag, "rect"))
        {
            HandleRectTag(scP->tag);
        }
        else if (TagIs(scP->tag, "ellipse"))
        {
            HandleEllipseTag(scP->tag);
        }
        else if (TagIs(scP->tag, "circle"))
        {
            HandleCircleTag(scP->tag);
        }
        else if (TagIs(scP->tag, "path"))
        {
            HandlePathTag(scP->tag, scP);
        }
        else
        {
            /* unhandled: <svg>, <g>, etc. */
        }
    }

    if (ioP) MemUnlock(ioH);
    if (ioH) MemFree(ioH);
    if (scP) MemUnlock(scH);
    if (scH) MemFree(scH);
    /* if (callback) (void)(*callback)(100); */

    return TE_NO_ERROR;
}
