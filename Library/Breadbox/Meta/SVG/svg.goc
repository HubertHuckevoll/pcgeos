/***********************************************************************
 *
 * PROJECT:      Meta
 * FILE:         svg.goc
 * DESCRIPTION:  Basic SVG parser for Meta library (streamed, GEOS/Watcom)
 *
 ***********************************************************************/

@include <stdapp.goh>

#include <Ansi/string.h>
#include <Ansi/stdlib.h>
#include <Ansi/ctype.h>
#include <file.h>
#include <system.h>
#include <graphics.h>
#include <gstring.h>
#include <meta.h>

#define MAX_SVG_POINTS    512
#define SVG_IO_BUF_SIZE   1024
#define TAG_BUF_SIZE      256

/* ===== Fixed-point helpers (16.16) ===== */
#define WWFIXED_ONE      ((WWFixedAsDWord)(1UL << 16))

/* ---------- forward prototypes (avoid implicit int / symbol surprises) ---------- */
static WWFixedAsDWord MakeWWFixedFromInt(int v);
static const char *   ParseWWFixed16_16(const char *s, WWFixedAsDWord *out);
static word           HexNibble(char c);
static word           HexByte(const char *p);
static Boolean        TagIs(const char *tag, const char *name);
static Boolean        GetAttrBounded(const char *tag, const char *name, char *out, word outSize);
static void           ApplyStrokeAndFill(const char *tag);
static void           ApplyStrokeWidth(const char *tag);
static void           ApplyTransform(const char *tag);
static void           SVG_ParsePoints(const char *points, Point *pointsP, word *numPointsP);
static void           HandleLineTag(const char *tag);
static void           HandlePolylineTag(const char *tag, struct _SVGScratch *sc);
static void           HandlePolygonTag(const char *tag, struct _SVGScratch *sc);
static void           HandleRectTag(const char *tag);
static void           HandleEllipseTag(const char *tag);
static void           HandleCircleTag(const char *tag);
static void           HandlePathTag(const char *tag, struct _SVGScratch *sc);

/* scanner context */
typedef struct {
    MemHandle  ioH;
    char      *ioP;
    word       bytes;
    word       pos;
    Boolean    inTag;
    Boolean    inQuote;
    char       quoteCh;
    word       tagLen;
} ScanCtx;

static void           ScanCtxInit(ScanCtx *c);
static Boolean        ScanNextTag(FileHandle fh, ScanCtx *c, struct _SVGScratch *sc);

/* ---------- impl ---------- */

static WWFixedAsDWord MakeWWFixedFromInt(int v)
{
    WWFixedAsDWord f;

    f = ((WWFixedAsDWord)((sdword)v)) << 16;
    return f;
}

static WWFixedAsDWord GrMulWWFixedSafe(WWFixedAsDWord a, WWFixedAsDWord b)
{
    return GrMulWWFixed(a, b);
}

/* Parse "-12.34" → 16.16; returns pointer after number */
static const char * ParseWWFixed16_16(const char *s, WWFixedAsDWord *out)
{
    sdword           sign;
    dword            ip;
    dword            frac;
    dword            scale;
    word             c;
    WWFixedAsDWord   result;

    sign  = 1;
    ip    = 0;
    frac  = 0;
    scale = 1;

    while (*s && isspace(*s))
    {
        s++;
    }
    if (*s == '+')
    {
        s++;
    }
    else if (*s == '-')
    {
        sign = -1;
        s++;
    }

    while ((c = (word)(byte)*s) >= '0' && c <= '9')
    {
        ip = ip * 10 + (c - '0');
        s++;
    }

    if (*s == '.')
    {
        s++;
        while ((c = (word)(byte)*s) >= '0' && c <= '9')
        {
            if (scale < 1000000UL)
            {
                frac = frac * 10 + (c - '0');
                scale *= 10;
            }
            s++;
        }
    }

    result = MakeWWFixedFromInt((int)ip);
    if (scale != 0)
    {
        dword fpart;
        fpart = ((frac << 16) / scale);
        result += (WWFixedAsDWord)fpart;
    }
    if (sign < 0)
    {
        result = (WWFixedAsDWord)(0 - (sdword)result);
    }
    *out = result;
    return s;
}

/* ---------- tiny hex helpers (no stdio) ---------- */
static word HexNibble(char c)
{
    if (c >= '0' && c <= '9') return (word)(c - '0');
    if (c >= 'A' && c <= 'F') return (word)(10 + (c - 'A'));
    if (c >= 'a' && c <= 'f') return (word)(10 + (c - 'a'));
    return 0;
}
static word HexByte(const char *p)
{
    return (word)((HexNibble(p[0]) << 4) | HexNibble(p[1]));
}

/* ---------- scan helpers ---------- */
static Boolean TagIs(const char *tag, const char *name)
{
    const char *s;
    const char *n;

    s = tag;
    n = name;
    while (*s && !isspace(*s) && *s != '/' && *s != '>')
    {
        if (*n == 0 || *s != *n)
        {
            return FALSE;
        }
        s++;
        n++;
    }
    return (*n == 0);
}

/* Robust, bounded attribute reader — supports ' and " */
static Boolean GetAttrBounded(const char *tag, const char *name,
                              char *out, word outSize)
{
    const char *s;
    word        nlen;

    if (outSize == 0) return FALSE;
    out[0] = 0;

    /* skip element name */
    s = tag;
    while (*s && !isspace(*s) && *s != '>' && *s != '/')
    {
        s++;
    }

    nlen = (word)strlen(name);

    while (*s && *s != '>')
    {
        const char *an;
        word        alen;

        while (*s && (isspace(*s) || *s == '/'))
        {
            s++;
        }
        if (!*s || *s == '>')
        {
            break;
        }

        an = s;
        alen = 0;

        while (*s && *s != '=' && !isspace(*s) && *s != '>' && *s != '/')
        {
            s++;
            alen++;
        }

        if (alen == nlen && !memcmp(an, name, nlen))
        {
            while (*s && isspace(*s)) s++;
            if (*s != '=') return FALSE;
            s++;
            while (*s && isspace(*s)) s++;

            if (*s == '"' || *s == '\'')
            {
                char  q;
                word  i;

                q = *s++;
                i = 0;
                while (*s && *s != q && i < (outSize - 1))
                {
                    out[i++] = *s++;
                }
                out[i] = 0;
                if (*s == q) s++;
            }
            else
            {
                word i;
                i = 0;
                while (*s && !isspace(*s) && *s != '>' && i < (outSize - 1))
                {
                    out[i++] = *s++;
                }
                out[i] = 0;
            }
            return TRUE;
        }
        else
        {
            while (*s && isspace(*s)) s++;
            if (*s == '=')
            {
                s++;
                while (*s && isspace(*s)) s++;
                if (*s == '"' || *s == '\'')
                {
                    char q = *s++;
                    while (*s && *s != q) s++;
                    if (*s == q) s++;
                }
                else
                {
                    while (*s && !isspace(*s) && *s != '>') s++;
                }
            }
        }
    }
    return FALSE;
}

/* All sizeable buffers live here to keep stack tiny */
typedef struct _SVGScratch {
    char    tag[TAG_BUF_SIZE];

    char    pb[256];
    char    db[256];
    char    xb[32], yb[32], x2b[32], y2b[32];
    char    wb[32], hb[32];
    char    cxb[32], cyb[32], rxb[32], ryb[32];
    char    rb[32];
    char    col[64];
    char    tbuf[96];

    Point   pts[MAX_SVG_POINTS];
} SVGScratch;

/* ---------- style helpers ---------- */
static void ApplyStrokeAndFill(const char *tag)
{
    static char sFill[64];
    static char sStroke[64];

    sFill[0] = 0;
    sStroke[0] = 0;

    if (GetAttrBounded(tag, "stroke", sStroke, sizeof(sStroke)))
    {
        if (strcmp(sStroke, "none") != 0 && sStroke[0] == '#' && strlen(sStroke) >= 7)
        {
            Meta_SetLineColor(CF_RGB, HexByte(sStroke+1), HexByte(sStroke+3), HexByte(sStroke+5));
        }
    }
    if (GetAttrBounded(tag, "fill", sFill, sizeof(sFill)))
    {
        if (strcmp(sFill, "none") != 0 && sFill[0] == '#' && strlen(sFill) >= 7)
        {
            Meta_SetAreaColor(CF_RGB, HexByte(sFill+1), HexByte(sFill+3), HexByte(sFill+5));
        }
    }
}

static void ApplyStrokeWidth(const char *tag)
{
    static char b[20];

    if (GetAttrBounded(tag, "stroke-width", b, sizeof(b)))
    {
        Meta_SetLineWidth(MakeWWFixed(atoi(b)));
    }
}

static void ApplyTransform(const char *tag)
{
    static char      b[96];
    char            *p;
    WWFixedAsDWord   sx;
    WWFixedAsDWord   sy;

    sx = WWFIXED_ONE;
    sy = WWFIXED_ONE;

    if (!GetAttrBounded(tag, "transform", b, sizeof(b)))
    {
        return;
    }

    p = strstr(b, "scale");
    if (p)
    {
        char        *lp;
        const char  *s;

        lp = strchr(p, '(');
        if (!lp) return;
        s = lp + 1;
        s = ParseWWFixed16_16(s, &sx);
        while (*s && isspace(*s)) s++;
        if (*s == ',')
        {
            s++;
            (void)ParseWWFixed16_16(s, &sy);
        }
        else
        {
            sy = sx;
        }

        {
            WWFixedAsDWord limit;
            WWFixedAsDWord sxScaled;
            WWFixedAsDWord syScaled;
            sword          xs;
            sword          ys;

            limit    = MakeWWFixedFromInt(32767);
            sxScaled = GrMulWWFixedSafe(sx, limit);
            syScaled = GrMulWWFixedSafe(sy, limit);
            xs       = (sword)((sdword)sxScaled >> 16);
            ys       = (sword)((sdword)syScaled >> 16);
            Meta_SetScaling(0, 0, xs, ys, 32767, 32767);
        }
    }
}

/* ---------- points parser (renamed to avoid collisions) ---------- */
static void SVG_ParsePoints(const char *points, Point *pointsP, word *numPointsP)
{
    const char *s;
    sword       x;
    sword       y;
    int         xi;
    int         yi;

    s = points;
    *numPointsP = 0;
    xi = yi = 0;

    while (*s && *numPointsP < MAX_SVG_POINTS)
    {
        while (*s && isspace(*s)) s++;
        if (!*s) break;

        xi = atoi(s);
        while (*s && *s != ',' && !isspace(*s)) s++;
        if (*s == ',') s++;
        while (*s && isspace(*s)) s++;
        yi = atoi(s);
        while (*s && *s != ' ' && *s != ',' && *s != '\0') s++;

        x = (sword)xi;
        y = (sword)yi;
        pointsP[*numPointsP].P_x = x;
        pointsP[*numPointsP].P_y = y;
        (*numPointsP)++;

        while (*s && (isspace(*s) || *s == ',')) s++;
    }
}

/* ---------- element handlers ---------- */
static void HandleLineTag(const char *tag)
{
    static char xb[32], yb[32], x2b[32], y2b[32];

    if (GetAttrBounded(tag, "x1", xb, sizeof(xb)) &&
        GetAttrBounded(tag, "y1", yb, sizeof(yb)) &&
        GetAttrBounded(tag, "x2", x2b, sizeof(x2b)) &&
        GetAttrBounded(tag, "y2", y2b, sizeof(y2b)))
    {
        ApplyStrokeAndFill(tag);
        ApplyStrokeWidth(tag);
        ApplyTransform(tag);
        Meta_Line((sword)atoi(xb), (sword)atoi(yb),
                  (sword)atoi(x2b), (sword)atoi(y2b));
    }
}

static void HandlePolylineTag(const char *tag, SVGScratch *sc)
{
    word np;

    sc->pb[0] = 0;
    if (GetAttrBounded(tag, "points", sc->pb, sizeof(sc->pb)))
    {
        ApplyStrokeAndFill(tag);
        ApplyStrokeWidth(tag);
        ApplyTransform(tag);
        SVG_ParsePoints(sc->pb, sc->pts, &np);
        if (np > 0) Meta_Polyline(sc->pts, np);
    }
}

static void HandlePolygonTag(const char *tag, SVGScratch *sc)
{
    word np;

    sc->pb[0] = 0;
    if (GetAttrBounded(tag, "points", sc->pb, sizeof(sc->pb)))
    {
        ApplyStrokeAndFill(tag);
        ApplyStrokeWidth(tag);
        ApplyTransform(tag);
        SVG_ParsePoints(sc->pb, sc->pts, &np);
        if (np > 0) Meta_Polygon(sc->pts, np, TRUE, TRUE);
    }
}

static void HandleRectTag(const char *tag)
{
    static char xb[32], yb[32], wb[32], hb[32];
    sword       x;
    sword       y;
    sword       x2;
    sword       y2;

    if (GetAttrBounded(tag, "x", xb, sizeof(xb)) &&
        GetAttrBounded(tag, "y", yb, sizeof(yb)) &&
        GetAttrBounded(tag, "width", wb, sizeof(wb)) &&
        GetAttrBounded(tag, "height", hb, sizeof(hb)))
    {
        ApplyStrokeAndFill(tag);
        ApplyStrokeWidth(tag);
        ApplyTransform(tag);

        x  = (sword)atoi(xb);
        y  = (sword)atoi(yb);
        x2 = (sword)(x + (sword)atoi(wb));
        y2 = (sword)(y + (sword)atoi(hb));
        Meta_Rect(x, y, x2, y2, TRUE, TRUE);
    }
}

static void HandleEllipseTag(const char *tag)
{
    static char cxb[32], cyb[32], rxb[32], ryb[32];

    if (GetAttrBounded(tag, "cx", cxb, sizeof(cxb)) &&
        GetAttrBounded(tag, "cy", cyb, sizeof(cyb)) &&
        GetAttrBounded(tag, "rx", rxb, sizeof(rxb)) &&
        GetAttrBounded(tag, "ry", ryb, sizeof(ryb)))
    {
        ApplyStrokeAndFill(tag);
        ApplyStrokeWidth(tag);
        ApplyTransform(tag);

        Meta_Ellipse((sword)atoi(cxb), (sword)atoi(cyb),
                     (sword)atoi(rxb), (sword)atoi(ryb),
                     0, TRUE, TRUE);
    }
}

static void HandleCircleTag(const char *tag)
{
    static char cxb[32], cyb[32], rb[32];

    if (GetAttrBounded(tag, "cx", cxb, sizeof(cxb)) &&
        GetAttrBounded(tag, "cy", cyb, sizeof(cyb)) &&
        GetAttrBounded(tag, "r",  rb,  sizeof(rb)))
    {
        ApplyStrokeAndFill(tag);
        ApplyStrokeWidth(tag);
        ApplyTransform(tag);

        Meta_Ellipse((sword)atoi(cxb), (sword)atoi(cyb),
                     (sword)atoi(rb),  (sword)atoi(rb),
                     0, TRUE, TRUE);
    }
}

static void HandlePathTag(const char *tag, SVGScratch *sc)
{
    const char *sP;
    word        np;
    Boolean     closed;
    sword       lastx;
    sword       lasty;

    sc->db[0] = 0;
    if (!GetAttrBounded(tag, "d", sc->db, sizeof(sc->db))) return;

    ApplyStrokeAndFill(tag);
    ApplyStrokeWidth(tag);
    ApplyTransform(tag);

    np = 0;
    closed = FALSE;
    lastx = 0;
    lasty = 0;
    sP = sc->db;

    while (*sP)
    {
        while (*sP && isspace(*sP)) sP++;
        if (*sP == 'M' || *sP == 'm')
        {
            sP++;
            lastx = (sword)atoi(sP);
            while (*sP && *sP != ',' && *sP != ' ') sP++;
            if (*sP == ',') sP++;
            while (*sP && isspace(*sP)) sP++;
            lasty = (sword)atoi(sP);
            while (*sP && *sP != ' ' && *sP != 'Z' && *sP != 'z') sP++;
            if (np < MAX_SVG_POINTS) { sc->pts[np].P_x = lastx; sc->pts[np].P_y = lasty; np++; }
        }
        else if (*sP == 'L' || *sP == 'l')
        {
            sword lx;
            sword ly;

            sP++;
            lx = (sword)atoi(sP);
            while (*sP && *sP != ',' && *sP != ' ') sP++;
            if (*sP == ',') sP++;
            while (*sP && isspace(*sP)) sP++;
            ly = (sword)atoi(sP);
            while (*sP && *sP != ' ' && *sP != 'Z' && *sP != 'z') sP++;
            if (np < MAX_SVG_POINTS) { sc->pts[np].P_x = lx; sc->pts[np].P_y = ly; np++; }
            lastx = lx;
            lasty = ly;
        }
        else if (*sP == 'Z' || *sP == 'z')
        {
            closed = TRUE;
            sP++;
            break;
        }
        else
        {
            sP++;  /* skip unhandled command */
        }
    }

    if (np > 1)
    {
        if (closed) Meta_Polygon(sc->pts, np, TRUE, TRUE);
        else        Meta_Polyline(sc->pts, np);
    }
}

/* ---------- streaming scanner ---------- */
static void ScanCtxInit(ScanCtx *c)
{
    c->ioH = 0;
    c->ioP = NULL;
    c->bytes = 0;
    c->pos = 0;
    c->inTag = FALSE;
    c->inQuote = FALSE;
    c->quoteCh = 0;
    c->tagLen = 0;
}

/* Pull next complete tag into sc->tag; returns FALSE on EOF/error with no tag */
static Boolean ScanNextTag(FileHandle fh, ScanCtx *c, SVGScratch *sc)
{
    for (;;)
    {
        if (c->pos >= c->bytes)
        {
            word r;

            if (!c->ioP) return FALSE;
            r = FileRead(fh, (void*)c->ioP, SVG_IO_BUF_SIZE, FALSE);
            if (r == (word)-1 || r == 0) return FALSE;
            c->bytes = r;
            c->pos   = 0;
        }

        {
            char ch;
            ch = c->ioP[c->pos++];

            if (!c->inTag)
            {
                if (ch == '<')
                {
                    c->inTag = TRUE;
                    c->inQuote = FALSE;
                    c->quoteCh = 0;
                    c->tagLen = 0;
                }
                continue;
            }

            if (c->inQuote)
            {
                if (ch == c->quoteCh) c->inQuote = FALSE;
                if (c->tagLen < (TAG_BUF_SIZE-1)) sc->tag[c->tagLen++] = ch;
                continue;
            }
            else
            {
                if (ch == '"' || ch == '\'')
                {
                    c->inQuote = TRUE;
                    c->quoteCh = ch;
                    if (c->tagLen < (TAG_BUF_SIZE-1)) sc->tag[c->tagLen++] = ch;
                    continue;
                }
                if (ch != '>')
                {
                    if (c->tagLen < (TAG_BUF_SIZE-1)) sc->tag[c->tagLen++] = ch;
                    continue;
                }

                /* finished a tag */
                sc->tag[c->tagLen] = 0;
                c->inTag = FALSE;
                return TRUE;
            }
        }
    }
}

/*---------------------------------------------------------------
 * ReadSVG -- streamed, SAX-like; callback(last param) is percent
 *---------------------------------------------------------------*/
TransError _export _pascal ReadSVG(FileHandle srcFile, word settings,
                                   ProgressCallback *callback)
{
    ScanCtx       scan;
    SVGScratch   *scP;
    MemHandle     scH;
    dword         total;
    dword         done;
    word          lastPct;
    MemHandle     ioH;
    char         *ioP;

    (void)settings;

    scH     = 0;
    scP     = NULL;
    ioH     = 0;
    ioP     = NULL;
    lastPct = 0;
    done    = 0;

    total = FilePos(srcFile, FILE_POS_END, 0);
    FilePos(srcFile, FILE_POS_START, 0);

    if (callback) (void)(*callback)(0);

    scH = MemAlloc((word)sizeof(SVGScratch), HF_DYNAMIC, HAF_ZERO_INIT);
    if (!scH)
    {
        if (callback) (void)(*callback)(100);
        return TE_OUT_OF_MEMORY;
    }
    scP = (SVGScratch*) MemLock(scH);
    if (!scP)
    {
        MemFree(scH);
        if (callback) (void)(*callback)(100);
        return TE_OUT_OF_MEMORY;
    }

    ioH = MemAlloc(SVG_IO_BUF_SIZE, HF_DYNAMIC, HAF_ZERO_INIT);
    if (!ioH)
    {
        MemUnlock(scH);
        MemFree(scH);
        if (callback) (void)(*callback)(100);
        return TE_OUT_OF_MEMORY;
    }
    ioP = (char*) MemLock(ioH);
    if (!ioP)
    {
        MemFree(ioH);
        MemUnlock(scH);
        MemFree(scH);
        if (callback) (void)(*callback)(100);
        return TE_OUT_OF_MEMORY;
    }

    ScanCtxInit(&scan);
    scan.ioH = ioH;
    scan.ioP = ioP;

    for (;;)
    {
        if (!ScanNextTag(srcFile, &scan, scP))
        {
            break;
        }

        /* progress (throttled; avoid tiny files) */
        if (callback && total >= 2048)
        {
            done = (dword)FilePos(srcFile, FILE_POS_RELATIVE, 0);
            if (done > total) done = total;

            {
                word pct;
                pct = (word)((done * 100UL) / total);
                if (pct != lastPct)
                {
                    lastPct = pct;
                    if ((*callback)(pct)) break;
                }
            }
        }

        if (scP->tag[0] == '/' || scP->tag[0] == '!' || scP->tag[0] == '?')
        {
            continue;
        }

        if (TagIs(scP->tag, "line"))
        {
            HandleLineTag(scP->tag);
        }
        else if (TagIs(scP->tag, "polyline"))
        {
            HandlePolylineTag(scP->tag, scP);
        }
        else if (TagIs(scP->tag, "polygon"))
        {
            HandlePolygonTag(scP->tag, scP);
        }
        else if (TagIs(scP->tag, "rect"))
        {
            HandleRectTag(scP->tag);
        }
        else if (TagIs(scP->tag, "ellipse"))
        {
            HandleEllipseTag(scP->tag);
        }
        else if (TagIs(scP->tag, "circle"))
        {
            HandleCircleTag(scP->tag);
        }
        else if (TagIs(scP->tag, "path"))
        {
            HandlePathTag(scP->tag, scP);
        }
        else
        {
            /* unhandled: <svg>, <g>, etc. */
        }
    }

    if (ioP) MemUnlock(ioH);
    if (ioH) MemFree(ioH);
    if (scP) MemUnlock(scH);
    if (scH) MemFree(scH);
    if (callback) (void)(*callback)(100);

    return TE_NO_ERROR;
}
