/***********************************************************************
 * svgParser.goc — streamed SAX-like parser, tag/attr utilities, ReadSVG
 ***********************************************************************/
@include <stdapp.goh>

#include <Ansi/string.h>
#include <Ansi/stdlib.h>
#include <Ansi/ctype.h>
#include <file.h>
#include <system.h>
#include <graphics.h>
#include <gstring.h>
#include <meta.h>
#include <float.h>

#include "SVG/svg.h"
#include "SVG/dbglog.h"

/* ---- scanner context ---- */
typedef struct {
    MemHandle  ioH;
    char      *ioP;
    word       bytes;
    word       pos;
    Boolean    inTag;
    Boolean    inQuote;
    char       quoteCh;
    word       tagLen;
} SvgScanCtx;

/* ---- raw text helpers (exported) ---- */

const char* SvgParserSkipWS(const char *s)
{
    while (*s && isspace(*s)) {
        s++;
    }
    return s;
}

/* Parse "-12.34" → 16.16; returns pointer after number */
const char* SvgParserParseWWFixed16_16(const char *s, WWFixedAsDWord *out)
{
    sdword           sign;
    dword            ip;
    dword            frac;
    dword            scale;
    word             c;
    WWFixedAsDWord   result;
    dword            fpart;    /* fractional part in 16.16 */
    dword            num;      /* intermediate for safe scaling */

    sign  = 1;
    ip    = 0;
    frac  = 0;
    scale = 1;

    while (*s && isspace((unsigned char)*s))
    {
        s++;
    }
    if (*s == '+')
    {
        s++;
    }
    else if (*s == '-')
    {
        sign = -1;
        s++;
    }

    while ((c = (word)(byte)*s) >= '0' && c <= '9')
    {
        ip = ip * 10 + (c - '0');
        s++;
    }

    if (*s == '.')
    {
        s++;
        while ((c = (word)(byte)*s) >= '0' && c <= '9')
        {
            if (scale < 1000000UL)
            {
                frac  = frac * 10 + (c - '0');
                scale = scale * 10;
            }
            s++;
        }
    }

    /* integer part (keep as-is to match existing behavior / 16-bit int helper) */
    result = SvgGeomMakeWWFixedFromInt((int)ip);

    /* fractional part: compute (frac * 2^16) / scale without 32-bit overflow, with rounding */
    fpart = 0;
    if (scale != 0)
    {
        /* Two-stage scale: ((frac<<8)/scale)<<8, with rounding at the 8-bit stage */
        num   = (frac << 8);                 /* <= 256,000,000 for our cap — safe in 32-bit */
        num   = (num + (scale >> 1)) / scale;/* round-to-nearest at 8 fractional bits */
        fpart = (num << 8);                  /* back to 16 fractional bits */
        result += (WWFixedAsDWord)fpart;
    }

    if (sign < 0)
    {
        result = (WWFixedAsDWord)(0 - (sdword)result);
    }

#ifdef DEBUG_LOG
    if (scale >= 1000000UL && frac != 0) {
        LOG_STR("[SvgParserParseWWFixed16_16]", "fraction scale capped at 1e6");
    }
    if ((sdword)result == 0 && (ip!=0 || frac!=0)) {
        LOG_STR("[SvgParserParseWWFixed16_16]", "result rounded to zero");
    }
#endif

    *out = result;
    return s;
}

/* Robust, bounded attribute reader — supports ' and " */
Boolean SvgParserGetAttrBounded(const char *tag, const char *name,
                                char *out, word outSize)
{
    const char *s;
    word        nlen;

    if (outSize == 0) return FALSE;
    out[0] = 0;

    s = tag;
    while (*s && !isspace(*s) && *s != '>' && *s != '/')
    {
        s++;
    }

    nlen = (word)strlen(name);

    while (*s && *s != '>')
    {
        const char *an;
        word        alen;

        while (*s && (isspace(*s) || *s == '/'))
        {
            s++;
        }
        if (!*s || *s == '>')
        {
            break;
        }

        an = s;
        alen = 0;

        while (*s && *s != '=' && !isspace(*s) && *s != '>' && *s != '/')
        {
            s++;
            alen++;
        }

        if (alen == nlen && !memcmp(an, name, nlen))
        {
            while (*s && isspace(*s)) s++;
            if (*s != '=') return FALSE;
            s++;
            while (*s && isspace(*s)) s++;

            if (*s == '"' || *s == '\'')
            {
                char  q;
                word  i;

                q = *s++;
                i = 0;
                while (*s && *s != q && i < (outSize - 1))
                {
                    out[i++] = *s++;
                }
                out[i] = 0;
                if (*s == q) s++;
            }
            else
            {
                word i;
                i = 0;
                while (*s && !isspace(*s) && *s != '>' && i < (outSize - 1))
                {
                    out[i++] = *s++;
                }
                out[i] = 0;
            }
            return TRUE;
        }
        else
        {
            while (*s && isspace(*s)) s++;
            if (*s == '=')
            {
                s++;
                while (*s && isspace(*s)) s++;
                if (*s == '"' || *s == '\'')
                {
                    char q = *s++;
                    while (*s && *s != q) s++;
                    if (*s == q) s++;
                }
                else
                {
                    while (*s && !isspace(*s) && *s != '>') s++;
                }
            }
        }
    }
    return FALSE;
}

Boolean SvgParserTagIs(const char *tag, const char *name)
{
    const char *s;
    const char *n;

    s = tag;
    n = name;
    while (*s && !isspace(*s) && *s != '/' && *s != '>')
    {
        if (*n == 0 || *s != *n)
        {
            return FALSE;
        }
        s++;
        n++;
    }
    return (*n == 0);
}

/* ---- scanner internals ---- */

static void SvgParserScanInit(SvgScanCtx *c)
{
    c->ioH = 0;
    c->ioP = NULL;
    c->bytes = 0;
    c->pos = 0;
    c->inTag = FALSE;
    c->inQuote = FALSE;
    c->quoteCh = 0;
    c->tagLen = 0;
}

/* Pull next complete tag into sc->tag; returns FALSE on EOF/error with no tag */
static Boolean SvgParserScanNextTag(FileHandle fh, SvgScanCtx *c, SVGScratch *sc)
{
    for (;;)
    {
        if (c->pos >= c->bytes)
        {
            word r;

            if (!c->ioP) return FALSE;
            r = FileRead(fh, (void*)c->ioP, SVG_IO_BUF_SIZE, FALSE);
            if (r == (word)-1 || r == 0) return FALSE;
            c->bytes = r;
            c->pos   = 0;
        }

        {
            char ch;
            ch = c->ioP[c->pos++];

            if (!c->inTag)
            {
                if (ch == '<')
                {
                    c->inTag = TRUE;
                    c->inQuote = FALSE;
                    c->quoteCh = 0;
                    c->tagLen = 0;
                }
                continue;
            }

            if (c->inQuote)
            {
                if (ch == c->quoteCh) c->inQuote = FALSE;
                if (c->tagLen < (TAG_BUF_SIZE-1)) sc->tag[c->tagLen++] = ch;
                continue;
            }
            else
            {
                if (ch == '"' || ch == '\'')
                {
                    c->inQuote = TRUE;
                    c->quoteCh = ch;
                    if (c->tagLen < (TAG_BUF_SIZE-1)) sc->tag[c->tagLen++] = ch;
                    continue;
                }
                if (ch != '>')
                {
                    if (c->tagLen < (TAG_BUF_SIZE-1)) sc->tag[c->tagLen++] = ch;
                    continue;
                }

                sc->tag[c->tagLen] = 0;
                c->inTag = FALSE;
                return TRUE;
            }
        }
    }
}

/*---------------------------------------------------------------
 * ReadSVG -- streamed, SAX-like; callback(last param) is percent
 *---------------------------------------------------------------*/
TransError _export _pascal ReadSVG(FileHandle srcFile, word settings, ProgressCallback *callback)
{
    SvgScanCtx scan;
    SVGScratch *scP;
    MemHandle scH;
    dword total;
    dword done;
    word lastPct;
    MemHandle ioH;
    char *ioP;
    Boolean sawSvg;
    word pct;
    Boolean abort=FALSE;
    TransError status;

    (void)settings;

    scH = 0;
    scP = NULL;
    ioH = 0;
    ioP = NULL;
    lastPct = 0;
    done = 0;
    sawSvg = FALSE;
    status = TE_NO_ERROR;

    LOG_INIT();
    LOG_START();

    total = FilePos(srcFile, 0, FILE_POS_END);
    FilePos(srcFile, 0, FILE_POS_START);

    LOG_STR("ReadSVG", "begin");
    LOG_FILE("srcFile", srcFile);
    LOG_DWORD("totalBytes", total);

    if (!SvgStyleStackInit()) { status = TE_OUT_OF_MEMORY; goto cleanup; }

    scH = MemAlloc((word)sizeof(SVGScratch), HF_DYNAMIC, HAF_ZERO_INIT);
    if (!scH) { status = TE_OUT_OF_MEMORY; goto cleanup; }
    scP = (SVGScratch*) MemLock(scH);
    if (!scP) { status = TE_OUT_OF_MEMORY; goto cleanup; }

    ioH = MemAlloc(SVG_IO_BUF_SIZE, HF_DYNAMIC, HAF_ZERO_INIT);
    if (!ioH) { status = TE_OUT_OF_MEMORY; goto cleanup; }
    ioP = (char*) MemLock(ioH);
    if (!ioP) { status = TE_OUT_OF_MEMORY; goto cleanup; }

    SvgParserScanInit(&scan);
    scan.ioH = ioH;
    scan.ioP = ioP;

    for (;;)
    {
        if (!SvgParserScanNextTag(srcFile, &scan, scP)) { break; }

        LOG_STR_HEAD("[TAG] head", (char*) scP->tag, 96);

        if (callback && total >= 2048)
        {
            done = (dword)FilePos(srcFile, 0, FILE_POS_RELATIVE);
            if (done > total) done = total;
            {
                pct = (word)((done * 100UL) / total);
                if (pct != lastPct) { lastPct = pct; /* if ((*callback)(pct)) break; */ }

                if (((pcfm_ProgressCallback *)ProcCallFixedOrMovable_pascal)(pct, callback))
                {
                  abort = TRUE;               /* aborted? set flag... */
                  break;
                }
            }
        }

        /* handle comments/declarations, but DO NOT drop close tags blindly */
        if (scP->tag[0] == '!' || scP->tag[0] == '?')
        {
            continue;
        }

        /* root close: </svg> */
        if (scP->tag[0] == '/' && SvgParserTagIs(scP->tag + 1, "svg"))
        {
            LOG_STR("[DISPATCH]", "/svg");
            SvgStyleGroupPop();
            continue;
        }

        /* group close: </g> */
        if (scP->tag[0] == '/' && SvgParserTagIs(scP->tag + 1, "g"))
        {
            LOG_STR("[DISPATCH]", "/g");
            SvgXformGroupPop();
            SvgStyleGroupPop();
            continue;
        }

        if (SvgParserTagIs(scP->tag, "svg"))
        {
            LOG_STR("[SVG]", "root");
            /* inherit root style like a group */
            SvgStyleGroupPush(scP->tag);
            SvgViewInitFromSvgTag(scP->tag);
            sawSvg = TRUE;
            continue;
        }

        if (!sawSvg)
        {
            SvgViewInitDefault();
            sawSvg = TRUE;
        }

        /* group open: <g ...> — no drawing */
        if (SvgParserTagIs(scP->tag, "g"))
        {
            LOG_STR("[DISPATCH]", "g");
            SvgStyleGroupPush(scP->tag);
            SvgXformGroupPush(scP->tag);
            continue;
        }

        if (SvgParserTagIs(scP->tag, "line"))
        {
            LOG_STR("[DISPATCH]", "line");
            SvgShapeHandleLine(scP->tag);
        }
        else if (SvgParserTagIs(scP->tag, "polyline"))
        {
            LOG_STR("[DISPATCH]", "polyline");
            SvgShapeHandlePolyline(scP->tag, scP);
        }
        else if (SvgParserTagIs(scP->tag, "polygon"))
        {
            LOG_STR("[DISPATCH]", "polygon");
            SvgShapeHandlePolygon(scP->tag, scP);
        }
        else if (SvgParserTagIs(scP->tag, "rect"))
        {
            LOG_STR("[DISPATCH]", "rect");
            SvgShapeHandleRect(scP->tag);
        }
        else if (SvgParserTagIs(scP->tag, "ellipse"))
        {
            LOG_STR("[DISPATCH]", "ellipse");
            SvgShapeHandleEllipse(scP->tag);
        }
        else if (SvgParserTagIs(scP->tag, "circle"))
        {
            LOG_STR("[DISPATCH]", "circle");
            SvgShapeHandleCircle(scP->tag);
        }
        else if (SvgParserTagIs(scP->tag, "path"))
        {
            LOG_STR("[DISPATCH]", "path");
            SvgPathHandle(scP->tag, scP);
        }
        else
        {
            LOG_STR_HEAD("[UNHANDLED_TAG]", scP->tag, 96);
        }
    }

    if (!sawSvg)
    {
        SvgViewInitDefault();
    }

cleanup:
    if (ioP) MemUnlock(ioH);
    if (ioH) MemFree(ioH);
    if (scP) MemUnlock(scH);
    if (scH) MemFree(scH);
    SvgStyleStackFree();

    if (abort && status == TE_NO_ERROR) {
      LOG_STR("ReadSVG", "User aborted!");
      status = TE_ERROR;
    }

    LOG_END();
    return status;
}
