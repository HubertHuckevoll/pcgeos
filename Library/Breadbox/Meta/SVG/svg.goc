/***********************************************************************
 * svgParser.goc — streamed SAX-like parser, tag/attr utilities, ReadSVG
 ***********************************************************************/
@include <stdapp.goh>

#include <Ansi/string.h>
#include <Ansi/stdlib.h>
#include <Ansi/ctype.h>
#include <file.h>
#include <system.h>
#include <graphics.h>
#include <gstring.h>
#include <meta.h>
#include <float.h>

#include "SVG/svg.h"
#include "SVG/dbglog.h"

static Boolean SvgScratchEnsureCapacityCommon(SVGScratch *sc, MemHandle *handleP,
                                             void **ptrP, word *capacityP,
                                             word neededUnits, word unitSize);

Boolean SvgScratchInit(SVGScratch *sc)
{
    word tagSize;
    word dbSize;
    word ptsSize;
    word ptsBytes;
    word ptsWWFBytes;

    if (!sc)
    {
        return FALSE;
    }

    sc->tagH = 0;
    sc->tagP = NULL;
    sc->tagCapacity = 0;
    sc->dbH = 0;
    sc->dbP = NULL;
    sc->dbCapacity = 0;
    sc->ptsH = 0;
    sc->ptsP = NULL;
    sc->ptsCapacity = 0;
    sc->ptsWWFH = 0;
    sc->ptsWWFP = NULL;
    sc->ptsWWFCapacity = 0;
    sc->allocFailed = FALSE;

    tagSize = TAG_BUF_SIZE;
    sc->tagH = MemAlloc(tagSize, HF_DYNAMIC, HAF_ZERO_INIT);
    if (!sc->tagH)
    {
        sc->allocFailed = TRUE;
        SvgScratchFree(sc);
        return FALSE;
    }
    sc->tagP = (char*)MemLock(sc->tagH);
    if (!sc->tagP)
    {
        sc->allocFailed = TRUE;
        SvgScratchFree(sc);
        return FALSE;
    }
    sc->tagCapacity = tagSize;

    dbSize = MAX_PATH_ATTR_SIZE;
    sc->dbH = MemAlloc(dbSize, HF_DYNAMIC, HAF_ZERO_INIT);
    if (!sc->dbH)
    {
        sc->allocFailed = TRUE;
        SvgScratchFree(sc);
        return FALSE;
    }
    sc->dbP = (char*)MemLock(sc->dbH);
    if (!sc->dbP)
    {
        sc->allocFailed = TRUE;
        SvgScratchFree(sc);
        return FALSE;
    }
    sc->dbCapacity = dbSize;

    ptsSize = MAX_SVG_POINTS;
    ptsBytes = (word)(ptsSize * sizeof(Point));
    sc->ptsH = MemAlloc(ptsBytes, HF_DYNAMIC, HAF_ZERO_INIT);
    if (!sc->ptsH)
    {
        sc->allocFailed = TRUE;
        SvgScratchFree(sc);
        return FALSE;
    }
    sc->ptsP = (Point*)MemLock(sc->ptsH);
    if (!sc->ptsP)
    {
        sc->allocFailed = TRUE;
        SvgScratchFree(sc);
        return FALSE;
    }
    sc->ptsCapacity = ptsSize;

    ptsWWFBytes = (word)(ptsSize * sizeof(SvgWWPoint));
    sc->ptsWWFH = MemAlloc(ptsWWFBytes, HF_DYNAMIC, HAF_ZERO_INIT);
    if (!sc->ptsWWFH)
    {
        sc->allocFailed = TRUE;
        SvgScratchFree(sc);
        return FALSE;
    }
    sc->ptsWWFP = (SvgWWPoint*)MemLock(sc->ptsWWFH);
    if (!sc->ptsWWFP)
    {
        sc->allocFailed = TRUE;
        SvgScratchFree(sc);
        return FALSE;
    }
    sc->ptsWWFCapacity = ptsSize;

    return TRUE;
}

void SvgScratchFree(SVGScratch *sc)
{
    if (!sc)
    {
        return;
    }

    if (sc->tagP)
    {
        MemUnlock(sc->tagH);
        sc->tagP = NULL;
    }
    if (sc->tagH)
    {
        MemFree(sc->tagH);
        sc->tagH = 0;
    }
    sc->tagCapacity = 0;

    if (sc->dbP)
    {
        MemUnlock(sc->dbH);
        sc->dbP = NULL;
    }
    if (sc->dbH)
    {
        MemFree(sc->dbH);
        sc->dbH = 0;
    }
    sc->dbCapacity = 0;

    if (sc->ptsP)
    {
        MemUnlock(sc->ptsH);
        sc->ptsP = NULL;
    }
    if (sc->ptsH)
    {
        MemFree(sc->ptsH);
        sc->ptsH = 0;
    }
    sc->ptsCapacity = 0;

    if (sc->ptsWWFP)
    {
        MemUnlock(sc->ptsWWFH);
        sc->ptsWWFP = NULL;
    }
    if (sc->ptsWWFH)
    {
        MemFree(sc->ptsWWFH);
        sc->ptsWWFH = 0;
    }
    sc->ptsWWFCapacity = 0;
}

Boolean SvgScratchEnsureTagCapacity(SVGScratch *sc, word neededBytes)
{
    return SvgScratchEnsureCapacityCommon(sc, &sc->tagH, (void**)&sc->tagP,
                                          &sc->tagCapacity, neededBytes,
                                          (word)sizeof(byte));
}

Boolean SvgScratchEnsurePathBuf(SVGScratch *sc, word neededBytes)
{
    return SvgScratchEnsureCapacityCommon(sc, &sc->dbH, (void**)&sc->dbP,
                                          &sc->dbCapacity, neededBytes,
                                          (word)sizeof(byte));
}

Boolean SvgScratchEnsurePointCapacity(SVGScratch *sc, word neededPoints)
{
    return SvgScratchEnsureCapacityCommon(sc, &sc->ptsH, (void**)&sc->ptsP,
                                          &sc->ptsCapacity, neededPoints,
                                          (word)sizeof(Point));
}

Boolean SvgScratchEnsureWWPointCapacity(SVGScratch *sc, word neededPoints)
{
    return SvgScratchEnsureCapacityCommon(sc, &sc->ptsWWFH, (void**)&sc->ptsWWFP,
                                          &sc->ptsWWFCapacity, neededPoints,
                                          (word)sizeof(SvgWWPoint));
}

static Boolean SvgScratchEnsureCapacityCommon(SVGScratch *sc, MemHandle *handleP,
                                             void **ptrP, word *capacityP,
                                             word neededUnits, word unitSize)
{
    MemHandle newH;
    void *newP;
    word current;
    word newCapacity;
    Boolean hadPointer;
    Boolean needInit;
    word maxUnits;

    if (!sc)
    {
        return FALSE;
    }

    current = *capacityP;
    if (neededUnits < current)
    {
        return TRUE;
    }

    maxUnits = (word)(0xFFFE / unitSize);
    newCapacity = current;
    needInit = (newCapacity == 0);
    if (needInit)
    {
        newCapacity = neededUnits + 1;
    }

    while (newCapacity <= neededUnits)
    {
        if (newCapacity >= maxUnits)
        {
            newCapacity = maxUnits;
            break;
        }
        if (newCapacity == 0)
        {
            newCapacity = neededUnits + 1;
            break;
        }
        newCapacity = (word)(newCapacity << 1);
    }

    if (newCapacity <= neededUnits)
    {
        sc->allocFailed = TRUE;
        return FALSE;
    }

    if (!*handleP)
    {
        sc->allocFailed = TRUE;
        return FALSE;
    }

    hadPointer = (*ptrP != NULL);
    if (hadPointer)
    {
        MemUnlock(*handleP);
    }

    newH = MemReAlloc(*handleP, (word)(newCapacity * unitSize), HAF_ZERO_INIT);
    if (!newH)
    {
        if (hadPointer)
        {
            *ptrP = (void*)MemLock(*handleP);
        }
        sc->allocFailed = TRUE;
        return FALSE;
    }
    *handleP = newH;

    newP = (void*)MemLock(*handleP);
    if (!newP)
    {
        *ptrP = NULL;
        sc->allocFailed = TRUE;
        return FALSE;
    }

    *ptrP = newP;
    *capacityP = newCapacity;
    return TRUE;
}

/*---------------------------------------------------------------
 * ReadSVG -- streamed, SAX-like; callback(last param) is percent
 *---------------------------------------------------------------*/
TransError _export _pascal ReadSVG(FileHandle srcFile, word settings, ProgressCallback *callback)
{
    SvgScanCtx scan;
    SVGScratch *scP;
    MemHandle scH;
    dword total;
    dword done;
    MemHandle ioH;
    char *ioP;
    Boolean sawSvg;
    word pct;
    Boolean abort=FALSE;
    TransError status;

    (void)settings;

    scH = 0;
    scP = NULL;
    ioH = 0;
    ioP = NULL;
    done = 0;
    sawSvg = FALSE;
    status = TE_NO_ERROR;

    LOG_INIT();
    LOG_START();

    total = FilePos(srcFile, 0, FILE_POS_END);
    FilePos(srcFile, 0, FILE_POS_START);

    LOG_STR("ReadSVG", "begin");
    LOG_FILE("srcFile", srcFile);
    LOG_DWORD("totalBytes", total);

    if (!SvgXformStackInit()) { status = TE_OUT_OF_MEMORY; goto cleanup; }
    if (!SvgStyleStackInit()) { status = TE_OUT_OF_MEMORY; goto cleanup; }

    scH = MemAlloc((word)sizeof(SVGScratch), HF_DYNAMIC, HAF_ZERO_INIT);
    if (!scH) { status = TE_OUT_OF_MEMORY; goto cleanup; }
    scP = (SVGScratch*) MemLock(scH);
    if (!scP) { status = TE_OUT_OF_MEMORY; goto cleanup; }

    if (!SvgScratchInit(scP))
    {
        status = TE_OUT_OF_MEMORY;
        goto cleanup;
    }

    ioH = MemAlloc(SVG_IO_BUF_SIZE, HF_DYNAMIC, HAF_ZERO_INIT);
    if (!ioH) { status = TE_OUT_OF_MEMORY; goto cleanup; }
    ioP = (char*) MemLock(ioH);
    if (!ioP) { status = TE_OUT_OF_MEMORY; goto cleanup; }

    SvgParserScanInit(&scan);
    scan.ioH = ioH;
    scan.ioP = ioP;

    for (;;)
    {
        if (!SvgParserScanNextTag(srcFile, &scan, scP)) { break; }

        LOG_STR_HEAD("[TAG] head", scP->tagP, 96);

        if (callback && total >= 2048)
        {
            done = (dword)FilePos(srcFile, 0, FILE_POS_RELATIVE);
            if (done > total) done = total;
            pct = (word)((done * 100UL) / total);

            if (((pcfm_ProgressCallback *)ProcCallFixedOrMovable_pascal)(pct, callback))
            {
              abort = TRUE;               /* aborted? set flag... */
              break;
            }
        }

        /* handle comments/declarations, but DO NOT drop close tags blindly */
        if (scP->tagP[0] == '!' || scP->tagP[0] == '?')
        {
            continue;
        }

        /* root close: </svg> */
        if (scP->tagP[0] == '/' && SvgParserTagIs(scP->tagP + 1, "svg"))
        {
            LOG_STR("[DISPATCH]", "/svg");
            SvgStyleGroupPop();
            continue;
        }

        /* group close: </g> */
        if (scP->tagP[0] == '/' && SvgParserTagIs(scP->tagP + 1, "g"))
        {
            LOG_STR("[DISPATCH]", "/g");
            SvgXformGroupPop();
            SvgStyleGroupPop();
            continue;
        }

        if (SvgParserTagIs(scP->tagP, "svg"))
        {
            LOG_STR("[SVG]", "root");
            /* inherit root style like a group */
            SvgStyleGroupPush(scP->tagP);
            SvgViewInitFromSvgTag(scP->tagP);
            sawSvg = TRUE;
            continue;
        }

        if (!sawSvg)
        {
            SvgViewInitDefault();
            sawSvg = TRUE;
        }

        /* group open: <g ...> — no drawing */
        if (SvgParserTagIs(scP->tagP, "g"))
        {
            LOG_STR("[DISPATCH]", "g");
            SvgStyleGroupPush(scP->tagP);
            SvgXformGroupPush(scP->tagP);
            continue;
        }

        if (SvgParserTagIs(scP->tagP, "line"))
        {
            LOG_STR("[DISPATCH]", "line");
            SvgShapeHandleLine(scP->tagP);
        }
        else if (SvgParserTagIs(scP->tagP, "polyline"))
        {
            LOG_STR("[DISPATCH]", "polyline");
            SvgShapeHandlePolyline(scP->tagP, scP);
        }
        else if (SvgParserTagIs(scP->tagP, "polygon"))
        {
            LOG_STR("[DISPATCH]", "polygon");
            SvgShapeHandlePolygon(scP->tagP, scP);
        }
        else if (SvgParserTagIs(scP->tagP, "rect"))
        {
            LOG_STR("[DISPATCH]", "rect");
            SvgShapeHandleRect(scP->tagP);
        }
        else if (SvgParserTagIs(scP->tagP, "ellipse"))
        {
            LOG_STR("[DISPATCH]", "ellipse");
            SvgShapeHandleEllipse(scP->tagP);
        }
        else if (SvgParserTagIs(scP->tagP, "circle"))
        {
            LOG_STR("[DISPATCH]", "circle");
            SvgShapeHandleCircle(scP->tagP);
        }
        else if (SvgParserTagIs(scP->tagP, "path"))
        {
            LOG_STR("[DISPATCH]", "path");
            SvgPathHandle(scP->tagP, scP);
        }
        else
        {
            LOG_STR_HEAD("[UNHANDLED_TAG]", scP->tagP, 96);
        }
    }

    if (!sawSvg)
    {
        SvgViewInitDefault();
    }

cleanup:
    if (scP && scP->allocFailed && status == TE_NO_ERROR)
    {
        status = TE_OUT_OF_MEMORY;
    }
    if (ioP) MemUnlock(ioH);
    if (ioH) MemFree(ioH);
    if (scP)
    {
        SvgScratchFree(scP);
        MemUnlock(scH);
    }
    if (scH) MemFree(scH);
    SvgStyleStackFree();
    SvgXformStackFree();

    if (abort && status == TE_NO_ERROR) {
      LOG_STR("ReadSVG", "User aborted!");
      status = TE_ERROR;
    }

    LOG_END();
    return status;
}
