/***********************************************************************
 *
 * PROJECT:       VCImpex SVG Exporter
 * FILE:          svgexpproc.goc
 *
 * DESCRIPTION:   Implements the export procedure for SVG output
 *
 ***********************************************************************/
@include <stdapp.goh>

#include "svgexp.h"

#define VCIMPEX_SVG_GSTRING_FLAGS   (GSC_ONE)

typedef struct
{
    byte raw[VCIMPEX_SVG_ELEMENT_BUFFER_SIZE];
} VCImpexSVGGStringElement;

typedef struct
{
    ChunkHandle dataChunk;
    word length;
    word capacity;
    Boolean subpathOpen;
    Boolean hasData;
    PointWWFixed lastPoint;
    PointWWFixed subpathStart;
} VCImpexSVGPathBuilder;

VCImpexSVGGStringElement svgElementBuffer;
PointWWFixed svgPolygonBuffer[VCIMPEX_SVG_MAX_POLY_POINTS];

word _pascal VCImpexSVGExportGString(GStateHandle sourceGState, VCImpexSVGExportContext *context);

void* _pascal VCImpexSVGAs(const void *raw, word expectedOpcode);
Boolean _pascal VCImpexSVGIsLineOpcode(word elementType);
Boolean _pascal VCImpexSVGIsRectangleOpcode(word elementType);
Boolean _pascal VCImpexSVGIsRoundRectOpcode(word elementType);
Boolean _pascal VCImpexSVGIsEllipseOpcode(word elementType);
Boolean _pascal VCImpexSVGIsCurveOpcode(word elementType);
Boolean _pascal VCImpexSVGIsArcOpcode(word elementType);
Boolean _pascal VCImpexSVGIsPolygonOpcode(word elementType);
Boolean _pascal VCImpexSVGIsPathOpcode(word elementType);
Boolean _pascal VCImpexSVGIsStyleStateOpcode(word elementType);
Boolean _pascal VCImpexSVGHandleStyleStateOpcode(word elementType,
                                                 VCImpexSVGExportContext *context,
                                                 word elementSize);
void _pascal VCImpexSVGResetDashPattern(VCImpexSVGExportContext *context);

word _pascal VCImpexSVGHandleLineOpcode(word elementType, GStateHandle playbackGState, VCImpexSVGExportContext *context, PointWWFixed *currentPosition, VCImpexSVGPendingRect *pendingRect);
word _pascal VCImpexSVGHandleRectangleOpcode(word elementType, GStateHandle playbackGState, VCImpexSVGExportContext *context, PointWWFixed *currentPosition, VCImpexSVGPendingRect *pendingRect);
word _pascal VCImpexSVGHandleRoundRectOpcode(word elementType, GStateHandle playbackGState, VCImpexSVGExportContext *context, PointWWFixed *currentPosition, VCImpexSVGPendingRect *pendingRect);
word _pascal VCImpexSVGHandleEllipseOpcode(word elementType, GStateHandle playbackGState, VCImpexSVGExportContext *context, PointWWFixed *currentPosition, VCImpexSVGPendingRect *pendingRect);
word _pascal VCImpexSVGHandleCurveOpcode(word elementType, GStateHandle playbackGState, VCImpexSVGExportContext *context, PointWWFixed *currentPosition, VCImpexSVGPendingRect *pendingRect);
word _pascal VCImpexSVGHandleArcOpcode(word elementType, GStateHandle playbackGState, VCImpexSVGExportContext *context, PointWWFixed *currentPosition, VCImpexSVGPendingRect *pendingRect);
word _pascal VCImpexSVGHandlePolygonOpcode(word elementType, GStateHandle playbackGState, VCImpexSVGExportContext *context, PointWWFixed *currentPosition, VCImpexSVGPendingRect *pendingRect);
word _pascal VCImpexSVGHandlePathOpcode(word elementType, GStateHandle playbackGState, VCImpexSVGExportContext *context);
word VCImpexSVGEmitPath(GStateHandle playbackGState,
                        VCImpexSVGExportContext *context,
                        Boolean fillPath,
                        Boolean strokePath,
                        RegionFillRule fillRule);
void _pascal VCImpexSVGSetWWFixedComponent(WWFixed *component, WWFixedAsDWord value);
void _pascal VCImpexSVGPendingCaptureFill(VCImpexSVGPendingRect *pending, const VCImpexSVGExportContext *context);
void _pascal VCImpexSVGPendingCaptureStroke(VCImpexSVGPendingRect *pending, const VCImpexSVGExportContext *context);
Boolean _pascal VCImpexSVGWWFixedEqual(const WWFixed *a, const WWFixed *b);
Boolean _pascal VCImpexSVGPointEqual(const PointWWFixed *a, const PointWWFixed *b);
Boolean _pascal VCImpexSVGPendingMatchesRect(const VCImpexSVGPendingRect *pending, const PointWWFixed *corner1, const PointWWFixed *corner3);
Boolean _pascal VCImpexSVGPendingMatchesRoundRect(const VCImpexSVGPendingRect *pending, const PointWWFixed *corner1, const PointWWFixed *corner3, const WWFixed *radiusX, const WWFixed *radiusY);
Boolean _pascal VCImpexSVGPendingMatchesEllipse(const VCImpexSVGPendingRect *pending, const WWFixed *cx, const WWFixed *cy, const WWFixed *rx, const WWFixed *ry, const TransMatrix *tm);
Boolean _pascal VCImpexSVGPendingElementMatches(const VCImpexSVGPendingRect *pending, word elementType);
Boolean _pascal VCImpexSVGStyleOpcodeRequiresPendingFlush(word elementType);
word _pascal VCImpexSVGReadWord(const byte *data, word offset);
sword _pascal VCImpexSVGReadSword(const byte *data, word offset);
void _pascal VCImpexSVGReadWWFixed(const byte *data, word offset, WWFixed *value);
Boolean VCImpexSVGPathPointsEqual(const PointWWFixed *a, const PointWWFixed *b);
Boolean VCImpexSVGPathBuilderEnsureCapacity(VCImpexSVGExportContext *context,
                                            VCImpexSVGPathBuilder *builder,
                                            word additional);
Boolean VCImpexSVGPathBuilderAppendString(VCImpexSVGExportContext *context,
                                          VCImpexSVGPathBuilder *builder,
                                          const char *text);
Boolean VCImpexSVGPathBuilderInit(VCImpexSVGExportContext *context,
                                  VCImpexSVGPathBuilder *builder,
                                  word initialCapacity);
void VCImpexSVGPathBuilderDestroy(VCImpexSVGExportContext *context,
                                  VCImpexSVGPathBuilder *builder);
Boolean VCImpexSVGPathBuilderMoveTo(VCImpexSVGExportContext *context,
                                    VCImpexSVGPathBuilder *builder,
                                    const PointWWFixed *point);
Boolean VCImpexSVGPathBuilderLineTo(VCImpexSVGExportContext *context,
                                    VCImpexSVGPathBuilder *builder,
                                    const PointWWFixed *startPoint,
                                    const PointWWFixed *endPoint);
Boolean VCImpexSVGPathBuilderEnsureSubpath(VCImpexSVGExportContext *context,
                                           VCImpexSVGPathBuilder *builder,
                                           const PointWWFixed *point);
Boolean VCImpexSVGPathBuilderCurveTo(VCImpexSVGExportContext *context,
                                     VCImpexSVGPathBuilder *builder,
                                     const PointWWFixed *startPoint,
                                     const PointWWFixed *cp1,
                                     const PointWWFixed *cp2,
                                     const PointWWFixed *endPoint);
Boolean VCImpexSVGPathBuilderClose(VCImpexSVGExportContext *context,
                                   VCImpexSVGPathBuilder *builder);

void* _pascal VCImpexSVGAs(const void *raw, word expectedOpcode)
{
    const GStringElement *opcodeP;

    if (raw == NULL)
    {
        return (void*)0;
    }

    opcodeP = (const GStringElement*)raw;
    if (*opcodeP != (GStringElement)expectedOpcode)
    {
        return (void*)0;
    }

    return (void*)raw;
}

Boolean _pascal VCImpexSVGIsLineOpcode(word elementType)
{
    switch (elementType)
    {
        case GR_DRAW_LINE:
        case GR_DRAW_LINE_TO:
        case GR_DRAW_REL_LINE_TO:
        case GR_DRAW_HLINE:
        case GR_DRAW_VLINE:
        case GR_DRAW_HLINE_TO:
        case GR_DRAW_VLINE_TO:
            return TRUE;
        default:
            return FALSE;
    }
}

Boolean _pascal VCImpexSVGIsRectangleOpcode(word elementType)
{
    switch (elementType)
    {
        case GR_DRAW_RECT:
        case GR_FILL_RECT:
        case GR_DRAW_RECT_TO:
        case GR_FILL_RECT_TO:
            return TRUE;
        default:
            return FALSE;
    }
}

Boolean _pascal VCImpexSVGIsRoundRectOpcode(word elementType)
{
    switch (elementType)
    {
        case GR_DRAW_ROUND_RECT:
        case GR_FILL_ROUND_RECT:
        case GR_DRAW_ROUND_RECT_TO:
        case GR_FILL_ROUND_RECT_TO:
            return TRUE;
        default:
            return FALSE;
    }
}

Boolean _pascal VCImpexSVGIsEllipseOpcode(word elementType)
{
    switch (elementType)
    {
        case GR_DRAW_ELLIPSE:
        case GR_FILL_ELLIPSE:
            return TRUE;
        default:
            return FALSE;
    }
}

Boolean _pascal VCImpexSVGIsCurveOpcode(word elementType)
{
    switch (elementType)
    {
        case GR_DRAW_CURVE:
        case GR_DRAW_CURVE_TO:
        case GR_DRAW_REL_CURVE_TO:
            return TRUE;
        default:
            return FALSE;
    }
}

Boolean _pascal VCImpexSVGIsArcOpcode(word elementType)
{
    switch (elementType)
    {
        case GR_DRAW_ARC:
        case GR_FILL_ARC:
            return TRUE;
        default:
            return FALSE;
    }
}

Boolean _pascal VCImpexSVGIsPolygonOpcode(word elementType)
{
    switch (elementType)
    {
        case GR_DRAW_POLYGON:
        case GR_DRAW_POLYLINE:
        case GR_FILL_POLYGON:
            return TRUE;
        default:
            return FALSE;
    }
}

Boolean _pascal VCImpexSVGIsPathOpcode(word elementType)
{
    switch (elementType)
    {
        case GR_DRAW_PATH:
        case GR_FILL_PATH:
            return TRUE;
        default:
            return FALSE;
    }
}

void _pascal VCImpexSVGPendingCaptureFill(VCImpexSVGPendingRect *pending, const VCImpexSVGExportContext *context)
{
    if (pending == NULL || context == NULL)
        return;
    pending->fillColor = context->fillColor;
    pending->fillRule = context->fillRule;
    pending->haveFill = TRUE;
}

void _pascal VCImpexSVGPendingCaptureStroke(VCImpexSVGPendingRect *pending, const VCImpexSVGExportContext *context)
{
    if (pending == NULL || context == NULL)
        return;
    pending->strokeWidth = context->lineWidth;
    pending->strokeColor = context->lineColor;
    pending->strokeJoin = context->lineJoin;
    pending->strokeCap = context->lineCap;
    pending->strokeMiterLimit = context->miterLimit;
    pending->strokeStyle = context->lineStyle;
    pending->strokeDashPairCount = context->dashPairCount;
    pending->strokeDashSkipCount = context->dashSkipCount;
    memcpy(pending->strokeDashPattern, context->dashPattern, sizeof(pending->strokeDashPattern));
    pending->haveStroke = (context->lineWidth != 0);
}

Boolean _pascal VCImpexSVGWWFixedEqual(const WWFixed *a, const WWFixed *b)
{
    if ((a == NULL) || (b == NULL))
        return FALSE;
    return (a->WWF_int == b->WWF_int) && (a->WWF_frac == b->WWF_frac);
}

Boolean _pascal VCImpexSVGPointEqual(const PointWWFixed *a, const PointWWFixed *b)
{
    if ((a == NULL) || (b == NULL))
        return FALSE;
    if (!VCImpexSVGWWFixedEqual(&a->PF_x, &b->PF_x))
        return FALSE;
    if (!VCImpexSVGWWFixedEqual(&a->PF_y, &b->PF_y))
        return FALSE;
    return TRUE;
}

Boolean _pascal VCImpexSVGPendingMatchesRect(const VCImpexSVGPendingRect *pending, const PointWWFixed *corner1, const PointWWFixed *corner3)
{
    if ((pending == NULL) || (pending->active == FALSE))
        return FALSE;
    if (pending->type != VCIMPEX_SVG_PENDING_RECT)
        return FALSE;
    return VCImpexSVGPointEqual(&pending->corner1, corner1) &&
           VCImpexSVGPointEqual(&pending->corner3, corner3);
}

Boolean _pascal VCImpexSVGPendingMatchesRoundRect(const VCImpexSVGPendingRect *pending, const PointWWFixed *corner1, const PointWWFixed *corner3, const WWFixed *radiusX, const WWFixed *radiusY)
{
    if ((pending == NULL) || (pending->active == FALSE))
        return FALSE;
    if (pending->type != VCIMPEX_SVG_PENDING_ROUND_RECT)
        return FALSE;
    if (!VCImpexSVGPointEqual(&pending->corner1, corner1) ||
        !VCImpexSVGPointEqual(&pending->corner3, corner3))
    {
        return FALSE;
    }
    if (!VCImpexSVGWWFixedEqual(&pending->radiusX, radiusX) ||
        !VCImpexSVGWWFixedEqual(&pending->radiusY, radiusY))
    {
        return FALSE;
    }
    return TRUE;
}

Boolean _pascal VCImpexSVGPendingMatchesEllipse(const VCImpexSVGPendingRect *pending, const WWFixed *cx, const WWFixed *cy, const WWFixed *rx, const WWFixed *ry, const TransMatrix *tm)
{
    if ((pending == NULL) || (pending->active == FALSE))
        return FALSE;
    if (pending->type != VCIMPEX_SVG_PENDING_ELLIPSE)
        return FALSE;
    if (!VCImpexSVGWWFixedEqual(&pending->ellipseCenterX, cx) ||
        !VCImpexSVGWWFixedEqual(&pending->ellipseCenterY, cy) ||
        !VCImpexSVGWWFixedEqual(&pending->ellipseRadiusX, rx) ||
        !VCImpexSVGWWFixedEqual(&pending->ellipseRadiusY, ry))
    {
        return FALSE;
    }
    if (pending->haveTransform)
    {
        if (tm == NULL)
        {
            return FALSE;
        }
        return memcmp(&pending->transform, tm, sizeof(TransMatrix)) == 0;
    }
    else
    {
        return (tm == NULL) ? TRUE : FALSE;
    }
}

Boolean _pascal VCImpexSVGPendingElementMatches(const VCImpexSVGPendingRect *pending, word elementType)
{
    if ((pending == NULL) || (pending->active == FALSE))
        return FALSE;
    switch (pending->type)
    {
        case VCIMPEX_SVG_PENDING_RECT:
            return VCImpexSVGIsRectangleOpcode(elementType);
        case VCIMPEX_SVG_PENDING_ROUND_RECT:
            return VCImpexSVGIsRoundRectOpcode(elementType);
        case VCIMPEX_SVG_PENDING_ELLIPSE:
            return VCImpexSVGIsEllipseOpcode(elementType);
        case VCIMPEX_SVG_PENDING_NONE:
        default:
            return FALSE;
    }
}

Boolean _pascal VCImpexSVGStyleOpcodeRequiresPendingFlush(word elementType)
{
    switch (elementType)
    {
        case GR_SET_AREA_COLOR:
        case GR_SET_AREA_COLOR_INDEX:
            return TRUE;
        default:
            return FALSE;
    }
}

Boolean _pascal VCImpexSVGIsStyleStateOpcode(word elementType)
{
    switch (elementType)
    {
        case GR_SET_LINE_STYLE:
        case GR_SET_CUSTOM_LINE_STYLE:
        case GR_SET_LINE_END:
        case GR_SET_LINE_JOIN:
        case GR_SET_MITER_LIMIT:
        case GR_SET_LINE_WIDTH:
        case GR_SET_LINE_COLOR:
        case GR_SET_LINE_COLOR_INDEX:
        case GR_SET_AREA_COLOR:
        case GR_SET_AREA_COLOR_INDEX:
            return TRUE;
        default:
            return FALSE;
    }
}

void _pascal VCImpexSVGResetDashPattern(VCImpexSVGExportContext *context)
{
    if (context == NULL)
        return;

    context->dashPairCount = 0;
    context->dashSkipCount = 0;
    memset(context->dashPattern, 0, sizeof(context->dashPattern));
}

Boolean _pascal VCImpexSVGHandleStyleStateOpcode(word elementType,
                                                 VCImpexSVGExportContext *context,
                                                 word elementSize)
{
    const byte *elementData;
    word pairCount;
    word entryCount;
    word index;

    if (context == NULL)
        return FALSE;

    elementData = svgElementBuffer.raw;

    switch (elementType)
    {
        case GR_SET_LINE_STYLE:
        {
            const OpSetLineStyle *styleOp;
            word skipCount;

            if (VCImpexSVGAs(elementData, GR_SET_LINE_STYLE) == (void*)0)
            {
                return FALSE;
            }

            styleOp = (const OpSetLineStyle *)elementData;
            skipCount = (word)styleOp->OSLS_index;
            if (styleOp->OSLS_style != LS_CUSTOM)
            {
                VCImpexSVGResetDashPattern(context);
            }
            context->dashSkipCount = skipCount;
            return TRUE;
        }

        case GR_SET_CUSTOM_LINE_STYLE:
        {
            const OpSetCustomLineStyle *customOp;
            const byte *patternData;
            word skipCount;

            if (VCImpexSVGAs(elementData, GR_SET_CUSTOM_LINE_STYLE) == (void*)0)
            {
                return FALSE;
            }

            customOp = (const OpSetCustomLineStyle *)elementData;
            pairCount = customOp->OSCLS_count;
            if (pairCount > MAX_DASH_ARRAY_PAIRS)
            {
                pairCount = MAX_DASH_ARRAY_PAIRS;
            }

            entryCount = pairCount * 2;
            if ((sizeof(OpSetCustomLineStyle) + entryCount) > elementSize)
            {
                return FALSE;
            }

            VCImpexSVGResetDashPattern(context);
            skipCount = customOp->OSCLS_index;
            context->dashSkipCount = skipCount;
            context->dashPairCount = pairCount;
            patternData = elementData + sizeof(OpSetCustomLineStyle);
            for (index = 0; index < (MAX_DASH_ARRAY_PAIRS * 2); index++)
            {
                if (index < entryCount)
                {
                    context->dashPattern[index] = (word)patternData[index];
                }
                else
                {
                    context->dashPattern[index] = 0;
                }
            }
            return TRUE;
        }

        default:
            return TRUE;
    }
}

/****************************************************************************
 * VCImpex SVG Export public entry point
 ****************************************************************************/

dword _export _pascal ExportProcedure(ExportFrame *frame)
{
    GStateHandle sourceGState;
    VCImpexSVGExportContext context;
    word error;

    if ((frame == NULL) || (frame->EF_transferVMChain == 0))
        return TE_EXPORT_ERROR;

    sourceGState = GrLoadGString(frame->EF_transferVMFile, GST_VMEM,
                                 VMCHAIN_GET_VM_BLOCK(frame->EF_transferVMChain));
    if (sourceGState == 0)
        return TE_METAFILE_CREATION_ERROR;

    context.svgFile = frame->EF_outputFile;
    if (FileTruncate(context.svgFile, 0, FALSE) != 0)
    {
        GrDestroyGString(sourceGState, 0, GSKT_LEAVE_DATA);
        return TE_FILE_WRITE;
    }

    FilePos(context.svgFile, 0, FILE_POS_START);
    GrGetGStringBoundsDWord(sourceGState, 0, 0, &context.bounds);
    context.lineWidth = 0;
    context.lineColor = 0;
    context.fillColor = 0;
    context.lineJoin = LJ_MITERED;
    context.lineCap = LE_BUTTCAP;
    context.miterLimit = 0;
    context.lineStyle = LS_SOLID;
    VCImpexSVGResetDashPattern(&context);
    context.fillRule = WINDING;

    context.bufferHeapH = MemAllocLMem(LMEM_TYPE_GENERAL, 0);
    if (context.bufferHeapH == NullHandle)
    {
        GrDestroyGString(sourceGState, 0, GSKT_LEAVE_DATA);
        return TE_OUT_OF_MEMORY;
    }

    error = VCImpexSVGExportGString(sourceGState, &context);

    if (context.bufferHeapH != NullHandle)
    {
        MemFree(context.bufferHeapH);
        context.bufferHeapH = NullHandle;
    }

    GrDestroyGString(sourceGState, 0, GSKT_LEAVE_DATA);

    return error;
}

/****************************************************************************
 * Core gstring traversal
 ****************************************************************************/

word _pascal VCImpexSVGExportGString(GStateHandle sourceGState, VCImpexSVGExportContext *context)
{
    MemHandle playbackBlockH;
    ChunkHandle playbackChunk;
    GStateHandle playbackGState;
    word elementType;
    word elementSize;
    PointWWFixed currentPosition;
    word error;
    GSRetType gsr;
    VCImpexSVGPendingRect pendingRect;
    word handlerResult;
    word pathDepth = 0;


    playbackBlockH = MemAllocLMem(LMEM_TYPE_GENERAL, sizeof(LMemBlockHeader));
    if (playbackBlockH == NullHandle)
    {
        return TE_OUT_OF_MEMORY;
    }

    playbackGState = GrCreateGString(playbackBlockH, GST_CHUNK, (word*) &playbackChunk);
    if (playbackGState == 0)
    {
        MemFree(playbackBlockH);
        return TE_OUT_OF_MEMORY;
    }

    if (!VCImpexSVGWriteHeader(context))
    {
        GrDestroyGString(playbackGState, 0, GSKT_KILL_DATA);
        return TE_FILE_WRITE;
    }

    error = TE_NO_ERROR;
    VCImpexSVGInitPendingRect(&pendingRect);

    /* the main loop */
    for(gsr = GrDrawGString(playbackGState, sourceGState, 0, 0, GSC_ONE, &elementType);
        gsr == GSRT_ONE;
        gsr = GrDrawGString(playbackGState, sourceGState, 0, 0, GSC_ONE, &elementType))
    {
        GrGetGStringElement(playbackGState, sourceGState, sizeof(svgElementBuffer.raw),
                            svgElementBuffer.raw, &elementSize);

        if (elementSize > sizeof(svgElementBuffer.raw))
        {
            error = TE_EXPORT_ERROR;
            break;
        }

        VCImpexSVGUpdateDrawingState(playbackGState, context);
        GrGetCurPosWWFixed(playbackGState, &currentPosition);

        if (VCImpexSVGIsStyleStateOpcode(elementType))
        {
            if (VCImpexSVGStyleOpcodeRequiresPendingFlush(elementType))
            {
                if (!VCImpexSVGFlushPendingRect(context, &pendingRect))
                {
                    error = TE_FILE_WRITE;
                    break;
                }
            }
            if (!VCImpexSVGHandleStyleStateOpcode(elementType, context, elementSize))
            {
                error = TE_EXPORT_ERROR;
                break;
            }
            continue;
        }

        /* Flush pending rectangle if we hit a transform/state change op */
        if ((elementType >= GR_APPLY_ROTATION && elementType <= GR_XFORM_1F) ||
            (elementType >= GR_SAVE_STATE && elementType <= GR_ATTR_9F))
        {
            if (!VCImpexSVGFlushPendingRect(context, &pendingRect))
            {
                error = TE_FILE_WRITE;
                break;
            }
            /* skip handling state ops */
            continue;
        }

        /* Flush pending element if the incoming opcode cannot complete it */
        if ((pendingRect.active != FALSE) &&
            (VCImpexSVGPendingElementMatches(&pendingRect, elementType) == FALSE))
        {
            if (!VCImpexSVGFlushPendingRect(context, &pendingRect))
            {
                error = TE_FILE_WRITE;
                break;
            }
        }

        switch (elementType)
        {
            case GR_BEGIN_PATH:
                pathDepth++;
                continue;

            case GR_END_PATH:
                if (pathDepth != 0)
                {
                    pathDepth--;
                }
                else
                {
                    pathDepth = 0;
                }
                continue;

#ifdef GR_SET_NULL_PATH
            case GR_SET_NULL_PATH:
                pathDepth = 0;
                continue;
#endif

            case GR_CLOSE_SUB_PATH:
                /* nothing to emit directly for subpath closures */
                continue;

            default:
                break;
        }

        if (pathDepth != 0)
        {
            /* suppress geometry opcodes recorded during an open path */
            continue;
        }

        handlerResult = TE_NO_ERROR;
        if (VCImpexSVGIsLineOpcode(elementType))
        {
            handlerResult = VCImpexSVGHandleLineOpcode(elementType, playbackGState, context, &currentPosition, &pendingRect);
        }
        else if (VCImpexSVGIsRectangleOpcode(elementType))
        {
            handlerResult = VCImpexSVGHandleRectangleOpcode(elementType, playbackGState, context, &currentPosition, &pendingRect);
        }
        else if (VCImpexSVGIsRoundRectOpcode(elementType))
        {
            handlerResult = VCImpexSVGHandleRoundRectOpcode(elementType, playbackGState, context, &currentPosition, &pendingRect);
        }
        else if (VCImpexSVGIsEllipseOpcode(elementType))
        {
            handlerResult = VCImpexSVGHandleEllipseOpcode(elementType, playbackGState, context, &currentPosition, &pendingRect);
        }
        else if (VCImpexSVGIsCurveOpcode(elementType))
        {
            handlerResult = VCImpexSVGHandleCurveOpcode(elementType, playbackGState, context, &currentPosition, &pendingRect);
        }
        else if (VCImpexSVGIsArcOpcode(elementType))
        {
            handlerResult = VCImpexSVGHandleArcOpcode(elementType, playbackGState, context, &currentPosition, &pendingRect);
        }
        else if (VCImpexSVGIsPolygonOpcode(elementType))
        {
            handlerResult = VCImpexSVGHandlePolygonOpcode(elementType, playbackGState, context, &currentPosition, &pendingRect);
        }
        else if (VCImpexSVGIsPathOpcode(elementType))
        {
            handlerResult = VCImpexSVGHandlePathOpcode(elementType, playbackGState, context);
        }

        if (handlerResult != TE_NO_ERROR)
        {
            error = handlerResult;
            break;
        }
    }

    /* Flush any pending rectangle before footer */
    if (error == TE_NO_ERROR)
    {
        if (!VCImpexSVGFlushPendingRect(context, &pendingRect))
        {
            error = TE_FILE_WRITE;
        }
    }

    if (error == TE_NO_ERROR)
    {
        if (!VCImpexSVGWriteFooter(context))
        {
            error = TE_FILE_WRITE;
        }
    }

    GrDestroyGString(playbackGState, 0, GSKT_KILL_DATA);

    return error;
}

/****************************************************************************
 * Opcode handlers
 ****************************************************************************/

word _pascal VCImpexSVGHandleLineOpcode(word elementType, GStateHandle playbackGState, VCImpexSVGExportContext *context, PointWWFixed *currentPosition, VCImpexSVGPendingRect *pendingRect)
{
    PointWWFixed startPoint;
    PointWWFixed endPoint;
    Point intPoint1;
    Point intPoint2;
    Point tempPoint;
    PointWWFixed deltaPoint;
    WWFixedAsDWord componentValue;
    const byte *elementData;
    word offset;
    word wordValue1;

    (void)pendingRect;

    elementData = svgElementBuffer.raw;

    switch (elementType)
    {
        case GR_DRAW_LINE:
            if (VCImpexSVGAs(elementData, GR_DRAW_LINE) == (void*)0)
            {
                return TE_EXPORT_ERROR;
            }
            offset = sizeof(GStringElement);
            intPoint1.P_x = (sword)VCImpexSVGReadWord(elementData, offset);
            offset += sizeof(word);
            intPoint1.P_y = (sword)VCImpexSVGReadWord(elementData, offset);
            offset += sizeof(word);
            intPoint2.P_x = (sword)VCImpexSVGReadWord(elementData, offset);
            offset += sizeof(word);
            intPoint2.P_y = (sword)VCImpexSVGReadWord(elementData, offset);
            VCImpexSVGTransformPointFromInt(playbackGState, &intPoint1, &startPoint);
            VCImpexSVGTransformPointFromInt(playbackGState, &intPoint2, &endPoint);
            if (!VCImpexSVGWriteLineElement(context, &startPoint, &endPoint))
            {
                return TE_FILE_WRITE;
            }
            return TE_NO_ERROR;

        case GR_DRAW_LINE_TO:
            VCImpexSVGTransformPointFromFixed(playbackGState, currentPosition, &startPoint);
            if (VCImpexSVGAs(elementData, GR_DRAW_LINE_TO) == (void*)0)
            {
                return TE_EXPORT_ERROR;
            }
            offset = sizeof(GStringElement);
            intPoint1.P_x = (sword)VCImpexSVGReadWord(elementData, offset);
            offset += sizeof(word);
            intPoint1.P_y = (sword)VCImpexSVGReadWord(elementData, offset);
            VCImpexSVGTransformPointFromInt(playbackGState, &intPoint1, &endPoint);
            if (!VCImpexSVGWriteLineElement(context, &startPoint, &endPoint))
            {
                return TE_FILE_WRITE;
            }
            return TE_NO_ERROR;

        case GR_DRAW_REL_LINE_TO:
            VCImpexSVGTransformPointFromFixed(playbackGState, currentPosition, &startPoint);
            if (VCImpexSVGAs(elementData, GR_DRAW_REL_LINE_TO) == (void*)0)
            {
                return TE_EXPORT_ERROR;
            }
            offset = sizeof(GStringElement);
            VCImpexSVGReadWWFixed(elementData, offset, &deltaPoint.PF_x);
            offset += sizeof(WWFixed);
            VCImpexSVGReadWWFixed(elementData, offset, &deltaPoint.PF_y);
            VCImpexSVGTransformRelativePoint(playbackGState, &deltaPoint, &endPoint);
            if (!VCImpexSVGWriteLineElement(context, &startPoint, &endPoint))
            {
                return TE_FILE_WRITE;
            }
            return TE_NO_ERROR;

        case GR_DRAW_HLINE:
            if (VCImpexSVGAs(elementData, GR_DRAW_HLINE) == (void*)0)
            {
                return TE_EXPORT_ERROR;
            }
            offset = sizeof(GStringElement);
            tempPoint.P_x = (sword)VCImpexSVGReadWord(elementData, offset);
            offset += sizeof(word);
            tempPoint.P_y = (sword)VCImpexSVGReadWord(elementData, offset);
            offset += sizeof(word);
            wordValue1 = VCImpexSVGReadWord(elementData, offset);
            VCImpexSVGTransformPointFromInt(playbackGState, &tempPoint, &startPoint);
            componentValue = ((WWFixedAsDWord)((sdword)(sword)wordValue1)) << 16;
            VCImpexSVGSetWWFixedComponent(&currentPosition->PF_x, componentValue);
            VCImpexSVGTransformPointFromFixed(playbackGState, currentPosition, &endPoint);
            if (!VCImpexSVGWriteLineElement(context, &startPoint, &endPoint))
            {
                return TE_FILE_WRITE;
            }
            return TE_NO_ERROR;

        case GR_DRAW_VLINE:
            if (VCImpexSVGAs(elementData, GR_DRAW_VLINE) == (void*)0)
            {
                return TE_EXPORT_ERROR;
            }
            offset = sizeof(GStringElement);
            tempPoint.P_x = (sword)VCImpexSVGReadWord(elementData, offset);
            offset += sizeof(word);
            tempPoint.P_y = (sword)VCImpexSVGReadWord(elementData, offset);
            offset += sizeof(word);
            wordValue1 = VCImpexSVGReadWord(elementData, offset);
            VCImpexSVGTransformPointFromInt(playbackGState, &tempPoint, &startPoint);
            componentValue = ((WWFixedAsDWord)((sdword)(sword)wordValue1)) << 16;
            VCImpexSVGSetWWFixedComponent(&currentPosition->PF_y, componentValue);
            VCImpexSVGTransformPointFromFixed(playbackGState, currentPosition, &endPoint);
            if (!VCImpexSVGWriteLineElement(context, &startPoint, &endPoint))
            {
                return TE_FILE_WRITE;
            }
            return TE_NO_ERROR;

        case GR_DRAW_HLINE_TO:
            VCImpexSVGTransformPointFromFixed(playbackGState, currentPosition, &startPoint);
            if (VCImpexSVGAs(elementData, GR_DRAW_HLINE_TO) == (void*)0)
            {
                return TE_EXPORT_ERROR;
            }
            offset = sizeof(GStringElement);
            wordValue1 = VCImpexSVGReadWord(elementData, offset);
            componentValue = ((WWFixedAsDWord)((sdword)(sword)wordValue1)) << 16;
            VCImpexSVGSetWWFixedComponent(&currentPosition->PF_x, componentValue);
            VCImpexSVGTransformPointFromFixed(playbackGState, currentPosition, &endPoint);
            if (!VCImpexSVGWriteLineElement(context, &startPoint, &endPoint))
            {
                return TE_FILE_WRITE;
            }
            return TE_NO_ERROR;

        case GR_DRAW_VLINE_TO:
            VCImpexSVGTransformPointFromFixed(playbackGState, currentPosition, &startPoint);
            if (VCImpexSVGAs(elementData, GR_DRAW_VLINE_TO) == (void*)0)
            {
                return TE_EXPORT_ERROR;
            }
            offset = sizeof(GStringElement);
            wordValue1 = VCImpexSVGReadWord(elementData, offset);
            componentValue = ((WWFixedAsDWord)((sdword)(sword)wordValue1)) << 16;
            VCImpexSVGSetWWFixedComponent(&currentPosition->PF_y, componentValue);
            VCImpexSVGTransformPointFromFixed(playbackGState, currentPosition, &endPoint);
            if (!VCImpexSVGWriteLineElement(context, &startPoint, &endPoint))
            {
                return TE_FILE_WRITE;
            }
            return TE_NO_ERROR;

        default:
            break;
    }
    return TE_NO_ERROR;
}

word _pascal VCImpexSVGHandleRectangleOpcode(word elementType, GStateHandle playbackGState, VCImpexSVGExportContext *context, PointWWFixed *currentPosition, VCImpexSVGPendingRect *pendingRect)
{
    PointWWFixed corner1;
    PointWWFixed corner3;
    Point intCorner1;
    Point intCorner3;
    Boolean filled;
    const byte *elementData;
    word offset;
    word wordValue1;
    word wordValue2;

    elementData = svgElementBuffer.raw;

    switch (elementType)
    {
        case GR_DRAW_RECT:
        case GR_FILL_RECT:
            if (VCImpexSVGAs(elementData, elementType) == (void*)0)
            {
                return TE_EXPORT_ERROR;
            }
            offset = sizeof(GStringElement);
            intCorner1.P_x = (sword)VCImpexSVGReadWord(elementData, offset);
            offset += sizeof(word);
            intCorner1.P_y = (sword)VCImpexSVGReadWord(elementData, offset);
            offset += sizeof(word);
            intCorner3.P_x = (sword)VCImpexSVGReadWord(elementData, offset);
            offset += sizeof(word);
            intCorner3.P_y = (sword)VCImpexSVGReadWord(elementData, offset);
            VCImpexSVGTransformPointFromInt(playbackGState, &intCorner1, &corner1);
            VCImpexSVGTransformPointFromInt(playbackGState, &intCorner3, &corner3);
            filled = (elementType == GR_FILL_RECT);
            /* Coalescing logic */
            if (pendingRect != NULL)
            {
                WWFixedAsDWord c1x = VCImpexSVGPackWWFixed(&corner1.PF_x);
                WWFixedAsDWord c1y = VCImpexSVGPackWWFixed(&corner1.PF_y);
                WWFixedAsDWord c3x = VCImpexSVGPackWWFixed(&corner3.PF_x);
                WWFixedAsDWord c3y = VCImpexSVGPackWWFixed(&corner3.PF_y);
                if (pendingRect->active)
                {
                    WWFixedAsDWord pc1x = VCImpexSVGPackWWFixed(&pendingRect->corner1.PF_x);
                    WWFixedAsDWord pc1y = VCImpexSVGPackWWFixed(&pendingRect->corner1.PF_y);
                    WWFixedAsDWord pc3x = VCImpexSVGPackWWFixed(&pendingRect->corner3.PF_x);
                    WWFixedAsDWord pc3y = VCImpexSVGPackWWFixed(&pendingRect->corner3.PF_y);
                    if (pc1x == c1x && pc1y == c1y && pc3x == c3x && pc3y == c3y)
                    {
                        if (filled)
                        {
                            VCImpexSVGPendingCaptureFill(pendingRect, context);
                        }
                        else
                        {
                            VCImpexSVGPendingCaptureStroke(pendingRect, context);
                        }
                        if (pendingRect->haveFill && pendingRect->haveStroke)
                        {
                            if (!VCImpexSVGFlushPendingRect(context, pendingRect))
                            {
                                return TE_FILE_WRITE;
                            }
                        }
                        return TE_NO_ERROR;
                    }
                    /* geometry differs: flush old then start new */
                    if (!VCImpexSVGFlushPendingRect(context, pendingRect))
                    {
                        return TE_FILE_WRITE;
                    }
                }
                /* Start new pending */
                pendingRect->active = TRUE;
                pendingRect->type = VCIMPEX_SVG_PENDING_RECT;
                pendingRect->corner1 = corner1;
                pendingRect->corner3 = corner3;
                pendingRect->radiusX.WWF_int = pendingRect->radiusX.WWF_frac = 0;
                pendingRect->radiusY.WWF_int = pendingRect->radiusY.WWF_frac = 0;
                pendingRect->ellipseCenterX.WWF_int = pendingRect->ellipseCenterX.WWF_frac = 0;
                pendingRect->ellipseCenterY.WWF_int = pendingRect->ellipseCenterY.WWF_frac = 0;
                pendingRect->ellipseRadiusX.WWF_int = pendingRect->ellipseRadiusX.WWF_frac = 0;
                pendingRect->ellipseRadiusY.WWF_int = pendingRect->ellipseRadiusY.WWF_frac = 0;
                pendingRect->haveTransform = FALSE;
                pendingRect->haveFill = FALSE;
                pendingRect->haveStroke = FALSE;
                if (filled)
                {
                    VCImpexSVGPendingCaptureFill(pendingRect, context);
                }
                else
                {
                    VCImpexSVGPendingCaptureStroke(pendingRect, context);
                }
                return TE_NO_ERROR;
            }
            /* Fallback: no coalescing */
            if (!VCImpexSVGWriteRectElement(context,
                                             &corner1,
                                             &corner3,
                                             (filled == FALSE),
                                             (filled != FALSE),
                                             filled))
            {
                return TE_FILE_WRITE;
            }
            return TE_NO_ERROR;

        case GR_DRAW_RECT_TO:
        case GR_FILL_RECT_TO:
            VCImpexSVGTransformPointFromFixed(playbackGState, currentPosition, &corner1);
            if (VCImpexSVGAs(elementData, elementType) == (void*)0)
            {
                return TE_EXPORT_ERROR;
            }
            offset = sizeof(GStringElement);
            wordValue1 = VCImpexSVGReadWord(elementData, offset);
            offset += sizeof(word);
            wordValue2 = VCImpexSVGReadWord(elementData, offset);
            intCorner3.P_x = (sword)wordValue1;
            intCorner3.P_y = (sword)wordValue2;
            VCImpexSVGTransformPointFromInt(playbackGState, &intCorner3, &corner3);
            filled = (elementType == GR_FILL_RECT_TO);
            if (pendingRect != NULL)
            {
                WWFixedAsDWord c1x = VCImpexSVGPackWWFixed(&corner1.PF_x);
                WWFixedAsDWord c1y = VCImpexSVGPackWWFixed(&corner1.PF_y);
                WWFixedAsDWord c3x = VCImpexSVGPackWWFixed(&corner3.PF_x);
                WWFixedAsDWord c3y = VCImpexSVGPackWWFixed(&corner3.PF_y);
                if (pendingRect->active)
                {
                    WWFixedAsDWord pc1x = VCImpexSVGPackWWFixed(&pendingRect->corner1.PF_x);
                    WWFixedAsDWord pc1y = VCImpexSVGPackWWFixed(&pendingRect->corner1.PF_y);
                    WWFixedAsDWord pc3x = VCImpexSVGPackWWFixed(&pendingRect->corner3.PF_x);
                    WWFixedAsDWord pc3y = VCImpexSVGPackWWFixed(&pendingRect->corner3.PF_y);
                    if (pc1x == c1x && pc1y == c1y && pc3x == c3x && pc3y == c3y)
                    {
                        if (filled)
                        {
                            VCImpexSVGPendingCaptureFill(pendingRect, context);
                        }
                        else
                        {
                            VCImpexSVGPendingCaptureStroke(pendingRect, context);
                        }
                        if (pendingRect->haveFill && pendingRect->haveStroke)
                        {
                            if (!VCImpexSVGFlushPendingRect(context, pendingRect))
                            {
                                return TE_FILE_WRITE;
                            }
                        }
                        return TE_NO_ERROR;
                    }
                    if (!VCImpexSVGFlushPendingRect(context, pendingRect))
                    {
                        return TE_FILE_WRITE;
                    }
                }
                pendingRect->active = TRUE;
                pendingRect->type = VCIMPEX_SVG_PENDING_RECT;
                pendingRect->corner1 = corner1;
                pendingRect->corner3 = corner3;
                pendingRect->radiusX.WWF_int = pendingRect->radiusX.WWF_frac = 0;
                pendingRect->radiusY.WWF_int = pendingRect->radiusY.WWF_frac = 0;
                pendingRect->ellipseCenterX.WWF_int = pendingRect->ellipseCenterX.WWF_frac = 0;
                pendingRect->ellipseCenterY.WWF_int = pendingRect->ellipseCenterY.WWF_frac = 0;
                pendingRect->ellipseRadiusX.WWF_int = pendingRect->ellipseRadiusX.WWF_frac = 0;
                pendingRect->ellipseRadiusY.WWF_int = pendingRect->ellipseRadiusY.WWF_frac = 0;
                pendingRect->haveTransform = FALSE;
                pendingRect->haveFill = FALSE;
                pendingRect->haveStroke = FALSE;
                if (filled)
                {
                    VCImpexSVGPendingCaptureFill(pendingRect, context);
                }
                else
                {
                    VCImpexSVGPendingCaptureStroke(pendingRect, context);
                }
                return TE_NO_ERROR;
            }
            if (!VCImpexSVGWriteRectElement(context,
                                             &corner1,
                                             &corner3,
                                             (filled == FALSE),
                                             (filled != FALSE),
                                             filled))
            {
                return TE_FILE_WRITE;
            }
            return TE_NO_ERROR;

        default:
            break;
    }
    return TE_NO_ERROR;
}

word _pascal VCImpexSVGHandleEllipseOpcode(word elementType, GStateHandle playbackGState, VCImpexSVGExportContext *context, PointWWFixed *currentPosition, VCImpexSVGPendingRect *pendingRect)
{
    WWFixed cx = {0};
    WWFixed cy = {0};
    WWFixed rx = {0};
    WWFixed ry = {0};
    sword x1, y1, x2, y2;
    sdword sum;
    sword dx, dy;
    TransMatrix tm;
    Boolean filled = FALSE;
    const byte *elementData;
    word offset;

    (void)currentPosition;

    elementData = svgElementBuffer.raw;

    switch (elementType)
    {
        case GR_DRAW_ELLIPSE:
        case GR_FILL_ELLIPSE:
            if (VCImpexSVGAs(elementData, elementType) == (void*)0)
            {
                return TE_EXPORT_ERROR;
            }
            offset = sizeof(GStringElement);
            x1 = (sword)VCImpexSVGReadWord(elementData, offset);
            offset += sizeof(word);
            y1 = (sword)VCImpexSVGReadWord(elementData, offset);
            offset += sizeof(word);
            x2 = (sword)VCImpexSVGReadWord(elementData, offset);
            offset += sizeof(word);
            y2 = (sword)VCImpexSVGReadWord(elementData, offset);

            /* center x */
            sum = (sdword)x1 + (sdword)x2;
            cx.WWF_int = (sword)(sum / 2);
            cx.WWF_frac = (word)((sum & 1) ? 0x8000 : 0);
            /* center y */
            sum = (sdword)y1 + (sdword)y2;
            cy.WWF_int = (sword)(sum / 2);
            cy.WWF_frac = (word)((sum & 1) ? 0x8000 : 0);

            /* radii */
            dx = (sword)(x2 - x1);
            if (dx < 0) dx = -dx;
            rx.WWF_int = (sword)(dx / 2);
            rx.WWF_frac = (word)((dx & 1) ? 0x8000 : 0);

            dy = (sword)(y2 - y1);
            if (dy < 0) dy = -dy;
            ry.WWF_int = (sword)(dy / 2);
            ry.WWF_frac = (word)((dy & 1) ? 0x8000 : 0);

            filled = (elementType == GR_FILL_ELLIPSE);

            /* get current transform so we can emit exact transform matrix */
            GrGetTransform(playbackGState, &tm);
            break;

        default:
            return TE_NO_ERROR;
    }

    if (pendingRect != NULL)
    {
        if (VCImpexSVGPendingMatchesEllipse(pendingRect, &cx, &cy, &rx, &ry, &tm))
        {
            if (filled)
            {
                VCImpexSVGPendingCaptureFill(pendingRect, context);
            }
            else
            {
                VCImpexSVGPendingCaptureStroke(pendingRect, context);
            }
            if (pendingRect->haveFill && pendingRect->haveStroke)
            {
                if (!VCImpexSVGFlushPendingRect(context, pendingRect))
                {
                    return TE_FILE_WRITE;
                }
            }
            return TE_NO_ERROR;
        }

        if (!VCImpexSVGFlushPendingRect(context, pendingRect))
        {
            return TE_FILE_WRITE;
        }

        pendingRect->active = TRUE;
        pendingRect->type = VCIMPEX_SVG_PENDING_ELLIPSE;
        pendingRect->ellipseCenterX = cx;
        pendingRect->ellipseCenterY = cy;
        pendingRect->ellipseRadiusX = rx;
        pendingRect->ellipseRadiusY = ry;
        pendingRect->haveTransform = TRUE;
        pendingRect->transform = tm;
        pendingRect->corner1.PF_x.WWF_int = pendingRect->corner1.PF_x.WWF_frac = 0;
        pendingRect->corner1.PF_y.WWF_int = pendingRect->corner1.PF_y.WWF_frac = 0;
        pendingRect->corner3 = pendingRect->corner1;
        pendingRect->haveFill = FALSE;
        pendingRect->haveStroke = FALSE;
        if (filled)
        {
            VCImpexSVGPendingCaptureFill(pendingRect, context);
        }
        else
        {
            VCImpexSVGPendingCaptureStroke(pendingRect, context);
        }
        return TE_NO_ERROR;
    }

    if (!VCImpexSVGWriteEllipseElement(context,
                                       &cx,
                                       &cy,
                                       &rx,
                                       &ry,
                                       (filled == FALSE),
                                       (filled != FALSE),
                                       filled,
                                       &tm))
    {
        return TE_FILE_WRITE;
    }

    return TE_NO_ERROR;
}

word _pascal VCImpexSVGHandlePolygonOpcode(word elementType, GStateHandle playbackGState, VCImpexSVGExportContext *context, PointWWFixed *currentPosition, VCImpexSVGPendingRect *pendingRect)
{
    word pointCount;
    word index;
    Boolean closeShape;
    Boolean filledShape;
    const byte *elementData;
    word offset;
    Point intPoint;
    RegionFillRule fillRule;

    (void)currentPosition;
    (void)pendingRect;

    elementData = svgElementBuffer.raw;
    fillRule = context->fillRule;

    switch (elementType)
    {
        case GR_DRAW_POLYGON:
            if (VCImpexSVGAs(elementData, GR_DRAW_POLYGON) == (void*)0)
            {
                return TE_EXPORT_ERROR;
            }
            offset = sizeof(GStringElement);
            pointCount = VCImpexSVGReadWord(elementData, offset);
            offset += sizeof(word);
            closeShape = TRUE;
            filledShape = FALSE;
            break;

        case GR_DRAW_POLYLINE:
            if (VCImpexSVGAs(elementData, GR_DRAW_POLYLINE) == (void*)0)
            {
                return TE_EXPORT_ERROR;
            }
            offset = sizeof(GStringElement);
            pointCount = VCImpexSVGReadWord(elementData, offset);
            offset += sizeof(word);
            closeShape = FALSE;
            filledShape = FALSE;
            break;

        case GR_FILL_POLYGON:
            if (VCImpexSVGAs(elementData, GR_FILL_POLYGON) == (void*)0)
            {
                return TE_EXPORT_ERROR;
            }
            offset = sizeof(GStringElement);
            pointCount = VCImpexSVGReadWord(elementData, offset);
            offset += sizeof(word);
            fillRule = (RegionFillRule)elementData[offset];
            offset += sizeof(RegionFillRule);
            closeShape = TRUE;
            filledShape = TRUE;
            break;

        default:
            return TE_NO_ERROR;
    }

    if (pointCount == 0)
    {
        return TE_NO_ERROR;
    }

    if (pointCount > VCIMPEX_SVG_MAX_POLY_POINTS)
    {
        return TE_EXPORT_ERROR;
    }

    for (index = 0; index < pointCount; index++)
    {
        intPoint.P_x = (sword)VCImpexSVGReadWord(elementData, offset);
        offset += sizeof(word);
        intPoint.P_y = (sword)VCImpexSVGReadWord(elementData, offset);
        offset += sizeof(word);
        VCImpexSVGTransformPointFromInt(playbackGState, &intPoint, &svgPolygonBuffer[index]);
    }

    {
        WWFixedAsDWord savedLineWidth = 0;
        Boolean strokeDisabled = FALSE;

        if ((filledShape != FALSE) && (context->lineWidth != 0))
        {
            strokeDisabled = TRUE;
            savedLineWidth = context->lineWidth;
            context->lineWidth = 0;
        }

        if (!VCImpexSVGWritePolygonElement(context, svgPolygonBuffer, pointCount, closeShape, filledShape, fillRule))
        {
            if (strokeDisabled != FALSE)
            {
                context->lineWidth = savedLineWidth;
            }
            return TE_FILE_WRITE;
        }

        if (strokeDisabled != FALSE)
        {
            context->lineWidth = savedLineWidth;
        }
    }
    return TE_NO_ERROR;
}

word _pascal VCImpexSVGHandlePathOpcode(word elementType, GStateHandle playbackGState, VCImpexSVGExportContext *context)
{
    RegionFillRule fillRule = context->fillRule;
    const byte *elementData = svgElementBuffer.raw;

    if (context == NULL)
        return TE_EXPORT_ERROR;

    if (elementType == GR_FILL_PATH)
    {
        if (VCImpexSVGAs(elementData, GR_FILL_PATH) == (void*)0)
        {
            return TE_EXPORT_ERROR;
        }
        fillRule = (RegionFillRule)elementData[sizeof(GStringElement)];
        return VCImpexSVGEmitPath(playbackGState, context, TRUE, FALSE, fillRule);
    }

    if (elementType == GR_DRAW_PATH)
    {
        return VCImpexSVGEmitPath(playbackGState, context, FALSE, TRUE, fillRule);
    }

    return TE_NO_ERROR;
}

word VCImpexSVGEmitPath(GStateHandle playbackGState,
                        VCImpexSVGExportContext *context,
                        Boolean fillPath,
                        Boolean strokePath,
                        RegionFillRule fillRule)
{
    MemHandle pathMem;
    void *pathPtr = (void*)0;
    GStateHandle pathSource = 0;
    MemHandle pathPlaybackBlock = NullHandle;
    GStateHandle pathPlayback = 0;
    ChunkHandle pathPlaybackChunk;
    VCImpexSVGPathBuilder builder;
    Boolean builderReady = FALSE;
    GSRetType gsr;
    word elementType;
    word elementSize;
    PointWWFixed currentPosition;
    const byte *elementData;
    Point intPoint;
    PointWWFixed startPoint;
    PointWWFixed endPoint;
    PointWWFixed cp1Point;
    PointWWFixed cp2Point;
    PointWWFixed tempPoint;
    WWFixedAsDWord componentValue;
    word wordValue1;
    word result = TE_NO_ERROR;
    ChunkHandle styleChunk = NullChunk;
    ChunkHandle bufferChunk = NullChunk;
    Boolean strokeDisabled = FALSE;
    WWFixedAsDWord savedLineWidth = 0;

    memset(&builder, 0, sizeof(builder));

    if ((context == NULL) || (playbackGState == 0))
        return TE_EXPORT_ERROR;

    pathMem = GrGetPath(playbackGState, GPT_CURRENT);
    if (pathMem == NullHandle)
    {
        return TE_NO_ERROR;
    }

    pathPtr = MemLock(pathMem);
    if (pathPtr == NULL)
    {
        MemFree(pathMem);
        return TE_OUT_OF_MEMORY;
    }

    pathSource = GrLoadGString(PtrToSegment(pathPtr), GST_PTR, PtrToOffset(pathPtr));
    if (pathSource == 0)
    {
        MemUnlock(pathMem);
        MemFree(pathMem);
        return TE_OUT_OF_MEMORY;
    }

    pathPlaybackBlock = MemAllocLMem(LMEM_TYPE_GENERAL, sizeof(LMemBlockHeader));
    if (pathPlaybackBlock == NullHandle)
    {
        result = TE_OUT_OF_MEMORY;
        goto cleanup;
    }

    pathPlayback = GrCreateGString(pathPlaybackBlock, GST_CHUNK, (word*)&pathPlaybackChunk);
    if (pathPlayback == 0)
    {
        MemFree(pathPlaybackBlock);
        pathPlaybackBlock = NullHandle;
        result = TE_OUT_OF_MEMORY;
        goto cleanup;
    }
    pathPlaybackBlock = NullHandle;

    if (!VCImpexSVGPathBuilderInit(context, &builder, 256))
    {
        result = TE_OUT_OF_MEMORY;
        goto cleanup;
    }
    builderReady = TRUE;

    for (gsr = GrDrawGString(pathPlayback, pathSource, 0, 0, VCIMPEX_SVG_GSTRING_FLAGS, &elementType);
         gsr == GSRT_ONE;
         gsr = GrDrawGString(pathPlayback, pathSource, 0, 0, VCIMPEX_SVG_GSTRING_FLAGS, &elementType))
    {
        GrGetGStringElement(pathPlayback, pathSource, sizeof(svgElementBuffer.raw),
                            svgElementBuffer.raw, &elementSize);

        if (elementSize > sizeof(svgElementBuffer.raw))
        {
            result = TE_EXPORT_ERROR;
            break;
        }

        elementData = svgElementBuffer.raw;
        GrGetCurPosWWFixed(pathPlayback, &currentPosition);

        switch (elementType)
        {
            case GR_MOVE_TO:
                if (VCImpexSVGAs(elementData, GR_MOVE_TO) == (void*)0)
                {
                    result = TE_EXPORT_ERROR;
                    break;
                }
                {
                    word offset = sizeof(GStringElement);
                    intPoint.P_x = (sword)VCImpexSVGReadWord(elementData, offset);
                    offset += sizeof(word);
                    intPoint.P_y = (sword)VCImpexSVGReadWord(elementData, offset);
                    VCImpexSVGTransformPointFromInt(pathPlayback, &intPoint, &startPoint);
                    if (!VCImpexSVGPathBuilderMoveTo(context, &builder, &startPoint))
                    {
                        result = TE_OUT_OF_MEMORY;
                    }
                }
                break;

            case GR_MOVE_TO_WWFIXED:
                if (VCImpexSVGAs(elementData, GR_MOVE_TO_WWFIXED) == (void*)0)
                {
                    result = TE_EXPORT_ERROR;
                    break;
                }
                {
                    word offset = sizeof(GStringElement);
                    VCImpexSVGReadWWFixed(elementData, offset, &tempPoint.PF_x);
                    offset += sizeof(WWFixed);
                    VCImpexSVGReadWWFixed(elementData, offset, &tempPoint.PF_y);
                    VCImpexSVGTransformPointFromFixed(pathPlayback, &tempPoint, &startPoint);
                    if (!VCImpexSVGPathBuilderMoveTo(context, &builder, &startPoint))
                    {
                        result = TE_OUT_OF_MEMORY;
                    }
                }
                break;

            case GR_REL_MOVE_TO:
                if (VCImpexSVGAs(elementData, GR_REL_MOVE_TO) == (void*)0)
                {
                    result = TE_EXPORT_ERROR;
                    break;
                }
                {
                    word offset = sizeof(GStringElement);
                    VCImpexSVGReadWWFixed(elementData, offset, &tempPoint.PF_x);
                    offset += sizeof(WWFixed);
                    VCImpexSVGReadWWFixed(elementData, offset, &tempPoint.PF_y);
                    VCImpexSVGTransformRelativePoint(pathPlayback, &tempPoint, &startPoint);
                    if (!VCImpexSVGPathBuilderMoveTo(context, &builder, &startPoint))
                    {
                        result = TE_OUT_OF_MEMORY;
                    }
                }
                break;

            case GR_DRAW_LINE:
                if (VCImpexSVGAs(elementData, GR_DRAW_LINE) == (void*)0)
                {
                    result = TE_EXPORT_ERROR;
                    break;
                }
                {
                    word offset = sizeof(GStringElement);
                    intPoint.P_x = (sword)VCImpexSVGReadWord(elementData, offset);
                    offset += sizeof(word);
                    intPoint.P_y = (sword)VCImpexSVGReadWord(elementData, offset);
                    offset += sizeof(word);
                    VCImpexSVGTransformPointFromInt(pathPlayback, &intPoint, &startPoint);

                    intPoint.P_x = (sword)VCImpexSVGReadWord(elementData, offset);
                    offset += sizeof(word);
                    intPoint.P_y = (sword)VCImpexSVGReadWord(elementData, offset);
                    VCImpexSVGTransformPointFromInt(pathPlayback, &intPoint, &endPoint);

                    if (!VCImpexSVGPathBuilderLineTo(context, &builder, &startPoint, &endPoint))
                    {
                        result = TE_OUT_OF_MEMORY;
                    }
                }
                break;

            case GR_DRAW_LINE_TO:
                if (VCImpexSVGAs(elementData, GR_DRAW_LINE_TO) == (void*)0)
                {
                    result = TE_EXPORT_ERROR;
                    break;
                }
                {
                    word offset = sizeof(GStringElement);
                    VCImpexSVGTransformPointFromFixed(pathPlayback, &currentPosition, &startPoint);
                    intPoint.P_x = (sword)VCImpexSVGReadWord(elementData, offset);
                    offset += sizeof(word);
                    intPoint.P_y = (sword)VCImpexSVGReadWord(elementData, offset);
                    VCImpexSVGTransformPointFromInt(pathPlayback, &intPoint, &endPoint);

                    if (!VCImpexSVGPathBuilderLineTo(context, &builder, &startPoint, &endPoint))
                    {
                        result = TE_OUT_OF_MEMORY;
                    }
                }
                break;

            case GR_DRAW_REL_LINE_TO:
                if (VCImpexSVGAs(elementData, GR_DRAW_REL_LINE_TO) == (void*)0)
                {
                    result = TE_EXPORT_ERROR;
                    break;
                }
                {
                    word offset = sizeof(GStringElement);
                    VCImpexSVGTransformPointFromFixed(pathPlayback, &currentPosition, &startPoint);
                    VCImpexSVGReadWWFixed(elementData, offset, &tempPoint.PF_x);
                    offset += sizeof(WWFixed);
                    VCImpexSVGReadWWFixed(elementData, offset, &tempPoint.PF_y);
                    VCImpexSVGTransformRelativePoint(pathPlayback, &tempPoint, &endPoint);

                    if (!VCImpexSVGPathBuilderLineTo(context, &builder, &startPoint, &endPoint))
                    {
                        result = TE_OUT_OF_MEMORY;
                    }
                }
                break;

            case GR_DRAW_HLINE:
                if (VCImpexSVGAs(elementData, GR_DRAW_HLINE) == (void*)0)
                {
                    result = TE_EXPORT_ERROR;
                    break;
                }
                {
                    word offset = sizeof(GStringElement);
                    intPoint.P_x = (sword)VCImpexSVGReadWord(elementData, offset);
                    offset += sizeof(word);
                    intPoint.P_y = (sword)VCImpexSVGReadWord(elementData, offset);
                    offset += sizeof(word);
                    wordValue1 = VCImpexSVGReadWord(elementData, offset);

                    VCImpexSVGTransformPointFromInt(pathPlayback, &intPoint, &startPoint);
                    VCImpexSVGTransformPointFromFixed(pathPlayback, &currentPosition, &endPoint);
                    componentValue = ((WWFixedAsDWord)((sdword)(sword)wordValue1)) << 16;
                    tempPoint = currentPosition;
                    VCImpexSVGSetWWFixedComponent(&tempPoint.PF_x, componentValue);
                    VCImpexSVGTransformPointFromFixed(pathPlayback, &tempPoint, &endPoint);

                    if (!VCImpexSVGPathBuilderLineTo(context, &builder, &startPoint, &endPoint))
                    {
                        result = TE_OUT_OF_MEMORY;
                    }
                }
                break;

            case GR_DRAW_VLINE:
                if (VCImpexSVGAs(elementData, GR_DRAW_VLINE) == (void*)0)
                {
                    result = TE_EXPORT_ERROR;
                    break;
                }
                {
                    word offset = sizeof(GStringElement);
                    intPoint.P_x = (sword)VCImpexSVGReadWord(elementData, offset);
                    offset += sizeof(word);
                    intPoint.P_y = (sword)VCImpexSVGReadWord(elementData, offset);
                    offset += sizeof(word);
                    wordValue1 = VCImpexSVGReadWord(elementData, offset);

                    VCImpexSVGTransformPointFromInt(pathPlayback, &intPoint, &startPoint);
                    VCImpexSVGTransformPointFromFixed(pathPlayback, &currentPosition, &endPoint);
                    componentValue = ((WWFixedAsDWord)((sdword)(sword)wordValue1)) << 16;
                    tempPoint = currentPosition;
                    VCImpexSVGSetWWFixedComponent(&tempPoint.PF_y, componentValue);
                    VCImpexSVGTransformPointFromFixed(pathPlayback, &tempPoint, &endPoint);

                    if (!VCImpexSVGPathBuilderLineTo(context, &builder, &startPoint, &endPoint))
                    {
                        result = TE_OUT_OF_MEMORY;
                    }
                }
                break;

            case GR_DRAW_HLINE_TO:
                if (VCImpexSVGAs(elementData, GR_DRAW_HLINE_TO) == (void*)0)
                {
                    result = TE_EXPORT_ERROR;
                    break;
                }
                {
                    word offset = sizeof(GStringElement);
                    VCImpexSVGTransformPointFromFixed(pathPlayback, &currentPosition, &startPoint);
                    wordValue1 = VCImpexSVGReadWord(elementData, offset);
                    componentValue = ((WWFixedAsDWord)((sdword)(sword)wordValue1)) << 16;
                    tempPoint = currentPosition;
                    VCImpexSVGSetWWFixedComponent(&tempPoint.PF_x, componentValue);
                    VCImpexSVGTransformPointFromFixed(pathPlayback, &tempPoint, &endPoint);

                    if (!VCImpexSVGPathBuilderLineTo(context, &builder, &startPoint, &endPoint))
                    {
                        result = TE_OUT_OF_MEMORY;
                    }
                }
                break;

            case GR_DRAW_VLINE_TO:
                if (VCImpexSVGAs(elementData, GR_DRAW_VLINE_TO) == (void*)0)
                {
                    result = TE_EXPORT_ERROR;
                    break;
                }
                {
                    word offset = sizeof(GStringElement);
                    VCImpexSVGTransformPointFromFixed(pathPlayback, &currentPosition, &startPoint);
                    wordValue1 = VCImpexSVGReadWord(elementData, offset);
                    componentValue = ((WWFixedAsDWord)((sdword)(sword)wordValue1)) << 16;
                    tempPoint = currentPosition;
                    VCImpexSVGSetWWFixedComponent(&tempPoint.PF_y, componentValue);
                    VCImpexSVGTransformPointFromFixed(pathPlayback, &tempPoint, &endPoint);

                    if (!VCImpexSVGPathBuilderLineTo(context, &builder, &startPoint, &endPoint))
                    {
                        result = TE_OUT_OF_MEMORY;
                    }
                }
                break;

            case GR_DRAW_CURVE:
                if (VCImpexSVGAs(elementData, GR_DRAW_CURVE) == (void*)0)
                {
                    result = TE_EXPORT_ERROR;
                    break;
                }
                {
                    word offset = sizeof(GStringElement);
                    intPoint.P_x = VCImpexSVGReadSword(elementData, offset);
                    offset += sizeof(sword);
                    intPoint.P_y = VCImpexSVGReadSword(elementData, offset);
                    offset += sizeof(sword);
                    VCImpexSVGTransformPointFromInt(pathPlayback, &intPoint, &startPoint);

                    intPoint.P_x = VCImpexSVGReadSword(elementData, offset);
                    offset += sizeof(sword);
                    intPoint.P_y = VCImpexSVGReadSword(elementData, offset);
                    offset += sizeof(sword);
                    VCImpexSVGTransformPointFromInt(pathPlayback, &intPoint, &cp1Point);

                    intPoint.P_x = VCImpexSVGReadSword(elementData, offset);
                    offset += sizeof(sword);
                    intPoint.P_y = VCImpexSVGReadSword(elementData, offset);
                    offset += sizeof(sword);
                    VCImpexSVGTransformPointFromInt(pathPlayback, &intPoint, &cp2Point);

                    intPoint.P_x = VCImpexSVGReadSword(elementData, offset);
                    offset += sizeof(sword);
                    intPoint.P_y = VCImpexSVGReadSword(elementData, offset);
                    VCImpexSVGTransformPointFromInt(pathPlayback, &intPoint, &endPoint);

                    if (!VCImpexSVGPathBuilderCurveTo(context, &builder, &startPoint, &cp1Point, &cp2Point, &endPoint))
                    {
                        result = TE_OUT_OF_MEMORY;
                    }
                }
                break;

            case GR_DRAW_CURVE_TO:
                if (VCImpexSVGAs(elementData, GR_DRAW_CURVE_TO) == (void*)0)
                {
                    result = TE_EXPORT_ERROR;
                    break;
                }
                {
                    word offset = sizeof(GStringElement);
                    VCImpexSVGTransformPointFromFixed(pathPlayback, &currentPosition, &startPoint);

                    intPoint.P_x = VCImpexSVGReadSword(elementData, offset);
                    offset += sizeof(sword);
                    intPoint.P_y = VCImpexSVGReadSword(elementData, offset);
                    offset += sizeof(sword);
                    VCImpexSVGTransformPointFromInt(pathPlayback, &intPoint, &cp1Point);

                    intPoint.P_x = VCImpexSVGReadSword(elementData, offset);
                    offset += sizeof(sword);
                    intPoint.P_y = VCImpexSVGReadSword(elementData, offset);
                    offset += sizeof(sword);
                    VCImpexSVGTransformPointFromInt(pathPlayback, &intPoint, &cp2Point);

                    intPoint.P_x = VCImpexSVGReadSword(elementData, offset);
                    offset += sizeof(sword);
                    intPoint.P_y = VCImpexSVGReadSword(elementData, offset);
                    VCImpexSVGTransformPointFromInt(pathPlayback, &intPoint, &endPoint);

                    if (!VCImpexSVGPathBuilderCurveTo(context, &builder, &startPoint, &cp1Point, &cp2Point, &endPoint))
                    {
                        result = TE_OUT_OF_MEMORY;
                    }
                }
                break;

            case GR_DRAW_REL_CURVE_TO:
                if (VCImpexSVGAs(elementData, GR_DRAW_REL_CURVE_TO) == (void*)0)
                {
                    result = TE_EXPORT_ERROR;
                    break;
                }
                {
                    word offset = sizeof(GStringElement);
                    VCImpexSVGTransformPointFromFixed(pathPlayback, &currentPosition, &startPoint);

                    VCImpexSVGReadWWFixed(elementData, offset, &tempPoint.PF_x);
                    offset += sizeof(WWFixed);
                    VCImpexSVGReadWWFixed(elementData, offset, &tempPoint.PF_y);
                    offset += sizeof(WWFixed);
                    VCImpexSVGTransformRelativePoint(pathPlayback, &tempPoint, &cp1Point);

                    VCImpexSVGReadWWFixed(elementData, offset, &tempPoint.PF_x);
                    offset += sizeof(WWFixed);
                    VCImpexSVGReadWWFixed(elementData, offset, &tempPoint.PF_y);
                    offset += sizeof(WWFixed);
                    VCImpexSVGTransformRelativePoint(pathPlayback, &tempPoint, &cp2Point);

                    VCImpexSVGReadWWFixed(elementData, offset, &tempPoint.PF_x);
                    offset += sizeof(WWFixed);
                    VCImpexSVGReadWWFixed(elementData, offset, &tempPoint.PF_y);
                    VCImpexSVGTransformRelativePoint(pathPlayback, &tempPoint, &endPoint);

                    if (!VCImpexSVGPathBuilderCurveTo(context, &builder, &startPoint, &cp1Point, &cp2Point, &endPoint))
                    {
                        result = TE_OUT_OF_MEMORY;
                    }
                }
                break;

            case GR_CLOSE_SUB_PATH:
                if (!VCImpexSVGPathBuilderClose(context, &builder))
                {
                    result = TE_OUT_OF_MEMORY;
                }
                break;

            default:
                /* ignore unsupported opcodes inside the path */
                break;
        }

        if (result != TE_NO_ERROR)
        {
            break;
        }
    }

    if ((result == TE_NO_ERROR) && (gsr != GSRT_COMPLETE))
    {
        result = TE_EXPORT_ERROR;
    }

    if ((result == TE_NO_ERROR) && (builderReady != FALSE) && (builder.hasData != FALSE))
    {
        char *buffer;
        char *pathData;
        word totalLength;
        word styleLength = 0;

        styleChunk = VCImpexSVGAllocBuffer(context, 256);
        if (styleChunk == NullChunk)
        {
            result = TE_OUT_OF_MEMORY;
            goto cleanup;
        }
        {
            MemHandle heapH = context->bufferHeapH;
            char *styleText = NULL;

            if (heapH == NullHandle)
            {
                result = TE_OUT_OF_MEMORY;
                goto cleanup;
            }

            if ((strokePath == FALSE) && (context->lineWidth != 0))
            {
                strokeDisabled = TRUE;
                savedLineWidth = context->lineWidth;
                context->lineWidth = 0;
            }

            MemLock(heapH);
            styleText = LMemDerefHandles(heapH, styleChunk);
            if (!VCImpexSVGStyleToAttributes(context,
                                             strokePath,
                                             fillPath,
                                             fillPath,
                                             fillRule,
                                             styleText,
                                             256))
            {
                MemUnlock(heapH);
                result = TE_FILE_WRITE;
                goto cleanup;
            }
            styleLength = strlen(styleText);
            totalLength = builder.length + styleLength + 48;
            MemUnlock(heapH);

            if (strokeDisabled != FALSE)
            {
                context->lineWidth = savedLineWidth;
            }
        }

        pathData = NULL;
        bufferChunk = VCImpexSVGAllocBuffer(context, totalLength);
        if (bufferChunk == NullChunk)
        {
            result = TE_OUT_OF_MEMORY;
            goto cleanup;
        }

        {
            MemHandle heapH = context->bufferHeapH;
            char *styleTextPtr;

            if (heapH == NullHandle)
            {
                result = TE_OUT_OF_MEMORY;
                goto cleanup;
            }

            MemLock(heapH);
            pathData = (builder.dataChunk != NullChunk) ? LMemDerefHandles(heapH, builder.dataChunk) : NULL;
            buffer = LMemDerefHandles(heapH, bufferChunk);
            styleTextPtr = LMemDerefHandles(heapH, styleChunk);
            if ((pathData == NULL) || (buffer == NULL) || (styleTextPtr == NULL))
            {
                MemUnlock(heapH);
                result = TE_OUT_OF_MEMORY;
                goto cleanup;
            }
            sprintf(buffer, "  <path d=\"%s\"%s />\n", pathData, styleTextPtr);
            MemUnlock(heapH);
        }
        if (!VCImpexSVGWriteRawString(context, buffer))
        {
            result = TE_FILE_WRITE;
        }
    }

cleanup:
    if (strokeDisabled != FALSE)
    {
        context->lineWidth = savedLineWidth;
    }

    if (bufferChunk != NullChunk)
    {
        VCImpexSVGFreeBuffer(context, bufferChunk);
    }
    if (styleChunk != NullChunk)
    {
        VCImpexSVGFreeBuffer(context, styleChunk);
    }
    if (builderReady != FALSE)
    {
        VCImpexSVGPathBuilderDestroy(context, &builder);
    }
    if (pathPlayback != 0)
    {
        GrDestroyGString(pathPlayback, 0, GSKT_KILL_DATA);
    }
    if (pathPlaybackBlock != NullHandle)
    {
        MemFree(pathPlaybackBlock);
    }
    if (pathSource != 0)
    {
        GrDestroyGString(pathSource, 0, GSKT_LEAVE_DATA);
    }
    if (pathPtr != NULL)
    {
        MemUnlock(pathMem);
    }
    if (pathMem != NullHandle)
    {
        MemFree(pathMem);
    }

    return result;
}

word _pascal VCImpexSVGHandleRoundRectOpcode(word elementType, GStateHandle playbackGState, VCImpexSVGExportContext *context, PointWWFixed *currentPosition, VCImpexSVGPendingRect *pendingRect)
{
    PointWWFixed corner1;
    PointWWFixed corner3;
    WWFixed radiusX;
    WWFixed radiusY;
    XYValueAsDWord t0;
    XYValueAsDWord tx;
    XYValueAsDWord ty;
    Boolean filled = FALSE;
    Point intCorner1;
    Point intCorner3;
    word radiusValue;
    const byte *elementData;
    word offset;
    word wordValue1;
    word wordValue2;

    elementData = svgElementBuffer.raw;

    switch (elementType)
    {
        case GR_DRAW_ROUND_RECT:
        case GR_FILL_ROUND_RECT:
            if (VCImpexSVGAs(elementData, elementType) == (void*)0)
            {
                return TE_EXPORT_ERROR;
            }
            offset = sizeof(GStringElement);
            radiusValue = VCImpexSVGReadWord(elementData, offset);
            offset += sizeof(word);
            intCorner1.P_x = (sword)VCImpexSVGReadWord(elementData, offset);
            offset += sizeof(word);
            intCorner1.P_y = (sword)VCImpexSVGReadWord(elementData, offset);
            offset += sizeof(word);
            intCorner3.P_x = (sword)VCImpexSVGReadWord(elementData, offset);
            offset += sizeof(word);
            intCorner3.P_y = (sword)VCImpexSVGReadWord(elementData, offset);
            VCImpexSVGTransformPointFromInt(playbackGState, &intCorner1, &corner1);
            VCImpexSVGTransformPointFromInt(playbackGState, &intCorner3, &corner3);
            t0 = GrTransform(playbackGState, 0, 0);
            tx = GrTransform(playbackGState, (sword)radiusValue, 0);
            ty = GrTransform(playbackGState, 0, (sword)radiusValue);
            {
                sdword dx = (sdword)DWORD_X(tx) - (sdword)DWORD_X(t0);
                sdword dy = (sdword)DWORD_Y(ty) - (sdword)DWORD_Y(t0);
                if (dx < 0) dx = -dx;
                if (dy < 0) dy = -dy;
                if (dx > 32767) dx = 32767;
                if (dy > 32767) dy = 32767;
                radiusX.WWF_int = (sword)dx;
                radiusY.WWF_int = (sword)dy;
            }
            radiusX.WWF_frac = 0;
            radiusY.WWF_frac = 0;
            filled = (elementType == GR_FILL_ROUND_RECT);
            break;

        case GR_DRAW_ROUND_RECT_TO:
        case GR_FILL_ROUND_RECT_TO:
            VCImpexSVGTransformPointFromFixed(playbackGState, currentPosition, &corner1);
            if (VCImpexSVGAs(elementData, elementType) == (void*)0)
            {
                return TE_EXPORT_ERROR;
            }
            offset = sizeof(GStringElement);
            radiusValue = VCImpexSVGReadWord(elementData, offset);
            offset += sizeof(word);
            wordValue1 = VCImpexSVGReadWord(elementData, offset);
            offset += sizeof(word);
            wordValue2 = VCImpexSVGReadWord(elementData, offset);
            intCorner3.P_x = (sword)wordValue1;
            intCorner3.P_y = (sword)wordValue2;
            VCImpexSVGTransformPointFromInt(playbackGState, &intCorner3, &corner3);
            t0 = GrTransform(playbackGState, 0, 0);
            tx = GrTransform(playbackGState, (sword)radiusValue, 0);
            ty = GrTransform(playbackGState, 0, (sword)radiusValue);
            {
                sdword dx = (sdword)DWORD_X(tx) - (sdword)DWORD_X(t0);
                sdword dy = (sdword)DWORD_Y(ty) - (sdword)DWORD_Y(t0);
                if (dx < 0) dx = -dx;
                if (dy < 0) dy = -dy;
                if (dx > 32767) dx = 32767;
                if (dy > 32767) dy = 32767;
                radiusX.WWF_int = (sword)dx;
                radiusY.WWF_int = (sword)dy;
            }
            radiusX.WWF_frac = 0;
            radiusY.WWF_frac = 0;
            filled = (elementType == GR_FILL_ROUND_RECT_TO);
            break;

        default:
            return TE_NO_ERROR;
    }

    if (pendingRect != NULL)
    {
        if (VCImpexSVGPendingMatchesRoundRect(pendingRect, &corner1, &corner3, &radiusX, &radiusY))
        {
            if (filled)
            {
                VCImpexSVGPendingCaptureFill(pendingRect, context);
            }
            else
            {
                VCImpexSVGPendingCaptureStroke(pendingRect, context);
            }
            if (pendingRect->haveFill && pendingRect->haveStroke)
            {
                if (!VCImpexSVGFlushPendingRect(context, pendingRect))
                {
                    return TE_FILE_WRITE;
                }
            }
            return TE_NO_ERROR;
        }

        if (!VCImpexSVGFlushPendingRect(context, pendingRect))
        {
            return TE_FILE_WRITE;
        }

        pendingRect->active = TRUE;
        pendingRect->type = VCIMPEX_SVG_PENDING_ROUND_RECT;
        pendingRect->corner1 = corner1;
        pendingRect->corner3 = corner3;
        pendingRect->radiusX = radiusX;
        pendingRect->radiusY = radiusY;
        pendingRect->haveTransform = FALSE;
        pendingRect->haveFill = FALSE;
        pendingRect->haveStroke = FALSE;
        if (filled)
        {
            VCImpexSVGPendingCaptureFill(pendingRect, context);
        }
        else
        {
            VCImpexSVGPendingCaptureStroke(pendingRect, context);
        }
        return TE_NO_ERROR;
    }

    if (!VCImpexSVGWriteRoundRectElement(context,
                                         &corner1,
                                         &corner3,
                                         &radiusX,
                                         &radiusY,
                                         (filled == FALSE),
                                         (filled != FALSE),
                                         filled))
    {
        return TE_FILE_WRITE;
    }
    return TE_NO_ERROR;
}

word _pascal VCImpexSVGHandleCurveOpcode(word elementType, GStateHandle playbackGState, VCImpexSVGExportContext *context, PointWWFixed *currentPosition, VCImpexSVGPendingRect *pendingRect)
{
    PointWWFixed startPoint;
    PointWWFixed cp1;
    PointWWFixed cp2;
    PointWWFixed endPoint;
    Point intPoint;
    const byte *elementData;
    word offset;

    (void)pendingRect;

    elementData = svgElementBuffer.raw;

    switch (elementType)
    {
        case GR_DRAW_CURVE:
            if (VCImpexSVGAs(elementData, GR_DRAW_CURVE) == (void*)0)
            {
                return TE_EXPORT_ERROR;
            }
            offset = sizeof(GStringElement);
            intPoint.P_x = VCImpexSVGReadSword(elementData, offset);
            offset += sizeof(sword);
            intPoint.P_y = VCImpexSVGReadSword(elementData, offset);
            offset += sizeof(sword);
            VCImpexSVGTransformPointFromInt(playbackGState, &intPoint, &startPoint);
            intPoint.P_x = VCImpexSVGReadSword(elementData, offset);
            offset += sizeof(sword);
            intPoint.P_y = VCImpexSVGReadSword(elementData, offset);
            offset += sizeof(sword);
            VCImpexSVGTransformPointFromInt(playbackGState, &intPoint, &cp1);
            intPoint.P_x = VCImpexSVGReadSword(elementData, offset);
            offset += sizeof(sword);
            intPoint.P_y = VCImpexSVGReadSword(elementData, offset);
            offset += sizeof(sword);
            VCImpexSVGTransformPointFromInt(playbackGState, &intPoint, &cp2);
            intPoint.P_x = VCImpexSVGReadSword(elementData, offset);
            offset += sizeof(sword);
            intPoint.P_y = VCImpexSVGReadSword(elementData, offset);
            VCImpexSVGTransformPointFromInt(playbackGState, &intPoint, &endPoint);
            if (!VCImpexSVGWriteCubicPathElement(context, &startPoint, &cp1, &cp2, &endPoint))
                return TE_FILE_WRITE;
            return TE_NO_ERROR;

        case GR_DRAW_CURVE_TO:
            VCImpexSVGTransformPointFromFixed(playbackGState, currentPosition, &startPoint);
            if (VCImpexSVGAs(elementData, GR_DRAW_CURVE_TO) == (void*)0)
            {
                return TE_EXPORT_ERROR;
            }
            offset = sizeof(GStringElement);
            intPoint.P_x = VCImpexSVGReadSword(elementData, offset);
            offset += sizeof(sword);
            intPoint.P_y = VCImpexSVGReadSword(elementData, offset);
            offset += sizeof(sword);
            VCImpexSVGTransformPointFromInt(playbackGState, &intPoint, &cp1);
            intPoint.P_x = VCImpexSVGReadSword(elementData, offset);
            offset += sizeof(sword);
            intPoint.P_y = VCImpexSVGReadSword(elementData, offset);
            offset += sizeof(sword);
            VCImpexSVGTransformPointFromInt(playbackGState, &intPoint, &cp2);
            intPoint.P_x = VCImpexSVGReadSword(elementData, offset);
            offset += sizeof(sword);
            intPoint.P_y = VCImpexSVGReadSword(elementData, offset);
            VCImpexSVGTransformPointFromInt(playbackGState, &intPoint, &endPoint);
            if (!VCImpexSVGWriteCubicPathElement(context, &startPoint, &cp1, &cp2, &endPoint))
                return TE_FILE_WRITE;
            return TE_NO_ERROR;

        case GR_DRAW_REL_CURVE_TO:
        {
            PointWWFixed delta;
            if (VCImpexSVGAs(elementData, GR_DRAW_REL_CURVE_TO) == (void*)0)
            {
                return TE_EXPORT_ERROR;
            }
            offset = sizeof(GStringElement);
            /* cp1 */
            delta.PF_x.WWF_int = VCImpexSVGReadSword(elementData, offset);
            delta.PF_x.WWF_frac = 0;
            offset += sizeof(sword);
            delta.PF_y.WWF_int = VCImpexSVGReadSword(elementData, offset);
            delta.PF_y.WWF_frac = 0;
            offset += sizeof(sword);
            VCImpexSVGTransformPointFromFixed(playbackGState, currentPosition, &startPoint);
            VCImpexSVGTransformRelativePoint(playbackGState, &delta, &cp1);
            /* cp2 */
            delta.PF_x.WWF_int = VCImpexSVGReadSword(elementData, offset);
            delta.PF_x.WWF_frac = 0;
            offset += sizeof(sword);
            delta.PF_y.WWF_int = VCImpexSVGReadSword(elementData, offset);
            delta.PF_y.WWF_frac = 0;
            offset += sizeof(sword);
            VCImpexSVGTransformRelativePoint(playbackGState, &delta, &cp2);
            /* end */
            delta.PF_x.WWF_int = VCImpexSVGReadSword(elementData, offset);
            delta.PF_x.WWF_frac = 0;
            offset += sizeof(sword);
            delta.PF_y.WWF_int = VCImpexSVGReadSword(elementData, offset);
            delta.PF_y.WWF_frac = 0;
            VCImpexSVGTransformRelativePoint(playbackGState, &delta, &endPoint);
            if (!VCImpexSVGWriteCubicPathElement(context, &startPoint, &cp1, &cp2, &endPoint))
                return TE_FILE_WRITE;
            return TE_NO_ERROR;
        }

        default:
            break;
    }
    return TE_NO_ERROR;
}

word _pascal VCImpexSVGHandleArcOpcode(word elementType, GStateHandle playbackGState, VCImpexSVGExportContext *context, PointWWFixed *currentPosition, VCImpexSVGPendingRect *pendingRect)
{
    Boolean fill = FALSE;
    TransMatrix tm;
    WWFixed cx;
    WWFixed cy;
    WWFixed rx;
    WWFixed ry;
    word startAngle;
    word endAngle;
    sword x1;
    sword y1;
    sword x2;
    sword y2;
    ArcCloseType closeType;
    WWFixedAsDWord cxFixed;
    WWFixedAsDWord cyFixed;
    WWFixedAsDWord rxFixed;
    WWFixedAsDWord ryFixed;
    const byte *elementData;
    word offset;
    word wordValue;

    (void)currentPosition;
    (void)pendingRect;

    elementData = svgElementBuffer.raw;

    switch (elementType)
    {
        case GR_DRAW_ARC:
        case GR_FILL_ARC:
        {
            if (VCImpexSVGAs(elementData, elementType) == (void*)0)
            {
                return TE_EXPORT_ERROR;
            }
            offset = sizeof(GStringElement);
            wordValue = VCImpexSVGReadWord(elementData, offset);
            closeType = (ArcCloseType)wordValue;
            offset += sizeof(word);
            x1 = (sword)VCImpexSVGReadWord(elementData, offset);
            offset += sizeof(word);
            y1 = (sword)VCImpexSVGReadWord(elementData, offset);
            offset += sizeof(word);
            x2 = (sword)VCImpexSVGReadWord(elementData, offset);
            offset += sizeof(word);
            y2 = (sword)VCImpexSVGReadWord(elementData, offset);
            offset += sizeof(word);
            startAngle = VCImpexSVGReadWord(elementData, offset);
            offset += sizeof(word);
            endAngle = VCImpexSVGReadWord(elementData, offset);

            /* center */
            cx.WWF_int = (sword)((x1 + x2) / 2);
            cx.WWF_frac = (word)(((x1 + x2) & 1) ? 0x8000 : 0);
            cy.WWF_int = (sword)((y1 + y2) / 2);
            cy.WWF_frac = (word)(((y1 + y2) & 1) ? 0x8000 : 0);
            /* radii */
            rx.WWF_int = (sword)(((x2 - x1) < 0) ? ((x1 - x2) / 2) : ((x2 - x1) / 2));
            rx.WWF_frac = (word)((((x2 - x1) & 1) != 0) ? 0x8000 : 0);
            ry.WWF_int = (sword)(((y2 - y1) < 0) ? ((y1 - y2) / 2) : ((y2 - y1) / 2));
            ry.WWF_frac = (word)((((y2 - y1) & 1) != 0) ? 0x8000 : 0);

            cxFixed = VCImpexSVGPackWWFixed(&cx);
            cyFixed = VCImpexSVGPackWWFixed(&cy);
            rxFixed = VCImpexSVGPackWWFixed(&rx);
            ryFixed = VCImpexSVGPackWWFixed(&ry);

            GrGetTransform(playbackGState, &tm);

            fill = (elementType == GR_FILL_ARC) ? TRUE : FALSE;
            {
                WWFixedAsDWord savedLineWidth = 0;
                Boolean strokeDisabled = FALSE;

                if ((fill != FALSE) && (context->lineWidth != 0))
                {
                    strokeDisabled = TRUE;
                    savedLineWidth = context->lineWidth;
                    context->lineWidth = 0;
                }

                if (!VCImpexSVGWriteArcElement(context, cxFixed, cyFixed, rxFixed, ryFixed, startAngle, endAngle, closeType, fill, &tm))
                {
                    if (strokeDisabled != FALSE)
                    {
                        context->lineWidth = savedLineWidth;
                    }
                    return TE_FILE_WRITE;
                }

                if (strokeDisabled != FALSE)
                {
                    context->lineWidth = savedLineWidth;
                }
            }
            return TE_NO_ERROR;
        }

        default:
            break;
    }
    return TE_NO_ERROR;
}

word _pascal VCImpexSVGReadWord(const byte *data, word offset)
{
    word value;

    if (data == NULL)
    {
        return 0;
    }

    memcpy(&value, data + offset, sizeof(word));
    return value;
}

sword _pascal VCImpexSVGReadSword(const byte *data, word offset)
{
    sword value;

    if (data == NULL)
    {
        return 0;
    }

    memcpy(&value, data + offset, sizeof(sword));
    return value;
}

void _pascal VCImpexSVGReadWWFixed(const byte *data, word offset, WWFixed *value)
{
    if ((data == NULL) || (value == NULL))
    {
        return;
    }

    memcpy(value, data + offset, sizeof(WWFixed));
}

Boolean VCImpexSVGPathPointsEqual(const PointWWFixed *a, const PointWWFixed *b)
{
    if ((a == NULL) || (b == NULL))
        return FALSE;
    if ((a->PF_x.WWF_int != b->PF_x.WWF_int) ||
        (a->PF_x.WWF_frac != b->PF_x.WWF_frac))
    {
        return FALSE;
    }
    if ((a->PF_y.WWF_int != b->PF_y.WWF_int) ||
        (a->PF_y.WWF_frac != b->PF_y.WWF_frac))
    {
        return FALSE;
    }
    return TRUE;
}

Boolean VCImpexSVGPathBuilderEnsureCapacity(VCImpexSVGExportContext *context,
                                            VCImpexSVGPathBuilder *builder,
                                            word additional)
{
    word needed;
    word newCapacity;
    MemHandle heapH;
    Boolean locked = FALSE;

    if ((context == NULL) || (builder == NULL))
        return FALSE;

    heapH = context->bufferHeapH;
    if (heapH == NullHandle)
        return FALSE;

    if (builder->dataChunk == NullChunk)
        return FALSE;

    needed = builder->length + additional + 1;
    if (needed <= builder->capacity)
    {
        return TRUE;
    }

    newCapacity = (builder->capacity == 0) ? 128 : builder->capacity;
    while (newCapacity < needed)
    {
        newCapacity += 128;
    }

    MemLock(heapH);
    locked = TRUE;
    if (LMemReAllocHandles(heapH, builder->dataChunk, newCapacity) != 0)
    {
        MemUnlock(heapH);
        return FALSE;
    }
    builder->capacity = newCapacity;
    MemUnlock(heapH);
    return TRUE;
}

Boolean VCImpexSVGPathBuilderAppendString(VCImpexSVGExportContext *context,
                                          VCImpexSVGPathBuilder *builder,
                                          const char *text)
{
    word len;
    char *buffer;
    MemHandle heapH;
    Boolean locked = FALSE;

    if ((context == NULL) || (builder == NULL) || (text == NULL))
        return FALSE;

    len = strlen(text);
    if (len == 0)
        return TRUE;

    if (!VCImpexSVGPathBuilderEnsureCapacity(context, builder, len))
    {
        return FALSE;
    }

    heapH = context->bufferHeapH;
    if (heapH == NullHandle)
        return FALSE;

    MemLock(heapH);
    locked = TRUE;
    if (builder->dataChunk == NullChunk)
    {
        MemUnlock(heapH);
        return FALSE;
    }

    buffer = LMemDerefHandles(heapH, builder->dataChunk);
    memcpy(buffer + builder->length, text, len);
    builder->length += len;
    buffer[builder->length] = '\0';
    MemUnlock(heapH);
    return TRUE;
}

Boolean VCImpexSVGPathBuilderInit(VCImpexSVGExportContext *context,
                                  VCImpexSVGPathBuilder *builder,
                                  word initialCapacity)
{
    if ((context == NULL) || (builder == NULL) || (context->bufferHeapH == NullHandle))
        return FALSE;

    memset(builder, 0, sizeof(*builder));
    builder->dataChunk = VCImpexSVGAllocBuffer(context, initialCapacity);
    if (builder->dataChunk == NullChunk)
    {
        return FALSE;
    }
    builder->capacity = initialCapacity;
    return TRUE;
}

void VCImpexSVGPathBuilderDestroy(VCImpexSVGExportContext *context,
                                  VCImpexSVGPathBuilder *builder)
{
    if ((context == NULL) || (builder == NULL))
        return;

    if (builder->dataChunk != NullChunk)
    {
        VCImpexSVGFreeBuffer(context, builder->dataChunk);
        builder->dataChunk = NullChunk;
    }
    builder->length = 0;
    builder->capacity = 0;
    builder->subpathOpen = FALSE;
    builder->hasData = FALSE;
}

Boolean VCImpexSVGPathBuilderMoveTo(VCImpexSVGExportContext *context,
                                    VCImpexSVGPathBuilder *builder,
                                    const PointWWFixed *point)
{
    char xText[32];
    char yText[32];
    char segment[96];

    VCImpexSVGFormatFixed(VCImpexSVGPackWWFixed(&point->PF_x), xText, 2);
    VCImpexSVGFormatFixed(VCImpexSVGPackWWFixed(&point->PF_y), yText, 2);
    sprintf(segment, "M %s %s ", xText, yText);
    if (!VCImpexSVGPathBuilderAppendString(context, builder, segment))
    {
        return FALSE;
    }
    builder->subpathOpen = TRUE;
    builder->hasData = TRUE;
    VCImpexSVGCopyPointWWFixed(&builder->lastPoint, point);
    VCImpexSVGCopyPointWWFixed(&builder->subpathStart, point);
    return TRUE;
}

Boolean VCImpexSVGPathBuilderEnsureSubpath(VCImpexSVGExportContext *context,
                                           VCImpexSVGPathBuilder *builder,
                                           const PointWWFixed *point)
{
    if (builder->subpathOpen == FALSE)
    {
        return VCImpexSVGPathBuilderMoveTo(context, builder, point);
    }
    if (!VCImpexSVGPathPointsEqual(&builder->lastPoint, point))
    {
        return VCImpexSVGPathBuilderMoveTo(context, builder, point);
    }
    return TRUE;
}

Boolean VCImpexSVGPathBuilderLineTo(VCImpexSVGExportContext *context,
                                    VCImpexSVGPathBuilder *builder,
                                    const PointWWFixed *startPoint,
                                    const PointWWFixed *endPoint)
{
    char xText[32];
    char yText[32];
    char segment[96];

    if (!VCImpexSVGPathBuilderEnsureSubpath(context, builder, startPoint))
    {
        return FALSE;
    }

    VCImpexSVGFormatFixed(VCImpexSVGPackWWFixed(&endPoint->PF_x), xText, 2);
    VCImpexSVGFormatFixed(VCImpexSVGPackWWFixed(&endPoint->PF_y), yText, 2);
    sprintf(segment, "L %s %s ", xText, yText);
    if (!VCImpexSVGPathBuilderAppendString(context, builder, segment))
    {
        return FALSE;
    }
    builder->hasData = TRUE;
    VCImpexSVGCopyPointWWFixed(&builder->lastPoint, endPoint);
    return TRUE;
}

Boolean VCImpexSVGPathBuilderCurveTo(VCImpexSVGExportContext *context,
                                     VCImpexSVGPathBuilder *builder,
                                     const PointWWFixed *startPoint,
                                     const PointWWFixed *cp1,
                                     const PointWWFixed *cp2,
                                     const PointWWFixed *endPoint)
{
    char c1x[32], c1y[32], c2x[32], c2y[32], ex[32], ey[32];
    char segment[192];

    if (!VCImpexSVGPathBuilderEnsureSubpath(context, builder, startPoint))
    {
        return FALSE;
    }

    VCImpexSVGFormatFixed(VCImpexSVGPackWWFixed(&cp1->PF_x), c1x, 2);
    VCImpexSVGFormatFixed(VCImpexSVGPackWWFixed(&cp1->PF_y), c1y, 2);
    VCImpexSVGFormatFixed(VCImpexSVGPackWWFixed(&cp2->PF_x), c2x, 2);
    VCImpexSVGFormatFixed(VCImpexSVGPackWWFixed(&cp2->PF_y), c2y, 2);
    VCImpexSVGFormatFixed(VCImpexSVGPackWWFixed(&endPoint->PF_x), ex, 2);
    VCImpexSVGFormatFixed(VCImpexSVGPackWWFixed(&endPoint->PF_y), ey, 2);
    sprintf(segment, "C %s %s %s %s %s %s ", c1x, c1y, c2x, c2y, ex, ey);
    if (!VCImpexSVGPathBuilderAppendString(context, builder, segment))
    {
        return FALSE;
    }
    builder->hasData = TRUE;
    VCImpexSVGCopyPointWWFixed(&builder->lastPoint, endPoint);
    return TRUE;
}

Boolean VCImpexSVGPathBuilderClose(VCImpexSVGExportContext *context,
                                   VCImpexSVGPathBuilder *builder)
{
    if ((builder->subpathOpen == FALSE) || (context == NULL))
        return TRUE;

    if (!VCImpexSVGPathBuilderAppendString(context, builder, "Z "))
    {
        return FALSE;
    }
    builder->subpathOpen = FALSE;
    builder->hasData = TRUE;
    VCImpexSVGCopyPointWWFixed(&builder->lastPoint, &builder->subpathStart);
    return TRUE;
}

void _pascal VCImpexSVGSetWWFixedComponent(WWFixed *component, WWFixedAsDWord value)
{
    component->WWF_int = (word)((((sdword)value) >> 16) & 0xffff);
    component->WWF_frac = (word)(value & 0xffff);
}
