/***********************************************************************
 *
 * PROJECT:       VCImpex SVG Exporter
 * FILE:          svgexpproc.goc
 *
 * DESCRIPTION:   Implements the export procedure for SVG output
 *
 ***********************************************************************/
@include <stdapp.goh>

#include "svgexp.h"

#define VCIMPEX_SVG_GSTRING_FLAGS   (GSC_ONE)

typedef struct
{
    byte raw[VCIMPEX_SVG_ELEMENT_BUFFER_SIZE];
} VCImpexSVGGStringElement;

typedef struct
{
    GStringElement  ODRLT_opcode;
    WWFixed         ODRLT_x2;
    WWFixed         ODRLT_y2;
} OpDrawRelLineTo;

VCImpexSVGGStringElement svgElementBuffer;
PointWWFixed svgPolygonBuffer[VCIMPEX_SVG_MAX_POLY_POINTS];

word _pascal VCImpexSVGExportGString(GStateHandle sourceGState, VCImpexSVGExportContext *context);

typedef Boolean (_pascal *VCImpexSVGOpcodePredicate)(word elementType);
typedef word (_pascal *VCImpexSVGOpcodeHandler)(word elementType,
                                                GStateHandle playbackGState,
                                                VCImpexSVGExportContext *context,
                                                PointWWFixed *currentPosition,
                                                VCImpexSVGPendingRect *pendingRect);

typedef struct
{
    VCImpexSVGOpcodePredicate predicate;
    VCImpexSVGOpcodeHandler handler;
} VCImpexSVGDispatchEntry;

void* _pascal VCImpexSVGAs(const void *raw, word expectedOpcode);
Boolean _pascal VCImpexSVGIsLineOpcode(word elementType);
Boolean _pascal VCImpexSVGIsRectangleOpcode(word elementType);
Boolean _pascal VCImpexSVGIsRoundRectOpcode(word elementType);
Boolean _pascal VCImpexSVGIsEllipseOpcode(word elementType);
Boolean _pascal VCImpexSVGIsCurveOpcode(word elementType);
Boolean _pascal VCImpexSVGIsArcOpcode(word elementType);
Boolean _pascal VCImpexSVGIsPolygonOpcode(word elementType);

word _pascal VCImpexSVGHandleLineOpcode(word elementType, GStateHandle playbackGState, VCImpexSVGExportContext *context, PointWWFixed *currentPosition, VCImpexSVGPendingRect *pendingRect);
word _pascal VCImpexSVGHandleRectangleOpcode(word elementType, GStateHandle playbackGState, VCImpexSVGExportContext *context, PointWWFixed *currentPosition, VCImpexSVGPendingRect *pendingRect);
word _pascal VCImpexSVGHandleRoundRectOpcode(word elementType, GStateHandle playbackGState, VCImpexSVGExportContext *context, PointWWFixed *currentPosition, VCImpexSVGPendingRect *pendingRect);
word _pascal VCImpexSVGHandleEllipseOpcode(word elementType, GStateHandle playbackGState, VCImpexSVGExportContext *context, PointWWFixed *currentPosition, VCImpexSVGPendingRect *pendingRect);
word _pascal VCImpexSVGHandleCurveOpcode(word elementType, GStateHandle playbackGState, VCImpexSVGExportContext *context, PointWWFixed *currentPosition, VCImpexSVGPendingRect *pendingRect);
word _pascal VCImpexSVGHandleArcOpcode(word elementType, GStateHandle playbackGState, VCImpexSVGExportContext *context, PointWWFixed *currentPosition, VCImpexSVGPendingRect *pendingRect);
word _pascal VCImpexSVGHandlePolygonOpcode(word elementType, GStateHandle playbackGState, VCImpexSVGExportContext *context, PointWWFixed *currentPosition, VCImpexSVGPendingRect *pendingRect);
void _pascal VCImpexSVGSetWWFixedComponent(WWFixed *component, WWFixedAsDWord value);

static const VCImpexSVGDispatchEntry gVCImpexSVGDispatchTable[] =
{
    {VCImpexSVGIsLineOpcode, VCImpexSVGHandleLineOpcode},
    {VCImpexSVGIsRectangleOpcode, VCImpexSVGHandleRectangleOpcode},
    {VCImpexSVGIsRoundRectOpcode, VCImpexSVGHandleRoundRectOpcode},
    {VCImpexSVGIsEllipseOpcode, VCImpexSVGHandleEllipseOpcode},
    {VCImpexSVGIsCurveOpcode, VCImpexSVGHandleCurveOpcode},
    {VCImpexSVGIsArcOpcode, VCImpexSVGHandleArcOpcode},
    {VCImpexSVGIsPolygonOpcode, VCImpexSVGHandlePolygonOpcode}
};

#define VCIMPEX_SVG_DISPATCH_COUNT  (sizeof(gVCImpexSVGDispatchTable) / sizeof(VCImpexSVGDispatchEntry))

void* _pascal VCImpexSVGAs(const void *raw, word expectedOpcode)
{
    const GStringElement *opcodeP;

    if (raw == NULL)
    {
        return (void*)0;
    }

    opcodeP = (const GStringElement*)raw;
    if (*opcodeP != (GStringElement)expectedOpcode)
    {
        return (void*)0;
    }

    return (void*)raw;
}

Boolean _pascal VCImpexSVGIsLineOpcode(word elementType)
{
    switch (elementType)
    {
        case GR_DRAW_LINE:
        case GR_DRAW_LINE_TO:
        case GR_DRAW_REL_LINE_TO:
        case GR_DRAW_HLINE:
        case GR_DRAW_VLINE:
        case GR_DRAW_HLINE_TO:
        case GR_DRAW_VLINE_TO:
            return TRUE;
        default:
            return FALSE;
    }
}

Boolean _pascal VCImpexSVGIsRectangleOpcode(word elementType)
{
    switch (elementType)
    {
        case GR_DRAW_RECT:
        case GR_FILL_RECT:
        case GR_DRAW_RECT_TO:
        case GR_FILL_RECT_TO:
            return TRUE;
        default:
            return FALSE;
    }
}

Boolean _pascal VCImpexSVGIsRoundRectOpcode(word elementType)
{
    switch (elementType)
    {
        case GR_DRAW_ROUND_RECT:
        case GR_FILL_ROUND_RECT:
        case GR_DRAW_ROUND_RECT_TO:
        case GR_FILL_ROUND_RECT_TO:
            return TRUE;
        default:
            return FALSE;
    }
}

Boolean _pascal VCImpexSVGIsEllipseOpcode(word elementType)
{
    switch (elementType)
    {
        case GR_DRAW_ELLIPSE:
        case GR_FILL_ELLIPSE:
            return TRUE;
        default:
            return FALSE;
    }
}

Boolean _pascal VCImpexSVGIsCurveOpcode(word elementType)
{
    switch (elementType)
    {
        case GR_DRAW_CURVE:
        case GR_DRAW_CURVE_TO:
        case GR_DRAW_REL_CURVE_TO:
            return TRUE;
        default:
            return FALSE;
    }
}

Boolean _pascal VCImpexSVGIsArcOpcode(word elementType)
{
    switch (elementType)
    {
        case GR_DRAW_ARC:
        case GR_FILL_ARC:
            return TRUE;
        default:
            return FALSE;
    }
}

Boolean _pascal VCImpexSVGIsPolygonOpcode(word elementType)
{
    switch (elementType)
    {
        case GR_DRAW_POLYGON:
        case GR_DRAW_POLYLINE:
        case GR_FILL_POLYGON:
            return TRUE;
        default:
            return FALSE;
    }
}

/****************************************************************************
 * VCImpex SVG Export public entry point
 ****************************************************************************/

dword _export _pascal ExportProcedure(ExportFrame *frame)
{
    GStateHandle sourceGState;
    VCImpexSVGExportContext context;
    word error;

    if ((frame == NULL) || (frame->EF_transferVMChain == 0))
        return TE_EXPORT_ERROR;

    sourceGState = GrLoadGString(frame->EF_transferVMFile, GST_VMEM,
                                 VMCHAIN_GET_VM_BLOCK(frame->EF_transferVMChain));
    if (sourceGState == 0)
        return TE_METAFILE_CREATION_ERROR;

    context.svgFile = frame->EF_outputFile;
    if (FileTruncate(context.svgFile, 0, FALSE) != 0)
    {
        GrDestroyGString(sourceGState, 0, GSKT_LEAVE_DATA);
        return TE_FILE_WRITE;
    }

    FilePos(context.svgFile, 0, FILE_POS_START);
    GrGetGStringBoundsDWord(sourceGState, 0, 0, &context.bounds);
    context.lineWidth = 0;
    context.lineColor = 0;
    context.fillColor = 0;

    context.bufferHeapH = MemAllocLMem(LMEM_TYPE_GENERAL, 0);
    if (context.bufferHeapH == NullHandle)
    {
        GrDestroyGString(sourceGState, 0, GSKT_LEAVE_DATA);
        return TE_OUT_OF_MEMORY;
    }

    error = VCImpexSVGExportGString(sourceGState, &context);

    if (context.bufferHeapH != NullHandle)
    {
        MemFree(context.bufferHeapH);
        context.bufferHeapH = NullHandle;
    }

    GrDestroyGString(sourceGState, 0, GSKT_LEAVE_DATA);

    return error;
}

/****************************************************************************
 * Core gstring traversal
 ****************************************************************************/

word _pascal VCImpexSVGExportGString(GStateHandle sourceGState, VCImpexSVGExportContext *context)
{
    MemHandle playbackBlockH;
    ChunkHandle playbackChunk;
    GStateHandle playbackGState;
    word elementType;
    word elementSize;
    PointWWFixed currentPosition;
    word error;
    GSRetType gsr;
    VCImpexSVGPendingRect pendingRect;
    word dispatchIndex;
    const VCImpexSVGDispatchEntry *entry;
    word handlerResult;


    playbackBlockH = MemAllocLMem(LMEM_TYPE_GENERAL, sizeof(LMemBlockHeader));
    if (playbackBlockH == NullHandle)
    {
        return TE_OUT_OF_MEMORY;
    }

    playbackGState = GrCreateGString(playbackBlockH, GST_CHUNK, (word*) &playbackChunk);
    if (playbackGState == 0)
    {
        MemFree(playbackBlockH);
        return TE_OUT_OF_MEMORY;
    }

    if (!VCImpexSVGWriteHeader(context))
    {
        GrDestroyGString(playbackGState, 0, GSKT_KILL_DATA);
        return TE_FILE_WRITE;
    }

    error = TE_NO_ERROR;
    VCImpexSVGInitPendingRect(&pendingRect);

    /* the main loop */
    for(gsr = GrDrawGString(playbackGState, sourceGState, 0, 0, GSC_ONE, &elementType);
        gsr == GSRT_ONE;
        gsr = GrDrawGString(playbackGState, sourceGState, 0, 0, GSC_ONE, &elementType))
    {

    //drawResult = GrDrawGString(playbackGState, sourceGState, 0, 0,
    //                           VCIMPEX_SVG_GSTRING_FLAGS, &elementType);
    //while (drawResult == GSRT_ONE)
    //{

        GrGetGStringElement(playbackGState, sourceGState, sizeof(svgElementBuffer.raw),
                            svgElementBuffer.raw, &elementSize);

        if (elementSize > sizeof(svgElementBuffer.raw))
        {
            error = TE_EXPORT_ERROR;
            break;
        }

        VCImpexSVGUpdateDrawingState(playbackGState, context);
        GrGetCurPosWWFixed(playbackGState, &currentPosition);

        /* Flush pending rectangle if we hit a transform/state change op */
        if ((elementType >= GR_APPLY_ROTATION && elementType <= GR_XFORM_1F) ||
            (elementType >= GR_SAVE_STATE && elementType <= GR_ATTR_9F))
        {
            if (!VCImpexSVGFlushPendingRect(context, &pendingRect))
            {
                error = TE_FILE_WRITE;
                break;
            }
            /* skip handling state ops */
            continue;
        }

        /* If current element is not a rect, flush any pending rect to preserve order */
        if (!VCImpexSVGIsRectangleOpcode(elementType))
        {
            if (!VCImpexSVGFlushPendingRect(context, &pendingRect))
            {
                error = TE_FILE_WRITE;
                break;
            }
        }

        handlerResult = TE_NO_ERROR;
        for (dispatchIndex = 0; dispatchIndex < VCIMPEX_SVG_DISPATCH_COUNT; dispatchIndex++)
        {
            entry = &gVCImpexSVGDispatchTable[dispatchIndex];
            if (entry->predicate(elementType))
            {
                handlerResult = entry->handler(elementType, playbackGState, context, &currentPosition, &pendingRect);
                break;
            }
        }

        if (handlerResult != TE_NO_ERROR)
        {
            error = handlerResult;
            break;
        }
    }

    //if ((error == TE_NO_ERROR) && (drawResult != GSRT_COMPLETE))
    //{
    //    error = TE_EXPORT_ERROR;
    //}

    /* Flush any pending rectangle before footer */
    if (error == TE_NO_ERROR)
    {
        if (!VCImpexSVGFlushPendingRect(context, &pendingRect))
        {
            error = TE_FILE_WRITE;
        }
    }

    if (error == TE_NO_ERROR)
    {
        if (!VCImpexSVGWriteFooter(context))
        {
            error = TE_FILE_WRITE;
        }
    }

    GrDestroyGString(playbackGState, 0, GSKT_KILL_DATA);

    return error;
}

/****************************************************************************
 * Opcode handlers
 ****************************************************************************/

word _pascal VCImpexSVGHandleLineOpcode(word elementType, GStateHandle playbackGState, VCImpexSVGExportContext *context, PointWWFixed *currentPosition, VCImpexSVGPendingRect *pendingRect)
{
    PointWWFixed startPoint;
    PointWWFixed endPoint;
    Point intPoint1;
    Point intPoint2;
    Point tempPoint;
    PointWWFixed deltaPoint;
    WWFixedAsDWord componentValue;
    OpDrawLine *drawLineP;
    OpDrawLineTo *drawLineToP;
    OpDrawRelLineTo *drawRelLineToP;
    OpDrawHLine *drawHLineP;
    OpDrawHLineTo *drawHLineToP;
    OpDrawVLine *drawVLineP;
    OpDrawVLineTo *drawVLineToP;

    (void)pendingRect;

    switch (elementType)
    {
        case GR_DRAW_LINE:
            drawLineP = (OpDrawLine*)VCImpexSVGAs(svgElementBuffer.raw, GR_DRAW_LINE);
            if (drawLineP == (void*)0)
            {
                return TE_EXPORT_ERROR;
            }
            intPoint1.P_x = (sword)drawLineP->ODL_x1;
            intPoint1.P_y = (sword)drawLineP->ODL_y1;
            intPoint2.P_x = (sword)drawLineP->ODL_x2;
            intPoint2.P_y = (sword)drawLineP->ODL_y2;
            VCImpexSVGTransformPointFromInt(playbackGState, &intPoint1, &startPoint);
            VCImpexSVGTransformPointFromInt(playbackGState, &intPoint2, &endPoint);
            if (!VCImpexSVGWriteLineElement(context, &startPoint, &endPoint))
            {
                return TE_FILE_WRITE;
            }
            return TE_NO_ERROR;

        case GR_DRAW_LINE_TO:
            VCImpexSVGTransformPointFromFixed(playbackGState, currentPosition, &startPoint);
            drawLineToP = (OpDrawLineTo*)VCImpexSVGAs(svgElementBuffer.raw, GR_DRAW_LINE_TO);
            if (drawLineToP == (void*)0)
            {
                return TE_EXPORT_ERROR;
            }
            intPoint1.P_x = (sword)drawLineToP->ODLT_x2;
            intPoint1.P_y = (sword)drawLineToP->ODLT_y2;
            VCImpexSVGTransformPointFromInt(playbackGState, &intPoint1, &endPoint);
            if (!VCImpexSVGWriteLineElement(context, &startPoint, &endPoint))
            {
                return TE_FILE_WRITE;
            }
            return TE_NO_ERROR;

        case GR_DRAW_REL_LINE_TO:
            VCImpexSVGTransformPointFromFixed(playbackGState, currentPosition, &startPoint);
            drawRelLineToP = (OpDrawRelLineTo*)VCImpexSVGAs(svgElementBuffer.raw, GR_DRAW_REL_LINE_TO);
            if (drawRelLineToP == (void*)0)
            {
                return TE_EXPORT_ERROR;
            }
            deltaPoint.PF_x.WWF_int = drawRelLineToP->ODRLT_x2.WWF_int;
            deltaPoint.PF_x.WWF_frac = drawRelLineToP->ODRLT_x2.WWF_frac;
            deltaPoint.PF_y.WWF_int = drawRelLineToP->ODRLT_y2.WWF_int;
            deltaPoint.PF_y.WWF_frac = drawRelLineToP->ODRLT_y2.WWF_frac;
            VCImpexSVGTransformRelativePoint(playbackGState, &deltaPoint, &endPoint);
            if (!VCImpexSVGWriteLineElement(context, &startPoint, &endPoint))
            {
                return TE_FILE_WRITE;
            }
            return TE_NO_ERROR;

        case GR_DRAW_HLINE:
            drawHLineP = (OpDrawHLine*)VCImpexSVGAs(svgElementBuffer.raw, GR_DRAW_HLINE);
            if (drawHLineP == (void*)0)
            {
                return TE_EXPORT_ERROR;
            }
            tempPoint.P_x = (sword)drawHLineP->ODHL_x1;
            tempPoint.P_y = (sword)drawHLineP->ODHL_y1;
            VCImpexSVGTransformPointFromInt(playbackGState, &tempPoint, &startPoint);
            componentValue = ((WWFixedAsDWord)((sdword)(sword)drawHLineP->ODHL_x2)) << 16;
            VCImpexSVGSetWWFixedComponent(&currentPosition->PF_x, componentValue);
            VCImpexSVGTransformPointFromFixed(playbackGState, currentPosition, &endPoint);
            if (!VCImpexSVGWriteLineElement(context, &startPoint, &endPoint))
            {
                return TE_FILE_WRITE;
            }
            return TE_NO_ERROR;

        case GR_DRAW_VLINE:
            drawVLineP = (OpDrawVLine*)VCImpexSVGAs(svgElementBuffer.raw, GR_DRAW_VLINE);
            if (drawVLineP == (void*)0)
            {
                return TE_EXPORT_ERROR;
            }
            tempPoint.P_x = (sword)drawVLineP->ODVL_x1;
            tempPoint.P_y = (sword)drawVLineP->ODVL_y1;
            VCImpexSVGTransformPointFromInt(playbackGState, &tempPoint, &startPoint);
            componentValue = ((WWFixedAsDWord)((sdword)(sword)drawVLineP->ODVL_y2)) << 16;
            VCImpexSVGSetWWFixedComponent(&currentPosition->PF_y, componentValue);
            VCImpexSVGTransformPointFromFixed(playbackGState, currentPosition, &endPoint);
            if (!VCImpexSVGWriteLineElement(context, &startPoint, &endPoint))
            {
                return TE_FILE_WRITE;
            }
            return TE_NO_ERROR;

        case GR_DRAW_HLINE_TO:
            VCImpexSVGTransformPointFromFixed(playbackGState, currentPosition, &startPoint);
            drawHLineToP = (OpDrawHLineTo*)VCImpexSVGAs(svgElementBuffer.raw, GR_DRAW_HLINE_TO);
            if (drawHLineToP == (void*)0)
            {
                return TE_EXPORT_ERROR;
            }
            componentValue = ((WWFixedAsDWord)((sdword)(sword)drawHLineToP->ODHLT_x2)) << 16;
            VCImpexSVGSetWWFixedComponent(&currentPosition->PF_x, componentValue);
            VCImpexSVGTransformPointFromFixed(playbackGState, currentPosition, &endPoint);
            if (!VCImpexSVGWriteLineElement(context, &startPoint, &endPoint))
            {
                return TE_FILE_WRITE;
            }
            return TE_NO_ERROR;

        case GR_DRAW_VLINE_TO:
            VCImpexSVGTransformPointFromFixed(playbackGState, currentPosition, &startPoint);
            drawVLineToP = (OpDrawVLineTo*)VCImpexSVGAs(svgElementBuffer.raw, GR_DRAW_VLINE_TO);
            if (drawVLineToP == (void*)0)
            {
                return TE_EXPORT_ERROR;
            }
            componentValue = ((WWFixedAsDWord)((sdword)(sword)drawVLineToP->ODVLT_y2)) << 16;
            VCImpexSVGSetWWFixedComponent(&currentPosition->PF_y, componentValue);
            VCImpexSVGTransformPointFromFixed(playbackGState, currentPosition, &endPoint);
            if (!VCImpexSVGWriteLineElement(context, &startPoint, &endPoint))
            {
                return TE_FILE_WRITE;
            }
            return TE_NO_ERROR;

        default:
            break;
    }
    return TE_NO_ERROR;
}

word _pascal VCImpexSVGHandleRectangleOpcode(word elementType, GStateHandle playbackGState, VCImpexSVGExportContext *context, PointWWFixed *currentPosition, VCImpexSVGPendingRect *pendingRect)
{
    PointWWFixed corner1;
    PointWWFixed corner3;
    Point intCorner1;
    Point intCorner3;
    Boolean filled;
    OpDrawRect *drawRectP;
    OpFillRect *fillRectP;
    OpDrawRectTo *drawRectToP;
    OpFillRectTo *fillRectToP;

    switch (elementType)
    {
        case GR_DRAW_RECT:
        case GR_FILL_RECT:
            if (elementType == GR_DRAW_RECT)
            {
                drawRectP = (OpDrawRect*)VCImpexSVGAs(svgElementBuffer.raw, GR_DRAW_RECT);
                if (drawRectP == (void*)0)
                {
                    return TE_EXPORT_ERROR;
                }
                intCorner1.P_x = (sword)drawRectP->ODR_x1;
                intCorner1.P_y = (sword)drawRectP->ODR_y1;
                intCorner3.P_x = (sword)drawRectP->ODR_x2;
                intCorner3.P_y = (sword)drawRectP->ODR_y2;
            }
            else
            {
                fillRectP = (OpFillRect*)VCImpexSVGAs(svgElementBuffer.raw, GR_FILL_RECT);
                if (fillRectP == (void*)0)
                {
                    return TE_EXPORT_ERROR;
                }
                intCorner1.P_x = (sword)fillRectP->OFFR_x1;
                intCorner1.P_y = (sword)fillRectP->OFFR_y1;
                intCorner3.P_x = (sword)fillRectP->OFFR_x2;
                intCorner3.P_y = (sword)fillRectP->OFFR_y2;
            }
            VCImpexSVGTransformPointFromInt(playbackGState, &intCorner1, &corner1);
            VCImpexSVGTransformPointFromInt(playbackGState, &intCorner3, &corner3);
            filled = (elementType == GR_FILL_RECT);
            /* Coalescing logic */
            if (pendingRect != NULL)
            {
                WWFixedAsDWord c1x = VCImpexSVGPackWWFixed(&corner1.PF_x);
                WWFixedAsDWord c1y = VCImpexSVGPackWWFixed(&corner1.PF_y);
                WWFixedAsDWord c3x = VCImpexSVGPackWWFixed(&corner3.PF_x);
                WWFixedAsDWord c3y = VCImpexSVGPackWWFixed(&corner3.PF_y);
                if (pendingRect->active)
                {
                    WWFixedAsDWord pc1x = VCImpexSVGPackWWFixed(&pendingRect->corner1.PF_x);
                    WWFixedAsDWord pc1y = VCImpexSVGPackWWFixed(&pendingRect->corner1.PF_y);
                    WWFixedAsDWord pc3x = VCImpexSVGPackWWFixed(&pendingRect->corner3.PF_x);
                    WWFixedAsDWord pc3y = VCImpexSVGPackWWFixed(&pendingRect->corner3.PF_y);
                    if (pc1x == c1x && pc1y == c1y && pc3x == c3x && pc3y == c3y)
                    {
                        if (filled)
                        {
                            pendingRect->haveFill = TRUE;
                            pendingRect->fillColor = context->fillColor;
                        }
                        else
                        {
                            pendingRect->haveStroke = (context->lineWidth != 0);
                            pendingRect->strokeColor = context->lineColor;
                            pendingRect->strokeWidth = context->lineWidth;
                        }
                        if (pendingRect->haveFill && pendingRect->haveStroke)
                        {
                            if (!VCImpexSVGFlushPendingRect(context, pendingRect))
                            {
                                return TE_FILE_WRITE;
                            }
                        }
                        return TE_NO_ERROR;
                    }
                    /* geometry differs: flush old then start new */
                    if (!VCImpexSVGFlushPendingRect(context, pendingRect))
                    {
                        return TE_FILE_WRITE;
                    }
                }
                /* Start new pending */
                pendingRect->active = TRUE;
                pendingRect->corner1 = corner1;
                pendingRect->corner3 = corner3;
                pendingRect->haveFill = filled ? TRUE : FALSE;
                pendingRect->haveStroke = (!filled && (context->lineWidth != 0)) ? TRUE : FALSE;
                pendingRect->strokeWidth = context->lineWidth;
                pendingRect->strokeColor = context->lineColor;
                pendingRect->fillColor = context->fillColor;
                return TE_NO_ERROR;
            }
            /* Fallback: no coalescing */
            if (!VCImpexSVGWriteRectElement(context, &corner1, &corner3, filled))
            {
                return TE_FILE_WRITE;
            }
            return TE_NO_ERROR;

        case GR_DRAW_RECT_TO:
        case GR_FILL_RECT_TO:
            VCImpexSVGTransformPointFromFixed(playbackGState, currentPosition, &corner1);
            if (elementType == GR_DRAW_RECT_TO)
            {
                drawRectToP = (OpDrawRectTo*)VCImpexSVGAs(svgElementBuffer.raw, GR_DRAW_RECT_TO);
                if (drawRectToP == (void*)0)
                {
                    return TE_EXPORT_ERROR;
                }
                intCorner3.P_x = (sword)drawRectToP->ODRT_x2;
                intCorner3.P_y = (sword)drawRectToP->ODRT_y2;
            }
            else
            {
                fillRectToP = (OpFillRectTo*)VCImpexSVGAs(svgElementBuffer.raw, GR_FILL_RECT_TO);
                if (fillRectToP == (void*)0)
                {
                    return TE_EXPORT_ERROR;
                }
                intCorner3.P_x = (sword)fillRectToP->OFFRT_x2;
                intCorner3.P_y = (sword)fillRectToP->OFFRT_y2;
            }
            VCImpexSVGTransformPointFromInt(playbackGState, &intCorner3, &corner3);
            filled = (elementType == GR_FILL_RECT_TO);
            if (pendingRect != NULL)
            {
                WWFixedAsDWord c1x = VCImpexSVGPackWWFixed(&corner1.PF_x);
                WWFixedAsDWord c1y = VCImpexSVGPackWWFixed(&corner1.PF_y);
                WWFixedAsDWord c3x = VCImpexSVGPackWWFixed(&corner3.PF_x);
                WWFixedAsDWord c3y = VCImpexSVGPackWWFixed(&corner3.PF_y);
                if (pendingRect->active)
                {
                    WWFixedAsDWord pc1x = VCImpexSVGPackWWFixed(&pendingRect->corner1.PF_x);
                    WWFixedAsDWord pc1y = VCImpexSVGPackWWFixed(&pendingRect->corner1.PF_y);
                    WWFixedAsDWord pc3x = VCImpexSVGPackWWFixed(&pendingRect->corner3.PF_x);
                    WWFixedAsDWord pc3y = VCImpexSVGPackWWFixed(&pendingRect->corner3.PF_y);
                    if (pc1x == c1x && pc1y == c1y && pc3x == c3x && pc3y == c3y)
                    {
                        if (filled)
                        {
                            pendingRect->haveFill = TRUE;
                            pendingRect->fillColor = context->fillColor;
                        }
                        else
                        {
                            pendingRect->haveStroke = (context->lineWidth != 0);
                            pendingRect->strokeColor = context->lineColor;
                            pendingRect->strokeWidth = context->lineWidth;
                        }
                        if (pendingRect->haveFill && pendingRect->haveStroke)
                        {
                            if (!VCImpexSVGFlushPendingRect(context, pendingRect))
                            {
                                return TE_FILE_WRITE;
                            }
                        }
                        return TE_NO_ERROR;
                    }
                    if (!VCImpexSVGFlushPendingRect(context, pendingRect))
                    {
                        return TE_FILE_WRITE;
                    }
                }
                pendingRect->active = TRUE;
                pendingRect->corner1 = corner1;
                pendingRect->corner3 = corner3;
                pendingRect->haveFill = filled ? TRUE : FALSE;
                pendingRect->haveStroke = (!filled && (context->lineWidth != 0)) ? TRUE : FALSE;
                pendingRect->strokeWidth = context->lineWidth;
                pendingRect->strokeColor = context->lineColor;
                pendingRect->fillColor = context->fillColor;
                return TE_NO_ERROR;
            }
            if (!VCImpexSVGWriteRectElement(context, &corner1, &corner3, filled))
            {
                return TE_FILE_WRITE;
            }
            return TE_NO_ERROR;

        default:
            break;
    }
    return TE_NO_ERROR;
}

word _pascal VCImpexSVGHandleEllipseOpcode(word elementType, GStateHandle playbackGState, VCImpexSVGExportContext *context, PointWWFixed *currentPosition, VCImpexSVGPendingRect *pendingRect)
{
    WWFixed cx = {0};
    WWFixed cy = {0};
    WWFixed rx = {0};
    WWFixed ry = {0};
    sword x1, y1, x2, y2;
    sdword sum;
    sword dx, dy;
    TransMatrix tm;
    Boolean filled;
    OpDrawEllipse *drawEllipseP;
    OpFillEllipse *fillEllipseP;

    (void)currentPosition;
    (void)pendingRect;

    switch (elementType)
    {
        case GR_DRAW_ELLIPSE:
        case GR_FILL_ELLIPSE:
            if (elementType == GR_DRAW_ELLIPSE)
            {
                drawEllipseP = (OpDrawEllipse*)VCImpexSVGAs(svgElementBuffer.raw, GR_DRAW_ELLIPSE);
                if (drawEllipseP == (void*)0)
                {
                    return TE_EXPORT_ERROR;
                }
                x1 = (sword)drawEllipseP->ODE_x1;
                y1 = (sword)drawEllipseP->ODE_y1;
                x2 = (sword)drawEllipseP->ODE_x2;
                y2 = (sword)drawEllipseP->ODE_y2;
            }
            else
            {
                fillEllipseP = (OpFillEllipse*)VCImpexSVGAs(svgElementBuffer.raw, GR_FILL_ELLIPSE);
                if (fillEllipseP == (void*)0)
                {
                    return TE_EXPORT_ERROR;
                }
                x1 = (sword)fillEllipseP->OFE_x1;
                y1 = (sword)fillEllipseP->OFE_y1;
                x2 = (sword)fillEllipseP->OFE_x2;
                y2 = (sword)fillEllipseP->OFE_y2;
            }

            /* center x */
            sum = (sdword)x1 + (sdword)x2;
            cx.WWF_int = (sword)(sum / 2);
            cx.WWF_frac = (word)((sum & 1) ? 0x8000 : 0);
            /* center y */
            sum = (sdword)y1 + (sdword)y2;
            cy.WWF_int = (sword)(sum / 2);
            cy.WWF_frac = (word)((sum & 1) ? 0x8000 : 0);

            /* radii */
            dx = (sword)(x2 - x1);
            if (dx < 0) dx = -dx;
            rx.WWF_int = (sword)(dx / 2);
            rx.WWF_frac = (word)((dx & 1) ? 0x8000 : 0);

            dy = (sword)(y2 - y1);
            if (dy < 0) dy = -dy;
            ry.WWF_int = (sword)(dy / 2);
            ry.WWF_frac = (word)((dy & 1) ? 0x8000 : 0);

            filled = (elementType == GR_FILL_ELLIPSE);

            /* get current transform so we can emit exact transform matrix */
            GrGetTransform(playbackGState, &tm);
            if (!VCImpexSVGWriteEllipseElement(context, &cx, &cy, &rx, &ry, filled, &tm))
            {
                return TE_FILE_WRITE;
            }
            return TE_NO_ERROR;

        default:
            break;
    }
    return TE_NO_ERROR;
}

word _pascal VCImpexSVGHandlePolygonOpcode(word elementType, GStateHandle playbackGState, VCImpexSVGExportContext *context, PointWWFixed *currentPosition, VCImpexSVGPendingRect *pendingRect)
{
    const Point *sourcePoints;
    word pointCount;
    word index;
    Boolean closeShape;
    Boolean filledShape;
    OpDrawPolygon *drawPolygonP;
    OpDrawPolyline *drawPolylineP;
    OpFillPolygon *fillPolygonP;

    (void)currentPosition;
    (void)pendingRect;

    switch (elementType)
    {
        case GR_DRAW_POLYGON:
            drawPolygonP = (OpDrawPolygon*)VCImpexSVGAs(svgElementBuffer.raw, GR_DRAW_POLYGON);
            if (drawPolygonP == (void*)0)
            {
                return TE_EXPORT_ERROR;
            }
            pointCount = drawPolygonP->ODPG_count;
            sourcePoints = (const Point *)((const byte *)drawPolygonP + sizeof(OpDrawPolygon));
            closeShape = TRUE;
            filledShape = FALSE;
            break;

        case GR_DRAW_POLYLINE:
            drawPolylineP = (OpDrawPolyline*)VCImpexSVGAs(svgElementBuffer.raw, GR_DRAW_POLYLINE);
            if (drawPolylineP == (void*)0)
            {
                return TE_EXPORT_ERROR;
            }
            pointCount = drawPolylineP->ODPL_count;
            sourcePoints = (const Point *)((const byte *)drawPolylineP + sizeof(OpDrawPolyline));
            closeShape = FALSE;
            filledShape = FALSE;
            break;

        case GR_FILL_POLYGON:
            fillPolygonP = (OpFillPolygon*)VCImpexSVGAs(svgElementBuffer.raw, GR_FILL_POLYGON);
            if (fillPolygonP == (void*)0)
            {
                return TE_EXPORT_ERROR;
            }
            pointCount = fillPolygonP->OFP_count;
            sourcePoints = (const Point *)((const byte *)fillPolygonP + sizeof(OpFillPolygon));
            closeShape = TRUE;
            filledShape = TRUE;
            break;

        default:
            return TE_NO_ERROR;
    }

    if (pointCount == 0)
    {
        return TE_NO_ERROR;
    }

    if (pointCount > VCIMPEX_SVG_MAX_POLY_POINTS)
    {
        return TE_EXPORT_ERROR;
    }

    for (index = 0; index < pointCount; index++)
    {
        VCImpexSVGTransformPointFromInt(playbackGState, &sourcePoints[index], &svgPolygonBuffer[index]);
    }

    if (!VCImpexSVGWritePolygonElement(context, svgPolygonBuffer, pointCount, closeShape, filledShape))
    {
        return TE_FILE_WRITE;
    }
    return TE_NO_ERROR;
}

word _pascal VCImpexSVGHandleRoundRectOpcode(word elementType, GStateHandle playbackGState, VCImpexSVGExportContext *context, PointWWFixed *currentPosition, VCImpexSVGPendingRect *pendingRect)
{
    PointWWFixed corner1;
    PointWWFixed corner3;
    WWFixed radiusX;
    WWFixed radiusY;
    XYValueAsDWord t0;
    XYValueAsDWord tx;
    XYValueAsDWord ty;
    Boolean filled;
    OpDrawRoundRect *roundRectP;
    OpDrawRoundRectTo *roundRectToP;
    Point intCorner1;
    Point intCorner3;
    word radiusValue;

    (void)pendingRect;

    switch (elementType)
    {
        case GR_DRAW_ROUND_RECT:
        case GR_FILL_ROUND_RECT:
            roundRectP = (OpDrawRoundRect*)VCImpexSVGAs(svgElementBuffer.raw, elementType);
            if (roundRectP == (void*)0)
            {
                return TE_EXPORT_ERROR;
            }
            intCorner1.P_x = (sword)roundRectP->ODRR_x1;
            intCorner1.P_y = (sword)roundRectP->ODRR_y1;
            intCorner3.P_x = (sword)roundRectP->ODRR_x2;
            intCorner3.P_y = (sword)roundRectP->ODRR_y2;
            VCImpexSVGTransformPointFromInt(playbackGState, &intCorner1, &corner1);
            VCImpexSVGTransformPointFromInt(playbackGState, &intCorner3, &corner3);
            radiusValue = roundRectP->ODRR_radius;
            /* Transform radius r along x and y axes to world coordinates */
            t0 = GrTransform(playbackGState, 0, 0);
            tx = GrTransform(playbackGState, (sword)radiusValue, 0);
            ty = GrTransform(playbackGState, 0, (sword)radiusValue);
            {
                sdword dx = (sdword)DWORD_X(tx) - (sdword)DWORD_X(t0);
                sdword dy = (sdword)DWORD_Y(ty) - (sdword)DWORD_Y(t0);
                if (dx < 0) dx = -dx;
                if (dy < 0) dy = -dy;
                if (dx > 32767) dx = 32767;
                if (dy > 32767) dy = 32767;
                radiusX.WWF_int = (sword)dx;
                radiusY.WWF_int = (sword)dy;
            }
            radiusX.WWF_frac = 0;
            radiusY.WWF_frac = 0;
            radiusY.WWF_frac = 0;
            filled = (elementType == GR_FILL_ROUND_RECT);
            if (!VCImpexSVGWriteRoundRectElement(context, &corner1, &corner3, &radiusX, &radiusY, filled))
            {
                return TE_FILE_WRITE;
            }
            return TE_NO_ERROR;

        case GR_DRAW_ROUND_RECT_TO:
        case GR_FILL_ROUND_RECT_TO:
            VCImpexSVGTransformPointFromFixed(playbackGState, currentPosition, &corner1);
            roundRectToP = (OpDrawRoundRectTo*)VCImpexSVGAs(svgElementBuffer.raw, elementType);
            if (roundRectToP == (void*)0)
            {
                return TE_EXPORT_ERROR;
            }
            intCorner3.P_x = (sword)roundRectToP->ODRRT_x2;
            intCorner3.P_y = (sword)roundRectToP->ODRRT_y2;
            VCImpexSVGTransformPointFromInt(playbackGState, &intCorner3, &corner3);
            radiusValue = roundRectToP->ODRRT_radius;
            t0 = GrTransform(playbackGState, 0, 0);
            tx = GrTransform(playbackGState, (sword)radiusValue, 0);
            ty = GrTransform(playbackGState, 0, (sword)radiusValue);
            {
                sdword dx = (sdword)DWORD_X(tx) - (sdword)DWORD_X(t0);
                sdword dy = (sdword)DWORD_Y(ty) - (sdword)DWORD_Y(t0);
                if (dx < 0) dx = -dx;
                if (dy < 0) dy = -dy;
                if (dx > 32767) dx = 32767;
                if (dy > 32767) dy = 32767;
                radiusX.WWF_int = (sword)dx;
                radiusY.WWF_int = (sword)dy;
            }
            radiusX.WWF_frac = 0;
            radiusY.WWF_frac = 0;
            radiusY.WWF_frac = 0;
            filled = (elementType == GR_FILL_ROUND_RECT_TO);
            if (!VCImpexSVGWriteRoundRectElement(context, &corner1, &corner3, &radiusX, &radiusY, filled))
            {
                return TE_FILE_WRITE;
            }
            return TE_NO_ERROR;

        default:
            break;
    }
    return TE_NO_ERROR;
}

word _pascal VCImpexSVGHandleCurveOpcode(word elementType, GStateHandle playbackGState, VCImpexSVGExportContext *context, PointWWFixed *currentPosition, VCImpexSVGPendingRect *pendingRect)
{
    PointWWFixed startPoint;
    PointWWFixed cp1;
    PointWWFixed cp2;
    PointWWFixed endPoint;
    OpDrawCurve *drawCurveP;
    OpDrawCurveTo *drawCurveToP;
    OpDrawRelCurveTo *drawRelCurveToP;
    Point intPoint;

    (void)pendingRect;

    switch (elementType)
    {
        case GR_DRAW_CURVE:
            drawCurveP = (OpDrawCurve*)VCImpexSVGAs(svgElementBuffer.raw, GR_DRAW_CURVE);
            if (drawCurveP == (void*)0)
            {
                return TE_EXPORT_ERROR;
            }
            intPoint.P_x = drawCurveP->ODCV_x1;
            intPoint.P_y = drawCurveP->ODCV_y1;
            VCImpexSVGTransformPointFromInt(playbackGState, &intPoint, &startPoint);
            intPoint.P_x = drawCurveP->ODCV_x2;
            intPoint.P_y = drawCurveP->ODCV_y2;
            VCImpexSVGTransformPointFromInt(playbackGState, &intPoint, &cp1);
            intPoint.P_x = drawCurveP->ODCV_x3;
            intPoint.P_y = drawCurveP->ODCV_y3;
            VCImpexSVGTransformPointFromInt(playbackGState, &intPoint, &cp2);
            intPoint.P_x = drawCurveP->ODCV_x4;
            intPoint.P_y = drawCurveP->ODCV_y4;
            VCImpexSVGTransformPointFromInt(playbackGState, &intPoint, &endPoint);
            if (!VCImpexSVGWriteCubicPathElement(context, &startPoint, &cp1, &cp2, &endPoint))
                return TE_FILE_WRITE;
            return TE_NO_ERROR;

        case GR_DRAW_CURVE_TO:
            VCImpexSVGTransformPointFromFixed(playbackGState, currentPosition, &startPoint);
            drawCurveToP = (OpDrawCurveTo*)VCImpexSVGAs(svgElementBuffer.raw, GR_DRAW_CURVE_TO);
            if (drawCurveToP == (void*)0)
            {
                return TE_EXPORT_ERROR;
            }
            intPoint.P_x = drawCurveToP->ODCVT_x2;
            intPoint.P_y = drawCurveToP->ODCVT_y2;
            VCImpexSVGTransformPointFromInt(playbackGState, &intPoint, &cp1);
            intPoint.P_x = drawCurveToP->ODCVT_x3;
            intPoint.P_y = drawCurveToP->ODCVT_y3;
            VCImpexSVGTransformPointFromInt(playbackGState, &intPoint, &cp2);
            intPoint.P_x = drawCurveToP->ODCVT_x4;
            intPoint.P_y = drawCurveToP->ODCVT_y4;
            VCImpexSVGTransformPointFromInt(playbackGState, &intPoint, &endPoint);
            if (!VCImpexSVGWriteCubicPathElement(context, &startPoint, &cp1, &cp2, &endPoint))
                return TE_FILE_WRITE;
            return TE_NO_ERROR;

        case GR_DRAW_REL_CURVE_TO:
        {
            PointWWFixed delta;
            drawRelCurveToP = (OpDrawRelCurveTo*)VCImpexSVGAs(svgElementBuffer.raw, GR_DRAW_REL_CURVE_TO);
            if (drawRelCurveToP == (void*)0)
            {
                return TE_EXPORT_ERROR;
            }
            /* cp1 */
            delta.PF_x.WWF_int = drawRelCurveToP->ODRCVT_x2;
            delta.PF_x.WWF_frac = 0;
            delta.PF_y.WWF_int = drawRelCurveToP->ODRCVT_y2;
            delta.PF_y.WWF_frac = 0;
            VCImpexSVGTransformPointFromFixed(playbackGState, currentPosition, &startPoint);
            VCImpexSVGTransformRelativePoint(playbackGState, &delta, &cp1);
            /* cp2 */
            delta.PF_x.WWF_int = drawRelCurveToP->ODRCVT_x3;
            delta.PF_x.WWF_frac = 0;
            delta.PF_y.WWF_int = drawRelCurveToP->ODRCVT_y3;
            delta.PF_y.WWF_frac = 0;
            VCImpexSVGTransformRelativePoint(playbackGState, &delta, &cp2);
            /* end */
            delta.PF_x.WWF_int = drawRelCurveToP->ODRCVT_x4;
            delta.PF_x.WWF_frac = 0;
            delta.PF_y.WWF_int = drawRelCurveToP->ODRCVT_y4;
            delta.PF_y.WWF_frac = 0;
            VCImpexSVGTransformRelativePoint(playbackGState, &delta, &endPoint);
            if (!VCImpexSVGWriteCubicPathElement(context, &startPoint, &cp1, &cp2, &endPoint))
                return TE_FILE_WRITE;
            return TE_NO_ERROR;
        }

        default:
            break;
    }
    return TE_NO_ERROR;
}

word _pascal VCImpexSVGHandleArcOpcode(word elementType, GStateHandle playbackGState, VCImpexSVGExportContext *context, PointWWFixed *currentPosition, VCImpexSVGPendingRect *pendingRect)
{
    Boolean fill = FALSE;
    OpDrawArc *drawArcP;
    OpFillArc *fillArcP;
    TransMatrix tm;
    WWFixed cx;
    WWFixed cy;
    WWFixed rx;
    WWFixed ry;
    word startAngle;
    word endAngle;
    sword x1;
    sword y1;
    sword x2;
    sword y2;
    ArcCloseType closeType;
    WWFixedAsDWord cxFixed;
    WWFixedAsDWord cyFixed;
    WWFixedAsDWord rxFixed;
    WWFixedAsDWord ryFixed;

    (void)currentPosition;
    (void)pendingRect;

    switch (elementType)
    {
        case GR_DRAW_ARC:
        case GR_FILL_ARC:
        {
            if (elementType == GR_DRAW_ARC)
            {
                drawArcP = (OpDrawArc*)VCImpexSVGAs(svgElementBuffer.raw, GR_DRAW_ARC);
                if (drawArcP == (void*)0)
                {
                    return TE_EXPORT_ERROR;
                }
                startAngle = drawArcP->ODA_ang1;
                endAngle = drawArcP->ODA_ang2;
                x1 = (sword)drawArcP->ODA_x1;
                y1 = (sword)drawArcP->ODA_y1;
                x2 = (sword)drawArcP->ODA_x2;
                y2 = (sword)drawArcP->ODA_y2;
                closeType = drawArcP->ODA_close;
            }
            else
            {
                fillArcP = (OpFillArc*)VCImpexSVGAs(svgElementBuffer.raw, GR_FILL_ARC);
                if (fillArcP == (void*)0)
                {
                    return TE_EXPORT_ERROR;
                }
                startAngle = fillArcP->OFA_ang1;
                endAngle = fillArcP->OFA_ang2;
                x1 = (sword)fillArcP->OFA_x1;
                y1 = (sword)fillArcP->OFA_y1;
                x2 = (sword)fillArcP->OFA_x2;
                y2 = (sword)fillArcP->OFA_y2;
                closeType = (ArcCloseType)fillArcP->OFA_close;
            }

            /* center */
            cx.WWF_int = (sword)((x1 + x2) / 2);
            cx.WWF_frac = (word)(((x1 + x2) & 1) ? 0x8000 : 0);
            cy.WWF_int = (sword)((y1 + y2) / 2);
            cy.WWF_frac = (word)(((y1 + y2) & 1) ? 0x8000 : 0);
            /* radii */
            rx.WWF_int = (sword)(((x2 - x1) < 0) ? ((x1 - x2) / 2) : ((x2 - x1) / 2));
            rx.WWF_frac = (word)((((x2 - x1) & 1) != 0) ? 0x8000 : 0);
            ry.WWF_int = (sword)(((y2 - y1) < 0) ? ((y1 - y2) / 2) : ((y2 - y1) / 2));
            ry.WWF_frac = (word)((((y2 - y1) & 1) != 0) ? 0x8000 : 0);

            cxFixed = VCImpexSVGPackWWFixed(&cx);
            cyFixed = VCImpexSVGPackWWFixed(&cy);
            rxFixed = VCImpexSVGPackWWFixed(&rx);
            ryFixed = VCImpexSVGPackWWFixed(&ry);

            GrGetTransform(playbackGState, &tm);

            fill = (elementType == GR_FILL_ARC) ? TRUE : FALSE;
            if (!VCImpexSVGWriteArcElement(context, cxFixed, cyFixed, rxFixed, ryFixed, startAngle, endAngle, closeType, fill, &tm))
                return TE_FILE_WRITE;
            return TE_NO_ERROR;
        }

        default:
            break;
    }
    return TE_NO_ERROR;
}

void _pascal VCImpexSVGSetWWFixedComponent(WWFixed *component, WWFixedAsDWord value)
{
    component->WWF_int = (word)((((sdword)value) >> 16) & 0xffff);
    component->WWF_frac = (word)(value & 0xffff);
}
