/***********************************************************************
 *
 * PROJECT:       VCImpex SVG Exporter
 * FILE:          svgexpproc.goc
 *
 * DESCRIPTION:   Implements the export procedure for SVG output
 *
 ***********************************************************************/
@include <stdapp.goh>

#include "svgexp.h"

#define VCIMPEX_SVG_GSTRING_FLAGS   (GSC_ONE)

typedef struct
{
    GStringElement element;
    union
    {
        struct { Point p1; Point p2; } DRAW_LINE;
        struct { Point p; } DRAW_LINE_TO;
        struct { PointWWFixed p; } DRAW_REL_LINE_TO;
        struct { Point p; sword xy; } DRAW_HVLINE;
        struct { sword xy; } DRAW_HVLINE_TO;
        struct { Point p1; Point p2; } DRAW_RECT;
        struct { Point p; } DRAW_RECT_TO;
        struct { word r; Point p1; Point p2; } DRAW_ROUND_RECT;
        struct { word r; Point p; } DRAW_ROUND_RECT_TO;
        struct { sword x1; sword y1; sword x2; sword y2; } DRAW_ELLIPSE;
        struct { sword x1; sword y1; sword x2; sword y2; sword x3; sword y3; sword x4; sword y4; } DRAW_CURVE;
        struct { sword x2; sword y2; sword x3; sword y3; sword x4; sword y4; } DRAW_CURVE_TO;
        struct { sword x2; sword y2; sword x3; sword y3; sword x4; sword y4; } DRAW_REL_CURVE_TO;
        struct { word close; sword x1; sword y1; sword x2; sword y2; word ang1; word ang2; } DRAW_ARC;
        struct { word close; sword x1; sword y1; sword x2; sword y2; word ang1; word ang2; } FILL_ARC;
        struct { word numPoints; Point p[VCIMPEX_SVG_MAX_POLY_POINTS]; } DRAW_POLY;
        struct { word numPoints; RegionFillRule rule; Point p[VCIMPEX_SVG_MAX_POLY_POINTS]; } FILL_POLYGON;
        byte raw[VCIMPEX_SVG_ELEMENT_BUFFER_SIZE];
    } data;
} VCImpexSVGGStringElement;

VCImpexSVGGStringElement svgElementBuffer;
PointWWFixed svgPolygonBuffer[VCIMPEX_SVG_MAX_POLY_POINTS];

word _pascal VCImpexSVGExportGString(GStateHandle sourceGState, VCImpexSVGExportContext *context);

word _pascal VCImpexSVGHandleLineOpcode(word elementType, GStateHandle playbackGState, VCImpexSVGExportContext *context, PointWWFixed *currentPosition, Boolean *handled);
word _pascal VCImpexSVGHandleRectangleOpcode(word elementType, GStateHandle playbackGState, VCImpexSVGExportContext *context, PointWWFixed *currentPosition, Boolean *handled, VCImpexSVGPendingRect *pendingRect);
word _pascal VCImpexSVGHandleRoundRectOpcode(word elementType, GStateHandle playbackGState, VCImpexSVGExportContext *context, PointWWFixed *currentPosition, Boolean *handled);
word _pascal VCImpexSVGHandleEllipseOpcode(word elementType, GStateHandle playbackGState, VCImpexSVGExportContext *context, Boolean *handled);
word _pascal VCImpexSVGHandleCurveOpcode(word elementType, GStateHandle playbackGState, VCImpexSVGExportContext *context, PointWWFixed *currentPosition, Boolean *handled);
word _pascal VCImpexSVGHandleArcOpcode(word elementType, GStateHandle playbackGState, VCImpexSVGExportContext *context, Boolean *handled);
word _pascal VCImpexSVGHandlePolygonOpcode(word elementType, GStateHandle playbackGState, VCImpexSVGExportContext *context, Boolean *handled);
void _pascal VCImpexSVGSetWWFixedComponent(WWFixed *component, WWFixedAsDWord value);

/****************************************************************************
 * VCImpex SVG Export public entry point
 ****************************************************************************/

dword _export _pascal ExportProcedure(ExportFrame *frame)
{
    GStateHandle sourceGState;
    VCImpexSVGExportContext context;
    word error;

    if ((frame == NULL) || (frame->EF_transferVMChain == 0))
        return TE_EXPORT_ERROR;

    sourceGState = GrLoadGString(frame->EF_transferVMFile, GST_VMEM,
                                 VMCHAIN_GET_VM_BLOCK(frame->EF_transferVMChain));
    if (sourceGState == 0)
        return TE_METAFILE_CREATION_ERROR;

    context.svgFile = frame->EF_outputFile;
    if (FileTruncate(context.svgFile, 0, FALSE) != 0)
    {
        GrDestroyGString(sourceGState, 0, GSKT_LEAVE_DATA);
        return TE_FILE_WRITE;
    }

    FilePos(context.svgFile, 0, FILE_POS_START);
    GrGetGStringBoundsDWord(sourceGState, 0, 0, &context.bounds);
    context.lineWidth = 0;
    context.lineColor = 0;
    context.fillColor = 0;

    context.bufferHeapH = MemAllocLMem(LMEM_TYPE_GENERAL, 0);
    if (context.bufferHeapH == NullHandle)
    {
        GrDestroyGString(sourceGState, 0, GSKT_LEAVE_DATA);
        return TE_OUT_OF_MEMORY;
    }

    error = VCImpexSVGExportGString(sourceGState, &context);

    if (context.bufferHeapH != NullHandle)
    {
        MemFree(context.bufferHeapH);
        context.bufferHeapH = NullHandle;
    }

    GrDestroyGString(sourceGState, 0, GSKT_LEAVE_DATA);

    return error;
}

/****************************************************************************
 * Core gstring traversal
 ****************************************************************************/

word _pascal VCImpexSVGExportGString(GStateHandle sourceGState, VCImpexSVGExportContext *context)
{
    MemHandle playbackBlockH;
    ChunkHandle playbackChunk;
    GStateHandle playbackGState;
    GSRetType drawResult;
    word elementType;
    word elementSize;
    PointWWFixed currentPosition;
    word error;
    word handlerResult;
    Boolean handled;
    GSRetType gsr;
    VCImpexSVGPendingRect pendingRect;


    playbackBlockH = MemAllocLMem(LMEM_TYPE_GENERAL, sizeof(LMemBlockHeader));
    if (playbackBlockH == NullHandle)
    {
        return TE_OUT_OF_MEMORY;
    }

    playbackGState = GrCreateGString(playbackBlockH, GST_CHUNK, (word*) &playbackChunk);
    if (playbackGState == 0)
    {
        MemFree(playbackBlockH);
        return TE_OUT_OF_MEMORY;
    }

    if (!VCImpexSVGWriteHeader(context))
    {
        GrDestroyGString(playbackGState, 0, GSKT_KILL_DATA);
        return TE_FILE_WRITE;
    }

    error = TE_NO_ERROR;
    VCImpexSVGInitPendingRect(&pendingRect);

    /* the main loop */
    for(gsr = GrDrawGString(playbackGState, sourceGState, 0, 0, GSC_ONE, &elementType);
        gsr == GSRT_ONE;
        gsr = GrDrawGString(playbackGState, sourceGState, 0, 0, GSC_ONE, &elementType))
    {

    //drawResult = GrDrawGString(playbackGState, sourceGState, 0, 0,
    //                           VCIMPEX_SVG_GSTRING_FLAGS, &elementType);
    //while (drawResult == GSRT_ONE)
    //{

        handled = FALSE;

        GrGetGStringElement(playbackGState, sourceGState, sizeof(svgElementBuffer),
                            &svgElementBuffer, &elementSize);

                            if (elementSize > sizeof(svgElementBuffer))
        {
            error = TE_EXPORT_ERROR;
            break;
        }

        VCImpexSVGUpdateDrawingState(playbackGState, context);
        GrGetCurPosWWFixed(playbackGState, &currentPosition);

        /* Flush pending rectangle if we hit a transform/state change op */
        if ((elementType >= GR_APPLY_ROTATION && elementType <= GR_XFORM_1F) ||
            (elementType >= GR_SAVE_STATE && elementType <= GR_ATTR_9F))
        {
            if (!VCImpexSVGFlushPendingRect(context, &pendingRect))
            {
                error = TE_FILE_WRITE;
                break;
            }
            /* skip handling state ops */
            continue;
        }

        /* If current element is not a rect, flush any pending rect to preserve order */
        if (!(elementType == GR_DRAW_RECT || elementType == GR_FILL_RECT ||
              elementType == GR_DRAW_RECT_TO || elementType == GR_FILL_RECT_TO))
        {
            if (!VCImpexSVGFlushPendingRect(context, &pendingRect))
            {
                error = TE_FILE_WRITE;
                break;
            }
        }

        handlerResult = VCImpexSVGHandleLineOpcode(elementType, playbackGState, context, &currentPosition, &handled);
        if (handlerResult != TE_NO_ERROR)
        {
            error = handlerResult;
            break;
        }

        if (!handled)
        {
            handlerResult = VCImpexSVGHandleRectangleOpcode(elementType, playbackGState, context, &currentPosition, &handled, &pendingRect);
            if (handlerResult != TE_NO_ERROR)
            {
                error = handlerResult;
                break;
            }

            if (!handled)
            {
                handlerResult = VCImpexSVGHandleRoundRectOpcode(elementType, playbackGState, context, &currentPosition, &handled);
                if (handlerResult != TE_NO_ERROR)
                {
                    error = handlerResult;
                    break;
                }

                if (!handled)
                {
                    handlerResult = VCImpexSVGHandleEllipseOpcode(elementType, playbackGState, context, &handled);
                    if (handlerResult != TE_NO_ERROR)
                    {
                        error = handlerResult;
                        break;
                    }
                    if (!handled)
                    {
                        handlerResult = VCImpexSVGHandleCurveOpcode(elementType, playbackGState, context, &currentPosition, &handled);
                        if (handlerResult != TE_NO_ERROR)
                        {
                            error = handlerResult;
                            break;
                        }
                        if (!handled)
                        {
                            handlerResult = VCImpexSVGHandleArcOpcode(elementType, playbackGState, context, &handled);
                            if (handlerResult != TE_NO_ERROR)
                            {
                                error = handlerResult;
                                break;
                            }
                            if (!handled)
                            {
                                handlerResult = VCImpexSVGHandlePolygonOpcode(elementType, playbackGState, context, &handled);
                                if (handlerResult != TE_NO_ERROR)
                                {
                                    error = handlerResult;
                                    break;
                                }
                            }
                        }
                    }
                }
            }
        }

        // drawResult = GrDrawGString(playbackGState, sourceGState, 0, 0,
        //                            VCIMPEX_SVG_GSTRING_FLAGS, &elementType);
    }

    //if ((error == TE_NO_ERROR) && (drawResult != GSRT_COMPLETE))
    //{
    //    error = TE_EXPORT_ERROR;
    //}

    /* Flush any pending rectangle before footer */
    if (error == TE_NO_ERROR)
    {
        if (!VCImpexSVGFlushPendingRect(context, &pendingRect))
        {
            error = TE_FILE_WRITE;
        }
    }

    if (error == TE_NO_ERROR)
    {
        if (!VCImpexSVGWriteFooter(context))
        {
            error = TE_FILE_WRITE;
        }
    }

    GrDestroyGString(playbackGState, 0, GSKT_KILL_DATA);

    return error;
}

/****************************************************************************
 * Opcode handlers
 ****************************************************************************/

word _pascal VCImpexSVGHandleLineOpcode(word elementType, GStateHandle playbackGState, VCImpexSVGExportContext *context, PointWWFixed *currentPosition, Boolean *handled)
{
    PointWWFixed startPoint;
    PointWWFixed endPoint;
    Point tempPoint;
    WWFixedAsDWord componentValue;

    *handled = TRUE;

    switch (elementType)
    {
        case GR_DRAW_LINE:
            VCImpexSVGTransformPointFromInt(playbackGState, &svgElementBuffer.data.DRAW_LINE.p1, &startPoint);
            VCImpexSVGTransformPointFromInt(playbackGState, &svgElementBuffer.data.DRAW_LINE.p2, &endPoint);
            if (!VCImpexSVGWriteLineElement(context, &startPoint, &endPoint))
            {
                return TE_FILE_WRITE;
            }
            return TE_NO_ERROR;

        case GR_DRAW_LINE_TO:
            VCImpexSVGTransformPointFromFixed(playbackGState, currentPosition, &startPoint);
            VCImpexSVGTransformPointFromInt(playbackGState, &svgElementBuffer.data.DRAW_LINE_TO.p, &endPoint);
            if (!VCImpexSVGWriteLineElement(context, &startPoint, &endPoint))
            {
                return TE_FILE_WRITE;
            }
            return TE_NO_ERROR;

        case GR_DRAW_REL_LINE_TO:
            VCImpexSVGTransformPointFromFixed(playbackGState, currentPosition, &startPoint);
            VCImpexSVGTransformRelativePoint(playbackGState, &svgElementBuffer.data.DRAW_REL_LINE_TO.p, &endPoint);
            if (!VCImpexSVGWriteLineElement(context, &startPoint, &endPoint))
            {
                return TE_FILE_WRITE;
            }
            return TE_NO_ERROR;

        case GR_DRAW_HLINE:
            tempPoint = svgElementBuffer.data.DRAW_HVLINE.p;
            VCImpexSVGTransformPointFromInt(playbackGState, &tempPoint, &startPoint);
            componentValue = ((WWFixedAsDWord)((sdword)svgElementBuffer.data.DRAW_HVLINE.xy)) << 16;
            VCImpexSVGSetWWFixedComponent(&currentPosition->PF_x, componentValue);
            VCImpexSVGTransformPointFromFixed(playbackGState, currentPosition, &endPoint);
            if (!VCImpexSVGWriteLineElement(context, &startPoint, &endPoint))
            {
                return TE_FILE_WRITE;
            }
            return TE_NO_ERROR;

        case GR_DRAW_VLINE:
            tempPoint = svgElementBuffer.data.DRAW_HVLINE.p;
            VCImpexSVGTransformPointFromInt(playbackGState, &tempPoint, &startPoint);
            componentValue = ((WWFixedAsDWord)((sdword)svgElementBuffer.data.DRAW_HVLINE.xy)) << 16;
            VCImpexSVGSetWWFixedComponent(&currentPosition->PF_y, componentValue);
            VCImpexSVGTransformPointFromFixed(playbackGState, currentPosition, &endPoint);
            if (!VCImpexSVGWriteLineElement(context, &startPoint, &endPoint))
            {
                return TE_FILE_WRITE;
            }
            return TE_NO_ERROR;

        case GR_DRAW_HLINE_TO:
            VCImpexSVGTransformPointFromFixed(playbackGState, currentPosition, &startPoint);
            componentValue = ((WWFixedAsDWord)((sdword)svgElementBuffer.data.DRAW_HVLINE_TO.xy)) << 16;
            VCImpexSVGSetWWFixedComponent(&currentPosition->PF_x, componentValue);
            VCImpexSVGTransformPointFromFixed(playbackGState, currentPosition, &endPoint);
            if (!VCImpexSVGWriteLineElement(context, &startPoint, &endPoint))
            {
                return TE_FILE_WRITE;
            }
            return TE_NO_ERROR;

        case GR_DRAW_VLINE_TO:
            VCImpexSVGTransformPointFromFixed(playbackGState, currentPosition, &startPoint);
            componentValue = ((WWFixedAsDWord)((sdword)svgElementBuffer.data.DRAW_HVLINE_TO.xy)) << 16;
            VCImpexSVGSetWWFixedComponent(&currentPosition->PF_y, componentValue);
            VCImpexSVGTransformPointFromFixed(playbackGState, currentPosition, &endPoint);
            if (!VCImpexSVGWriteLineElement(context, &startPoint, &endPoint))
            {
                return TE_FILE_WRITE;
            }
            return TE_NO_ERROR;

        default:
            break;
    }
    *handled = FALSE;
    return TE_NO_ERROR;
}

word _pascal VCImpexSVGHandleRectangleOpcode(word elementType, GStateHandle playbackGState, VCImpexSVGExportContext *context, PointWWFixed *currentPosition, Boolean *handled, VCImpexSVGPendingRect *pendingRect)
{
    PointWWFixed corner1;
    PointWWFixed corner3;
    Boolean filled;

    *handled = TRUE;

    switch (elementType)
    {
        case GR_DRAW_RECT:
        case GR_FILL_RECT:
            VCImpexSVGTransformPointFromInt(playbackGState, &svgElementBuffer.data.DRAW_RECT.p1, &corner1);
            VCImpexSVGTransformPointFromInt(playbackGState, &svgElementBuffer.data.DRAW_RECT.p2, &corner3);
            filled = (elementType == GR_FILL_RECT);
            /* Coalescing logic */
            if (pendingRect != NULL)
            {
                WWFixedAsDWord c1x = VCImpexSVGPackWWFixed(&corner1.PF_x);
                WWFixedAsDWord c1y = VCImpexSVGPackWWFixed(&corner1.PF_y);
                WWFixedAsDWord c3x = VCImpexSVGPackWWFixed(&corner3.PF_x);
                WWFixedAsDWord c3y = VCImpexSVGPackWWFixed(&corner3.PF_y);
                if (pendingRect->active)
                {
                    WWFixedAsDWord pc1x = VCImpexSVGPackWWFixed(&pendingRect->corner1.PF_x);
                    WWFixedAsDWord pc1y = VCImpexSVGPackWWFixed(&pendingRect->corner1.PF_y);
                    WWFixedAsDWord pc3x = VCImpexSVGPackWWFixed(&pendingRect->corner3.PF_x);
                    WWFixedAsDWord pc3y = VCImpexSVGPackWWFixed(&pendingRect->corner3.PF_y);
                    if (pc1x == c1x && pc1y == c1y && pc3x == c3x && pc3y == c3y)
                    {
                        if (filled)
                        {
                            pendingRect->haveFill = TRUE;
                            pendingRect->fillColor = context->fillColor;
                        }
                        else
                        {
                            pendingRect->haveStroke = (context->lineWidth != 0);
                            pendingRect->strokeColor = context->lineColor;
                            pendingRect->strokeWidth = context->lineWidth;
                        }
                        if (pendingRect->haveFill && pendingRect->haveStroke)
                        {
                            if (!VCImpexSVGFlushPendingRect(context, pendingRect))
                            {
                                return TE_FILE_WRITE;
                            }
                        }
                        return TE_NO_ERROR;
                    }
                    /* geometry differs: flush old then start new */
                    if (!VCImpexSVGFlushPendingRect(context, pendingRect))
                    {
                        return TE_FILE_WRITE;
                    }
                }
                /* Start new pending */
                pendingRect->active = TRUE;
                pendingRect->corner1 = corner1;
                pendingRect->corner3 = corner3;
                pendingRect->haveFill = filled ? TRUE : FALSE;
                pendingRect->haveStroke = (!filled && (context->lineWidth != 0)) ? TRUE : FALSE;
                pendingRect->strokeWidth = context->lineWidth;
                pendingRect->strokeColor = context->lineColor;
                pendingRect->fillColor = context->fillColor;
                return TE_NO_ERROR;
            }
            /* Fallback: no coalescing */
            if (!VCImpexSVGWriteRectElement(context, &corner1, &corner3, filled))
            {
                return TE_FILE_WRITE;
            }
            return TE_NO_ERROR;

        case GR_DRAW_RECT_TO:
        case GR_FILL_RECT_TO:
            VCImpexSVGTransformPointFromFixed(playbackGState, currentPosition, &corner1);
            VCImpexSVGTransformPointFromInt(playbackGState, &svgElementBuffer.data.DRAW_RECT_TO.p, &corner3);
            filled = (elementType == GR_FILL_RECT_TO);
            if (pendingRect != NULL)
            {
                WWFixedAsDWord c1x = VCImpexSVGPackWWFixed(&corner1.PF_x);
                WWFixedAsDWord c1y = VCImpexSVGPackWWFixed(&corner1.PF_y);
                WWFixedAsDWord c3x = VCImpexSVGPackWWFixed(&corner3.PF_x);
                WWFixedAsDWord c3y = VCImpexSVGPackWWFixed(&corner3.PF_y);
                if (pendingRect->active)
                {
                    WWFixedAsDWord pc1x = VCImpexSVGPackWWFixed(&pendingRect->corner1.PF_x);
                    WWFixedAsDWord pc1y = VCImpexSVGPackWWFixed(&pendingRect->corner1.PF_y);
                    WWFixedAsDWord pc3x = VCImpexSVGPackWWFixed(&pendingRect->corner3.PF_x);
                    WWFixedAsDWord pc3y = VCImpexSVGPackWWFixed(&pendingRect->corner3.PF_y);
                    if (pc1x == c1x && pc1y == c1y && pc3x == c3x && pc3y == c3y)
                    {
                        if (filled)
                        {
                            pendingRect->haveFill = TRUE;
                            pendingRect->fillColor = context->fillColor;
                        }
                        else
                        {
                            pendingRect->haveStroke = (context->lineWidth != 0);
                            pendingRect->strokeColor = context->lineColor;
                            pendingRect->strokeWidth = context->lineWidth;
                        }
                        if (pendingRect->haveFill && pendingRect->haveStroke)
                        {
                            if (!VCImpexSVGFlushPendingRect(context, pendingRect))
                            {
                                return TE_FILE_WRITE;
                            }
                        }
                        return TE_NO_ERROR;
                    }
                    if (!VCImpexSVGFlushPendingRect(context, pendingRect))
                    {
                        return TE_FILE_WRITE;
                    }
                }
                pendingRect->active = TRUE;
                pendingRect->corner1 = corner1;
                pendingRect->corner3 = corner3;
                pendingRect->haveFill = filled ? TRUE : FALSE;
                pendingRect->haveStroke = (!filled && (context->lineWidth != 0)) ? TRUE : FALSE;
                pendingRect->strokeWidth = context->lineWidth;
                pendingRect->strokeColor = context->lineColor;
                pendingRect->fillColor = context->fillColor;
                return TE_NO_ERROR;
            }
            if (!VCImpexSVGWriteRectElement(context, &corner1, &corner3, filled))
            {
                return TE_FILE_WRITE;
            }
            return TE_NO_ERROR;

        default:
            break;
    }
    *handled = FALSE;
    return TE_NO_ERROR;
}

word _pascal VCImpexSVGHandleEllipseOpcode(word elementType, GStateHandle playbackGState, VCImpexSVGExportContext *context, Boolean *handled)
{
    WWFixed cx = {0};
    WWFixed cy = {0};
    WWFixed rx = {0};
    WWFixed ry = {0};
    sword x1, y1, x2, y2;
    sdword sum;
    sword dx, dy;
    TransMatrix tm;
    Boolean filled;

    *handled = TRUE;

    switch (elementType)
    {
        case GR_DRAW_ELLIPSE:
        case GR_FILL_ELLIPSE:
            x1 = svgElementBuffer.data.DRAW_ELLIPSE.x1;
            y1 = svgElementBuffer.data.DRAW_ELLIPSE.y1;
            x2 = svgElementBuffer.data.DRAW_ELLIPSE.x2;
            y2 = svgElementBuffer.data.DRAW_ELLIPSE.y2;

            /* center x */
            sum = (sdword)x1 + (sdword)x2;
            cx.WWF_int = (sword)(sum / 2);
            cx.WWF_frac = (word)((sum & 1) ? 0x8000 : 0);
            /* center y */
            sum = (sdword)y1 + (sdword)y2;
            cy.WWF_int = (sword)(sum / 2);
            cy.WWF_frac = (word)((sum & 1) ? 0x8000 : 0);

            /* radii */
            dx = (sword)(x2 - x1);
            if (dx < 0) dx = -dx;
            rx.WWF_int = (sword)(dx / 2);
            rx.WWF_frac = (word)((dx & 1) ? 0x8000 : 0);

            dy = (sword)(y2 - y1);
            if (dy < 0) dy = -dy;
            ry.WWF_int = (sword)(dy / 2);
            ry.WWF_frac = (word)((dy & 1) ? 0x8000 : 0);

            filled = (elementType == GR_FILL_ELLIPSE);

            /* get current transform so we can emit exact transform matrix */
            GrGetTransform(playbackGState, &tm);
            if (!VCImpexSVGWriteEllipseElement(context, &cx, &cy, &rx, &ry, filled, &tm))
            {
                return TE_FILE_WRITE;
            }
            return TE_NO_ERROR;

        default:
            break;
    }
    *handled = FALSE;
    return TE_NO_ERROR;
}

word _pascal VCImpexSVGHandlePolygonOpcode(word elementType, GStateHandle playbackGState, VCImpexSVGExportContext *context, Boolean *handled)
{
    Point *sourcePoints;
    word pointCount;
    word index;
    Boolean closeShape;
    Boolean filledShape;

    *handled = TRUE;

    switch (elementType)
    {
        case GR_DRAW_POLYGON:
            pointCount = svgElementBuffer.data.DRAW_POLY.numPoints;
            sourcePoints = svgElementBuffer.data.DRAW_POLY.p;
            closeShape = TRUE;
            filledShape = FALSE;
            break;

        case GR_DRAW_POLYLINE:
            pointCount = svgElementBuffer.data.DRAW_POLY.numPoints;
            sourcePoints = svgElementBuffer.data.DRAW_POLY.p;
            closeShape = FALSE;
            filledShape = FALSE;
            break;

        case GR_FILL_POLYGON:
            pointCount = svgElementBuffer.data.FILL_POLYGON.numPoints;
            sourcePoints = svgElementBuffer.data.FILL_POLYGON.p;
            closeShape = TRUE;
            filledShape = TRUE;
            break;

        default:
            *handled = FALSE;
            return TE_NO_ERROR;
    }

    if (pointCount == 0)
    {
        return TE_NO_ERROR;
    }

    if (pointCount > VCIMPEX_SVG_MAX_POLY_POINTS)
    {
        return TE_EXPORT_ERROR;
    }

    for (index = 0; index < pointCount; index++)
    {
        VCImpexSVGTransformPointFromInt(playbackGState, &sourcePoints[index], &svgPolygonBuffer[index]);
    }

    if (!VCImpexSVGWritePolygonElement(context, svgPolygonBuffer, pointCount, closeShape, filledShape))
    {
        return TE_FILE_WRITE;
    }
    return TE_NO_ERROR;
}

word _pascal VCImpexSVGHandleRoundRectOpcode(word elementType, GStateHandle playbackGState, VCImpexSVGExportContext *context, PointWWFixed *currentPosition, Boolean *handled)
{
    PointWWFixed corner1;
    PointWWFixed corner3;
    WWFixed radiusX;
    WWFixed radiusY;
    XYValueAsDWord t0;
    XYValueAsDWord tx;
    XYValueAsDWord ty;
    Boolean filled;

    *handled = TRUE;

    switch (elementType)
    {
        case GR_DRAW_ROUND_RECT:
        case GR_FILL_ROUND_RECT:
            VCImpexSVGTransformPointFromInt(playbackGState, &svgElementBuffer.data.DRAW_ROUND_RECT.p1, &corner1);
            VCImpexSVGTransformPointFromInt(playbackGState, &svgElementBuffer.data.DRAW_ROUND_RECT.p2, &corner3);
            /* Transform radius r along x and y axes to world coordinates */
            t0 = GrTransform(playbackGState, 0, 0);
            tx = GrTransform(playbackGState, (sword)svgElementBuffer.data.DRAW_ROUND_RECT.r, 0);
            ty = GrTransform(playbackGState, 0, (sword)svgElementBuffer.data.DRAW_ROUND_RECT.r);
            {
                sdword dx = (sdword)DWORD_X(tx) - (sdword)DWORD_X(t0);
                sdword dy = (sdword)DWORD_Y(ty) - (sdword)DWORD_Y(t0);
                if (dx < 0) dx = -dx;
                if (dy < 0) dy = -dy;
                if (dx > 32767) dx = 32767;
                if (dy > 32767) dy = 32767;
                radiusX.WWF_int = (sword)dx;
                radiusY.WWF_int = (sword)dy;
            }
            radiusX.WWF_frac = 0;
            radiusY.WWF_frac = 0;
            radiusY.WWF_frac = 0;
            filled = (elementType == GR_FILL_ROUND_RECT);
            if (!VCImpexSVGWriteRoundRectElement(context, &corner1, &corner3, &radiusX, &radiusY, filled))
            {
                return TE_FILE_WRITE;
            }
            return TE_NO_ERROR;

        case GR_DRAW_ROUND_RECT_TO:
        case GR_FILL_ROUND_RECT_TO:
            VCImpexSVGTransformPointFromFixed(playbackGState, currentPosition, &corner1);
            VCImpexSVGTransformPointFromInt(playbackGState, &svgElementBuffer.data.DRAW_ROUND_RECT_TO.p, &corner3);
            t0 = GrTransform(playbackGState, 0, 0);
            tx = GrTransform(playbackGState, (sword)svgElementBuffer.data.DRAW_ROUND_RECT_TO.r, 0);
            ty = GrTransform(playbackGState, 0, (sword)svgElementBuffer.data.DRAW_ROUND_RECT_TO.r);
            {
                sdword dx = (sdword)DWORD_X(tx) - (sdword)DWORD_X(t0);
                sdword dy = (sdword)DWORD_Y(ty) - (sdword)DWORD_Y(t0);
                if (dx < 0) dx = -dx;
                if (dy < 0) dy = -dy;
                if (dx > 32767) dx = 32767;
                if (dy > 32767) dy = 32767;
                radiusX.WWF_int = (sword)dx;
                radiusY.WWF_int = (sword)dy;
            }
            radiusX.WWF_frac = 0;
            radiusY.WWF_frac = 0;
            radiusY.WWF_frac = 0;
            filled = (elementType == GR_FILL_ROUND_RECT_TO);
            if (!VCImpexSVGWriteRoundRectElement(context, &corner1, &corner3, &radiusX, &radiusY, filled))
            {
                return TE_FILE_WRITE;
            }
            return TE_NO_ERROR;

        default:
            break;
    }
    *handled = FALSE;
    return TE_NO_ERROR;
}

word _pascal VCImpexSVGHandleCurveOpcode(word elementType, GStateHandle playbackGState, VCImpexSVGExportContext *context, PointWWFixed *currentPosition, Boolean *handled)
{
    PointWWFixed startPoint;
    PointWWFixed cp1;
    PointWWFixed cp2;
    PointWWFixed endPoint;

    *handled = TRUE;

    switch (elementType)
    {
        case GR_DRAW_CURVE:
            VCImpexSVGTransformPointFromInt(playbackGState, (Point*)&svgElementBuffer.data.DRAW_CURVE.x1, &startPoint);
            VCImpexSVGTransformPointFromInt(playbackGState, (Point*)&svgElementBuffer.data.DRAW_CURVE.x2, &cp1);
            VCImpexSVGTransformPointFromInt(playbackGState, (Point*)&svgElementBuffer.data.DRAW_CURVE.x3, &cp2);
            VCImpexSVGTransformPointFromInt(playbackGState, (Point*)&svgElementBuffer.data.DRAW_CURVE.x4, &endPoint);
            if (!VCImpexSVGWriteCubicPathElement(context, &startPoint, &cp1, &cp2, &endPoint))
                return TE_FILE_WRITE;
            return TE_NO_ERROR;

        case GR_DRAW_CURVE_TO:
            VCImpexSVGTransformPointFromFixed(playbackGState, currentPosition, &startPoint);
            VCImpexSVGTransformPointFromInt(playbackGState, (Point*)&svgElementBuffer.data.DRAW_CURVE_TO.x2, &cp1);
            VCImpexSVGTransformPointFromInt(playbackGState, (Point*)&svgElementBuffer.data.DRAW_CURVE_TO.x3, &cp2);
            VCImpexSVGTransformPointFromInt(playbackGState, (Point*)&svgElementBuffer.data.DRAW_CURVE_TO.x4, &endPoint);
            if (!VCImpexSVGWriteCubicPathElement(context, &startPoint, &cp1, &cp2, &endPoint))
                return TE_FILE_WRITE;
            return TE_NO_ERROR;

        case GR_DRAW_REL_CURVE_TO:
        {
            PointWWFixed delta;
            /* cp1 */
            delta.PF_x.WWF_int = (sword)svgElementBuffer.data.DRAW_REL_CURVE_TO.x2;
            delta.PF_x.WWF_frac = 0;
            delta.PF_y.WWF_int = (sword)svgElementBuffer.data.DRAW_REL_CURVE_TO.y2;
            delta.PF_y.WWF_frac = 0;
            VCImpexSVGTransformPointFromFixed(playbackGState, currentPosition, &startPoint);
            VCImpexSVGTransformRelativePoint(playbackGState, &delta, &cp1);
            /* cp2 */
            delta.PF_x.WWF_int = (sword)svgElementBuffer.data.DRAW_REL_CURVE_TO.x3;
            delta.PF_x.WWF_frac = 0;
            delta.PF_y.WWF_int = (sword)svgElementBuffer.data.DRAW_REL_CURVE_TO.y3;
            delta.PF_y.WWF_frac = 0;
            VCImpexSVGTransformRelativePoint(playbackGState, &delta, &cp2);
            /* end */
            delta.PF_x.WWF_int = (sword)svgElementBuffer.data.DRAW_REL_CURVE_TO.x4;
            delta.PF_x.WWF_frac = 0;
            delta.PF_y.WWF_int = (sword)svgElementBuffer.data.DRAW_REL_CURVE_TO.y4;
            delta.PF_y.WWF_frac = 0;
            VCImpexSVGTransformRelativePoint(playbackGState, &delta, &endPoint);
            if (!VCImpexSVGWriteCubicPathElement(context, &startPoint, &cp1, &cp2, &endPoint))
                return TE_FILE_WRITE;
            return TE_NO_ERROR;
        }

        default:
            break;
    }
    *handled = FALSE;
    return TE_NO_ERROR;
}

word _pascal VCImpexSVGHandleArcOpcode(word elementType, GStateHandle playbackGState, VCImpexSVGExportContext *context, Boolean *handled)
{
    Boolean fill = FALSE;
    *handled = TRUE;

    switch (elementType)
    {
        case GR_DRAW_ARC:
        case GR_FILL_ARC:
        {
            TransMatrix tm;
            WWFixed cx, cy, rx, ry;
            word startAngle = svgElementBuffer.data.DRAW_ARC.ang1;
            word endAngle = svgElementBuffer.data.DRAW_ARC.ang2;
            sword x1 = svgElementBuffer.data.DRAW_ARC.x1;
            sword y1 = svgElementBuffer.data.DRAW_ARC.y1;
            sword x2 = svgElementBuffer.data.DRAW_ARC.x2;
            sword y2 = svgElementBuffer.data.DRAW_ARC.y2;
            ArcCloseType closeType = (ArcCloseType)svgElementBuffer.data.DRAW_ARC.close;
            WWFixedAsDWord cxFixed, cyFixed, rxFixed, ryFixed;

            /* center */
            cx.WWF_int = (sword)((x1 + x2) / 2);
            cx.WWF_frac = (word)(((x1 + x2) & 1) ? 0x8000 : 0);
            cy.WWF_int = (sword)((y1 + y2) / 2);
            cy.WWF_frac = (word)(((y1 + y2) & 1) ? 0x8000 : 0);
            /* radii */
            rx.WWF_int = (sword)(((x2 - x1) < 0) ? ((x1 - x2) / 2) : ((x2 - x1) / 2));
            rx.WWF_frac = (word)((((x2 - x1) & 1) != 0) ? 0x8000 : 0);
            ry.WWF_int = (sword)(((y2 - y1) < 0) ? ((y1 - y2) / 2) : ((y2 - y1) / 2));
            ry.WWF_frac = (word)((((y2 - y1) & 1) != 0) ? 0x8000 : 0);

            cxFixed = VCImpexSVGPackWWFixed(&cx);
            cyFixed = VCImpexSVGPackWWFixed(&cy);
            rxFixed = VCImpexSVGPackWWFixed(&rx);
            ryFixed = VCImpexSVGPackWWFixed(&ry);

            GrGetTransform(playbackGState, &tm);

            fill = (elementType == GR_FILL_ARC) ? TRUE : FALSE;
            if (!VCImpexSVGWriteArcElement(context, cxFixed, cyFixed, rxFixed, ryFixed, startAngle, endAngle, closeType, fill, &tm))
                return TE_FILE_WRITE;
            return TE_NO_ERROR;
        }

        default:
            break;
    }
    *handled = FALSE;
    return TE_NO_ERROR;
}

void _pascal VCImpexSVGSetWWFixedComponent(WWFixed *component, WWFixedAsDWord value)
{
    component->WWF_int = (word)((((sdword)value) >> 16) & 0xffff);
    component->WWF_frac = (word)(value & 0xffff);
}
