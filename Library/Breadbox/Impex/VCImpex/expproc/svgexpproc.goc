/***********************************************************************
 *
 * PROJECT:       VCImpex SVG Exporter
 * FILE:          svgexpproc.goc
 *
 * DESCRIPTION:   Implements the export procedure for SVG output
 *
 ***********************************************************************/
@include <stdapp.goh>

#include "svgexp.h"

#define VCIMPEX_SVG_GSTRING_FLAGS   (GSC_ONE)

typedef struct
{
    byte raw[VCIMPEX_SVG_ELEMENT_BUFFER_SIZE];
} VCImpexSVGGStringElement;

VCImpexSVGGStringElement svgElementBuffer;
PointWWFixed svgPolygonBuffer[VCIMPEX_SVG_MAX_POLY_POINTS];

word _pascal VCImpexSVGExportGString(GStateHandle sourceGState, VCImpexSVGExportContext *context);

typedef Boolean (_pascal *VCImpexSVGOpcodePredicate)(word elementType);
typedef word (_pascal *VCImpexSVGOpcodeHandler)(word elementType,
                                                GStateHandle playbackGState,
                                                VCImpexSVGExportContext *context,
                                                PointWWFixed *currentPosition,
                                                VCImpexSVGPendingRect *pendingRect);

typedef struct
{
    VCImpexSVGOpcodePredicate predicate;
    VCImpexSVGOpcodeHandler handler;
} VCImpexSVGDispatchEntry;

void* _pascal VCImpexSVGAs(const void *raw, word expectedOpcode);
Boolean _pascal VCImpexSVGIsLineOpcode(word elementType);
Boolean _pascal VCImpexSVGIsRectangleOpcode(word elementType);
Boolean _pascal VCImpexSVGIsRoundRectOpcode(word elementType);
Boolean _pascal VCImpexSVGIsEllipseOpcode(word elementType);
Boolean _pascal VCImpexSVGIsCurveOpcode(word elementType);
Boolean _pascal VCImpexSVGIsArcOpcode(word elementType);
Boolean _pascal VCImpexSVGIsPolygonOpcode(word elementType);

word _pascal VCImpexSVGHandleLineOpcode(word elementType, GStateHandle playbackGState, VCImpexSVGExportContext *context, PointWWFixed *currentPosition, VCImpexSVGPendingRect *pendingRect);
word _pascal VCImpexSVGHandleRectangleOpcode(word elementType, GStateHandle playbackGState, VCImpexSVGExportContext *context, PointWWFixed *currentPosition, VCImpexSVGPendingRect *pendingRect);
word _pascal VCImpexSVGHandleRoundRectOpcode(word elementType, GStateHandle playbackGState, VCImpexSVGExportContext *context, PointWWFixed *currentPosition, VCImpexSVGPendingRect *pendingRect);
word _pascal VCImpexSVGHandleEllipseOpcode(word elementType, GStateHandle playbackGState, VCImpexSVGExportContext *context, PointWWFixed *currentPosition, VCImpexSVGPendingRect *pendingRect);
word _pascal VCImpexSVGHandleCurveOpcode(word elementType, GStateHandle playbackGState, VCImpexSVGExportContext *context, PointWWFixed *currentPosition, VCImpexSVGPendingRect *pendingRect);
word _pascal VCImpexSVGHandleArcOpcode(word elementType, GStateHandle playbackGState, VCImpexSVGExportContext *context, PointWWFixed *currentPosition, VCImpexSVGPendingRect *pendingRect);
word _pascal VCImpexSVGHandlePolygonOpcode(word elementType, GStateHandle playbackGState, VCImpexSVGExportContext *context, PointWWFixed *currentPosition, VCImpexSVGPendingRect *pendingRect);
void _pascal VCImpexSVGSetWWFixedComponent(WWFixed *component, WWFixedAsDWord value);
word _pascal VCImpexSVGReadWord(const byte *data, word offset);
sword _pascal VCImpexSVGReadSword(const byte *data, word offset);
void _pascal VCImpexSVGReadWWFixed(const byte *data, word offset, WWFixed *value);

static const VCImpexSVGDispatchEntry gVCImpexSVGDispatchTable[] =
{
    {VCImpexSVGIsLineOpcode, VCImpexSVGHandleLineOpcode},
    {VCImpexSVGIsRectangleOpcode, VCImpexSVGHandleRectangleOpcode},
    {VCImpexSVGIsRoundRectOpcode, VCImpexSVGHandleRoundRectOpcode},
    {VCImpexSVGIsEllipseOpcode, VCImpexSVGHandleEllipseOpcode},
    {VCImpexSVGIsCurveOpcode, VCImpexSVGHandleCurveOpcode},
    {VCImpexSVGIsArcOpcode, VCImpexSVGHandleArcOpcode},
    {VCImpexSVGIsPolygonOpcode, VCImpexSVGHandlePolygonOpcode}
};

#define VCIMPEX_SVG_DISPATCH_COUNT  (sizeof(gVCImpexSVGDispatchTable) / sizeof(VCImpexSVGDispatchEntry))

void* _pascal VCImpexSVGAs(const void *raw, word expectedOpcode)
{
    const GStringElement *opcodeP;

    if (raw == NULL)
    {
        return (void*)0;
    }

    opcodeP = (const GStringElement*)raw;
    if (*opcodeP != (GStringElement)expectedOpcode)
    {
        return (void*)0;
    }

    return (void*)raw;
}

Boolean _pascal VCImpexSVGIsLineOpcode(word elementType)
{
    switch (elementType)
    {
        case GR_DRAW_LINE:
        case GR_DRAW_LINE_TO:
        case GR_DRAW_REL_LINE_TO:
        case GR_DRAW_HLINE:
        case GR_DRAW_VLINE:
        case GR_DRAW_HLINE_TO:
        case GR_DRAW_VLINE_TO:
            return TRUE;
        default:
            return FALSE;
    }
}

Boolean _pascal VCImpexSVGIsRectangleOpcode(word elementType)
{
    switch (elementType)
    {
        case GR_DRAW_RECT:
        case GR_FILL_RECT:
        case GR_DRAW_RECT_TO:
        case GR_FILL_RECT_TO:
            return TRUE;
        default:
            return FALSE;
    }
}

Boolean _pascal VCImpexSVGIsRoundRectOpcode(word elementType)
{
    switch (elementType)
    {
        case GR_DRAW_ROUND_RECT:
        case GR_FILL_ROUND_RECT:
        case GR_DRAW_ROUND_RECT_TO:
        case GR_FILL_ROUND_RECT_TO:
            return TRUE;
        default:
            return FALSE;
    }
}

Boolean _pascal VCImpexSVGIsEllipseOpcode(word elementType)
{
    switch (elementType)
    {
        case GR_DRAW_ELLIPSE:
        case GR_FILL_ELLIPSE:
            return TRUE;
        default:
            return FALSE;
    }
}

Boolean _pascal VCImpexSVGIsCurveOpcode(word elementType)
{
    switch (elementType)
    {
        case GR_DRAW_CURVE:
        case GR_DRAW_CURVE_TO:
        case GR_DRAW_REL_CURVE_TO:
            return TRUE;
        default:
            return FALSE;
    }
}

Boolean _pascal VCImpexSVGIsArcOpcode(word elementType)
{
    switch (elementType)
    {
        case GR_DRAW_ARC:
        case GR_FILL_ARC:
            return TRUE;
        default:
            return FALSE;
    }
}

Boolean _pascal VCImpexSVGIsPolygonOpcode(word elementType)
{
    switch (elementType)
    {
        case GR_DRAW_POLYGON:
        case GR_DRAW_POLYLINE:
        case GR_FILL_POLYGON:
            return TRUE;
        default:
            return FALSE;
    }
}

/****************************************************************************
 * VCImpex SVG Export public entry point
 ****************************************************************************/

dword _export _pascal ExportProcedure(ExportFrame *frame)
{
    GStateHandle sourceGState;
    VCImpexSVGExportContext context;
    word error;

    if ((frame == NULL) || (frame->EF_transferVMChain == 0))
        return TE_EXPORT_ERROR;

    sourceGState = GrLoadGString(frame->EF_transferVMFile, GST_VMEM,
                                 VMCHAIN_GET_VM_BLOCK(frame->EF_transferVMChain));
    if (sourceGState == 0)
        return TE_METAFILE_CREATION_ERROR;

    context.svgFile = frame->EF_outputFile;
    if (FileTruncate(context.svgFile, 0, FALSE) != 0)
    {
        GrDestroyGString(sourceGState, 0, GSKT_LEAVE_DATA);
        return TE_FILE_WRITE;
    }

    FilePos(context.svgFile, 0, FILE_POS_START);
    GrGetGStringBoundsDWord(sourceGState, 0, 0, &context.bounds);
    context.lineWidth = 0;
    context.lineColor = 0;
    context.fillColor = 0;

    context.bufferHeapH = MemAllocLMem(LMEM_TYPE_GENERAL, 0);
    if (context.bufferHeapH == NullHandle)
    {
        GrDestroyGString(sourceGState, 0, GSKT_LEAVE_DATA);
        return TE_OUT_OF_MEMORY;
    }

    error = VCImpexSVGExportGString(sourceGState, &context);

    if (context.bufferHeapH != NullHandle)
    {
        MemFree(context.bufferHeapH);
        context.bufferHeapH = NullHandle;
    }

    GrDestroyGString(sourceGState, 0, GSKT_LEAVE_DATA);

    return error;
}

/****************************************************************************
 * Core gstring traversal
 ****************************************************************************/

word _pascal VCImpexSVGExportGString(GStateHandle sourceGState, VCImpexSVGExportContext *context)
{
    MemHandle playbackBlockH;
    ChunkHandle playbackChunk;
    GStateHandle playbackGState;
    word elementType;
    word elementSize;
    PointWWFixed currentPosition;
    word error;
    GSRetType gsr;
    VCImpexSVGPendingRect pendingRect;
    word dispatchIndex;
    const VCImpexSVGDispatchEntry *entry;
    word handlerResult;


    playbackBlockH = MemAllocLMem(LMEM_TYPE_GENERAL, sizeof(LMemBlockHeader));
    if (playbackBlockH == NullHandle)
    {
        return TE_OUT_OF_MEMORY;
    }

    playbackGState = GrCreateGString(playbackBlockH, GST_CHUNK, (word*) &playbackChunk);
    if (playbackGState == 0)
    {
        MemFree(playbackBlockH);
        return TE_OUT_OF_MEMORY;
    }

    if (!VCImpexSVGWriteHeader(context))
    {
        GrDestroyGString(playbackGState, 0, GSKT_KILL_DATA);
        return TE_FILE_WRITE;
    }

    error = TE_NO_ERROR;
    VCImpexSVGInitPendingRect(&pendingRect);

    /* the main loop */
    for(gsr = GrDrawGString(playbackGState, sourceGState, 0, 0, GSC_ONE, &elementType);
        gsr == GSRT_ONE;
        gsr = GrDrawGString(playbackGState, sourceGState, 0, 0, GSC_ONE, &elementType))
    {

    //drawResult = GrDrawGString(playbackGState, sourceGState, 0, 0,
    //                           VCIMPEX_SVG_GSTRING_FLAGS, &elementType);
    //while (drawResult == GSRT_ONE)
    //{

        GrGetGStringElement(playbackGState, sourceGState, sizeof(svgElementBuffer.raw),
                            svgElementBuffer.raw, &elementSize);

        if (elementSize > sizeof(svgElementBuffer.raw))
        {
            error = TE_EXPORT_ERROR;
            break;
        }

        VCImpexSVGUpdateDrawingState(playbackGState, context);
        GrGetCurPosWWFixed(playbackGState, &currentPosition);

        /* Flush pending rectangle if we hit a transform/state change op */
        if ((elementType >= GR_APPLY_ROTATION && elementType <= GR_XFORM_1F) ||
            (elementType >= GR_SAVE_STATE && elementType <= GR_ATTR_9F))
        {
            if (!VCImpexSVGFlushPendingRect(context, &pendingRect))
            {
                error = TE_FILE_WRITE;
                break;
            }
            /* skip handling state ops */
            continue;
        }

        /* If current element is not a rect, flush any pending rect to preserve order */
        if (!VCImpexSVGIsRectangleOpcode(elementType))
        {
            if (!VCImpexSVGFlushPendingRect(context, &pendingRect))
            {
                error = TE_FILE_WRITE;
                break;
            }
        }

        handlerResult = TE_NO_ERROR;
        for (dispatchIndex = 0; dispatchIndex < VCIMPEX_SVG_DISPATCH_COUNT; dispatchIndex++)
        {
            entry = &gVCImpexSVGDispatchTable[dispatchIndex];
            if (entry->predicate(elementType))
            {
                handlerResult = entry->handler(elementType, playbackGState, context, &currentPosition, &pendingRect);
                break;
            }
        }

        if (handlerResult != TE_NO_ERROR)
        {
            error = handlerResult;
            break;
        }
    }

    //if ((error == TE_NO_ERROR) && (drawResult != GSRT_COMPLETE))
    //{
    //    error = TE_EXPORT_ERROR;
    //}

    /* Flush any pending rectangle before footer */
    if (error == TE_NO_ERROR)
    {
        if (!VCImpexSVGFlushPendingRect(context, &pendingRect))
        {
            error = TE_FILE_WRITE;
        }
    }

    if (error == TE_NO_ERROR)
    {
        if (!VCImpexSVGWriteFooter(context))
        {
            error = TE_FILE_WRITE;
        }
    }

    GrDestroyGString(playbackGState, 0, GSKT_KILL_DATA);

    return error;
}

/****************************************************************************
 * Opcode handlers
 ****************************************************************************/

word _pascal VCImpexSVGHandleLineOpcode(word elementType, GStateHandle playbackGState, VCImpexSVGExportContext *context, PointWWFixed *currentPosition, VCImpexSVGPendingRect *pendingRect)
{
    PointWWFixed startPoint;
    PointWWFixed endPoint;
    Point intPoint1;
    Point intPoint2;
    Point tempPoint;
    PointWWFixed deltaPoint;
    WWFixedAsDWord componentValue;
    const byte *elementData;
    word offset;
    word wordValue1;

    (void)pendingRect;

    elementData = svgElementBuffer.raw;

    switch (elementType)
    {
        case GR_DRAW_LINE:
            if (VCImpexSVGAs(elementData, GR_DRAW_LINE) == (void*)0)
            {
                return TE_EXPORT_ERROR;
            }
            offset = sizeof(GStringElement);
            intPoint1.P_x = (sword)VCImpexSVGReadWord(elementData, offset);
            offset += sizeof(word);
            intPoint1.P_y = (sword)VCImpexSVGReadWord(elementData, offset);
            offset += sizeof(word);
            intPoint2.P_x = (sword)VCImpexSVGReadWord(elementData, offset);
            offset += sizeof(word);
            intPoint2.P_y = (sword)VCImpexSVGReadWord(elementData, offset);
            VCImpexSVGTransformPointFromInt(playbackGState, &intPoint1, &startPoint);
            VCImpexSVGTransformPointFromInt(playbackGState, &intPoint2, &endPoint);
            if (!VCImpexSVGWriteLineElement(context, &startPoint, &endPoint))
            {
                return TE_FILE_WRITE;
            }
            return TE_NO_ERROR;

        case GR_DRAW_LINE_TO:
            VCImpexSVGTransformPointFromFixed(playbackGState, currentPosition, &startPoint);
            if (VCImpexSVGAs(elementData, GR_DRAW_LINE_TO) == (void*)0)
            {
                return TE_EXPORT_ERROR;
            }
            offset = sizeof(GStringElement);
            intPoint1.P_x = (sword)VCImpexSVGReadWord(elementData, offset);
            offset += sizeof(word);
            intPoint1.P_y = (sword)VCImpexSVGReadWord(elementData, offset);
            VCImpexSVGTransformPointFromInt(playbackGState, &intPoint1, &endPoint);
            if (!VCImpexSVGWriteLineElement(context, &startPoint, &endPoint))
            {
                return TE_FILE_WRITE;
            }
            return TE_NO_ERROR;

        case GR_DRAW_REL_LINE_TO:
            VCImpexSVGTransformPointFromFixed(playbackGState, currentPosition, &startPoint);
            if (VCImpexSVGAs(elementData, GR_DRAW_REL_LINE_TO) == (void*)0)
            {
                return TE_EXPORT_ERROR;
            }
            offset = sizeof(GStringElement);
            VCImpexSVGReadWWFixed(elementData, offset, &deltaPoint.PF_x);
            offset += sizeof(WWFixed);
            VCImpexSVGReadWWFixed(elementData, offset, &deltaPoint.PF_y);
            VCImpexSVGTransformRelativePoint(playbackGState, &deltaPoint, &endPoint);
            if (!VCImpexSVGWriteLineElement(context, &startPoint, &endPoint))
            {
                return TE_FILE_WRITE;
            }
            return TE_NO_ERROR;

        case GR_DRAW_HLINE:
            if (VCImpexSVGAs(elementData, GR_DRAW_HLINE) == (void*)0)
            {
                return TE_EXPORT_ERROR;
            }
            offset = sizeof(GStringElement);
            tempPoint.P_x = (sword)VCImpexSVGReadWord(elementData, offset);
            offset += sizeof(word);
            tempPoint.P_y = (sword)VCImpexSVGReadWord(elementData, offset);
            offset += sizeof(word);
            wordValue1 = VCImpexSVGReadWord(elementData, offset);
            VCImpexSVGTransformPointFromInt(playbackGState, &tempPoint, &startPoint);
            componentValue = ((WWFixedAsDWord)((sdword)(sword)wordValue1)) << 16;
            VCImpexSVGSetWWFixedComponent(&currentPosition->PF_x, componentValue);
            VCImpexSVGTransformPointFromFixed(playbackGState, currentPosition, &endPoint);
            if (!VCImpexSVGWriteLineElement(context, &startPoint, &endPoint))
            {
                return TE_FILE_WRITE;
            }
            return TE_NO_ERROR;

        case GR_DRAW_VLINE:
            if (VCImpexSVGAs(elementData, GR_DRAW_VLINE) == (void*)0)
            {
                return TE_EXPORT_ERROR;
            }
            offset = sizeof(GStringElement);
            tempPoint.P_x = (sword)VCImpexSVGReadWord(elementData, offset);
            offset += sizeof(word);
            tempPoint.P_y = (sword)VCImpexSVGReadWord(elementData, offset);
            offset += sizeof(word);
            wordValue1 = VCImpexSVGReadWord(elementData, offset);
            VCImpexSVGTransformPointFromInt(playbackGState, &tempPoint, &startPoint);
            componentValue = ((WWFixedAsDWord)((sdword)(sword)wordValue1)) << 16;
            VCImpexSVGSetWWFixedComponent(&currentPosition->PF_y, componentValue);
            VCImpexSVGTransformPointFromFixed(playbackGState, currentPosition, &endPoint);
            if (!VCImpexSVGWriteLineElement(context, &startPoint, &endPoint))
            {
                return TE_FILE_WRITE;
            }
            return TE_NO_ERROR;

        case GR_DRAW_HLINE_TO:
            VCImpexSVGTransformPointFromFixed(playbackGState, currentPosition, &startPoint);
            if (VCImpexSVGAs(elementData, GR_DRAW_HLINE_TO) == (void*)0)
            {
                return TE_EXPORT_ERROR;
            }
            offset = sizeof(GStringElement);
            wordValue1 = VCImpexSVGReadWord(elementData, offset);
            componentValue = ((WWFixedAsDWord)((sdword)(sword)wordValue1)) << 16;
            VCImpexSVGSetWWFixedComponent(&currentPosition->PF_x, componentValue);
            VCImpexSVGTransformPointFromFixed(playbackGState, currentPosition, &endPoint);
            if (!VCImpexSVGWriteLineElement(context, &startPoint, &endPoint))
            {
                return TE_FILE_WRITE;
            }
            return TE_NO_ERROR;

        case GR_DRAW_VLINE_TO:
            VCImpexSVGTransformPointFromFixed(playbackGState, currentPosition, &startPoint);
            if (VCImpexSVGAs(elementData, GR_DRAW_VLINE_TO) == (void*)0)
            {
                return TE_EXPORT_ERROR;
            }
            offset = sizeof(GStringElement);
            wordValue1 = VCImpexSVGReadWord(elementData, offset);
            componentValue = ((WWFixedAsDWord)((sdword)(sword)wordValue1)) << 16;
            VCImpexSVGSetWWFixedComponent(&currentPosition->PF_y, componentValue);
            VCImpexSVGTransformPointFromFixed(playbackGState, currentPosition, &endPoint);
            if (!VCImpexSVGWriteLineElement(context, &startPoint, &endPoint))
            {
                return TE_FILE_WRITE;
            }
            return TE_NO_ERROR;

        default:
            break;
    }
    return TE_NO_ERROR;
}

word _pascal VCImpexSVGHandleRectangleOpcode(word elementType, GStateHandle playbackGState, VCImpexSVGExportContext *context, PointWWFixed *currentPosition, VCImpexSVGPendingRect *pendingRect)
{
    PointWWFixed corner1;
    PointWWFixed corner3;
    Point intCorner1;
    Point intCorner3;
    Boolean filled;
    const byte *elementData;
    word offset;
    word wordValue1;
    word wordValue2;

    elementData = svgElementBuffer.raw;

    switch (elementType)
    {
        case GR_DRAW_RECT:
        case GR_FILL_RECT:
            if (VCImpexSVGAs(elementData, elementType) == (void*)0)
            {
                return TE_EXPORT_ERROR;
            }
            offset = sizeof(GStringElement);
            intCorner1.P_x = (sword)VCImpexSVGReadWord(elementData, offset);
            offset += sizeof(word);
            intCorner1.P_y = (sword)VCImpexSVGReadWord(elementData, offset);
            offset += sizeof(word);
            intCorner3.P_x = (sword)VCImpexSVGReadWord(elementData, offset);
            offset += sizeof(word);
            intCorner3.P_y = (sword)VCImpexSVGReadWord(elementData, offset);
            VCImpexSVGTransformPointFromInt(playbackGState, &intCorner1, &corner1);
            VCImpexSVGTransformPointFromInt(playbackGState, &intCorner3, &corner3);
            filled = (elementType == GR_FILL_RECT);
            /* Coalescing logic */
            if (pendingRect != NULL)
            {
                WWFixedAsDWord c1x = VCImpexSVGPackWWFixed(&corner1.PF_x);
                WWFixedAsDWord c1y = VCImpexSVGPackWWFixed(&corner1.PF_y);
                WWFixedAsDWord c3x = VCImpexSVGPackWWFixed(&corner3.PF_x);
                WWFixedAsDWord c3y = VCImpexSVGPackWWFixed(&corner3.PF_y);
                if (pendingRect->active)
                {
                    WWFixedAsDWord pc1x = VCImpexSVGPackWWFixed(&pendingRect->corner1.PF_x);
                    WWFixedAsDWord pc1y = VCImpexSVGPackWWFixed(&pendingRect->corner1.PF_y);
                    WWFixedAsDWord pc3x = VCImpexSVGPackWWFixed(&pendingRect->corner3.PF_x);
                    WWFixedAsDWord pc3y = VCImpexSVGPackWWFixed(&pendingRect->corner3.PF_y);
                    if (pc1x == c1x && pc1y == c1y && pc3x == c3x && pc3y == c3y)
                    {
                        if (filled)
                        {
                            pendingRect->haveFill = TRUE;
                            pendingRect->fillColor = context->fillColor;
                        }
                        else
                        {
                            pendingRect->haveStroke = (context->lineWidth != 0);
                            pendingRect->strokeColor = context->lineColor;
                            pendingRect->strokeWidth = context->lineWidth;
                        }
                        if (pendingRect->haveFill && pendingRect->haveStroke)
                        {
                            if (!VCImpexSVGFlushPendingRect(context, pendingRect))
                            {
                                return TE_FILE_WRITE;
                            }
                        }
                        return TE_NO_ERROR;
                    }
                    /* geometry differs: flush old then start new */
                    if (!VCImpexSVGFlushPendingRect(context, pendingRect))
                    {
                        return TE_FILE_WRITE;
                    }
                }
                /* Start new pending */
                pendingRect->active = TRUE;
                pendingRect->corner1 = corner1;
                pendingRect->corner3 = corner3;
                pendingRect->haveFill = filled ? TRUE : FALSE;
                pendingRect->haveStroke = (!filled && (context->lineWidth != 0)) ? TRUE : FALSE;
                pendingRect->strokeWidth = context->lineWidth;
                pendingRect->strokeColor = context->lineColor;
                pendingRect->fillColor = context->fillColor;
                return TE_NO_ERROR;
            }
            /* Fallback: no coalescing */
            if (!VCImpexSVGWriteRectElement(context, &corner1, &corner3, filled))
            {
                return TE_FILE_WRITE;
            }
            return TE_NO_ERROR;

        case GR_DRAW_RECT_TO:
        case GR_FILL_RECT_TO:
            VCImpexSVGTransformPointFromFixed(playbackGState, currentPosition, &corner1);
            if (VCImpexSVGAs(elementData, elementType) == (void*)0)
            {
                return TE_EXPORT_ERROR;
            }
            offset = sizeof(GStringElement);
            wordValue1 = VCImpexSVGReadWord(elementData, offset);
            offset += sizeof(word);
            wordValue2 = VCImpexSVGReadWord(elementData, offset);
            intCorner3.P_x = (sword)wordValue1;
            intCorner3.P_y = (sword)wordValue2;
            VCImpexSVGTransformPointFromInt(playbackGState, &intCorner3, &corner3);
            filled = (elementType == GR_FILL_RECT_TO);
            if (pendingRect != NULL)
            {
                WWFixedAsDWord c1x = VCImpexSVGPackWWFixed(&corner1.PF_x);
                WWFixedAsDWord c1y = VCImpexSVGPackWWFixed(&corner1.PF_y);
                WWFixedAsDWord c3x = VCImpexSVGPackWWFixed(&corner3.PF_x);
                WWFixedAsDWord c3y = VCImpexSVGPackWWFixed(&corner3.PF_y);
                if (pendingRect->active)
                {
                    WWFixedAsDWord pc1x = VCImpexSVGPackWWFixed(&pendingRect->corner1.PF_x);
                    WWFixedAsDWord pc1y = VCImpexSVGPackWWFixed(&pendingRect->corner1.PF_y);
                    WWFixedAsDWord pc3x = VCImpexSVGPackWWFixed(&pendingRect->corner3.PF_x);
                    WWFixedAsDWord pc3y = VCImpexSVGPackWWFixed(&pendingRect->corner3.PF_y);
                    if (pc1x == c1x && pc1y == c1y && pc3x == c3x && pc3y == c3y)
                    {
                        if (filled)
                        {
                            pendingRect->haveFill = TRUE;
                            pendingRect->fillColor = context->fillColor;
                        }
                        else
                        {
                            pendingRect->haveStroke = (context->lineWidth != 0);
                            pendingRect->strokeColor = context->lineColor;
                            pendingRect->strokeWidth = context->lineWidth;
                        }
                        if (pendingRect->haveFill && pendingRect->haveStroke)
                        {
                            if (!VCImpexSVGFlushPendingRect(context, pendingRect))
                            {
                                return TE_FILE_WRITE;
                            }
                        }
                        return TE_NO_ERROR;
                    }
                    if (!VCImpexSVGFlushPendingRect(context, pendingRect))
                    {
                        return TE_FILE_WRITE;
                    }
                }
                pendingRect->active = TRUE;
                pendingRect->corner1 = corner1;
                pendingRect->corner3 = corner3;
                pendingRect->haveFill = filled ? TRUE : FALSE;
                pendingRect->haveStroke = (!filled && (context->lineWidth != 0)) ? TRUE : FALSE;
                pendingRect->strokeWidth = context->lineWidth;
                pendingRect->strokeColor = context->lineColor;
                pendingRect->fillColor = context->fillColor;
                return TE_NO_ERROR;
            }
            if (!VCImpexSVGWriteRectElement(context, &corner1, &corner3, filled))
            {
                return TE_FILE_WRITE;
            }
            return TE_NO_ERROR;

        default:
            break;
    }
    return TE_NO_ERROR;
}

word _pascal VCImpexSVGHandleEllipseOpcode(word elementType, GStateHandle playbackGState, VCImpexSVGExportContext *context, PointWWFixed *currentPosition, VCImpexSVGPendingRect *pendingRect)
{
    WWFixed cx = {0};
    WWFixed cy = {0};
    WWFixed rx = {0};
    WWFixed ry = {0};
    sword x1, y1, x2, y2;
    sdword sum;
    sword dx, dy;
    TransMatrix tm;
    Boolean filled;
    const byte *elementData;
    word offset;

    (void)currentPosition;
    (void)pendingRect;

    elementData = svgElementBuffer.raw;

    switch (elementType)
    {
        case GR_DRAW_ELLIPSE:
        case GR_FILL_ELLIPSE:
            if (VCImpexSVGAs(elementData, elementType) == (void*)0)
            {
                return TE_EXPORT_ERROR;
            }
            offset = sizeof(GStringElement);
            x1 = (sword)VCImpexSVGReadWord(elementData, offset);
            offset += sizeof(word);
            y1 = (sword)VCImpexSVGReadWord(elementData, offset);
            offset += sizeof(word);
            x2 = (sword)VCImpexSVGReadWord(elementData, offset);
            offset += sizeof(word);
            y2 = (sword)VCImpexSVGReadWord(elementData, offset);

            /* center x */
            sum = (sdword)x1 + (sdword)x2;
            cx.WWF_int = (sword)(sum / 2);
            cx.WWF_frac = (word)((sum & 1) ? 0x8000 : 0);
            /* center y */
            sum = (sdword)y1 + (sdword)y2;
            cy.WWF_int = (sword)(sum / 2);
            cy.WWF_frac = (word)((sum & 1) ? 0x8000 : 0);

            /* radii */
            dx = (sword)(x2 - x1);
            if (dx < 0) dx = -dx;
            rx.WWF_int = (sword)(dx / 2);
            rx.WWF_frac = (word)((dx & 1) ? 0x8000 : 0);

            dy = (sword)(y2 - y1);
            if (dy < 0) dy = -dy;
            ry.WWF_int = (sword)(dy / 2);
            ry.WWF_frac = (word)((dy & 1) ? 0x8000 : 0);

            filled = (elementType == GR_FILL_ELLIPSE);

            /* get current transform so we can emit exact transform matrix */
            GrGetTransform(playbackGState, &tm);
            if (!VCImpexSVGWriteEllipseElement(context, &cx, &cy, &rx, &ry, filled, &tm))
            {
                return TE_FILE_WRITE;
            }
            return TE_NO_ERROR;

        default:
            break;
    }
    return TE_NO_ERROR;
}

word _pascal VCImpexSVGHandlePolygonOpcode(word elementType, GStateHandle playbackGState, VCImpexSVGExportContext *context, PointWWFixed *currentPosition, VCImpexSVGPendingRect *pendingRect)
{
    word pointCount;
    word index;
    Boolean closeShape;
    Boolean filledShape;
    const byte *elementData;
    word offset;
    Point intPoint;

    (void)currentPosition;
    (void)pendingRect;

    elementData = svgElementBuffer.raw;

    switch (elementType)
    {
        case GR_DRAW_POLYGON:
            if (VCImpexSVGAs(elementData, GR_DRAW_POLYGON) == (void*)0)
            {
                return TE_EXPORT_ERROR;
            }
            offset = sizeof(GStringElement);
            pointCount = VCImpexSVGReadWord(elementData, offset);
            offset += sizeof(word);
            closeShape = TRUE;
            filledShape = FALSE;
            break;

        case GR_DRAW_POLYLINE:
            if (VCImpexSVGAs(elementData, GR_DRAW_POLYLINE) == (void*)0)
            {
                return TE_EXPORT_ERROR;
            }
            offset = sizeof(GStringElement);
            pointCount = VCImpexSVGReadWord(elementData, offset);
            offset += sizeof(word);
            closeShape = FALSE;
            filledShape = FALSE;
            break;

        case GR_FILL_POLYGON:
            if (VCImpexSVGAs(elementData, GR_FILL_POLYGON) == (void*)0)
            {
                return TE_EXPORT_ERROR;
            }
            offset = sizeof(GStringElement);
            pointCount = VCImpexSVGReadWord(elementData, offset);
            offset += sizeof(word);
            closeShape = TRUE;
            filledShape = TRUE;
            break;

        default:
            return TE_NO_ERROR;
    }

    if (pointCount == 0)
    {
        return TE_NO_ERROR;
    }

    if (pointCount > VCIMPEX_SVG_MAX_POLY_POINTS)
    {
        return TE_EXPORT_ERROR;
    }

    for (index = 0; index < pointCount; index++)
    {
        intPoint.P_x = (sword)VCImpexSVGReadWord(elementData, offset);
        offset += sizeof(word);
        intPoint.P_y = (sword)VCImpexSVGReadWord(elementData, offset);
        offset += sizeof(word);
        VCImpexSVGTransformPointFromInt(playbackGState, &intPoint, &svgPolygonBuffer[index]);
    }

    if (!VCImpexSVGWritePolygonElement(context, svgPolygonBuffer, pointCount, closeShape, filledShape))
    {
        return TE_FILE_WRITE;
    }
    return TE_NO_ERROR;
}

word _pascal VCImpexSVGHandleRoundRectOpcode(word elementType, GStateHandle playbackGState, VCImpexSVGExportContext *context, PointWWFixed *currentPosition, VCImpexSVGPendingRect *pendingRect)
{
    PointWWFixed corner1;
    PointWWFixed corner3;
    WWFixed radiusX;
    WWFixed radiusY;
    XYValueAsDWord t0;
    XYValueAsDWord tx;
    XYValueAsDWord ty;
    Boolean filled;
    Point intCorner1;
    Point intCorner3;
    word radiusValue;
    const byte *elementData;
    word offset;
    word wordValue1;
    word wordValue2;

    (void)pendingRect;

    elementData = svgElementBuffer.raw;

    switch (elementType)
    {
        case GR_DRAW_ROUND_RECT:
        case GR_FILL_ROUND_RECT:
            if (VCImpexSVGAs(elementData, elementType) == (void*)0)
            {
                return TE_EXPORT_ERROR;
            }
            offset = sizeof(GStringElement);
            radiusValue = VCImpexSVGReadWord(elementData, offset);
            offset += sizeof(word);
            intCorner1.P_x = (sword)VCImpexSVGReadWord(elementData, offset);
            offset += sizeof(word);
            intCorner1.P_y = (sword)VCImpexSVGReadWord(elementData, offset);
            offset += sizeof(word);
            intCorner3.P_x = (sword)VCImpexSVGReadWord(elementData, offset);
            offset += sizeof(word);
            intCorner3.P_y = (sword)VCImpexSVGReadWord(elementData, offset);
            VCImpexSVGTransformPointFromInt(playbackGState, &intCorner1, &corner1);
            VCImpexSVGTransformPointFromInt(playbackGState, &intCorner3, &corner3);
            /* Transform radius r along x and y axes to world coordinates */
            t0 = GrTransform(playbackGState, 0, 0);
            tx = GrTransform(playbackGState, (sword)radiusValue, 0);
            ty = GrTransform(playbackGState, 0, (sword)radiusValue);
            {
                sdword dx = (sdword)DWORD_X(tx) - (sdword)DWORD_X(t0);
                sdword dy = (sdword)DWORD_Y(ty) - (sdword)DWORD_Y(t0);
                if (dx < 0) dx = -dx;
                if (dy < 0) dy = -dy;
                if (dx > 32767) dx = 32767;
                if (dy > 32767) dy = 32767;
                radiusX.WWF_int = (sword)dx;
                radiusY.WWF_int = (sword)dy;
            }
            radiusX.WWF_frac = 0;
            radiusY.WWF_frac = 0;
            radiusY.WWF_frac = 0;
            filled = (elementType == GR_FILL_ROUND_RECT);
            if (!VCImpexSVGWriteRoundRectElement(context, &corner1, &corner3, &radiusX, &radiusY, filled))
            {
                return TE_FILE_WRITE;
            }
            return TE_NO_ERROR;

        case GR_DRAW_ROUND_RECT_TO:
        case GR_FILL_ROUND_RECT_TO:
            VCImpexSVGTransformPointFromFixed(playbackGState, currentPosition, &corner1);
            if (VCImpexSVGAs(elementData, elementType) == (void*)0)
            {
                return TE_EXPORT_ERROR;
            }
            offset = sizeof(GStringElement);
            radiusValue = VCImpexSVGReadWord(elementData, offset);
            offset += sizeof(word);
            wordValue1 = VCImpexSVGReadWord(elementData, offset);
            offset += sizeof(word);
            wordValue2 = VCImpexSVGReadWord(elementData, offset);
            intCorner3.P_x = (sword)wordValue1;
            intCorner3.P_y = (sword)wordValue2;
            VCImpexSVGTransformPointFromInt(playbackGState, &intCorner3, &corner3);
            t0 = GrTransform(playbackGState, 0, 0);
            tx = GrTransform(playbackGState, (sword)radiusValue, 0);
            ty = GrTransform(playbackGState, 0, (sword)radiusValue);
            {
                sdword dx = (sdword)DWORD_X(tx) - (sdword)DWORD_X(t0);
                sdword dy = (sdword)DWORD_Y(ty) - (sdword)DWORD_Y(t0);
                if (dx < 0) dx = -dx;
                if (dy < 0) dy = -dy;
                if (dx > 32767) dx = 32767;
                if (dy > 32767) dy = 32767;
                radiusX.WWF_int = (sword)dx;
                radiusY.WWF_int = (sword)dy;
            }
            radiusX.WWF_frac = 0;
            radiusY.WWF_frac = 0;
            radiusY.WWF_frac = 0;
            filled = (elementType == GR_FILL_ROUND_RECT_TO);
            if (!VCImpexSVGWriteRoundRectElement(context, &corner1, &corner3, &radiusX, &radiusY, filled))
            {
                return TE_FILE_WRITE;
            }
            return TE_NO_ERROR;

        default:
            break;
    }
    return TE_NO_ERROR;
}

word _pascal VCImpexSVGHandleCurveOpcode(word elementType, GStateHandle playbackGState, VCImpexSVGExportContext *context, PointWWFixed *currentPosition, VCImpexSVGPendingRect *pendingRect)
{
    PointWWFixed startPoint;
    PointWWFixed cp1;
    PointWWFixed cp2;
    PointWWFixed endPoint;
    Point intPoint;
    const byte *elementData;
    word offset;

    (void)pendingRect;

    elementData = svgElementBuffer.raw;

    switch (elementType)
    {
        case GR_DRAW_CURVE:
            if (VCImpexSVGAs(elementData, GR_DRAW_CURVE) == (void*)0)
            {
                return TE_EXPORT_ERROR;
            }
            offset = sizeof(GStringElement);
            intPoint.P_x = VCImpexSVGReadSword(elementData, offset);
            offset += sizeof(sword);
            intPoint.P_y = VCImpexSVGReadSword(elementData, offset);
            offset += sizeof(sword);
            VCImpexSVGTransformPointFromInt(playbackGState, &intPoint, &startPoint);
            intPoint.P_x = VCImpexSVGReadSword(elementData, offset);
            offset += sizeof(sword);
            intPoint.P_y = VCImpexSVGReadSword(elementData, offset);
            offset += sizeof(sword);
            VCImpexSVGTransformPointFromInt(playbackGState, &intPoint, &cp1);
            intPoint.P_x = VCImpexSVGReadSword(elementData, offset);
            offset += sizeof(sword);
            intPoint.P_y = VCImpexSVGReadSword(elementData, offset);
            offset += sizeof(sword);
            VCImpexSVGTransformPointFromInt(playbackGState, &intPoint, &cp2);
            intPoint.P_x = VCImpexSVGReadSword(elementData, offset);
            offset += sizeof(sword);
            intPoint.P_y = VCImpexSVGReadSword(elementData, offset);
            VCImpexSVGTransformPointFromInt(playbackGState, &intPoint, &endPoint);
            if (!VCImpexSVGWriteCubicPathElement(context, &startPoint, &cp1, &cp2, &endPoint))
                return TE_FILE_WRITE;
            return TE_NO_ERROR;

        case GR_DRAW_CURVE_TO:
            VCImpexSVGTransformPointFromFixed(playbackGState, currentPosition, &startPoint);
            if (VCImpexSVGAs(elementData, GR_DRAW_CURVE_TO) == (void*)0)
            {
                return TE_EXPORT_ERROR;
            }
            offset = sizeof(GStringElement);
            intPoint.P_x = VCImpexSVGReadSword(elementData, offset);
            offset += sizeof(sword);
            intPoint.P_y = VCImpexSVGReadSword(elementData, offset);
            offset += sizeof(sword);
            VCImpexSVGTransformPointFromInt(playbackGState, &intPoint, &cp1);
            intPoint.P_x = VCImpexSVGReadSword(elementData, offset);
            offset += sizeof(sword);
            intPoint.P_y = VCImpexSVGReadSword(elementData, offset);
            offset += sizeof(sword);
            VCImpexSVGTransformPointFromInt(playbackGState, &intPoint, &cp2);
            intPoint.P_x = VCImpexSVGReadSword(elementData, offset);
            offset += sizeof(sword);
            intPoint.P_y = VCImpexSVGReadSword(elementData, offset);
            VCImpexSVGTransformPointFromInt(playbackGState, &intPoint, &endPoint);
            if (!VCImpexSVGWriteCubicPathElement(context, &startPoint, &cp1, &cp2, &endPoint))
                return TE_FILE_WRITE;
            return TE_NO_ERROR;

        case GR_DRAW_REL_CURVE_TO:
        {
            PointWWFixed delta;
            if (VCImpexSVGAs(elementData, GR_DRAW_REL_CURVE_TO) == (void*)0)
            {
                return TE_EXPORT_ERROR;
            }
            offset = sizeof(GStringElement);
            /* cp1 */
            delta.PF_x.WWF_int = VCImpexSVGReadSword(elementData, offset);
            delta.PF_x.WWF_frac = 0;
            offset += sizeof(sword);
            delta.PF_y.WWF_int = VCImpexSVGReadSword(elementData, offset);
            delta.PF_y.WWF_frac = 0;
            offset += sizeof(sword);
            VCImpexSVGTransformPointFromFixed(playbackGState, currentPosition, &startPoint);
            VCImpexSVGTransformRelativePoint(playbackGState, &delta, &cp1);
            /* cp2 */
            delta.PF_x.WWF_int = VCImpexSVGReadSword(elementData, offset);
            delta.PF_x.WWF_frac = 0;
            offset += sizeof(sword);
            delta.PF_y.WWF_int = VCImpexSVGReadSword(elementData, offset);
            delta.PF_y.WWF_frac = 0;
            offset += sizeof(sword);
            VCImpexSVGTransformRelativePoint(playbackGState, &delta, &cp2);
            /* end */
            delta.PF_x.WWF_int = VCImpexSVGReadSword(elementData, offset);
            delta.PF_x.WWF_frac = 0;
            offset += sizeof(sword);
            delta.PF_y.WWF_int = VCImpexSVGReadSword(elementData, offset);
            delta.PF_y.WWF_frac = 0;
            VCImpexSVGTransformRelativePoint(playbackGState, &delta, &endPoint);
            if (!VCImpexSVGWriteCubicPathElement(context, &startPoint, &cp1, &cp2, &endPoint))
                return TE_FILE_WRITE;
            return TE_NO_ERROR;
        }

        default:
            break;
    }
    return TE_NO_ERROR;
}

word _pascal VCImpexSVGHandleArcOpcode(word elementType, GStateHandle playbackGState, VCImpexSVGExportContext *context, PointWWFixed *currentPosition, VCImpexSVGPendingRect *pendingRect)
{
    Boolean fill = FALSE;
    TransMatrix tm;
    WWFixed cx;
    WWFixed cy;
    WWFixed rx;
    WWFixed ry;
    word startAngle;
    word endAngle;
    sword x1;
    sword y1;
    sword x2;
    sword y2;
    ArcCloseType closeType;
    WWFixedAsDWord cxFixed;
    WWFixedAsDWord cyFixed;
    WWFixedAsDWord rxFixed;
    WWFixedAsDWord ryFixed;
    const byte *elementData;
    word offset;
    word wordValue;

    (void)currentPosition;
    (void)pendingRect;

    elementData = svgElementBuffer.raw;

    switch (elementType)
    {
        case GR_DRAW_ARC:
        case GR_FILL_ARC:
        {
            if (VCImpexSVGAs(elementData, elementType) == (void*)0)
            {
                return TE_EXPORT_ERROR;
            }
            offset = sizeof(GStringElement);
            wordValue = VCImpexSVGReadWord(elementData, offset);
            closeType = (ArcCloseType)wordValue;
            offset += sizeof(word);
            x1 = (sword)VCImpexSVGReadWord(elementData, offset);
            offset += sizeof(word);
            y1 = (sword)VCImpexSVGReadWord(elementData, offset);
            offset += sizeof(word);
            x2 = (sword)VCImpexSVGReadWord(elementData, offset);
            offset += sizeof(word);
            y2 = (sword)VCImpexSVGReadWord(elementData, offset);
            offset += sizeof(word);
            startAngle = VCImpexSVGReadWord(elementData, offset);
            offset += sizeof(word);
            endAngle = VCImpexSVGReadWord(elementData, offset);

            /* center */
            cx.WWF_int = (sword)((x1 + x2) / 2);
            cx.WWF_frac = (word)(((x1 + x2) & 1) ? 0x8000 : 0);
            cy.WWF_int = (sword)((y1 + y2) / 2);
            cy.WWF_frac = (word)(((y1 + y2) & 1) ? 0x8000 : 0);
            /* radii */
            rx.WWF_int = (sword)(((x2 - x1) < 0) ? ((x1 - x2) / 2) : ((x2 - x1) / 2));
            rx.WWF_frac = (word)((((x2 - x1) & 1) != 0) ? 0x8000 : 0);
            ry.WWF_int = (sword)(((y2 - y1) < 0) ? ((y1 - y2) / 2) : ((y2 - y1) / 2));
            ry.WWF_frac = (word)((((y2 - y1) & 1) != 0) ? 0x8000 : 0);

            cxFixed = VCImpexSVGPackWWFixed(&cx);
            cyFixed = VCImpexSVGPackWWFixed(&cy);
            rxFixed = VCImpexSVGPackWWFixed(&rx);
            ryFixed = VCImpexSVGPackWWFixed(&ry);

            GrGetTransform(playbackGState, &tm);

            fill = (elementType == GR_FILL_ARC) ? TRUE : FALSE;
            if (!VCImpexSVGWriteArcElement(context, cxFixed, cyFixed, rxFixed, ryFixed, startAngle, endAngle, closeType, fill, &tm))
                return TE_FILE_WRITE;
            return TE_NO_ERROR;
        }

        default:
            break;
    }
    return TE_NO_ERROR;
}

word _pascal VCImpexSVGReadWord(const byte *data, word offset)
{
    word value;

    if (data == NULL)
    {
        return 0;
    }

    memcpy(&value, data + offset, sizeof(word));
    return value;
}

sword _pascal VCImpexSVGReadSword(const byte *data, word offset)
{
    sword value;

    if (data == NULL)
    {
        return 0;
    }

    memcpy(&value, data + offset, sizeof(sword));
    return value;
}

void _pascal VCImpexSVGReadWWFixed(const byte *data, word offset, WWFixed *value)
{
    if ((data == NULL) || (value == NULL))
    {
        return;
    }

    memcpy(value, data + offset, sizeof(WWFixed));
}

void _pascal VCImpexSVGSetWWFixedComponent(WWFixed *component, WWFixedAsDWord value)
{
    component->WWF_int = (word)((((sdword)value) >> 16) & 0xffff);
    component->WWF_frac = (word)(value & 0xffff);
}
