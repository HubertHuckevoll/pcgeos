/***********************************************************************
 *
 * PROJECT:       VCImpex SVG Exporter
 * FILE:          svgsubcode.goc
 *
 * DESCRIPTION:   Helper functions for writing SVG data
 *
 ***********************************************************************/

#include "svgexp.h"

void _pascal VCImpexSVGFormatColor(RGBColorAsDWord colorValue, char *buffer)
{
    word redComponent = 0;
    word greenComponent = 0;
    word blueComponent = 0;

    redComponent = RGB_RED(colorValue);
    greenComponent = RGB_GREEN(colorValue);
    blueComponent = RGB_BLUE(colorValue);
    sprintf(buffer, "#%02X%02X%02X", (unsigned int)redComponent, (unsigned int)greenComponent, (unsigned int)blueComponent);
}

void _pascal VCImpexSVGFormatFixed(WWFixedAsDWord value, char *buffer, word fractionDigits)
{
    LocalFixedToAscii(buffer, value, fractionDigits);
}

static inline ChunkHandle _pascal VCImpexSVGAllocBuffer(VCImpexSVGExportContext *context, word size)
{
    ChunkHandle chunkH = NullHandle;

    if ((context == NULL) || (context->bufferHeapH == NullHandle))
    {
        return NullChunk;
    }

    chunkH = LMemAlloc(context->bufferHeapH, size);

    return chunkH;
}

static inline void _pascal VCImpexSVGFreeBuffer(VCImpexSVGExportContext *context, ChunkHandle chunkHandle)
{
    if ((context != NULL) && (context->bufferHeapH != NullHandle) && (chunkHandle != NullChunk))
    {
        LMemFreeHandles(context->bufferHeapH, chunkHandle);
    }
}

Boolean _pascal VCImpexSVGWriteRawString(VCImpexSVGExportContext *context, const char *text)
{
    word length = 0;

    if ((context == NULL) || (text == NULL))
    {
        return FALSE;
    }

    if (context->svgFile == NullHandle)
    {
        return FALSE;
    }

    length = strlen(text);
    if (length == 0)
    {
        return TRUE;
    }

    if (FileWrite(context->svgFile, text, length, FALSE) != length)
    {
        return FALSE;
    }
    return TRUE;
}

Boolean _pascal VCImpexSVGWriteHeader(VCImpexSVGExportContext *context)
{
    char *buffer = (void*) 0;
    char *widthText = (void*) 0;
    char *heightText = (void*) 0;
    ChunkHandle bufferChunk = NullChunk;
    ChunkHandle widthChunk = NullChunk;
    ChunkHandle heightChunk = NullChunk;
    dword width = 0;
    dword height = 0;
    Boolean success = FALSE;
    Boolean locked = FALSE;

    if ((context == NULL) || (context->bufferHeapH == NullHandle))
    {
        return FALSE;
    }

    width = 0;
    height = 0;
    if (context->bounds.RD_right > context->bounds.RD_left)
    {
        width = context->bounds.RD_right - context->bounds.RD_left;
    }
    if (context->bounds.RD_bottom > context->bounds.RD_top)
    {
        height = context->bounds.RD_bottom - context->bounds.RD_top;
    }

    MemLock(context->bufferHeapH);
    locked = TRUE;

    bufferChunk = VCImpexSVGAllocBuffer(context, 200);
    if (bufferChunk == NullChunk)
        goto cleanup;

    widthChunk = VCImpexSVGAllocBuffer(context, 20);
    if (widthChunk == NullChunk)
        goto cleanup;

    heightChunk = VCImpexSVGAllocBuffer(context, 20);
    if (heightChunk == NullChunk)
        goto cleanup;

    buffer = LMemDerefHandles(context->bufferHeapH, bufferChunk);
    widthText = LMemDerefHandles(context->bufferHeapH, widthChunk);
    heightText = LMemDerefHandles(context->bufferHeapH, heightChunk);

    sprintf(buffer, "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");
    if (!VCImpexSVGWriteRawString(context, buffer))
        goto cleanup;

    sprintf(buffer, "<svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\"\n");
    if (!VCImpexSVGWriteRawString(context, buffer))
        goto cleanup;

    sprintf(widthText, "%lu", (unsigned long)width);
    sprintf(heightText, "%lu", (unsigned long)height);
    sprintf(buffer, "     width=\"%s\" height=\"%s\" viewBox=\"%ld %ld %lu %lu\">\n", widthText, heightText,
            (long)context->bounds.RD_left, (long)context->bounds.RD_top, (unsigned long)width, (unsigned long)height);
    if (!VCImpexSVGWriteRawString(context, buffer))
        goto cleanup;

    success = TRUE;

cleanup:
    VCImpexSVGFreeBuffer(context, heightChunk);
    VCImpexSVGFreeBuffer(context, widthChunk);
    VCImpexSVGFreeBuffer(context, bufferChunk);

    if (locked != FALSE)
    {
        MemUnlock(context->bufferHeapH);
    }

    return success;
}

Boolean _pascal VCImpexSVGWriteFooter(VCImpexSVGExportContext *context)
{
    if (context == NULL)
    {
        return FALSE;
    }
    return VCImpexSVGWriteRawString(context, "</svg>\n");
}

Boolean _pascal VCImpexSVGUpdateDrawingState(GStateHandle gstate, VCImpexSVGExportContext *context)
{
    if (context == NULL)
    {
        return FALSE;
    }

    context->lineWidth = GrGetLineWidth(gstate);
    context->lineColor = GrGetLineColor(gstate);
    context->fillColor = GrGetAreaColor(gstate);
    return TRUE;
}

Boolean _pascal VCImpexSVGWriteLineElement(VCImpexSVGExportContext *context, const PointWWFixed *startPoint, const PointWWFixed *endPoint)
{
    char *buffer = (void*) 0;
    char *x1Text = (void*) 0;
    char *y1Text = (void*) 0;
    char *x2Text = (void*) 0;
    char *y2Text = (void*) 0;
    char *widthText = (void*) 0;
    char *colorText = (void*) 0;
    ChunkHandle bufferChunk = NullChunk;
    ChunkHandle x1Chunk = NullChunk;
    ChunkHandle y1Chunk = NullChunk;
    ChunkHandle x2Chunk = NullChunk;
    ChunkHandle y2Chunk = NullChunk;
    ChunkHandle widthChunk = NullChunk;
    ChunkHandle colorChunk = NullChunk;
    Boolean success = FALSE;
    Boolean locked = FALSE;

    if ((context == NULL) || (startPoint == NULL) || (endPoint == NULL) || (context->bufferHeapH == NullHandle))
    {
        return FALSE;
    }

    MemLock(context->bufferHeapH);
    locked = TRUE;

    bufferChunk = VCImpexSVGAllocBuffer(context, 200);
    if (bufferChunk == NullChunk)
    {
        goto cleanup;
    }

    x1Chunk = VCImpexSVGAllocBuffer(context, 24);
    if (x1Chunk == NullChunk)
    {
        goto cleanup;
    }

    y1Chunk = VCImpexSVGAllocBuffer(context, 24);
    if (y1Chunk == NullChunk)
    {
        goto cleanup;
    }

    x2Chunk = VCImpexSVGAllocBuffer(context, 24);
    if (x2Chunk == NullChunk)
    {
        goto cleanup;
    }

    y2Chunk = VCImpexSVGAllocBuffer(context, 24);
    if (y2Chunk == NullChunk)
    {
        goto cleanup;
    }

    widthChunk = VCImpexSVGAllocBuffer(context, 24);
    if (widthChunk == NullChunk)
    {
        goto cleanup;
    }

    colorChunk = VCImpexSVGAllocBuffer(context, 10);
    if (colorChunk == NullChunk)
    {
        goto cleanup;
    }

    buffer = LMemDerefHandles(context->bufferHeapH, bufferChunk);
    x1Text = LMemDerefHandles(context->bufferHeapH, x1Chunk);
    y1Text = LMemDerefHandles(context->bufferHeapH, y1Chunk);
    x2Text = LMemDerefHandles(context->bufferHeapH, x2Chunk);
    y2Text = LMemDerefHandles(context->bufferHeapH, y2Chunk);
    widthText = LMemDerefHandles(context->bufferHeapH, widthChunk);
    colorText = LMemDerefHandles(context->bufferHeapH, colorChunk);

    VCImpexSVGFormatFixed(VCImpexSVGPackWWFixed(&startPoint->PF_x), x1Text, 2);
    VCImpexSVGFormatFixed(VCImpexSVGPackWWFixed(&startPoint->PF_y), y1Text, 2);
    VCImpexSVGFormatFixed(VCImpexSVGPackWWFixed(&endPoint->PF_x), x2Text, 2);
    VCImpexSVGFormatFixed(VCImpexSVGPackWWFixed(&endPoint->PF_y), y2Text, 2);
    VCImpexSVGFormatFixed(context->lineWidth, widthText, 2);

    if (context->lineWidth == 0)
    {
        strcpy(colorText, "none");
    }
    else
    {
        VCImpexSVGFormatColor(context->lineColor, colorText);
    }

    sprintf(buffer, "  <line x1=\"%s\" y1=\"%s\" x2=\"%s\" y2=\"%s\" stroke=\"%s\" stroke-width=\"%s\" fill=\"none\" />\n",
            x1Text, y1Text, x2Text, y2Text, colorText, widthText);
    success = VCImpexSVGWriteRawString(context, buffer);

cleanup:
    VCImpexSVGFreeBuffer(context, colorChunk);
    VCImpexSVGFreeBuffer(context, widthChunk);
    VCImpexSVGFreeBuffer(context, y2Chunk);
    VCImpexSVGFreeBuffer(context, x2Chunk);
    VCImpexSVGFreeBuffer(context, y1Chunk);
    VCImpexSVGFreeBuffer(context, x1Chunk);
    VCImpexSVGFreeBuffer(context, bufferChunk);

    if (locked != FALSE)
    {
        MemUnlock(context->bufferHeapH);
    }

    return success;
}

Boolean _pascal VCImpexSVGWriteRectElement(VCImpexSVGExportContext *context, const PointWWFixed *corner1, const PointWWFixed *corner3, Boolean filled)
{
    char *buffer = (void*) 0;
    char *xText = (void*) 0;
    char *yText = (void*) 0;
    char *widthText = (void*) 0;
    char *heightText = (void*) 0;
    char *strokeWidthText = (void*) 0;
    char *strokeColor = (void*) 0;
    char *fillText = (void*) 0;
    ChunkHandle bufferChunk = NullChunk;
    ChunkHandle xChunk = NullChunk;
    ChunkHandle yChunk = NullChunk;
    ChunkHandle widthChunk = NullChunk;
    ChunkHandle heightChunk = NullChunk;
    ChunkHandle strokeWidthChunk = NullChunk;
    ChunkHandle strokeColorChunk = NullChunk;
    ChunkHandle fillChunk = NullChunk;
    WWFixedAsDWord leftValue = {0};
    WWFixedAsDWord topValue = {0};
    WWFixedAsDWord rightValue = {0};
    WWFixedAsDWord bottomValue = {0};
    sdword widthSigned = 0;
    sdword heightSigned = 0;
    Boolean success = FALSE;
    Boolean locked = FALSE;

    if ((context == NULL) || (corner1 == NULL) || (corner3 == NULL) || (context->bufferHeapH == NullHandle))
    {
        return FALSE;
    }

    MemLock(context->bufferHeapH);
    locked = TRUE;

    bufferChunk = VCImpexSVGAllocBuffer(context, 220);
    if (bufferChunk == NullChunk)
    {
        goto cleanup;
    }

    xChunk = VCImpexSVGAllocBuffer(context, 24);
    if (xChunk == NullChunk)
    {
        goto cleanup;
    }

    yChunk = VCImpexSVGAllocBuffer(context, 24);
    if (yChunk == NullChunk)
    {
        goto cleanup;
    }

    widthChunk = VCImpexSVGAllocBuffer(context, 24);
    if (widthChunk == NullChunk)
    {
        goto cleanup;
    }

    heightChunk = VCImpexSVGAllocBuffer(context, 24);
    if (heightChunk == NullChunk)
    {
        goto cleanup;
    }

    strokeWidthChunk = VCImpexSVGAllocBuffer(context, 24);
    if (strokeWidthChunk == NullChunk)
    {
        goto cleanup;
    }

    strokeColorChunk = VCImpexSVGAllocBuffer(context, 10);
    if (strokeColorChunk == NullChunk)
    {
        goto cleanup;
    }

    fillChunk = VCImpexSVGAllocBuffer(context, 10);
    if (fillChunk == NullChunk)
    {
        goto cleanup;
    }

    buffer = LMemDerefHandles(context->bufferHeapH, bufferChunk);
    xText = LMemDerefHandles(context->bufferHeapH, xChunk);
    yText = LMemDerefHandles(context->bufferHeapH, yChunk);
    widthText = LMemDerefHandles(context->bufferHeapH, widthChunk);
    heightText = LMemDerefHandles(context->bufferHeapH, heightChunk);
    strokeWidthText = LMemDerefHandles(context->bufferHeapH, strokeWidthChunk);
    strokeColor = LMemDerefHandles(context->bufferHeapH, strokeColorChunk);
    fillText = LMemDerefHandles(context->bufferHeapH, fillChunk);

    leftValue = VCImpexSVGPackWWFixed(&corner1->PF_x);
    topValue = VCImpexSVGPackWWFixed(&corner1->PF_y);
    rightValue = VCImpexSVGPackWWFixed(&corner3->PF_x);
    bottomValue = VCImpexSVGPackWWFixed(&corner3->PF_y);

    widthSigned = (sdword)rightValue - (sdword)leftValue;
    heightSigned = (sdword)bottomValue - (sdword)topValue;
    if (widthSigned < 0)
    {
        leftValue = rightValue;
        widthSigned = -widthSigned;
    }
    if (heightSigned < 0)
    {
        topValue = bottomValue;
        heightSigned = -heightSigned;
    }

    VCImpexSVGFormatFixed(leftValue, xText, 2);
    VCImpexSVGFormatFixed(topValue, yText, 2);
    VCImpexSVGFormatFixed((WWFixedAsDWord)widthSigned, widthText, 2);
    VCImpexSVGFormatFixed((WWFixedAsDWord)heightSigned, heightText, 2);
    VCImpexSVGFormatFixed(context->lineWidth, strokeWidthText, 2);

    if (context->lineWidth == 0)
    {
        strcpy(strokeColor, "none");
    }
    else
    {
        VCImpexSVGFormatColor(context->lineColor, strokeColor);
    }

    if (filled != FALSE)
    {
        VCImpexSVGFormatColor(context->fillColor, fillText);
    }
    else
    {
        strcpy(fillText, "none");
    }

    sprintf(buffer, "  <rect x=\"%s\" y=\"%s\" width=\"%s\" height=\"%s\" stroke=\"%s\" fill=\"%s\" stroke-width=\"%s\" />\n",
            xText, yText, widthText, heightText, strokeColor, fillText, strokeWidthText);
    success = VCImpexSVGWriteRawString(context, buffer);

cleanup:
    VCImpexSVGFreeBuffer(context, fillChunk);
    VCImpexSVGFreeBuffer(context, strokeColorChunk);
    VCImpexSVGFreeBuffer(context, strokeWidthChunk);
    VCImpexSVGFreeBuffer(context, heightChunk);
    VCImpexSVGFreeBuffer(context, widthChunk);
    VCImpexSVGFreeBuffer(context, yChunk);
    VCImpexSVGFreeBuffer(context, xChunk);
    VCImpexSVGFreeBuffer(context, bufferChunk);

    if (locked != FALSE)
    {
        MemUnlock(context->bufferHeapH);
    }

    return success;
}

Boolean _pascal VCImpexSVGWritePolygonElement(VCImpexSVGExportContext *context, const PointWWFixed *points, word pointCount, Boolean closeShape, Boolean filled)
{
    const char *elementName = (void*) 0;
    char *prefix = (void*) 0;
    char *xText = (void*) 0;
    char *yText = (void*) 0;
    char *coordinateText = (void*) 0;
    char *strokeWidthText = (void*) 0;
    char *strokeColor = (void*) 0;
    char *fillText = (void*) 0;
    ChunkHandle prefixChunk = NullChunk;
    ChunkHandle xChunk = NullChunk;
    ChunkHandle yChunk = NullChunk;
    ChunkHandle coordinateChunk = NullChunk;
    ChunkHandle strokeWidthChunk = NullChunk;
    ChunkHandle strokeColorChunk = NullChunk;
    ChunkHandle fillChunk = NullChunk;
    word index = 0;
    Boolean success = FALSE;
    Boolean locked = FALSE;

    if ((context == NULL) || (points == NULL) || (pointCount == 0) || (context->bufferHeapH == NullHandle))
    {
        return FALSE;
    }

    if (closeShape != FALSE)
    {
        elementName = "polygon";
    }
    else
    {
        elementName = "polyline";
    }

    MemLock(context->bufferHeapH);
    locked = TRUE;

    prefixChunk = VCImpexSVGAllocBuffer(context, 20);
    if (prefixChunk == NullChunk)
    {
        goto cleanup;
    }

    xChunk = VCImpexSVGAllocBuffer(context, 24);
    if (xChunk == NullChunk)
    {
        goto cleanup;
    }

    yChunk = VCImpexSVGAllocBuffer(context, 24);
    if (yChunk == NullChunk)
    {
        goto cleanup;
    }

    coordinateChunk = VCImpexSVGAllocBuffer(context, 64);
    if (coordinateChunk == NullChunk)
    {
        goto cleanup;
    }

    strokeWidthChunk = VCImpexSVGAllocBuffer(context, 24);
    if (strokeWidthChunk == NullChunk)
    {
        goto cleanup;
    }

    strokeColorChunk = VCImpexSVGAllocBuffer(context, 10);
    if (strokeColorChunk == NullChunk)
    {
        goto cleanup;
    }

    fillChunk = VCImpexSVGAllocBuffer(context, 10);
    if (fillChunk == NullChunk)
    {
        goto cleanup;
    }

    prefix = LMemDerefHandles(context->bufferHeapH, prefixChunk);
    xText = LMemDerefHandles(context->bufferHeapH, xChunk);
    yText = LMemDerefHandles(context->bufferHeapH, yChunk);
    coordinateText = LMemDerefHandles(context->bufferHeapH, coordinateChunk);
    strokeWidthText = LMemDerefHandles(context->bufferHeapH, strokeWidthChunk);
    strokeColor = LMemDerefHandles(context->bufferHeapH, strokeColorChunk);
    fillText = LMemDerefHandles(context->bufferHeapH, fillChunk);

    VCImpexSVGFormatFixed(context->lineWidth, strokeWidthText, 2);

    if (context->lineWidth == 0)
    {
        strcpy(strokeColor, "none");
    }
    else
    {
        VCImpexSVGFormatColor(context->lineColor, strokeColor);
    }

    if (filled != FALSE)
    {
        VCImpexSVGFormatColor(context->fillColor, fillText);
    }
    else
    {
        strcpy(fillText, "none");
    }

    sprintf(prefix, "  <%s points=\"", elementName);
    if (!VCImpexSVGWriteRawString(context, prefix))
    {
        goto cleanup;
    }

    for (index = 0; index < pointCount; index++)
    {
        VCImpexSVGFormatFixed(VCImpexSVGPackWWFixed(&points[index].PF_x), xText, 2);
        VCImpexSVGFormatFixed(VCImpexSVGPackWWFixed(&points[index].PF_y), yText, 2);
        sprintf(coordinateText, "%s,%s", xText, yText);
        if (!VCImpexSVGWriteRawString(context, coordinateText))
        {
            goto cleanup;
        }
        if (index + 1 < pointCount)
        {
            if (!VCImpexSVGWriteRawString(context, " "))
            {
                goto cleanup;
            }
        }
    }

    sprintf(coordinateText, "\" stroke=\"%s\" fill=\"%s\" stroke-width=\"%s\" />\n", strokeColor, fillText, strokeWidthText);
    success = VCImpexSVGWriteRawString(context, coordinateText);

cleanup:
    VCImpexSVGFreeBuffer(context, fillChunk);
    VCImpexSVGFreeBuffer(context, strokeColorChunk);
    VCImpexSVGFreeBuffer(context, strokeWidthChunk);
    VCImpexSVGFreeBuffer(context, coordinateChunk);
    VCImpexSVGFreeBuffer(context, yChunk);
    VCImpexSVGFreeBuffer(context, xChunk);
    VCImpexSVGFreeBuffer(context, prefixChunk);

    if (locked != FALSE)
    {
        MemUnlock(context->bufferHeapH);
    }

    return success;
}

WWFixedAsDWord _pascal VCImpexSVGPackWWFixed(const WWFixed *value)
{
    WWFixedAsDWord result = {0};
    sdword integerPart = 0;

    if (value == NULL)
    {
        return 0;
    }

    integerPart = (sdword)((sword)value->WWF_int);
    result = (WWFixedAsDWord)(integerPart << 16);
    result |= value->WWF_frac;
    return result;
}

void _pascal VCImpexSVGTransformPointFromInt(GStateHandle gstate, const Point *sourcePoint, PointWWFixed *targetPoint)
{
    XYValueAsDWord transformedValue = {0};

    transformedValue = GrTransform(gstate, sourcePoint->P_x, sourcePoint->P_y);
    targetPoint->PF_x.WWF_int = DWORD_X(transformedValue);
    targetPoint->PF_y.WWF_int = DWORD_Y(transformedValue);
    targetPoint->PF_x.WWF_frac = 0;
    targetPoint->PF_y.WWF_frac = 0;
}

void _pascal VCImpexSVGTransformPointFromFixed(GStateHandle gstate, const PointWWFixed *sourcePoint, PointWWFixed *targetPoint)
{
    GrTransformWWFixed(gstate, VCImpexSVGPackWWFixed(&sourcePoint->PF_x), VCImpexSVGPackWWFixed(&sourcePoint->PF_y), targetPoint);
}

void _pascal VCImpexSVGTransformRelativePoint(GStateHandle gstate, const PointWWFixed *deltaPoint, PointWWFixed *targetPoint)
{
    PointWWFixed currentPoint = {0};
    WWFixedAsDWord xValue = {0};
    WWFixedAsDWord yValue = {0};

    GrGetCurPosWWFixed(gstate, &currentPoint);
    xValue = VCImpexSVGPackWWFixed(&currentPoint.PF_x) + VCImpexSVGPackWWFixed(&deltaPoint->PF_x);
    yValue = VCImpexSVGPackWWFixed(&currentPoint.PF_y) + VCImpexSVGPackWWFixed(&deltaPoint->PF_y);
    GrTransformWWFixed(gstate, xValue, yValue, targetPoint);
}

void _pascal VCImpexSVGCopyPointWWFixed(PointWWFixed *destination, const PointWWFixed *source)
{
    destination->PF_x.WWF_int = source->PF_x.WWF_int;
    destination->PF_x.WWF_frac = source->PF_x.WWF_frac;
    destination->PF_y.WWF_int = source->PF_y.WWF_int;
    destination->PF_y.WWF_frac = source->PF_y.WWF_frac;
}
