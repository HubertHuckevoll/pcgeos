/***********************************************************************
 *
 * PROJECT:       VCImpex SVG Exporter
 * FILE:          svgsubcode.goc
 *
 * DESCRIPTION:   Helper functions for writing SVG data
 *
 ***********************************************************************/
@include <stdapp.goh>

#include "svgexp.h"

static const word kVCImpexSVGBuiltinDashCounts[] = {0, 1, 1, 2, 3, 0};
static const word kVCImpexSVGBuiltinDashValues[][MAX_DASH_ARRAY_PAIRS * 2] =
{
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, /* LS_SOLID */
    {4, 4, 0, 0, 0, 0, 0, 0, 0, 0}, /* LS_DASHED */
    {1, 2, 0, 0, 0, 0, 0, 0, 0, 0}, /* LS_DOTTED */
    {4, 4, 1, 4, 0, 0, 0, 0, 0, 0}, /* LS_DASHDOT */
    {4, 4, 1, 4, 1, 4, 0, 0, 0, 0}, /* LS_DASHDDOT */
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}  /* LS_CUSTOM placeholder */
};

static const WWFixedAsDWord kVCImpexSVGHairlineWidth = 0x00001000;

static WWFixedAsDWord VCImpexSVGScaleDashLength(WWFixedAsDWord lineWidth, word factor);
static WWFixedAsDWord VCImpexSVGGetEffectiveLineWidth(const VCImpexSVGExportContext *context);
static void VCImpexSVGFormatDashArray(const VCImpexSVGExportContext *context,
                                      char *buffer,
                                      word bufferSize);
static Boolean VCImpexSVGFormatDashOffset(const VCImpexSVGExportContext *context,
                                          char *buffer,
                                          word bufferSize);
static const char* VCImpexSVGLineCapToString(LineEnd lineCap);
static const char* VCImpexSVGLineJoinToString(LineJoin lineJoin);
static const char* VCImpexSVGFillRuleToString(RegionFillRule fillRule);

/* Helper: format DWFixed (approximate to 16.16) */
static void VCImpexSVGFormatDWFixed(const DWFixed *value, char *buffer, word fractionDigits)
{
    WWFixedAsDWord approx = 0;
    sdword i = 0;
    word f = 0;
    if ((buffer == NULL) || (value == NULL))
        return;

    /* Approximate DWFixed (int32.frac16) to 16.16 WWFixed for printing. */
    i = value->DWF_int;
    f = value->DWF_frac;
    approx = ((WWFixedAsDWord)((sdword)i) << 16) | (WWFixedAsDWord)f;
    LocalFixedToAscii(buffer, approx, fractionDigits);
}

void _pascal VCImpexSVGFormatColor(RGBColorAsDWord colorValue, char *buffer)
{
    word redComponent = 0;
    word greenComponent = 0;
    word blueComponent = 0;

    redComponent = RGB_RED(colorValue);
    greenComponent = RGB_GREEN(colorValue);
    blueComponent = RGB_BLUE(colorValue);
    sprintf(buffer, "#%02X%02X%02X", (unsigned int)redComponent, (unsigned int)greenComponent, (unsigned int)blueComponent);
}

void _pascal VCImpexSVGFormatFixed(WWFixedAsDWord value, char *buffer, word fractionDigits)
{
    LocalFixedToAscii(buffer, value, fractionDigits);
}

static WWFixedAsDWord VCImpexSVGScaleDashLength(WWFixedAsDWord lineWidth, word factor)
{
    dword product = 0;

    product = (dword)lineWidth * (dword)factor;
    return (WWFixedAsDWord)product;
}

static WWFixedAsDWord VCImpexSVGGetEffectiveLineWidth(const VCImpexSVGExportContext *context)
{
    if (context == NULL)
    {
        return kVCImpexSVGHairlineWidth;
    }

    if (context->lineWidth == 0)
    {
        return kVCImpexSVGHairlineWidth;
    }

    return context->lineWidth;
}

static const char* VCImpexSVGLineCapToString(LineEnd lineCap)
{
    switch (lineCap)
    {
        case LE_ROUNDCAP:
            return "round";
        case LE_SQUARECAP:
            return "square";
        default:
            return "butt";
    }
}

static const char* VCImpexSVGLineJoinToString(LineJoin lineJoin)
{
    switch (lineJoin)
    {
        case LJ_ROUND:
            return "round";
        case LJ_BEVELED:
            return "bevel";
        default:
            return "miter";
    }
}

static const char* VCImpexSVGFillRuleToString(RegionFillRule fillRule)
{
    switch (fillRule)
    {
        case ODD_EVEN:
            return "evenodd";
        case WINDING:
        default:
            return "nonzero";
    }
}

static void VCImpexSVGFormatDashArray(const VCImpexSVGExportContext *context,
                                      char *buffer,
                                      word bufferSize)
{
    const word *values = (void*)0;
    word pairCount = 0;
    word totalEntries = 0;
    word index = 0;
    Boolean first = TRUE;
    char number[24];
    char *out = buffer;
    word remaining = bufferSize;
    WWFixedAsDWord effectiveWidth = 0;

    if ((context == NULL) || (buffer == NULL) || (bufferSize == 0))
        return;

    buffer[0] = '\0';

    if (remaining <= 1)
    {
        strcpy(buffer, "none");
        return;
    }

    effectiveWidth = VCImpexSVGGetEffectiveLineWidth(context);

    if ((context->lineStyle == LS_CUSTOM) && (context->dashPairCount != 0))
    {
        pairCount = context->dashPairCount;
        values = context->dashPattern;
    }
    else if ((context->lineStyle >= LS_DASHED) && (context->lineStyle <= LS_DASHDDOT))
    {
        pairCount = kVCImpexSVGBuiltinDashCounts[context->lineStyle];
        values = kVCImpexSVGBuiltinDashValues[context->lineStyle];
    }
    else
    {
        strcpy(buffer, "none");
        return;
    }

    if (pairCount == 0)
    {
        strcpy(buffer, "none");
        return;
    }

    totalEntries = pairCount * 2;
    for (index = 0; index < totalEntries; index++)
    {
        word baseValue = values[index];
        WWFixedAsDWord scaled = 0;
        word length = 0;

        if (baseValue == 0)
            continue;

        scaled = VCImpexSVGScaleDashLength(effectiveWidth, baseValue);
        VCImpexSVGFormatFixed(scaled, number, 2);
        length = strlen(number);

        if (first)
        {
            if (length + 1 > remaining)
            {
                break;
            }
            strcpy(out, number);
            out += length;
            remaining -= length;
            first = FALSE;
        }
        else
        {
            if (length + 2 > remaining)
            {
                break;
            }
            *out = ' ';
            out++;
            memcpy(out, number, length + 1);
            out += length;
            remaining -= (length + 1);
        }
    }

    if (first != FALSE)
    {
        strcpy(buffer, "none");
    }
}

static Boolean VCImpexSVGFormatDashOffset(const VCImpexSVGExportContext *context,
                                          char *buffer,
                                          word bufferSize)
{
    WWFixedAsDWord scaled = 0;
    WWFixedAsDWord effectiveWidth = 0;

    if ((buffer == NULL) || (bufferSize == 0))
        return FALSE;

    buffer[0] = '\0';

    if ((context == NULL) || (context->dashSkipCount == 0))
    {
        strcpy(buffer, "0");
        return FALSE;
    }

    effectiveWidth = VCImpexSVGGetEffectiveLineWidth(context);

    scaled = VCImpexSVGScaleDashLength(effectiveWidth, context->dashSkipCount);
    VCImpexSVGFormatFixed(scaled, buffer, 2);

    if (scaled == 0)
    {
        return FALSE;
    }

    return TRUE;
}

ChunkHandle _pascal VCImpexSVGAllocBuffer(VCImpexSVGExportContext *context, word size)
{
    ChunkHandle chunkH = NullHandle;

    if ((context == NULL) || (context->bufferHeapH == NullHandle))
        return NullChunk;

    MemLock(context->bufferHeapH);
    chunkH = LMemAlloc(context->bufferHeapH, size);
    if (chunkH != NullChunk)
    {
        memset(LMemDerefHandles(context->bufferHeapH, chunkH), 0, size);
    }
    MemUnlock(context->bufferHeapH);

    if (chunkH == NullChunk)
        return NullChunk;

    return chunkH;
}

void _pascal VCImpexSVGFreeBuffer(VCImpexSVGExportContext *context, ChunkHandle chunkHandle)
{
    if ((context != NULL) && (context->bufferHeapH != NullHandle) && (chunkHandle != NullChunk))
    {
        MemLock(context->bufferHeapH);
        LMemFreeHandles(context->bufferHeapH, chunkHandle);
        MemUnlock(context->bufferHeapH);
    }
}

Boolean _pascal VCImpexSVGWriteRawString(VCImpexSVGExportContext *context, const char *text)
{
    word length = 0;

    if ((context == NULL) || (text == NULL))
        return FALSE;

    if (context->svgFile == NullHandle)
        return FALSE;

    length = strlen(text);
    if (length == 0)
        return TRUE;

    if (FileWrite(context->svgFile, text, length, FALSE) != length)
        return FALSE;

    return TRUE;
}

Boolean _pascal VCImpexSVGWriteHeader(VCImpexSVGExportContext *context)
{
    char *buffer = (void*) 0;
    char *widthText = (void*) 0;
    char *heightText = (void*) 0;
    ChunkHandle bufferChunk = NullChunk;
    ChunkHandle widthChunk = NullChunk;
    ChunkHandle heightChunk = NullChunk;
    dword width = 0;
    dword height = 0;
    Boolean success = FALSE;
    Boolean locked = FALSE;

    if ((context == NULL) || (context->bufferHeapH == NullHandle))
        return FALSE;

    width = 0;
    height = 0;
    if (context->bounds.RD_right > context->bounds.RD_left)
    {
        width = context->bounds.RD_right - context->bounds.RD_left;
    }

    if (context->bounds.RD_bottom > context->bounds.RD_top)
    {
        height = context->bounds.RD_bottom - context->bounds.RD_top;
    }

    MemLock(context->bufferHeapH);
    locked = TRUE;

    bufferChunk = VCImpexSVGAllocBuffer(context, 220);
    if (bufferChunk == NullChunk) goto cleanup;

    widthChunk = VCImpexSVGAllocBuffer(context, 20);
    if (widthChunk == NullChunk) goto cleanup;

    heightChunk = VCImpexSVGAllocBuffer(context, 20);
    if (heightChunk == NullChunk) goto cleanup;

    buffer = LMemDerefHandles(context->bufferHeapH, bufferChunk);
    widthText = LMemDerefHandles(context->bufferHeapH, widthChunk);
    heightText = LMemDerefHandles(context->bufferHeapH, heightChunk);

    sprintf(buffer, "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");
    if (!VCImpexSVGWriteRawString(context, buffer)) goto cleanup;

    sprintf(buffer, "<svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\"\n");
    if (!VCImpexSVGWriteRawString(context, buffer)) goto cleanup;

    sprintf(widthText, "%lu", (unsigned long)width);
    sprintf(heightText, "%lu", (unsigned long)height);
    sprintf(buffer, "     width=\"%s\" height=\"%s\" viewBox=\"%ld %ld %lu %lu\">\n", widthText, heightText,
            (long)context->bounds.RD_left, (long)context->bounds.RD_top, (unsigned long)width, (unsigned long)height);
    if (!VCImpexSVGWriteRawString(context, buffer)) goto cleanup;

    success = TRUE;

cleanup:
    VCImpexSVGFreeBuffer(context, heightChunk);
    VCImpexSVGFreeBuffer(context, widthChunk);
    VCImpexSVGFreeBuffer(context, bufferChunk);

    if (locked != FALSE)
    {
        MemUnlock(context->bufferHeapH);
    }

    return success;
}

Boolean _pascal VCImpexSVGWriteFooter(VCImpexSVGExportContext *context)
{
    if (context == NULL) return FALSE;

    return VCImpexSVGWriteRawString(context, "</svg>\n");
}

Boolean _pascal VCImpexSVGUpdateDrawingState(GStateHandle gstate, VCImpexSVGExportContext *context)
{
    if (context == NULL) return FALSE;

    context->lineWidth = GrGetLineWidth(gstate);
    context->lineColor = GrGetLineColor(gstate);
    context->fillColor = GrGetAreaColor(gstate);
    context->lineJoin = GrGetLineJoin(gstate);
    context->lineCap = GrGetLineEnd(gstate);
    context->miterLimit = GrGetMiterLimit(gstate);
    context->lineStyle = GrGetLineStyle(gstate);

    return TRUE;
}

Boolean _pascal VCImpexSVGStyleToAttributes(VCImpexSVGExportContext *context,
                                            Boolean includeFill,
                                            Boolean filled,
                                            RegionFillRule fillRule,
                                            char *buffer,
                                            word bufferSize)
{
    char strokeWidthText[40];
    char strokeColorText[16];
    char fillColorText[16];
    char dashArrayText[160];
    char dashOffsetText[40];
    char dashOffsetSection[64];
    char miterLimitText[40];
    const char *lineCapText = (void*)0;
    const char *lineJoinText = (void*)0;
    const char *fillRuleText = (void*)0;
    char fillSection[48];
    Boolean appendDashOffset;
    WWFixedAsDWord effectiveLineWidth = 0;

    if ((context == NULL) || (buffer == NULL) || (bufferSize < 240))
        return FALSE;

    effectiveLineWidth = VCImpexSVGGetEffectiveLineWidth(context);

    VCImpexSVGFormatFixed(effectiveLineWidth, strokeWidthText, 2);
    VCImpexSVGFormatColor(context->lineColor, strokeColorText);

    VCImpexSVGFormatDashArray(context, dashArrayText, sizeof(dashArrayText));
    dashOffsetText[0] = '\0';
    dashOffsetSection[0] = '\0';
    appendDashOffset = FALSE;
    if (strcmp(dashArrayText, "none") != 0)
    {
        if (VCImpexSVGFormatDashOffset(context, dashOffsetText, sizeof(dashOffsetText)))
        {
            appendDashOffset = TRUE;
        }
    }
    lineCapText = VCImpexSVGLineCapToString(context->lineCap);
    lineJoinText = VCImpexSVGLineJoinToString(context->lineJoin);
    VCImpexSVGFormatFixed(context->miterLimit, miterLimitText, 2);

    fillColorText[0] = '\0';
    fillRuleText = VCImpexSVGFillRuleToString(fillRule);

    if (includeFill != FALSE)
    {
        if (filled != FALSE)
        {
            VCImpexSVGFormatColor(context->fillColor, fillColorText);
        }
        else
        {
            strcpy(fillColorText, "none");
        }
    }

    sprintf(buffer,
            " stroke=\"%s\" stroke-width=\"%s\" stroke-linecap=\"%s\" stroke-linejoin=\"%s\" stroke-dasharray=\"%s\" stroke-miterlimit=\"%s\"",
            strokeColorText,
            strokeWidthText,
            lineCapText,
            lineJoinText,
            dashArrayText,
            miterLimitText);

    if (appendDashOffset != FALSE)
    {
        sprintf(dashOffsetSection, " stroke-dashoffset=\"%s\"", dashOffsetText);
        if (strlen(buffer) + strlen(dashOffsetSection) + 1 >= bufferSize)
        {
            return FALSE;
        }
        strcat(buffer, dashOffsetSection);
    }

    if (includeFill != FALSE)
    {
        sprintf(fillSection, " fill=\"%s\" fill-rule=\"%s\"", fillColorText, fillRuleText);
        if (strlen(buffer) + strlen(fillSection) + 1 >= bufferSize)
        {
            return FALSE;
        }
        strcat(buffer, fillSection);
    }

    return TRUE;
}

Boolean _pascal VCImpexSVGWriteLineElement(VCImpexSVGExportContext *context, const PointWWFixed *startPoint, const PointWWFixed *endPoint)
{
    char *buffer = (void*) 0;
    char *x1Text = (void*) 0;
    char *y1Text = (void*) 0;
    char *x2Text = (void*) 0;
    char *y2Text = (void*) 0;
    char *styleAttributes = (void*) 0;
    ChunkHandle bufferChunk = NullChunk;
    ChunkHandle x1Chunk = NullChunk;
    ChunkHandle y1Chunk = NullChunk;
    ChunkHandle x2Chunk = NullChunk;
    ChunkHandle y2Chunk = NullChunk;
    ChunkHandle styleChunk = NullChunk;
    Boolean success = FALSE;
    Boolean locked = FALSE;

    if ((context == NULL) || (startPoint == NULL) || (endPoint == NULL) || (context->bufferHeapH == NullHandle))
        return FALSE;

    MemLock(context->bufferHeapH);
    locked = TRUE;

    bufferChunk = VCImpexSVGAllocBuffer(context, 220);
    if (bufferChunk == NullChunk) goto cleanup;

    x1Chunk = VCImpexSVGAllocBuffer(context, 24);
    if (x1Chunk == NullChunk) goto cleanup;

    y1Chunk = VCImpexSVGAllocBuffer(context, 24);
    if (y1Chunk == NullChunk) goto cleanup;

    x2Chunk = VCImpexSVGAllocBuffer(context, 24);
    if (x2Chunk == NullChunk) goto cleanup;

    y2Chunk = VCImpexSVGAllocBuffer(context, 24);
    if (y2Chunk == NullChunk) goto cleanup;

    styleChunk = VCImpexSVGAllocBuffer(context, 256);
    if (styleChunk == NullChunk) goto cleanup;

    buffer = LMemDerefHandles(context->bufferHeapH, bufferChunk);
    x1Text = LMemDerefHandles(context->bufferHeapH, x1Chunk);
    y1Text = LMemDerefHandles(context->bufferHeapH, y1Chunk);
    x2Text = LMemDerefHandles(context->bufferHeapH, x2Chunk);
    y2Text = LMemDerefHandles(context->bufferHeapH, y2Chunk);
    styleAttributes = LMemDerefHandles(context->bufferHeapH, styleChunk);

    VCImpexSVGFormatFixed(VCImpexSVGPackWWFixed(&startPoint->PF_x), x1Text, 2);
    VCImpexSVGFormatFixed(VCImpexSVGPackWWFixed(&startPoint->PF_y), y1Text, 2);
    VCImpexSVGFormatFixed(VCImpexSVGPackWWFixed(&endPoint->PF_x), x2Text, 2);
    VCImpexSVGFormatFixed(VCImpexSVGPackWWFixed(&endPoint->PF_y), y2Text, 2);
    if (!VCImpexSVGStyleToAttributes(context, TRUE, FALSE, context->fillRule, styleAttributes, 256))
        goto cleanup;

    sprintf(buffer, "  <line x1=\"%s\" y1=\"%s\" x2=\"%s\" y2=\"%s\"%s />\n",
            x1Text, y1Text, x2Text, y2Text, styleAttributes);
    success = VCImpexSVGWriteRawString(context, buffer);

cleanup:
    VCImpexSVGFreeBuffer(context, styleChunk);
    VCImpexSVGFreeBuffer(context, y2Chunk);
    VCImpexSVGFreeBuffer(context, x2Chunk);
    VCImpexSVGFreeBuffer(context, y1Chunk);
    VCImpexSVGFreeBuffer(context, x1Chunk);
    VCImpexSVGFreeBuffer(context, bufferChunk);

    if (locked != FALSE)
    {
        MemUnlock(context->bufferHeapH);
    }

    return success;
}

Boolean _pascal VCImpexSVGWriteRectElement(VCImpexSVGExportContext *context, const PointWWFixed *corner1, const PointWWFixed *corner3, Boolean filled)
{
    char *buffer = (void*) 0;
    char *xText = (void*) 0;
    char *yText = (void*) 0;
    char *widthText = (void*) 0;
    char *heightText = (void*) 0;
    char *styleAttributes = (void*) 0;
    ChunkHandle bufferChunk = NullChunk;
    ChunkHandle xChunk = NullChunk;
    ChunkHandle yChunk = NullChunk;
    ChunkHandle widthChunk = NullChunk;
    ChunkHandle heightChunk = NullChunk;
    ChunkHandle styleChunk = NullChunk;
    WWFixedAsDWord leftValue = 0;
    WWFixedAsDWord topValue = 0;
    WWFixedAsDWord rightValue = 0;
    WWFixedAsDWord bottomValue = 0;
    sdword widthSigned = 0;
    sdword heightSigned = 0;
    Boolean success = FALSE;
    Boolean locked = FALSE;

    if ((context == NULL) || (corner1 == NULL) || (corner3 == NULL) || (context->bufferHeapH == NullHandle))
    {
        return FALSE;
    }

    MemLock(context->bufferHeapH);
    locked = TRUE;

    bufferChunk = VCImpexSVGAllocBuffer(context, 512);
    if (bufferChunk == NullChunk) goto cleanup;

    xChunk = VCImpexSVGAllocBuffer(context, 40);
    if (xChunk == NullChunk) goto cleanup;

    yChunk = VCImpexSVGAllocBuffer(context, 40);
    if (yChunk == NullChunk) goto cleanup;

    widthChunk = VCImpexSVGAllocBuffer(context, 40);
    if (widthChunk == NullChunk) goto cleanup;

    heightChunk = VCImpexSVGAllocBuffer(context, 40);
    if (heightChunk == NullChunk) goto cleanup;

    styleChunk = VCImpexSVGAllocBuffer(context, 256);
    if (styleChunk == NullChunk) goto cleanup;

    buffer = LMemDerefHandles(context->bufferHeapH, bufferChunk);
    xText = LMemDerefHandles(context->bufferHeapH, xChunk);
    yText = LMemDerefHandles(context->bufferHeapH, yChunk);
    widthText = LMemDerefHandles(context->bufferHeapH, widthChunk);
    heightText = LMemDerefHandles(context->bufferHeapH, heightChunk);
    styleAttributes = LMemDerefHandles(context->bufferHeapH, styleChunk);

    leftValue = VCImpexSVGPackWWFixed(&corner1->PF_x);
    topValue = VCImpexSVGPackWWFixed(&corner1->PF_y);
    rightValue = VCImpexSVGPackWWFixed(&corner3->PF_x);
    bottomValue = VCImpexSVGPackWWFixed(&corner3->PF_y);

    widthSigned = (sdword)rightValue - (sdword)leftValue;
    heightSigned = (sdword)bottomValue - (sdword)topValue;
    if (widthSigned < 0)
    {
        leftValue = rightValue;
        widthSigned = -widthSigned;
    }
    if (heightSigned < 0)
    {
        topValue = bottomValue;
        heightSigned = -heightSigned;
    }

    VCImpexSVGFormatFixed(leftValue, xText, 2);
    VCImpexSVGFormatFixed(topValue, yText, 2);
    VCImpexSVGFormatFixed((WWFixedAsDWord)widthSigned, widthText, 2);
    VCImpexSVGFormatFixed((WWFixedAsDWord)heightSigned, heightText, 2);

    if (!VCImpexSVGStyleToAttributes(context, TRUE, filled, context->fillRule, styleAttributes, 256))
        goto cleanup;

    sprintf(buffer, "  <rect x=\"%s\" y=\"%s\" width=\"%s\" height=\"%s\"%s />\n",
            xText, yText, widthText, heightText, styleAttributes);
    success = VCImpexSVGWriteRawString(context, buffer);

cleanup:
    VCImpexSVGFreeBuffer(context, styleChunk);
    VCImpexSVGFreeBuffer(context, heightChunk);
    VCImpexSVGFreeBuffer(context, widthChunk);
    VCImpexSVGFreeBuffer(context, yChunk);
    VCImpexSVGFreeBuffer(context, xChunk);
    VCImpexSVGFreeBuffer(context, bufferChunk);

    if (locked != FALSE)
    {
        MemUnlock(context->bufferHeapH);
    }

    return success;
}

Boolean _pascal VCImpexSVGWriteRoundRectElement(VCImpexSVGExportContext *context, const PointWWFixed *corner1, const PointWWFixed *corner3, const WWFixed *radiusX, const WWFixed *radiusY, Boolean filled)
{
    char *buffer = (void*) 0;
    char *xText = (void*) 0;
    char *yText = (void*) 0;
    char *widthText = (void*) 0;
    char *heightText = (void*) 0;
    char *rxText = (void*) 0;
    char *ryText = (void*) 0;
    char *styleAttributes = (void*) 0;
    ChunkHandle bufferChunk = NullChunk;
    ChunkHandle xChunk = NullChunk;
    ChunkHandle yChunk = NullChunk;
    ChunkHandle widthChunk = NullChunk;
    ChunkHandle heightChunk = NullChunk;
    ChunkHandle rxChunk = NullChunk;
    ChunkHandle ryChunk = NullChunk;
    ChunkHandle styleChunk = NullChunk;
    WWFixedAsDWord leftValue = 0;
    WWFixedAsDWord topValue = 0;
    WWFixedAsDWord rightValue = 0;
    WWFixedAsDWord bottomValue = 0;
    sdword widthSigned = 0;
    sdword heightSigned = 0;
    Boolean success = FALSE;
    Boolean locked = FALSE;

    if ((context == NULL) || (corner1 == NULL) || (corner3 == NULL) || (radiusX == NULL) || (radiusY == NULL) || (context->bufferHeapH == NullHandle))
    {
        return FALSE;
    }

    MemLock(context->bufferHeapH);
    locked = TRUE;

    bufferChunk = VCImpexSVGAllocBuffer(context, 600);
    if (bufferChunk == NullChunk) goto cleanup;

    xChunk = VCImpexSVGAllocBuffer(context, 40);
    if (xChunk == NullChunk) goto cleanup;
    yChunk = VCImpexSVGAllocBuffer(context, 40);
    if (yChunk == NullChunk) goto cleanup;
    widthChunk = VCImpexSVGAllocBuffer(context, 40);
    if (widthChunk == NullChunk) goto cleanup;
    heightChunk = VCImpexSVGAllocBuffer(context, 40);
    if (heightChunk == NullChunk) goto cleanup;
    rxChunk = VCImpexSVGAllocBuffer(context, 40);
    if (rxChunk == NullChunk) goto cleanup;
    ryChunk = VCImpexSVGAllocBuffer(context, 40);
    if (ryChunk == NullChunk) goto cleanup;
    styleChunk = VCImpexSVGAllocBuffer(context, 256);
    if (styleChunk == NullChunk) goto cleanup;

    buffer = LMemDerefHandles(context->bufferHeapH, bufferChunk);
    xText = LMemDerefHandles(context->bufferHeapH, xChunk);
    yText = LMemDerefHandles(context->bufferHeapH, yChunk);
    widthText = LMemDerefHandles(context->bufferHeapH, widthChunk);
    heightText = LMemDerefHandles(context->bufferHeapH, heightChunk);
    rxText = LMemDerefHandles(context->bufferHeapH, rxChunk);
    ryText = LMemDerefHandles(context->bufferHeapH, ryChunk);
    styleAttributes = LMemDerefHandles(context->bufferHeapH, styleChunk);

    leftValue = VCImpexSVGPackWWFixed(&corner1->PF_x);
    topValue = VCImpexSVGPackWWFixed(&corner1->PF_y);
    rightValue = VCImpexSVGPackWWFixed(&corner3->PF_x);
    bottomValue = VCImpexSVGPackWWFixed(&corner3->PF_y);

    widthSigned = (sdword)rightValue - (sdword)leftValue;
    heightSigned = (sdword)bottomValue - (sdword)topValue;
    if (widthSigned < 0)
    {
        leftValue = rightValue;
        widthSigned = -widthSigned;
    }
    if (heightSigned < 0)
    {
        topValue = bottomValue;
        heightSigned = -heightSigned;
    }

    VCImpexSVGFormatFixed(leftValue, xText, 2);
    VCImpexSVGFormatFixed(topValue, yText, 2);
    VCImpexSVGFormatFixed((WWFixedAsDWord)widthSigned, widthText, 2);
    VCImpexSVGFormatFixed((WWFixedAsDWord)heightSigned, heightText, 2);
    VCImpexSVGFormatFixed(VCImpexSVGPackWWFixed(radiusX), rxText, 2);
    VCImpexSVGFormatFixed(VCImpexSVGPackWWFixed(radiusY), ryText, 2);

    if (!VCImpexSVGStyleToAttributes(context, TRUE, filled, context->fillRule, styleAttributes, 256))
        goto cleanup;

    sprintf(buffer, "  <rect x=\"%s\" y=\"%s\" width=\"%s\" height=\"%s\" rx=\"%s\" ry=\"%s\"%s />\n",
            xText, yText, widthText, heightText, rxText, ryText, styleAttributes);
    success = VCImpexSVGWriteRawString(context, buffer);

cleanup:
    VCImpexSVGFreeBuffer(context, styleChunk);
    VCImpexSVGFreeBuffer(context, ryChunk);
    VCImpexSVGFreeBuffer(context, rxChunk);
    VCImpexSVGFreeBuffer(context, heightChunk);
    VCImpexSVGFreeBuffer(context, widthChunk);
    VCImpexSVGFreeBuffer(context, yChunk);
    VCImpexSVGFreeBuffer(context, xChunk);
    VCImpexSVGFreeBuffer(context, bufferChunk);

    if (locked != FALSE)
    {
        MemUnlock(context->bufferHeapH);
    }

    return success;
}

Boolean _pascal VCImpexSVGWriteCubicPathElement(VCImpexSVGExportContext *context,
                                                const PointWWFixed *start,
                                                const PointWWFixed *cp1,
                                                const PointWWFixed *cp2,
                                                const PointWWFixed *end)
{
    char *buffer = (void*) 0;
    char *xText = (void*) 0;
    char *yText = (void*) 0;
    char *cx1Text = (void*) 0;
    char *cy1Text = (void*) 0;
    char *cx2Text = (void*) 0;
    char *cy2Text = (void*) 0;
    char *exText = (void*) 0;
    char *eyText = (void*) 0;
    char *styleAttributes = (void*) 0;
    ChunkHandle bufferChunk = NullChunk;
    ChunkHandle xChunk = NullChunk;
    ChunkHandle yChunk = NullChunk;
    ChunkHandle cx1Chunk = NullChunk;
    ChunkHandle cy1Chunk = NullChunk;
    ChunkHandle cx2Chunk = NullChunk;
    ChunkHandle cy2Chunk = NullChunk;
    ChunkHandle exChunk = NullChunk;
    ChunkHandle eyChunk = NullChunk;
    ChunkHandle styleChunk = NullChunk;
    Boolean success = FALSE;
    Boolean locked = FALSE;

    if ((context == NULL) || (start == NULL) || (cp1 == NULL) || (cp2 == NULL) || (end == NULL) || (context->bufferHeapH == NullHandle))
    {
        return FALSE;
    }

    MemLock(context->bufferHeapH);
    locked = TRUE;

    bufferChunk = VCImpexSVGAllocBuffer(context, 512);
    if (bufferChunk == NullChunk) goto cleanup;

    xChunk = VCImpexSVGAllocBuffer(context, 32); if (xChunk == NullChunk) goto cleanup;
    yChunk = VCImpexSVGAllocBuffer(context, 32); if (yChunk == NullChunk) goto cleanup;
    cx1Chunk = VCImpexSVGAllocBuffer(context, 32); if (cx1Chunk == NullChunk) goto cleanup;
    cy1Chunk = VCImpexSVGAllocBuffer(context, 32); if (cy1Chunk == NullChunk) goto cleanup;
    cx2Chunk = VCImpexSVGAllocBuffer(context, 32); if (cx2Chunk == NullChunk) goto cleanup;
    cy2Chunk = VCImpexSVGAllocBuffer(context, 32); if (cy2Chunk == NullChunk) goto cleanup;
    exChunk = VCImpexSVGAllocBuffer(context, 32); if (exChunk == NullChunk) goto cleanup;
    eyChunk = VCImpexSVGAllocBuffer(context, 32); if (eyChunk == NullChunk) goto cleanup;
    styleChunk = VCImpexSVGAllocBuffer(context, 256); if (styleChunk == NullChunk) goto cleanup;

    buffer = LMemDerefHandles(context->bufferHeapH, bufferChunk);
    xText = LMemDerefHandles(context->bufferHeapH, xChunk);
    yText = LMemDerefHandles(context->bufferHeapH, yChunk);
    cx1Text = LMemDerefHandles(context->bufferHeapH, cx1Chunk);
    cy1Text = LMemDerefHandles(context->bufferHeapH, cy1Chunk);
    cx2Text = LMemDerefHandles(context->bufferHeapH, cx2Chunk);
    cy2Text = LMemDerefHandles(context->bufferHeapH, cy2Chunk);
    exText = LMemDerefHandles(context->bufferHeapH, exChunk);
    eyText = LMemDerefHandles(context->bufferHeapH, eyChunk);
    styleAttributes = LMemDerefHandles(context->bufferHeapH, styleChunk);

    VCImpexSVGFormatFixed(VCImpexSVGPackWWFixed(&start->PF_x), xText, 2);
    VCImpexSVGFormatFixed(VCImpexSVGPackWWFixed(&start->PF_y), yText, 2);
    VCImpexSVGFormatFixed(VCImpexSVGPackWWFixed(&cp1->PF_x), cx1Text, 2);
    VCImpexSVGFormatFixed(VCImpexSVGPackWWFixed(&cp1->PF_y), cy1Text, 2);
    VCImpexSVGFormatFixed(VCImpexSVGPackWWFixed(&cp2->PF_x), cx2Text, 2);
    VCImpexSVGFormatFixed(VCImpexSVGPackWWFixed(&cp2->PF_y), cy2Text, 2);
    VCImpexSVGFormatFixed(VCImpexSVGPackWWFixed(&end->PF_x), exText, 2);
    VCImpexSVGFormatFixed(VCImpexSVGPackWWFixed(&end->PF_y), eyText, 2);

    if (!VCImpexSVGStyleToAttributes(context, TRUE, FALSE, context->fillRule, styleAttributes, 256))
        goto cleanup;

    sprintf(buffer, "  <path d=\"M %s %s C %s %s %s %s %s %s\"%s />\n",
            xText, yText, cx1Text, cy1Text, cx2Text, cy2Text, exText, eyText, styleAttributes);
    success = VCImpexSVGWriteRawString(context, buffer);

cleanup:
    VCImpexSVGFreeBuffer(context, styleChunk);
    VCImpexSVGFreeBuffer(context, eyChunk);
    VCImpexSVGFreeBuffer(context, exChunk);
    VCImpexSVGFreeBuffer(context, cy2Chunk);
    VCImpexSVGFreeBuffer(context, cx2Chunk);
    VCImpexSVGFreeBuffer(context, cy1Chunk);
    VCImpexSVGFreeBuffer(context, cx1Chunk);
    VCImpexSVGFreeBuffer(context, yChunk);
    VCImpexSVGFreeBuffer(context, xChunk);
    VCImpexSVGFreeBuffer(context, bufferChunk);

    if (locked != FALSE)
    {
        MemUnlock(context->bufferHeapH);
    }

    return success;
}



/* Helper to format transform matrix string from TransMatrix */
static void VCImpexSVGFormatMatrix(const TransMatrix *tm, char *out, word outSize)
{
    if ((tm == NULL) || (out == NULL) || (outSize == 0))
        return;
    if (outSize < 80)
    {
        out[0] = '\0';
        return;
    }
    {
        char a[40], b[40], c[40], d[40], e[40], f[40];
        a[0]=b[0]=c[0]=d[0]=e[0]=f[0]='\0';
        VCImpexSVGFormatFixed(VCImpexSVGPackWWFixed(&tm->TM_e11), a, 6);
        VCImpexSVGFormatFixed(VCImpexSVGPackWWFixed(&tm->TM_e12), b, 6);
        VCImpexSVGFormatFixed(VCImpexSVGPackWWFixed(&tm->TM_e21), c, 6);
        VCImpexSVGFormatFixed(VCImpexSVGPackWWFixed(&tm->TM_e22), d, 6);
        VCImpexSVGFormatDWFixed(&tm->TM_e31, e, 2);
        VCImpexSVGFormatDWFixed(&tm->TM_e32, f, 2);
        sprintf(out, " transform=\"matrix(%s %s %s %s %s %s)\"", a, b, c, d, e, f);
    }
}

Boolean _pascal VCImpexSVGWriteArcElement(VCImpexSVGExportContext *context,
                                          WWFixedAsDWord cx,
                                          WWFixedAsDWord cy,
                                          WWFixedAsDWord rx,
                                          WWFixedAsDWord ry,
                                          word startAngleDeg,
                                          word endAngleDeg,
                                          ArcCloseType closeType,
                                          Boolean filled,
                                          const TransMatrix *tm)
{
    char *buffer = (void*) 0;
    char *sxText = (void*) 0;
    char *syText = (void*) 0;
    char *exText = (void*) 0;
    char *eyText = (void*) 0;
    char *rxText = (void*) 0;
    char *ryText = (void*) 0;
    char *styleAttributes = (void*) 0;
    char *matrixText = (void*) 0;
    char centerXText[40];
    char centerYText[40];
    ChunkHandle bufferChunk = NullChunk;
    ChunkHandle sxChunk = NullChunk;
    ChunkHandle syChunk = NullChunk;
    ChunkHandle exChunk = NullChunk;
    ChunkHandle eyChunk = NullChunk;
    ChunkHandle rxChunk = NullChunk;
    ChunkHandle ryChunk = NullChunk;
    ChunkHandle styleChunk = NullChunk;
    ChunkHandle matrixChunk = NullChunk;
    Boolean success = FALSE;
    Boolean locked = FALSE;
    WWFixedAsDWord a1 = 0, a2 = 0;
    WWFixedAsDWord c1 = 0, s1 = 0, c2 = 0, s2 = 0;
    WWFixedAsDWord sx = 0, sy = 0, ex = 0, ey = 0;
    word largeArcFlag = 0;
    word sweepFlag = 0;

    if ((context == NULL) || (context->bufferHeapH == NullHandle))
        return FALSE;

    a1 = (WWFixedAsDWord)((sdword)startAngleDeg << 16);
    a2 = (WWFixedAsDWord)((sdword)endAngleDeg << 16);

    /* Use GEOS fixed-point trig to avoid libm */
    c1 = GrQuickCosine(a1);
    s1 = GrQuickSine(a1);
    c2 = GrQuickCosine(a2);
    s2 = GrQuickSine(a2);

    /* Compute local start/end points in 16.16: center + radius * cos/sin */
    sx = cx + GrMulWWFixed(rx, c1);
    sy = cy + GrMulWWFixed(ry, s1);
    ex = cx + GrMulWWFixed(rx, c2);
    ey = cy + GrMulWWFixed(ry, s2);

    /* Large-arc and sweep flags */
    {
        sdword diff = (sdword)endAngleDeg - (sdword)startAngleDeg;
        while (diff < 0) diff += 360;
        while (diff >= 360) diff -= 360;
        largeArcFlag = (diff > 180) ? 1 : 0;
        /* GEOS increases angles counterclockwise; SVG sweep-flag=1 is increasing angle */
        sweepFlag = 1;
    }

    MemLock(context->bufferHeapH);
    locked = TRUE;

    bufferChunk = VCImpexSVGAllocBuffer(context, 640);
    if (bufferChunk == NullChunk) goto cleanup;
    sxChunk = VCImpexSVGAllocBuffer(context, 40); if (sxChunk == NullChunk) goto cleanup;
    syChunk = VCImpexSVGAllocBuffer(context, 40); if (syChunk == NullChunk) goto cleanup;
    exChunk = VCImpexSVGAllocBuffer(context, 40); if (exChunk == NullChunk) goto cleanup;
    eyChunk = VCImpexSVGAllocBuffer(context, 40); if (eyChunk == NullChunk) goto cleanup;
    rxChunk = VCImpexSVGAllocBuffer(context, 40); if (rxChunk == NullChunk) goto cleanup;
    ryChunk = VCImpexSVGAllocBuffer(context, 40); if (ryChunk == NullChunk) goto cleanup;
    styleChunk = VCImpexSVGAllocBuffer(context, 256); if (styleChunk == NullChunk) goto cleanup;
    matrixChunk = VCImpexSVGAllocBuffer(context, 160); if (matrixChunk == NullChunk) goto cleanup;

    buffer = LMemDerefHandles(context->bufferHeapH, bufferChunk);
    sxText = LMemDerefHandles(context->bufferHeapH, sxChunk);
    syText = LMemDerefHandles(context->bufferHeapH, syChunk);
    exText = LMemDerefHandles(context->bufferHeapH, exChunk);
    eyText = LMemDerefHandles(context->bufferHeapH, eyChunk);
    rxText = LMemDerefHandles(context->bufferHeapH, rxChunk);
    ryText = LMemDerefHandles(context->bufferHeapH, ryChunk);
    styleAttributes = LMemDerefHandles(context->bufferHeapH, styleChunk);
    matrixText = LMemDerefHandles(context->bufferHeapH, matrixChunk);

    VCImpexSVGFormatFixed(sx, sxText, 2);
    VCImpexSVGFormatFixed(sy, syText, 2);
    VCImpexSVGFormatFixed(ex, exText, 2);
    VCImpexSVGFormatFixed(ey, eyText, 2);
    VCImpexSVGFormatFixed(rx, rxText, 2);
    VCImpexSVGFormatFixed(ry, ryText, 2);
    if (!VCImpexSVGStyleToAttributes(context, TRUE, filled, context->fillRule, styleAttributes, 256))
        goto cleanup;

    centerXText[0] = '\0';
    centerYText[0] = '\0';
    VCImpexSVGFormatFixed(cx, centerXText, 2);
    VCImpexSVGFormatFixed(cy, centerYText, 2);

    matrixText[0] = '\0';
    if (tm != NULL)
        VCImpexSVGFormatMatrix(tm, matrixText, 160);

    if (filled != FALSE)
    {
        if (closeType == ACT_PIE)
        {
            sprintf(buffer, "  <path d=\"M %s %s L %s %s A %s %s 0 %u %u %s %s Z\"%s%s />\n",
                    centerXText, centerYText,
                    sxText, syText, rxText, ryText,
                    (unsigned)largeArcFlag, (unsigned)sweepFlag,
                    exText, eyText, styleAttributes, matrixText);
        }
        else /* ACT_CHORD or ACT_OPEN treated as chord when filled */
        {
            sprintf(buffer, "  <path d=\"M %s %s A %s %s 0 %u %u %s %s Z\"%s%s />\n",
                    sxText, syText, rxText, ryText,
                    (unsigned)largeArcFlag, (unsigned)sweepFlag,
                    exText, eyText, styleAttributes, matrixText);
        }
    }
    else
    {
        sprintf(buffer, "  <path d=\"M %s %s A %s %s 0 %u %u %s %s\"%s%s />\n",
                sxText, syText, rxText, ryText,
                (unsigned)largeArcFlag, (unsigned)sweepFlag,
                exText, eyText, styleAttributes, matrixText);
    }

    success = VCImpexSVGWriteRawString(context, buffer);

cleanup:
    VCImpexSVGFreeBuffer(context, matrixChunk);
    VCImpexSVGFreeBuffer(context, styleChunk);
    VCImpexSVGFreeBuffer(context, ryChunk);
    VCImpexSVGFreeBuffer(context, rxChunk);
    VCImpexSVGFreeBuffer(context, eyChunk);
    VCImpexSVGFreeBuffer(context, exChunk);
    VCImpexSVGFreeBuffer(context, syChunk);
    VCImpexSVGFreeBuffer(context, sxChunk);
    VCImpexSVGFreeBuffer(context, bufferChunk);

    if (locked != FALSE)
        MemUnlock(context->bufferHeapH);

    return success;
}

Boolean _pascal VCImpexSVGWriteEllipseElement(VCImpexSVGExportContext *context,
                                              const WWFixed *cx,
                                              const WWFixed *cy,
                                              const WWFixed *rx,
                                              const WWFixed *ry,
                                              Boolean filled,
                                              const TransMatrix *tm)
{
    char *buffer = (void*) 0;
    char *cxText = (void*) 0;
    char *cyText = (void*) 0;
    char *rxText = (void*) 0;
    char *ryText = (void*) 0;
    char *styleAttributes = (void*) 0;
    char *matrixText = (void*) 0;
    ChunkHandle bufferChunk = NullChunk;
    ChunkHandle cxChunk = NullChunk;
    ChunkHandle cyChunk = NullChunk;
    ChunkHandle rxChunk = NullChunk;
    ChunkHandle ryChunk = NullChunk;
    ChunkHandle styleChunk = NullChunk;
    ChunkHandle matrixChunk = NullChunk;
    Boolean success = FALSE;
    Boolean locked = FALSE;

    if ((context == NULL) || (cx == NULL) || (cy == NULL) || (rx == NULL) || (ry == NULL) || (context->bufferHeapH == NullHandle))
    {
        return FALSE;
    }

    MemLock(context->bufferHeapH);
    locked = TRUE;

    bufferChunk = VCImpexSVGAllocBuffer(context, 512);
    if (bufferChunk == NullChunk) goto cleanup;

    cxChunk = VCImpexSVGAllocBuffer(context, 40);
    if (cxChunk == NullChunk) goto cleanup;
    cyChunk = VCImpexSVGAllocBuffer(context, 40);
    if (cyChunk == NullChunk) goto cleanup;
    rxChunk = VCImpexSVGAllocBuffer(context, 40);
    if (rxChunk == NullChunk) goto cleanup;
    ryChunk = VCImpexSVGAllocBuffer(context, 40);
    if (ryChunk == NullChunk) goto cleanup;

    styleChunk = VCImpexSVGAllocBuffer(context, 256);
    if (styleChunk == NullChunk) goto cleanup;

    matrixChunk = VCImpexSVGAllocBuffer(context, 160);
    if (matrixChunk == NullChunk) goto cleanup;

    buffer = LMemDerefHandles(context->bufferHeapH, bufferChunk);
    cxText = LMemDerefHandles(context->bufferHeapH, cxChunk);
    cyText = LMemDerefHandles(context->bufferHeapH, cyChunk);
    rxText = LMemDerefHandles(context->bufferHeapH, rxChunk);
    ryText = LMemDerefHandles(context->bufferHeapH, ryChunk);
    styleAttributes = LMemDerefHandles(context->bufferHeapH, styleChunk);
    matrixText = LMemDerefHandles(context->bufferHeapH, matrixChunk);

    VCImpexSVGFormatFixed(VCImpexSVGPackWWFixed(cx), cxText, 2);
    VCImpexSVGFormatFixed(VCImpexSVGPackWWFixed(cy), cyText, 2);
    VCImpexSVGFormatFixed(VCImpexSVGPackWWFixed(rx), rxText, 2);
    VCImpexSVGFormatFixed(VCImpexSVGPackWWFixed(ry), ryText, 2);
    if (!VCImpexSVGStyleToAttributes(context, TRUE, filled, context->fillRule, styleAttributes, 256))
        goto cleanup;

    matrixText[0] = '\0';
    if (tm != NULL)
    {
        char a[40], b[40], c[40], d[40], e[40], f[40];
        a[0]=b[0]=c[0]=d[0]=e[0]=f[0]='\0';
        VCImpexSVGFormatFixed(VCImpexSVGPackWWFixed(&tm->TM_e11), a, 6);
        VCImpexSVGFormatFixed(VCImpexSVGPackWWFixed(&tm->TM_e12), b, 6);
        VCImpexSVGFormatFixed(VCImpexSVGPackWWFixed(&tm->TM_e21), c, 6);
        VCImpexSVGFormatFixed(VCImpexSVGPackWWFixed(&tm->TM_e22), d, 6);
        VCImpexSVGFormatDWFixed(&tm->TM_e31, e, 2);
        VCImpexSVGFormatDWFixed(&tm->TM_e32, f, 2);
        sprintf(matrixText, " transform=\"matrix(%s %s %s %s %s %s)\"", a, b, c, d, e, f);
    }

    sprintf(buffer, "  <ellipse cx=\"%s\" cy=\"%s\" rx=\"%s\" ry=\"%s\"%s%s />\n",
            cxText, cyText, rxText, ryText, styleAttributes, matrixText);
    success = VCImpexSVGWriteRawString(context, buffer);

cleanup:
    VCImpexSVGFreeBuffer(context, matrixChunk);
    VCImpexSVGFreeBuffer(context, styleChunk);
    VCImpexSVGFreeBuffer(context, ryChunk);
    VCImpexSVGFreeBuffer(context, rxChunk);
    VCImpexSVGFreeBuffer(context, cyChunk);
    VCImpexSVGFreeBuffer(context, cxChunk);
    VCImpexSVGFreeBuffer(context, bufferChunk);

    if (locked != FALSE)
    {
        MemUnlock(context->bufferHeapH);
    }

    return success;
}

void _pascal VCImpexSVGInitPendingRect(VCImpexSVGPendingRect *pending)
{
    if (pending == NULL) return;
    pending->active = FALSE;
    pending->haveStroke = FALSE;
    pending->haveFill = FALSE;
    pending->strokeWidth = 0;
    pending->strokeColor = 0;
    pending->fillColor = 0;
    pending->strokeJoin = LJ_MITERED;
    pending->strokeCap = LE_BUTTCAP;
    pending->strokeMiterLimit = 0;
    pending->strokeStyle = LS_SOLID;
    pending->strokeDashPairCount = 0;
    pending->strokeDashSkipCount = 0;
    memset(pending->strokeDashPattern, 0, sizeof(pending->strokeDashPattern));
    pending->fillRule = WINDING;
    pending->corner1.PF_x.WWF_int = 0; pending->corner1.PF_x.WWF_frac = 0;
    pending->corner1.PF_y.WWF_int = 0; pending->corner1.PF_y.WWF_frac = 0;
    pending->corner3.PF_x.WWF_int = 0; pending->corner3.PF_x.WWF_frac = 0;
    pending->corner3.PF_y.WWF_int = 0; pending->corner3.PF_y.WWF_frac = 0;
}

Boolean _pascal VCImpexSVGFlushPendingRect(VCImpexSVGExportContext *context, VCImpexSVGPendingRect *pending)
{
    Boolean ok = TRUE;
    WWFixedAsDWord savedWidth;
    RGBColorAsDWord savedLine;
    RGBColorAsDWord savedFill;
    LineJoin savedJoin;
    LineEnd savedCap;
    WWFixedAsDWord savedMiter;
    LineStyle savedStyle;
    word savedDashPairCount;
    word savedDashSkipCount;
    word savedDashPattern[MAX_DASH_ARRAY_PAIRS * 2];
    RegionFillRule savedFillRule;

    if ((context == NULL) || (pending == NULL))
        return FALSE;

    if (pending->active == FALSE)
        return TRUE;

    /* Save */
    savedWidth = context->lineWidth;
    savedLine = context->lineColor;
    savedFill = context->fillColor;
    savedJoin = context->lineJoin;
    savedCap = context->lineCap;
    savedMiter = context->miterLimit;
    savedStyle = context->lineStyle;
    savedDashPairCount = context->dashPairCount;
    savedDashSkipCount = context->dashSkipCount;
    memcpy(savedDashPattern, context->dashPattern, sizeof(savedDashPattern));
    savedFillRule = context->fillRule;

    /* Apply pending styles */
    context->lineWidth = pending->haveStroke ? pending->strokeWidth : 0;
    context->lineColor = pending->strokeColor;
    context->fillColor = pending->fillColor;
    context->lineJoin = pending->strokeJoin;
    context->lineCap = pending->strokeCap;
    context->miterLimit = pending->strokeMiterLimit;
    context->lineStyle = pending->strokeStyle;
    context->dashPairCount = pending->strokeDashPairCount;
    context->dashSkipCount = pending->strokeDashSkipCount;
    memcpy(context->dashPattern, pending->strokeDashPattern, sizeof(context->dashPattern));
    context->fillRule = pending->fillRule;

    ok = VCImpexSVGWriteRectElement(context, &pending->corner1, &pending->corner3, pending->haveFill);

    /* Restore and clear */
    context->lineWidth = savedWidth;
    context->lineColor = savedLine;
    context->fillColor = savedFill;
    context->lineJoin = savedJoin;
    context->lineCap = savedCap;
    context->miterLimit = savedMiter;
    context->lineStyle = savedStyle;
    context->dashPairCount = savedDashPairCount;
    context->dashSkipCount = savedDashSkipCount;
    memcpy(context->dashPattern, savedDashPattern, sizeof(savedDashPattern));
    context->fillRule = savedFillRule;

    pending->active = FALSE;
    pending->haveStroke = FALSE;
    pending->haveFill = FALSE;
    pending->strokeDashSkipCount = 0;
    return ok;
}

Boolean _pascal VCImpexSVGWritePolygonElement(VCImpexSVGExportContext *context,
                                             const PointWWFixed *points,
                                             word pointCount,
                                             Boolean closeShape,
                                             Boolean filled,
                                             RegionFillRule fillRule)
{
    char elementName[10] = {0};
    char *prefix = (void*) 0;
    char *xText = (void*) 0;
    char *yText = (void*) 0;
    char *coordinateText = (void*) 0;
    char *styleAttributes = (void*) 0;
    ChunkHandle prefixChunk = NullChunk;
    ChunkHandle xChunk = NullChunk;
    ChunkHandle yChunk = NullChunk;
    ChunkHandle coordinateChunk = NullChunk;
    ChunkHandle styleChunk = NullChunk;
    word index = 0;
    Boolean success = FALSE;
    Boolean locked = FALSE;

    if ((context == NULL) || (points == NULL) || (pointCount == 0) || (context->bufferHeapH == NullHandle))
    {
        return FALSE;
    }

    if (closeShape != FALSE)
    {
        strcpy(elementName, "polygon");
    }
    else
    {
        strcpy(elementName, "polyline");
    }

    MemLock(context->bufferHeapH);
    locked = TRUE;

    prefixChunk = VCImpexSVGAllocBuffer(context, 24);
    if (prefixChunk == NullChunk) goto cleanup;

    xChunk = VCImpexSVGAllocBuffer(context, 24);
    if (xChunk == NullChunk) goto cleanup;

    yChunk = VCImpexSVGAllocBuffer(context, 24);
    if (yChunk == NullChunk) goto cleanup;

    coordinateChunk = VCImpexSVGAllocBuffer(context, 64);
    if (coordinateChunk == NullChunk) goto cleanup;

    styleChunk = VCImpexSVGAllocBuffer(context, 256);
    if (styleChunk == NullChunk) goto cleanup;

    prefix = LMemDerefHandles(context->bufferHeapH, prefixChunk);
    xText = LMemDerefHandles(context->bufferHeapH, xChunk);
    yText = LMemDerefHandles(context->bufferHeapH, yChunk);
    coordinateText = LMemDerefHandles(context->bufferHeapH, coordinateChunk);
    styleAttributes = LMemDerefHandles(context->bufferHeapH, styleChunk);

    if (!VCImpexSVGStyleToAttributes(context, TRUE, filled, fillRule, styleAttributes, 256))
        goto cleanup;

    sprintf(prefix, "  <%s points=\"", elementName);
    if (!VCImpexSVGWriteRawString(context, prefix))
    {
        goto cleanup;
    }

    for (index = 0; index < pointCount; index++)
    {
        VCImpexSVGFormatFixed(VCImpexSVGPackWWFixed(&points[index].PF_x), xText, 2);
        VCImpexSVGFormatFixed(VCImpexSVGPackWWFixed(&points[index].PF_y), yText, 2);

        sprintf(coordinateText, "%s,%s ", xText, yText);
        if (!VCImpexSVGWriteRawString(context, coordinateText))
        {
            goto cleanup;
        }
    }

    sprintf(coordinateText, "\"%s />\n", styleAttributes);
    success = VCImpexSVGWriteRawString(context, coordinateText);

cleanup:
    VCImpexSVGFreeBuffer(context, styleChunk);
    VCImpexSVGFreeBuffer(context, coordinateChunk);
    VCImpexSVGFreeBuffer(context, yChunk);
    VCImpexSVGFreeBuffer(context, xChunk);
    VCImpexSVGFreeBuffer(context, prefixChunk);

    if (locked != FALSE)
    {
        MemUnlock(context->bufferHeapH);
    }

    return success;
}


WWFixedAsDWord _pascal VCImpexSVGPackWWFixed(const WWFixed *value)
{
    WWFixedAsDWord result = {0};
    sdword integerPart = 0;

    if (value == NULL) return 0;

    integerPart = (sdword)((sword)value->WWF_int);
    result = (WWFixedAsDWord)(integerPart << 16);
    result |= value->WWF_frac;

    return result;
}

void _pascal VCImpexSVGTransformPointFromInt(GStateHandle gstate, const Point *sourcePoint, PointWWFixed *targetPoint)
{
    XYValueAsDWord transformedValue = {0};

    transformedValue = GrTransform(gstate, sourcePoint->P_x, sourcePoint->P_y);
    targetPoint->PF_x.WWF_int = DWORD_X(transformedValue);
    targetPoint->PF_y.WWF_int = DWORD_Y(transformedValue);
    targetPoint->PF_x.WWF_frac = 0;
    targetPoint->PF_y.WWF_frac = 0;
}

void _pascal VCImpexSVGTransformPointFromFixed(GStateHandle gstate, const PointWWFixed *sourcePoint, PointWWFixed *targetPoint)
{
    GrTransformWWFixed(gstate, VCImpexSVGPackWWFixed(&sourcePoint->PF_x), VCImpexSVGPackWWFixed(&sourcePoint->PF_y), targetPoint);
}

void _pascal VCImpexSVGTransformRelativePoint(GStateHandle gstate, const PointWWFixed *deltaPoint, PointWWFixed *targetPoint)
{
    PointWWFixed currentPoint = {0};
    WWFixedAsDWord xValue = {0};
    WWFixedAsDWord yValue = {0};

    GrGetCurPosWWFixed(gstate, &currentPoint);
    xValue = VCImpexSVGPackWWFixed(&currentPoint.PF_x) + VCImpexSVGPackWWFixed(&deltaPoint->PF_x);
    yValue = VCImpexSVGPackWWFixed(&currentPoint.PF_y) + VCImpexSVGPackWWFixed(&deltaPoint->PF_y);
    GrTransformWWFixed(gstate, xValue, yValue, targetPoint);
}

void _pascal VCImpexSVGCopyPointWWFixed(PointWWFixed *destination, const PointWWFixed *source)
{
    destination->PF_x.WWF_int = source->PF_x.WWF_int;
    destination->PF_x.WWF_frac = source->PF_x.WWF_frac;
    destination->PF_y.WWF_int = source->PF_y.WWF_int;
    destination->PF_y.WWF_frac = source->PF_y.WWF_frac;
}
