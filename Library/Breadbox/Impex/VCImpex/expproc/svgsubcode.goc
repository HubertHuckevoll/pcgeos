/***********************************************************************
 *
 * PROJECT:       VCImpex SVG Exporter
 * FILE:          svgsubcode.goc
 *
 * DESCRIPTION:   Helper functions for writing SVG data
 *
 ***********************************************************************/

#include "svgexp.h"

static void VCImpexSVGCopyLiteral(char *destination, const char *source)
{
    char currentChar;

    if ((destination == NULL) || (source == NULL))
    {
        return;
    }

    do
    {
        currentChar = *source;
        *destination = currentChar;
        destination++;
        source++;
    } while (currentChar != '\0');
}

static word VCImpexSVGStringLength(const char *text)
{
    const char *scan;
    word length;

    if (text == NULL)
    {
        return 0;
    }

    scan = text;
    while (*scan != '\0')
    {
        scan++;
    }

    length = (word)(scan - text);
    return length;
}

static void VCImpexSVGFormatColor(RGBColorAsDWord colorValue, char *buffer)
{
    word redComponent = 0;
    word greenComponent = 0;
    word blueComponent = 0;

    redComponent = RGB_RED(colorValue);
    greenComponent = RGB_GREEN(colorValue);
    blueComponent = RGB_BLUE(colorValue);
    sprintf(buffer, "#%02X%02X%02X", (unsigned int)redComponent, (unsigned int)greenComponent, (unsigned int)blueComponent);
}

static void VCImpexSVGFormatFixed(WWFixedAsDWord value, char *buffer, word fractionDigits)
{
    LocalFixedToAscii(buffer, value, fractionDigits);
}

Boolean _pascal VCImpexSVGWriteRawString(VCImpexSVGExportContext *context, const char *text)
{
    word length = 0;

    if ((context == NULL) || (text == NULL))
    {
        return FALSE;
    }

    if (context->svgFile == NullHandle)
    {
        return FALSE;
    }

    length = VCImpexSVGStringLength(text);
    if (length == 0)
    {
        return TRUE;
    }

    if (FileWrite(context->svgFile, text, length, FALSE) != length)
    {
        return FALSE;
    }
    return TRUE;
}

Boolean _pascal VCImpexSVGWriteHeader(VCImpexSVGExportContext *context)
{
    char buffer[160] = {0};
    dword width = 0;
    dword height = 0;
    char widthText[20] = {0};
    char heightText[20] = {0};

    if (context == NULL)
    {
        return FALSE;
    }

    width = 0;
    height = 0;
    if (context->bounds.RD_right > context->bounds.RD_left)
    {
        width = context->bounds.RD_right - context->bounds.RD_left;
    }
    if (context->bounds.RD_bottom > context->bounds.RD_top)
    {
        height = context->bounds.RD_bottom - context->bounds.RD_top;
    }

    sprintf(buffer, "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");
    if (!VCImpexSVGWriteRawString(context, buffer))
    {
        return FALSE;
    }

    sprintf(buffer, "<svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\"\n");
    if (!VCImpexSVGWriteRawString(context, buffer))
    {
        return FALSE;
    }

    sprintf(widthText, "%lu", (unsigned long)width);
    sprintf(heightText, "%lu", (unsigned long)height);
    sprintf(buffer, "     width=\"%s\" height=\"%s\" viewBox=\"%ld %ld %lu %lu\">\n", widthText, heightText,
            (long)context->bounds.RD_left, (long)context->bounds.RD_top, (unsigned long)width, (unsigned long)height);
    if (!VCImpexSVGWriteRawString(context, buffer))
    {
        return FALSE;
    }
    return TRUE;
}

Boolean _pascal VCImpexSVGWriteFooter(VCImpexSVGExportContext *context)
{
    if (context == NULL)
    {
        return FALSE;
    }
    return VCImpexSVGWriteRawString(context, "</svg>\n");
}

Boolean _pascal VCImpexSVGUpdateDrawingState(GStateHandle gstate, VCImpexSVGExportContext *context)
{
    if (context == NULL)
    {
        return FALSE;
    }

    context->lineWidth = GrGetLineWidth(gstate);
    context->lineColor = GrGetLineColor(gstate);
    context->fillColor = GrGetAreaColor(gstate);
    return TRUE;
}

Boolean _pascal VCImpexSVGWriteLineElement(VCImpexSVGExportContext *context, const PointWWFixed *startPoint, const PointWWFixed *endPoint)
{
    char buffer[200] = {0};
    char x1Text[24] = {0};
    char y1Text[24] = {0};
    char x2Text[24] = {0};
    char y2Text[24] = {0};
    char widthText[24] = {0};
    char colorText[10] = {0};

    if ((context == NULL) || (startPoint == NULL) || (endPoint == NULL))
    {
        return FALSE;
    }

    VCImpexSVGFormatFixed(VCImpexSVGPackWWFixed(&startPoint->PF_x), x1Text, 2);
    VCImpexSVGFormatFixed(VCImpexSVGPackWWFixed(&startPoint->PF_y), y1Text, 2);
    VCImpexSVGFormatFixed(VCImpexSVGPackWWFixed(&endPoint->PF_x), x2Text, 2);
    VCImpexSVGFormatFixed(VCImpexSVGPackWWFixed(&endPoint->PF_y), y2Text, 2);
    VCImpexSVGFormatFixed(context->lineWidth, widthText, 2);

    if (context->lineWidth == 0)
    {
        VCImpexSVGCopyLiteral(colorText, "none");
    }
    else
    {
        VCImpexSVGFormatColor(context->lineColor, colorText);
    }

    sprintf(buffer, "  <line x1=\"%s\" y1=\"%s\" x2=\"%s\" y2=\"%s\" stroke=\"%s\" stroke-width=\"%s\" fill=\"none\" />\n",
            x1Text, y1Text, x2Text, y2Text, colorText, widthText);
    return VCImpexSVGWriteRawString(context, buffer);
}

Boolean _pascal VCImpexSVGWriteRectElement(VCImpexSVGExportContext *context, const PointWWFixed *corner1, const PointWWFixed *corner3, Boolean filled)
{
    char buffer[220] = {0};
    char xText[24] = {0};
    char yText[24] = {0};
    char widthText[24] = {0};
    char heightText[24] = {0};
    char strokeWidthText[24] = {0};
    char strokeColor[10] = {0};
    char fillText[10] = {0};
    WWFixedAsDWord leftValue = {0};
    WWFixedAsDWord topValue = {0};
    WWFixedAsDWord rightValue = {0};
    WWFixedAsDWord bottomValue = {0};
    sdword widthSigned = 0;
    sdword heightSigned = 0;

    if ((context == NULL) || (corner1 == NULL) || (corner3 == NULL))
    {
        return FALSE;
    }

    leftValue = VCImpexSVGPackWWFixed(&corner1->PF_x);
    topValue = VCImpexSVGPackWWFixed(&corner1->PF_y);
    rightValue = VCImpexSVGPackWWFixed(&corner3->PF_x);
    bottomValue = VCImpexSVGPackWWFixed(&corner3->PF_y);

    widthSigned = (sdword)rightValue - (sdword)leftValue;
    heightSigned = (sdword)bottomValue - (sdword)topValue;
    if (widthSigned < 0)
    {
        leftValue = rightValue;
        widthSigned = -widthSigned;
    }
    if (heightSigned < 0)
    {
        topValue = bottomValue;
        heightSigned = -heightSigned;
    }

    VCImpexSVGFormatFixed(leftValue, xText, 2);
    VCImpexSVGFormatFixed(topValue, yText, 2);
    VCImpexSVGFormatFixed((WWFixedAsDWord)widthSigned, widthText, 2);
    VCImpexSVGFormatFixed((WWFixedAsDWord)heightSigned, heightText, 2);
    VCImpexSVGFormatFixed(context->lineWidth, strokeWidthText, 2);

    if (context->lineWidth == 0)
    {
        VCImpexSVGCopyLiteral(strokeColor, "none");
    }
    else
    {
        VCImpexSVGFormatColor(context->lineColor, strokeColor);
    }

    if (filled != FALSE)
    {
        VCImpexSVGFormatColor(context->fillColor, fillText);
    }
    else
    {
        VCImpexSVGCopyLiteral(fillText, "none");
    }

    sprintf(buffer, "  <rect x=\"%s\" y=\"%s\" width=\"%s\" height=\"%s\" stroke=\"%s\" fill=\"%s\" stroke-width=\"%s\" />\n",
            xText, yText, widthText, heightText, strokeColor, fillText, strokeWidthText);
    return VCImpexSVGWriteRawString(context, buffer);
}

Boolean _pascal VCImpexSVGWritePolygonElement(VCImpexSVGExportContext *context, const PointWWFixed *points, word pointCount, Boolean closeShape, Boolean filled)
{
    const char *elementName = (void*) 0;
    char prefix[20] = {0};
    char xText[24] = {0};
    char yText[24] = {0};
    char coordinateText[64] = {0};
    char strokeWidthText[24] = {0};
    char strokeColor[10] = {0};
    char fillText[10] = {0};
    word index = 0;

    if ((context == NULL) || (points == NULL) || (pointCount == 0))
    {
        return FALSE;
    }

    if (closeShape != FALSE)
    {
        elementName = "polygon";
    }
    else
    {
        elementName = "polyline";
    }

    if (context->lineWidth == 0)
    {
        VCImpexSVGCopyLiteral(strokeColor, "none");
    }
    else
    {
        VCImpexSVGFormatColor(context->lineColor, strokeColor);
    }
    VCImpexSVGFormatFixed(context->lineWidth, strokeWidthText, 2);

    if (filled != FALSE)
    {
        VCImpexSVGFormatColor(context->fillColor, fillText);
    }
    else
    {
        VCImpexSVGCopyLiteral(fillText, "none");
    }

    sprintf(prefix, "  <%s points=\"", elementName);
    if (!VCImpexSVGWriteRawString(context, prefix))
    {
        return FALSE;
    }

    for (index = 0; index < pointCount; index++)
    {
        VCImpexSVGFormatFixed(VCImpexSVGPackWWFixed(&points[index].PF_x), xText, 2);
        VCImpexSVGFormatFixed(VCImpexSVGPackWWFixed(&points[index].PF_y), yText, 2);
        sprintf(coordinateText, "%s,%s", xText, yText);
        if (!VCImpexSVGWriteRawString(context, coordinateText))
        {
            return FALSE;
        }
        if (index + 1 < pointCount)
        {
            if (!VCImpexSVGWriteRawString(context, " "))
            {
                return FALSE;
            }
        }
    }

    sprintf(coordinateText, "\" stroke=\"%s\" fill=\"%s\" stroke-width=\"%s\" />\n", strokeColor, fillText, strokeWidthText);
    return VCImpexSVGWriteRawString(context, coordinateText);
}

WWFixedAsDWord _pascal VCImpexSVGPackWWFixed(const WWFixed *value)
{
    WWFixedAsDWord result = {0};
    sdword integerPart = 0;

    if (value == NULL)
    {
        return 0;
    }

    integerPart = (sdword)((sword)value->WWF_int);
    result = (WWFixedAsDWord)(integerPart << 16);
    result |= value->WWF_frac;
    return result;
}

void _pascal VCImpexSVGTransformPointFromInt(GStateHandle gstate, const Point *sourcePoint, PointWWFixed *targetPoint)
{
    XYValueAsDWord transformedValue = {0};

    transformedValue = GrTransform(gstate, sourcePoint->P_x, sourcePoint->P_y);
    targetPoint->PF_x.WWF_int = DWORD_X(transformedValue);
    targetPoint->PF_y.WWF_int = DWORD_Y(transformedValue);
    targetPoint->PF_x.WWF_frac = 0;
    targetPoint->PF_y.WWF_frac = 0;
}

void _pascal VCImpexSVGTransformPointFromFixed(GStateHandle gstate, const PointWWFixed *sourcePoint, PointWWFixed *targetPoint)
{
    GrTransformWWFixed(gstate, VCImpexSVGPackWWFixed(&sourcePoint->PF_x), VCImpexSVGPackWWFixed(&sourcePoint->PF_y), targetPoint);
}

void _pascal VCImpexSVGTransformRelativePoint(GStateHandle gstate, const PointWWFixed *deltaPoint, PointWWFixed *targetPoint)
{
    PointWWFixed currentPoint = {0};
    WWFixedAsDWord xValue = {0};
    WWFixedAsDWord yValue = {0};

    GrGetCurPosWWFixed(gstate, &currentPoint);
    xValue = VCImpexSVGPackWWFixed(&currentPoint.PF_x) + VCImpexSVGPackWWFixed(&deltaPoint->PF_x);
    yValue = VCImpexSVGPackWWFixed(&currentPoint.PF_y) + VCImpexSVGPackWWFixed(&deltaPoint->PF_y);
    GrTransformWWFixed(gstate, xValue, yValue, targetPoint);
}

void _pascal VCImpexSVGCopyPointWWFixed(PointWWFixed *destination, const PointWWFixed *source)
{
    destination->PF_x.WWF_int = source->PF_x.WWF_int;
    destination->PF_x.WWF_frac = source->PF_x.WWF_frac;
    destination->PF_y.WWF_int = source->PF_y.WWF_int;
    destination->PF_y.WWF_frac = source->PF_y.WWF_frac;
}
