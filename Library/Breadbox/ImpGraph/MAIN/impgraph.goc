@include <stdapp.goh>
#include <graphics.h>
#include <gstring.h>
#include <initfile.h>
#include <htmldrv.h>
@include <STATBAR/statbar.goh>

#include "IMPBMP/impgif.h"
#include "IMPBMP/impjpeg.h"
#include "IMPBMP/imppng.h"
#include "meta.h" /* Meta SVG renderer */
@include <extgraph.goh>

@include <impex.goh>
#include <Ansi/string.h>


typedef MemHandle ImpGIFHandle ;
extern void _pascal ImpGIFDestroy(ImpGIFHandle mem) ;


/*****************************************************************************
 *  Global variables set by library initalization                            *
 *****************************************************************************/

Boolean initGlobals = FALSE;
Boolean doCompress = TRUE;
Boolean useSysPal = TRUE;
Boolean allowAnimations = TRUE;

void InitGlobals(void)
{
  DisplayClass displayClass ;
  DisplayScheme display ;

  if(!initGlobals)                      // init global variables only once
  {
    initGlobals = TRUE;

    /* if TRUE, we'll compress bitmap */
    InitFileReadBoolean("impgraph", "compress", &doCompress);

    /* Only use the system palette if we are in a video mode that is */
    /* 256 or less. */
    @call application::MSG_GEN_APPLICATION_GET_DISPLAY_SCHEME(&display) ;
    displayClass = (display.DS_displayType & DT_DISP_CLASS) ;

    if (displayClass <= DC_COLOR_8)
        useSysPal = TRUE ;
    else
        useSysPal = FALSE ;

    /* Ini will override */
    InitFileReadBoolean("impgraph", "useSysPalForGIF", &useSysPal);

    #if !PROGRESS_DISPLAY
      /* I don't want to write the data stream support in the assembly
         ImpGIFProcessFile routine, so we don't support no-animations for
         progress display */
      InitFileReadBoolean("impgraph", "allowAnimations", &allowAnimations) ;
    #endif
  }
}


/*****************************************************************************
 *  GIF import - main routine                                                *
 *****************************************************************************/

#if PROGRESS_DISPLAY
ImpBmpStatus ImpGIF(TCHAR *file, VMFileHandle vmf, ImageAdditionalData *iad,
          MimeRes resolution, AllocWatcherHandle watcher, dword *usedMem,
          ImpBmpParams *params, Boolean *isAnimation, Boolean *isCompacted,
          VMBlockHandle *bmVMBlock, VMFileHandle destFile,
          ImportProgressData *importProgressDataP,
		  Boolean locAllowAnimations)
#else
ImpBmpStatus ImpGIF(TCHAR *file, VMFileHandle vmf, ImageAdditionalData *iad,
          MimeRes resolution, AllocWatcherHandle watcher, dword *usedMem,
          ImpBmpParams *params, Boolean *isAnimation, Boolean *isCompacted,
          VMBlockHandle *bmVMBlock,
		  Boolean locAllowAnimations)
#endif
{
    ImpBmpStatus status;
    MemHandle mem ;
    AnimationHeader *p_header ;
    VMChain *p_chain ;

  params->IBP_bitmap = NullHandle ;
  params->IBP_dest = vmf;
  params->IBP_status = 0;              /* no status object */
#if PROGRESS_DISPLAY
  /* destination file for animated GIFs, they are written directly
     to destination file, not copied there later */
  params->IBP_animDest = destFile;
  /* point to import progress data */
  params->IBP_importProgressDataP = importProgressDataP;
#endif

  if (!locAllowAnimations)  {
      params->IBP_source = FileOpen(file, FILE_ACCESS_R|FILE_DENY_W);

      if(!params->IBP_source)              /* error opening file: abort */
        return 0;

      status = ImpGIFProcessFile(
                   params,
                   watcher,
                   usedMem,
                   resolution,
                   useSysPal,
                   MSG_SB_SET_STATUS_VALUE);

      /* Note if we got the whole graphic */
      if (status == IBS_IMPORT_STOPPED)
          iad->IAD_completeGraphic = FALSE ;
      else
          iad->IAD_completeGraphic = TRUE ;

      if (params->IBP_source)
          FileClose(params->IBP_source,TRUE);  /* close source file */

      *isCompacted = FALSE ;
  } else {
      status = ImpGIFProcessAnimationFile(
                   params,
                   file,
                   watcher,
                   usedMem,
                   resolution,
                   useSysPal,
                   MSG_SB_SET_STATUS_VALUE,
                   isAnimation,
                   &iad->IAD_completeGraphic);
      *isCompacted = TRUE ;
  }
  /* Load up to the abort point. */
  if ((status == IBS_IMPORT_STOPPED) && (params->IBP_bitmap != NullHandle))  {
      /* If we don't even have a first frame, then delete the whole thing */
      if (!*isAnimation)  {
          /* Only dump if we are not progressive */
#if PROGRESS_DISPLAY
          if ((!importProgressDataP) || (!importProgressDataP->IPD_callback))  {
#endif
              VMFreeVMChain(params->IBP_dest, VMCHAIN_MAKE_FROM_VM_BLOCK(params->IBP_bitmap)) ;

              /* Destroy the bitmap, but return the used memory count */
              AllocWatcherFree(watcher, *usedMem) ;
              *usedMem = 0 ;
              params->IBP_width = params->IBP_height = 1 ;
              params->IBP_bitmap = NullHandle ;
#if PROGRESS_DISPLAY
          }
#endif
      } else {
          /* We have at least one frame of this graphic.  Convert it to a single */
          /* frame image */
          VMBlockHandle originalBitmap = params->IBP_bitmap ;
          dword amountUsed ;
          int i ;

          /* Get access to each frame's animation */
          p_header = VMLock(params->IBP_animDest, params->IBP_bitmap, &mem) ;
          p_chain = (VMChain *)(((byte *)p_header) + p_header->AH_tree.VMCT_offset) ;

          /* Keep the first one */
          params->IBP_bitmap = VMCHAIN_GET_VM_BLOCK(*(p_chain++)) ;

          /* Delete the rest */
          for (i=1; i<p_header->AH_tree.VMCT_count; i++, p_chain++)
              VMFreeVMChain(params->IBP_animDest, *p_chain) ;

          /* Now delete the no longer needed header */
          VMUnlock(mem) ;
          VMFree(params->IBP_animDest, originalBitmap) ;

          /* Sorry, not an animation anymore */
          *isAnimation = FALSE ;

          /* Free up what we said we were using in memory */
          AllocWatcherFree(watcher, *usedMem) ;
          *usedMem = 0 ;

          /* Now allocate the lesser amount (ensuring we get it) */
          amountUsed = params->IBP_width ;
          amountUsed *= params->IBP_height ;
          if (AllocWatcherAllocate(watcher, amountUsed))
              *usedMem = amountUsed ;
      }
  }

  iad->IAD_size.XYS_width = params->IBP_width;
  iad->IAD_size.XYS_height = params->IBP_height;

  /* handle JPEGs disguised as GIFs (with .gif extension) */
  if (status == IBS_UNKNOWN_FORMAT) {
  }

  if ((status == IBS_NO_ERROR) || (status == IBS_IMPORT_STOPPED))
    *bmVMBlock = params->IBP_bitmap;
  else
    *bmVMBlock = 0;

    return status;
}


/*****************************************************************************
 *  JPEG import - main routine                                               *
 *****************************************************************************/

#if PROGRESS_DISPLAY
ImpBmpStatus ImpJPG(TCHAR *file, VMFileHandle vmf, ImageAdditionalData *iad,
          MimeRes resolution, AllocWatcherHandle watcher, dword *usedMem,
          Boolean doCompress, ImpBmpParams *params, Boolean *isCompacted,
          VMBlockHandle *bmVMBlock, ImportProgressData *importProgressDataP,
          MimeStatus *mimeStatus)
#else
ImpBmpStatus ImpJPG(TCHAR *file, VMFileHandle vmf, ImageAdditionalData *iad,
          MimeRes resolution, AllocWatcherHandle watcher, dword *usedMem,
          Boolean doCompress, ImpBmpParams *params, Boolean *isCompacted,
          VMBlockHandle *bmVMBlock,
          MimeStatus *mimeStatus)
#endif
{
    ImpBmpStatus status;
#if SCANLINE_COMPRESS
    Boolean scanlineCompress = TRUE;
#endif

    /* we don't override scanlineCompress even if no progress display
       as it still seems faster than GrCompactBitmap */
#if SCANLINE_COMPRESS
    if (doCompress) {
	/* if TRUE, we'll compress per-scanline */
	InitFileReadBoolean("impgraph", "scanlineCompress", &scanlineCompress);
    } else {
	scanlineCompress = FALSE;
    }
#endif

    iad->IAD_completeGraphic = FALSE ;

@ifdef PRODUCT_FJPEG
    *bmVMBlock =
        FJpegImport(file, vmf, &(iad->IAD_size), resolution, watcher, usedMem,
#if SCANLINE_COMPRESS
	        scanlineCompress,
#endif
            &iad->IAD_completeGraphic
#if PROGRESS_DISPLAY
	        , importProgressDataP
#endif
            , mimeStatus
           );

    /* if fast import failed, try using IJGJPEG library */
    if(!(*bmVMBlock))
    {
@endif
        *bmVMBlock =
            JpegImport(file, vmf, &(iad->IAD_size), resolution, watcher, usedMem,
#if SCANLINE_COMPRESS
	            scanlineCompress,
#endif
                &iad->IAD_completeGraphic
#if PROGRESS_DISPLAY
	            , importProgressDataP
#endif
                , mimeStatus
           );
@ifdef PRODUCT_FJPEG
    }
@endif

#if SCANLINE_COMPRESS
    if (scanlineCompress) *isCompacted = TRUE;
#endif
    if (*bmVMBlock) {
      status = IBS_NO_ERROR;
      params->IBP_bitmap = *bmVMBlock;
    }
    else
      status = IBS_UNKNOWN_FORMAT;

    return status;
}

/********************************************************************
 ImpPNG
 *******************************************************************/
#if PROGRESS_DISPLAY
ImpBmpStatus ImpPNG(TCHAR *file, VMFileHandle vmf, ImageAdditionalData *iad,
          MimeRes resolution, AllocWatcherHandle watcher, dword *usedMem,
          Boolean doCompress, ImpBmpParams *params, Boolean *isCompacted,
          VMBlockHandle *bmVMBlock, ImportProgressData *importProgressDataP,
          MimeStatus *mimeStatus)
#else
ImpBmpStatus ImpPNG(TCHAR *file, VMFileHandle vmf, ImageAdditionalData *iad,
          MimeRes resolution, AllocWatcherHandle watcher, dword *usedMem,
          Boolean doCompress, ImpBmpParams *params, Boolean *isCompacted,
          VMBlockHandle *bmVMBlock,
          MimeStatus *mimeStatus)
#endif
{
    ImpBmpStatus status = IBS_NO_ERROR;

    *bmVMBlock = PngImport(file, vmf, &(iad->IAD_size), resolution, watcher, usedMem,
    &iad->IAD_completeGraphic
#if PROGRESS_DISPLAY
	, importProgressDataP
#endif
    , mimeStatus
    );

/*
    FIXME: SCANLINE_COMPRESS
    We don't do the improved scanline compression as of now
    (see "doCompress" in ImpJPG).
    So we return false in "isCompacted" and at least the
    (painfully slow) GrCompactBitmap will be called on
    the bitmap in our caller...
*/
    *isCompacted = FALSE;

    if (*bmVMBlock)
    {
      status = IBS_NO_ERROR;
      params->IBP_bitmap = *bmVMBlock;
    }
    else
    {
      status = IBS_UNKNOWN_FORMAT;
      params->IBP_bitmap = NullHandle;
    }

    return status;
}


/*****************************************************************************
 *  SVG import - main routine (rasterize to bitmap via extgraph)             *
 *****************************************************************************/

#if PROGRESS_DISPLAY
ImpBmpStatus ImpSVG(TCHAR *file, VMFileHandle vmf, ImageAdditionalData *iad,
          MimeRes resolution, AllocWatcherHandle watcher, dword *usedMem,
          Boolean doCompress, /* ignored for vectors; kept for symmetry */
          ImpBmpParams *params, Boolean *isCompacted,
          VMBlockHandle *bmVMBlock, ImportProgressData *importProgressDataP,
          MimeStatus *mimeStatus)
#else
ImpBmpStatus ImpSVG(TCHAR *file, VMFileHandle vmf, ImageAdditionalData *iad,
          MimeRes resolution, AllocWatcherHandle watcher, dword *usedMem,
          Boolean doCompress, /* ignored for vectors; kept for symmetry */
          ImpBmpParams *params, Boolean *isCompacted,
          VMBlockHandle *bmVMBlock,
          MimeStatus *mimeStatus)
#endif
{
    /* locals first (C89) */
    ImpBmpStatus status;
    FileHandle srcFile;
    GStateHandle gs;
    VMBlockHandle gsBlock;
    RectDWord bounds;
    word metaSettings;
    EGError egstat;
    VMBlockHandle bmBlock;
    word destType;
    DisplayClass displayClass;
    DisplayScheme display;

    /* quiet warnings for unused params we don't need for vectors */
    resolution = resolution;
    watcher = watcher;
    usedMem = usedMem;
    mimeStatus = mimeStatus;
#if PROGRESS_DISPLAY
    importProgressDataP = importProgressDataP;
#endif
    doCompress = doCompress;

    params->IBP_bitmap = NullHandle;
    params->IBP_dest   = vmf;
    params->IBP_status = 0;                 /* no status object */
    *isCompacted       = FALSE;             /* we don't compact here */
    iad->IAD_completeGraphic = FALSE;

    /* 1) Open the SVG source */
    srcFile = FileOpen(file, FILE_ACCESS_R | FILE_DENY_W);
    if (!srcFile)
    {
        *bmVMBlock = 0;
        return IBS_UNKNOWN_FORMAT;          /* consistent with other importers */
    }

    /* 2) Create an output GString in vmf for Meta to record into */
    gs = GrCreateGString(vmf, GST_VMEM, &gsBlock);
    if (!gs)
    {
        FileClose(srcFile, TRUE);
        *bmVMBlock = 0;
        return IBS_UNKNOWN_FORMAT;
    }

    /* 3) Configure Meta: Y-down, default style conversion on; no GrObj */
    metaSettings = 0;
    metaSettings |= SETTINGS_INPUT_Y_DOWN; // SVG Y axis is downwards

    Meta_Start(metaSettings, gs, (optr)0, vmf);

    /* 4) Parse + render the SVG into the GString */
    /* Progress callback is optional; pass NULL to keep things simple here. */
    if (ReadSVG(srcFile, metaSettings, (ProgressCallback *)(void*)0) != 0)
    {
        /* Parser error: clean up and signal failure */
        Meta_End();
        GrEndGString(gs);
        VMFreeVMChain(vmf, VMCHAIN_MAKE_FROM_VM_BLOCK(gsBlock));
        FileClose(srcFile, TRUE);
        *bmVMBlock = 0;
        return IBS_UNKNOWN_FORMAT;
    }

    /* 5) Finish GString, compute bounds (for IAD_size) */
    Meta_End();
    GrEndGString(gs);
    GrSetGStringPos(gs, GSSPT_BEGINNING, 0);
    GrGetGStringBoundsDWord(gs, 0, 0, &bounds);

    /* 6) Choose raster target format:
          - Use palette only on <=8bpp displays (like existing GIF path)
          - Otherwise, make a 24-bit bitmap to preserve colors
    */
    @call application::MSG_GEN_APPLICATION_GET_DISPLAY_SCHEME(&display);
    displayClass = (display.DS_displayType & DT_DISP_CLASS);
    if (displayClass <= DC_COLOR_8)
    {
        destType = BMF_8BIT | BMT_PALETTE;
    }
    else
    {
        destType = BMF_24BIT; /* true-color, no palette */
    }

    /* 7) Rasterize the GString into a bitmap */
    bmBlock = BmpGStringToBitmap(
        vmf,
        gsBlock,
        vmf,
        destType,
        &egstat
    );

    /* 8) GString VMChain is no longer needed on success or failure */
    VMFreeVMChain(vmf, VMCHAIN_MAKE_FROM_VM_BLOCK(gsBlock));

    FileClose(srcFile, TRUE);

    if (!bmBlock || egstat != EGE_NO_ERROR)
    {
        *bmVMBlock = 0;
        params->IBP_bitmap = NullHandle;
        return IBS_UNKNOWN_FORMAT;          /* keep status surface small like JPG/PNG */
    }

    /* 9) Report result */
    *bmVMBlock = bmBlock;
    params->IBP_bitmap = bmBlock;
    iad->IAD_completeGraphic = TRUE;

    /* size (in pixels) for layout/consumers */
    iad->IAD_size.XYS_width  = (word)(bounds.RD_right  - bounds.RD_left);
    iad->IAD_size.XYS_height = (word)(bounds.RD_bottom - bounds.RD_top);

    return IBS_NO_ERROR;
}

/*****************************************************************************
 *  Common code for GIF and JPEG formats                                     *
 *****************************************************************************/

/*
 * Find out if we have already sent the bitmap to the text object
 * previously or not. If so, the text object should handle the freeing.
 * Otherwise (i.e. if no progress update ever got out), we'll just
 * discard the bitmap ourselves since nobody else knows about it.
 */
#if PROGRESS_DISPLAY
void FreeViaProgress(_ImportProgressParams_, VMFileHandle vmFile, VMBlockHandle bitmap)
{
    Boolean dofree;

    if (bitmap) {
	dofree = TRUE;

	if (importProgressDataP && importProgressDataP->IPD_callback)
	{
	    VMFileHandle oldFile = importProgressDataP->IPD_vmFile;
	    VMBlockHandle oldBitmap = importProgressDataP->IPD_bitmap;

	    if(oldFile == vmFile && oldBitmap == bitmap)
		dofree = FALSE;
	}

	if(dofree)
	  VMFreeVMChain(vmFile, VMCHAIN_MAKE_FROM_VM_BLOCK(bitmap));
    }
}
#endif

/*
 *  Import file whose name is specified in *file, assume it has the MIME
 *  type that is passed in *mimeType. The file is converted to a VMChain
 *  in the file specified by vmf. The size of the objects bounding box is
 *  passed back in *size.
 */
VMBlockHandle _pascal _export MimeDrvGraphicEx(_MimeGraphicParams_, dword extFlags)
{
    Boolean locAllowAnimations;
    Boolean locCompress;
    ImpBmpParams params;
    ImpBmpStatus status;
    VMBlockHandle dataVMBlock,bmVMBlock = NullHandle;
    Boolean isAnimation = FALSE ;
    Boolean isCompacted = FALSE ;
#if PROGRESS_DISPLAY
    VMFileHandle destFile = vmf;
#endif

    InitGlobals();                      /* Handled cached INI entries */

    locAllowAnimations = allowAnimations;
    locCompress = doCompress;

    if(extFlags & MIME_GREX_NO_ANIMATIONS) {
        locAllowAnimations = FALSE;
    }
    if(extFlags & MIME_GREX_NO_SCANLINE_COMPRESS) {
        locCompress = FALSE;
    }

    params.IBP_mimeStatus = mimeStatus ;
#if PROGRESS_DISPLAY
    /* use local work file, if available */
    if (importProgressDataP && importProgressDataP->IPD_callback) {
        /* must use actual dest file */
        importProgressDataP->IPD_vmFile = vmf;
        if (importProgressDataP->IPD_vmFile) {
            vmf = importProgressDataP->IPD_vmFile;
        } else {
            /* make sure progress handler knows we're using this file */
            importProgressDataP->IPD_vmFile = vmf;
        }

        /* initialize complete structure for standard case: */
        importProgressDataP->IPD_iad.IAD_type = IAD_TYPE_BITMAP;
        importProgressDataP->IPD_iad.IAD_origin.P_x =
        importProgressDataP->IPD_iad.IAD_origin.P_y = 0;
        importProgressDataP->IPD_iad.IAD_completeGraphic = FALSE;
    }
#endif  /* PROGRESS_DISPLAY */

/* Define macros to add parameters only if PROGRESS_DISPLAY is set */
#if PROGRESS_DISPLAY
  #define IMP_DESTFILE_PARAM , destFile
  #define IMP_PROGRESS_PARAM , importProgressDataP
#else
  #define IMP_DESTFILE_PARAM
  #define IMP_PROGRESS_PARAM
#endif

/* Define parameter lists for each import routine to make the calls below
   easier to read and maintain. */
#define IMP_GIF_PARAMS file, vmf, iad, resolution, watcher, usedMem, \
          &params, &isAnimation, &isCompacted, &bmVMBlock \
          IMP_DESTFILE_PARAM IMP_PROGRESS_PARAM, locAllowAnimations
#define IMP_JPG_PARAMS file, vmf, iad, resolution, watcher, usedMem, \
          locCompress, &params, &isCompacted, &bmVMBlock IMP_PROGRESS_PARAM \
          , mimeStatus
#define IMP_PNG_PARAMS file, vmf, iad, resolution, watcher, usedMem, \
          locCompress, &params, &isCompacted, &bmVMBlock IMP_PROGRESS_PARAM \
          , mimeStatus
/* Reuse the same macro shape as others; doCompress is ignored for vectors */
#define IMP_SVG_PARAMS file, vmf, iad, resolution, watcher, usedMem, \
        locCompress, &params, &isCompacted, &bmVMBlock IMP_PROGRESS_PARAM \
        , mimeStatus

    /* Call the appropriate import routine based on the MIME type */
    if (strcmp(mimeType, _TEXT("image/gif")) == 0)
    {
        status = ImpGIF(IMP_GIF_PARAMS);
        if (status == IBS_UNKNOWN_FORMAT)
            status = ImpJPG(IMP_JPG_PARAMS);
        if (status == IBS_UNKNOWN_FORMAT)
            status = ImpPNG(IMP_PNG_PARAMS);
        if (status == IBS_UNKNOWN_FORMAT)
            status = ImpSVG(IMP_SVG_PARAMS);
    }
    else if (strcmp(mimeType, _TEXT("image/jpeg")) == 0)
    {
        status = ImpJPG(IMP_JPG_PARAMS);
        if (status == IBS_UNKNOWN_FORMAT)
            status = ImpGIF(IMP_GIF_PARAMS);
        if (status == IBS_UNKNOWN_FORMAT)
            status = ImpPNG(IMP_PNG_PARAMS);
        if (status == IBS_UNKNOWN_FORMAT)
            status = ImpSVG(IMP_SVG_PARAMS);
    }
    else if (strcmp(mimeType, _TEXT("image/png")) == 0)
    {
        status = ImpPNG(IMP_PNG_PARAMS);
        if (status == IBS_UNKNOWN_FORMAT)
            status = ImpJPG(IMP_JPG_PARAMS);
        if (status == IBS_UNKNOWN_FORMAT)
            status = ImpGIF(IMP_GIF_PARAMS);
        if (status == IBS_UNKNOWN_FORMAT)
            status = ImpSVG(IMP_SVG_PARAMS);
    }
    else if (strcmp(mimeType, _TEXT("image/svg+xml")) == 0)
    {
        status = ImpSVG(IMP_SVG_PARAMS);
        if (status == IBS_UNKNOWN_FORMAT)
            status = ImpPNG(IMP_PNG_PARAMS);
        if (status == IBS_UNKNOWN_FORMAT)
            status = ImpJPG(IMP_JPG_PARAMS);
        if (status == IBS_UNKNOWN_FORMAT)
            status = ImpGIF(IMP_GIF_PARAMS);
    }

    if (bmVMBlock)                       /* check if import successful */
    {
        /* Compress and convert the bitmap to a GString if not an animation */
        if (!isAnimation) {
            /* Compact the bitmap if not already */
            if (!isCompacted && locCompress) {
                VMBlockHandle bmCompacted;

                bmCompacted = GrCompactBitmap(vmf, bmVMBlock, vmf);
                if(bmCompacted)
                {
#if PROGRESS_DISPLAY
                    FreeViaProgress(importProgressDataP, vmf, bmVMBlock);
#else
                    VMFreeVMChain(vmf, VMCHAIN_MAKE_FROM_VM_BLOCK(bmVMBlock));
#endif
                    bmVMBlock = bmCompacted;
                }
            }
            dataVMBlock = bmVMBlock;
            iad->IAD_type = IAD_TYPE_BITMAP;
        } else {
            iad->IAD_type = IAD_TYPE_ANIMATION; /* returned data is an animation */
            dataVMBlock = bmVMBlock ;
        }
        iad->IAD_origin.P_x = iad->IAD_origin.P_y = 0;
    }
    else
    {
        dataVMBlock = 0;                  /* import did not succeed */
    }

    return dataVMBlock;
}

char * _pascal _export MimeDrvInfo(_MimeInfoParams_)
{
#define FORMATS _TEXT("image/gif\0")       /* MIME type of supported format */ \
                  _TEXT("GIF\0")           /* primary suggested extension */ \
                  _TEXT("\0")              /* end of extension list */ \
                _TEXT("image/jpeg\0") \
                  _TEXT("JPG\0") \
                  _TEXT("\0") \
                _TEXT("image/png\0") \
                  _TEXT("PNG\0") \
                  _TEXT("\0") \
                _TEXT("image/svg+xml\0") \
                  _TEXT("SVG\0") \
                  _TEXT("\0") \
                _TEXT("\0")                /* end of format list */

    /* Return list of supported formats */
    return memcpy(buf, FORMATS, sizeof(FORMATS));
}

#pragma argsused
char * _pascal _export MimeDrvText(_MimeTextParams_)
{
   /* This is a graphics driver that likes to be called for returning an
      image, rather than for returning a text transfer item. */

   tad->TAD_type = TAD_TYPE_REQUEST_IMG;

   return 0;                            /* anything... */
}

VMBlockHandle _pascal _export MimeDrvGraphic(_MimeGraphicParams_)
{
    return MimeDrvGraphicEx(
            mimeType,
            file,
            vmf,
            iad,
            resolution,
            watcher,
            usedMem,
            mimeStatus,
#ifdef PROGRESS_DISPLAY
            importProgressDataP,
#endif
            0   // no specific flags here
    );
}


