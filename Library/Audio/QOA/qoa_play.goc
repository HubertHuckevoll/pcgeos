/***************************************************************
 *  qoa_play.goc â€” QOA player that uses BSNWAV internally
 *  App calls QOAPlayFile(); this feeds PCM to BSNWAV via callback.
 ***************************************************************/
@include <qoa.goh>
@include <bsnwav.goh>

#include <Ansi/string.h>
#include <Ansi/stdio.h>
#include <library.h>
#include <system.h>
#include <file.h>
#include <heap.h>


/* ------------ Internal static playback context ------------ */
/* BSNWAV's callback type has no user-data -> keep a static handle. */
static QOAHandle *s_qoaHandle = 0;
static word       s_qoaChannels = 1;
static dword      s_totalFramesDecoded = 0;

static const char gQOALogFileName[] = "qoa.log";

static void QOA_LogMessage(const char *message)
{
    FileHandle      logFileH;
    FileCreateFlags createFlags;
    word            messageLen;
    char            newlineStr[2];
    word            newlineLen;

    createFlags = (FILE_CREATE_NO_TRUNCATE | FCF_NATIVE | FILE_ACCESS_RW | FILE_DENY_NONE);
    logFileH = FileCreate(gQOALogFileName, createFlags, FA_ARCHIVE);
    if (!logFileH)
    {
        return;
    }

    FilePos(logFileH, 0, FILE_POS_END);

    messageLen = (word)strlen(message);
    if (messageLen > 0)
    {
        FileWrite(logFileH, (void*)message, messageLen, FALSE);
    }

    newlineStr[0] = '\r';
    newlineStr[1] = '\n';
    newlineLen = 2;
    FileWrite(logFileH, (void*)newlineStr, newlineLen, FALSE);

    FileClose(logFileH, TRUE);
}

static Boolean QOA_VerifyDecoder(QOAHandle *qh, const QOAInfo *info)
{
    MemHandle      bufferH;
    signed short  *bufferP;
    dword          framesRequested;
    dword          framesDecoded;
    word           bufferSize;
    Boolean        success;
    char           dbg[80];

    framesRequested = 4096;
    success = FALSE;

    if (!info || info->channels == 0)
    {
        // invalid decoder info
        return FALSE;
    }

    bufferSize = (word)(framesRequested * (dword)info->channels * sizeof(signed short));
    if (bufferSize == 0)
    {
        // calculated buffer size is zero
        return FALSE;
    }

    bufferH = MemAlloc(bufferSize, HF_SWAPABLE, HAF_ZERO_INIT);
    if (bufferH == NullHandle)
    {
        // MemAlloc failed
        return FALSE;
    }

    bufferP = (signed short*)MemLock(bufferH);
    if (!bufferP)
    {
        // MemLock failed
        MemFree(bufferH);
        return FALSE;
    }

    framesDecoded = qoaReadS16(qh, framesRequested, bufferP);
    if (framesDecoded > 0)
    {
        FileHandle      dumpH;
        FileCreateFlags createFlags;
        word            dumpBytes;
        signed short    minSample;
        signed short    maxSample;
        dword           sampleCount;

        // decoded %lu frames", framesDecoded
        sampleCount = framesDecoded * (dword)info->channels;
        minSample = bufferP[0];
        maxSample = bufferP[0];
        if (sampleCount > 1)
        {
            dword idx;
            for (idx = 1; idx < sampleCount; idx++)
            {
                signed short s;
                s = bufferP[idx];
                if (s < minSample)
                {
                    minSample = s;
                }
                if (s > maxSample)
                {
                    maxSample = s;
                }
            }
        }

        success = TRUE;
    }
    else
    {
        // QOA verify: decoder produced zero frames
    }

    MemUnlock(bufferH);
    MemFree(bufferH);

    if (!qoaSeek(qh, 0))
    {
        // failed to seek to start
        success = FALSE;
    }

    return success;
}

static void QOA_ResetStaticState(void)
{
    s_qoaHandle = 0;
    s_qoaChannels = 1;
    s_totalFramesDecoded = 0;
}

/* BSNWAV will invoke this */
word _export _pascal QOA_BSNW_Callback(void *dstBuf, word wantBytes)
{
    signed short *dst;
    dword framesReq;
    dword framesGot;
    word  blockAlign;

    if (!s_qoaHandle || !dstBuf || wantBytes == 0 || s_qoaChannels == 0)
    {
        return 1; /* signal error -> BSNW stops */
    }

    blockAlign = (word)(s_qoaChannels * 2u);
    if (blockAlign == 0)
    {
        return 1;
    }

    dst = (signed short*)dstBuf;

    if (wantBytes == 0)
    {
        return 0;
    }

    {
        signed short *writePtr;
        dword producedBytes;

        writePtr = dst;
        producedBytes = 0;

        while (producedBytes + (dword)blockAlign <= (dword)wantBytes)
        {
            dword framesDesired;
            dword framesGot;

            framesDesired = ((dword)wantBytes - producedBytes) / blockAlign;
            if (framesDesired == 0)
            {
                break;
            }

            framesGot = qoaReadS16(s_qoaHandle, framesDesired, writePtr);
            if (framesGot == 0)
            {
                // QOA cb: EOF
                break;
            }

            s_totalFramesDecoded += framesGot;

            writePtr      += framesGot * (dword)s_qoaChannels;
            producedBytes += framesGot * blockAlign;

            if (framesGot == 0)
            {
                break;
            }
        }

        if (producedBytes < (dword)wantBytes)
        {
            byte *fill;
            dword remaining;

            remaining = (dword)wantBytes - producedBytes;
            fill = (byte *)writePtr;
            memset(fill, 0, (word)remaining);
        }
    }

    return 0;
}

/* ------------ Public player API ------------ */

int _pascal _export QOAPlayFile(FileHandle fh, word playFlags, optr parent)
{
    QOAHandle      *qh;
    QOAInfo         info;
    BSWavFormChunk  fmt;
    dword           totalBytes;
    int             status;

    qh = qoaOpenGEOS(fh, &info);
    if (!qh)
    {
        // qoaOpenGEOS failed
        return BSNW_UNKNOWN_WAVE_FORMAT;
    }

    s_qoaHandle   = qh;
    s_qoaChannels = info.channels;

    if (!QOA_VerifyDecoder(qh, &info))
    {
        // decoder verification failed
        qoaClose(qh);
        QOA_ResetStaticState();
        return BSNW_UNKNOWN_WAVE_FORMAT;
    }

    fmt.BWFC_dataFormat    = 1; /* PCM */
    fmt.BWFC_channels      = info.channels;
    fmt.BWFC_sampleRate    = info.sampleRate;
    fmt.BWFC_bitsPerSample = 16;
    fmt.BWFC_blockAlign    = (word)(info.channels * 2);
    fmt.BWFC_avgRate       = (dword)fmt.BWFC_blockAlign * info.sampleRate;

    totalBytes = (dword)info.totalFrames * (dword)fmt.BWFC_blockAlign;

    status = BSNWavePlayCallback(&fmt,
                                 totalBytes,
                                 playFlags,
                                 parent,
                                 (PlayCallbackFunctionType*) QOA_BSNW_Callback);
    qoaClose(qh);

    QOA_ResetStaticState();
    return status;
}

void _pascal _export QOAStop(void)
{
    BSNWaveStop();
    QOA_ResetStaticState();
}

Boolean _pascal _export QOALibEntry(LibraryCallType call, GeodeHandle client)
{
    (void)client;

    if (call == LCT_DETACH)
    {
        QOA_ResetStaticState();
    }

    return FALSE;
}
