/************************************************
 *                      *
 *  Project:    BestSound       *
 *                      *
 *  Module:     Mixer library       *
 *                      *
 *  File:       MIXLIB.GOC      *
 *                      *
 *  Author:     Dirk Lausecker      *
 *                      *
 * BSMixerLoadDriver    Load and prepare mixer driver  *
 * BSMixerGetCap    Out: valNum number of values *
 * BSMixerGetValue              *
 *                      *
 ************************************************/

/*
@define GERMAN
#define GERMAN
/* */

@include <stdapp.goh>
@include <Ansi/stdio.h>

#include <Ansi/string.h>
#include <sound.h>
#include <library.h>
#include <driver.h>
#include <initfile.h>
#include <geode.h>

#include <dirksnd.h>

@include "mixlib.goh"

/**************************** Konstanten ************************/

// #define FP_SEG( fp )( (unsigned )( void _seg * )( void far * )( fp ))
// #define FP_OFF( fp )( (unsigned )( fp ))

// Watcom C 16 bit compatible macros
#define FP_SEG(fp) ((unsigned short)((unsigned long)(void far *)(fp) >> 16))
#define FP_OFF(fp) ((unsigned short)(fp))
#define MK_FP(seg, ofs) ((void far *)(((unsigned long)(seg) << 16) | (unsigned)(ofs)))
#define MIX_FARPTR(type, ptr) ((type far *)MK_FP(FP_SEG(ptr), FP_OFF(ptr)))


/******************** Assembly helpers ************************/

extern void _far _pascal MixAsmSetDriverInfo(GeodeHandle driverHandle);
extern void _far _pascal MixAsmSetValue(word token, word valueLeft, word valueRight);
extern word _far _pascal MixAsmGetValue(word token);
extern word _far _pascal MixAsmGetCap(word _far *dspPtr);
extern void _far _pascal MixAsmTokenToText(word token, char _far *dest);
extern word _far _pascal MixAsmGetSubToken(word token, word identifier);
extern void _far _pascal MixAsmSpecValue(
    word valNum,
    word _far *rangePtr,
    word _far *tokenPtr,
    byte _far *targetPtr,
    byte _far *typePtr,
    byte _far *sliderPtr,
    byte _far *visiblePtr,
    byte _far *stereoPtr
);
extern word _far _pascal MixAsmGetState(void);


/********************** Globals ******************/
word        datasize    = 0;        //Buffer for ReadIni
Handle      mixerDriver = NullHandle;
const char  soundCatIT[]     = "sound";      //INI Entry
const char  mixerDriverIT[]  = "mixerDriver";    //INI Entry
const char  synthDriverIT[]  = "synthDriver";    //INI Entry
//char      driverName[32]  = "sblaster.geo";
Boolean     demoModus   = TRUE;
byte        valNum      = 0;
GeodeLoadError  gle;
Boolean     driverUsed  = FALSE;    //Driver was loaded explicitly


/**************************** Funktionen ************************/

/****************************

    LibMixEntry

  IN:
  LibraryCallType   type
  (reason the library was invoked)
  GeodeHandle       client
  (calling geode, if any)

  OUT:
  TRUE      error
  FALSE     no error

 ****************************/

Boolean _pascal _export LibMixEntry(LibraryCallType type,GeodeHandle client)
{
        switch (type) {
            case LCT_ATTACH:                /* The library was just loaded. */
              {
                  char driverName[GEODE_NAME_SIZE];

                  //Init
                  mixerDriver = NullHandle;
                  driverUsed  = FALSE;
                  demoModus = TRUE;
                  driverName[0] = '\0';

                  if (BSMixerLoadDriver(&gle, driverName))
                  {
                      // demo mode, assembly helper already reset
                  }
                  else
                  {
                      // driver ready, MixAsmSetDriverInfo called by loader
                  }
              };
              break;

            case LCT_DETACH:                /* The library is about to be unloaded. */
            {
                //Release driver if it was loaded with GeodeUseDriver
                if (mixerDriver && driverUsed)
                {
                  GeodeFreeDriver (mixerDriver);
                  mixerDriver = NullHandle;
                };
                MixAsmSetDriverInfo(NullHandle);
            };

              break;
            case LCT_NEW_CLIENT:    break;      /* A new client of the library was just loaded. */
            case LCT_NEW_CLIENT_THREAD: break;      /* A new thread was just created for a
                                             * current client of the library. */
            case LCT_CLIENT_THREAD_EXIT:break;      /* A thread was just exited for a current
                                                         * client of the library. */
            case LCT_CLIENT_EXIT:   break;      /* Library's client is about to be unloaded. */
        };

        return (FALSE);
}

/****************************

    BSMixerLoadDriver

 Load the mixer driver and prepare it for usage

 IN
 * gle       location to store the error code
 [mixerDriver] = driver name
 OUT    Boolean demoMode
 * name      driver name

 ****************************/

Boolean _pascal _export BSMixerLoadDriver(GeodeLoadError  *gle, char * name)
{
        Boolean demoMode;

     /* Read driver name from INI */
        demoMode = FALSE;
        driverUsed = FALSE;

        if(InitFileReadStringBuffer(soundCatIT,mixerDriverIT,name,32,&datasize))
        {   //mixerDriver entry not found
            //Try synthDriver if mixerDriver is missing
            demoMode = (InitFileReadStringBuffer(soundCatIT,synthDriverIT,name,32,&datasize));
        };

        //Reset error code
        *gle = 0;

        //Locate/load driver
        if (demoMode)
        {
            //Demo mode = load no driver
        }
        else
        {   //Entry found in INI, now load mixer driver
            mixerDriver = GeodeFind (name,GEODE_NAME_SIZE,0,0);
            if (!mixerDriver)
            {   //mixerDriver not in memory - must be loaded

                FilePushDir ();
                FileSetCurrentPath (SP_SYSTEM,"SOUND");

                /* load mixer driver, check handle */
                mixerDriver = GeodeUseDriver (name, 0, 0, gle);
                demoMode = (mixerDriver == NullHandle);
                driverUsed = !demoMode;     //set Flag, driver has been loaded (driverUsed)

                FilePopDir ();
            };

        };

        demoModus = demoMode;

        if (demoMode)
        {
            MixAsmSetDriverInfo(NullHandle);
        }
        else
        {
            MixAsmSetDriverInfo(mixerDriver);
        }

        return (demoMode);
}

/********************************
 *    BSMixerSetValue       *
 *              *
 * Set mixer channel        *
 *              *
 * IN:  word    token       *
 *      0 = Reset   *
 *  byte    datatype    *
 *  1       Volume,Balance   *
 *  2   Volume_L,Volume_R *
 *  byte    value1,value2   *
 *              *
 ********************************/

void    _pascal _export BSMixerSetValue (word token, byte dataType, byte value1, byte value2)
{
        word    val_L;
        word    val_R;

        if (demoModus)
        {
        //Do not send data to the driver while in demo mode
        }
        else
        {
            //Not in demo mode
            //Convert volume/balance into left/right levels
            if (dataType == 1)
            {
                if ((value2 >127))
                {
                    val_R = ((255-value2)*value1)/127;
                    val_L = value1;
                }
                else
                {
                    //if (!value2) value2 = 1;
                    val_L = ((value2)*value1)/127;
                    val_R = value1;
                }
                value1 = (byte)val_R;
                value2 = (byte)val_L;
            };

                //Call driver
            MixAsmSetValue(token, value1, value2);
        };
}

/************************
 *          *
 *    BSMixerGetValue   *
 *          *
 * Read mixer channel *
 *          *
 * dataType     *
 * 1 = Volume           *
 * 2 = Balance          *
 * 3 = Raw data         *
 ************************/

word _pascal _export BSMixerGetValue (word token, byte dataType)
{
    word    value;
    byte    val1,val2;

        if (demoModus)
        {
          value = 0;
        }
        else
        {
            value = MixAsmGetValue(token);

            //Interpret data type
            val1 = value & 0x00ff;
            val2 = (value>>8) & 0x00ff;
            if (!val1)
            val1 = 1;
            switch (dataType)
            {
                case 1 : {    //Volume
                    if (val1 > val2)
                    { value = val1; }
                    else
                    { value = val2; };
                }; break;

                case 2 : {    //Balance
                    if (val1 > val2)
                    {
                        value = val2*127/val1;
                    }
                    else
                    {   value = val1*127/val2;
                        value = 255 - value;
                    };
                    if ((val1|val2)<2) value = 128;
                }; break;
            };
              //Volume 0 -> Balance equals center
        };

        return(value);
}

/********************************
 *      BSMixerGetCap   *
 *              *
 *  Determine number of adjustable channels  *
 *              *
 *  IN  word    *dsp  address of DSP version *
 *                              *
 * OUT  word    number of channels  *
 *  *dsp    DSP version *
 ********************************/

word _pascal _export BSMixerGetCap (word *dsp)
{
        word    valNum,DSPVersion;

//    demoModus = TRUE;     //LA TEST !!!

        if (demoModus)
        {
            //Do not send data to the driver while in demo mode
            valNum = 5;
            DSPVersion = 0;
        }
        else
        {
            valNum = MixAsmGetCap(MIX_FARPTR(word, &DSPVersion));
        }

        *dsp    = DSPVersion;

        return (valNum);
}

@start  STRINGRESOURCE, data;

@ifdef  GERMAN

@chunk  char bsmText1[] = "SUMME";
@chunk  char bsmText2[] = "FM";
@chunk  char bsmText3[] = "CD";
@chunk  char bsmText4[] = "WAV";
@chunk  char bsmText5[] = "LINE";
@chunk  char bsmText6[] = "Mikro";
@chunk  char bsmText7[] = "PC-Lspr";
@chunk  char bsmText8[] = "H�hen";
@chunk  char bsmText9[] = "Tiefen";
@chunk  char bsmText10[] = "Aufnahmefilter";
@chunk  char bsmText11[] = "Tiefpass";
@chunk  char bsmText12[] = "Aufnahmequelle";
@chunk  char bsmText13[] = "Wiedergabefilter";
@chunk  char bsmText14[] = "Stereo";
@chunk  char bsmText15[] = "Quelle f�r Wiedergabe";
@chunk  char bsmText16[] = "Aufnahmequelle Links";
@chunk  char bsmText17[] = "Aufnahmequelle Rechts";
@chunk  char bsmText18[] = "Aufnahmeverst�rkung Links";
@chunk  char bsmText19[] = "Aufnahmeverst�rkung Rechts";
@chunk  char bsmText20[] = "Wiedergabeverst�rkung Links";
@chunk  char bsmText21[] = "Wiedergabeverst�rkung Rechts";
@chunk  char bsmText22[] = "Automatische Verst�rkungsregelung";
@chunk  char bsmText23[] = "FM-L";
@chunk  char bsmText24[] = "FM-R";
@chunk  char bsmText25[] = "LINE-L";
@chunk  char bsmText26[] = "LINE-R";
@chunk  char bsmText27[] = "CD-L";
@chunk  char bsmText28[] = "CD-R";
@chunk  char bsmText29[] = "1 fach";
@chunk  char bsmText30[] = "2 fach";
@chunk  char bsmText31[] = "4 fach";
@chunk  char bsmText32[] = "8 fach";
@chunk  char bsmText33[] = "aus";
@chunk  char bsmText34[] = "ein";
@chunk  char bsmText35[] = "aktiv";
@chunk  char bsmText36[] = "inaktiv";
@chunk  char bsmText0[]  = "???";

@else

@chunk  char bsmText1[] = "MASTER";
@chunk  char bsmText2[] = "FM";
@chunk  char bsmText3[] = "CD";
@chunk  char bsmText4[] = "WAV";
@chunk  char bsmText5[] = "LINE";
@chunk  char bsmText6[] = "Micro";
@chunk  char bsmText7[] = "PC-Spkr";
@chunk  char bsmText8[] = "Treble";
@chunk  char bsmText9[] = "Bass";
@chunk  char bsmText10[] = "Imput Filter";
@chunk  char bsmText11[] = "Lowpass";
@chunk  char bsmText12[] = "Recording Source";
@chunk  char bsmText13[] = "Output Filter";
@chunk  char bsmText14[] = "Stereo";
@chunk  char bsmText15[] = "Output Source";
@chunk  char bsmText16[] = "Record Source Left";
@chunk  char bsmText17[] = "Record Source Right";
@chunk  char bsmText18[] = "Input Gain Left";
@chunk  char bsmText19[] = "Input Gain Right";
@chunk  char bsmText20[] = "Output Gain Left";
@chunk  char bsmText21[] = "Output Gain Right";
@chunk  char bsmText22[] = "AGC";
@chunk  char bsmText23[] = "FM-L";
@chunk  char bsmText24[] = "FM-R";
@chunk  char bsmText25[] = "LINE-L";
@chunk  char bsmText26[] = "LINE-R";
@chunk  char bsmText27[] = "CD-L";
@chunk  char bsmText28[] = "CD-R";
@chunk  char bsmText29[] = "1x";
@chunk  char bsmText30[] = "2x";
@chunk  char bsmText31[] = "4x";
@chunk  char bsmText32[] = "8x";
@chunk  char bsmText33[] = "off";
@chunk  char bsmText34[] = "on";
@chunk  char bsmText35[] = "active";
@chunk  char bsmText36[] = "inactive";
@chunk  char bsmText0[]  = "???";

@endif

@end    STRINGRESOURCE;


/********************************
 *  BSMixerGetTokenText *
 *              *
 * IN   word    token       *
 *  char    *tokenText  *
 * OUT  tokenText       *
 ********************************/

void _pascal _export BSMixerGetTokenText (word token,char *tokenText)
{
        char *textPtr;
        optr op;

        //Lock text resource
        MemLock(OptrToHandle(@bsmText1));

        //Convert token to text
        switch (token)
        {
            case BSMX_TOKEN_MASTER   : op = @bsmText1 ; break;
            case BSMX_TOKEN_MIDI     : op = @bsmText2 ; break;   //FM
            case BSMX_TOKEN_CD   : op = @bsmText3 ; break;
            case BSMX_TOKEN_VOICE    : op = @bsmText4 ; break;   //WAV
            case BSMX_TOKEN_LINE : op = @bsmText5 ; break;
            case BSMX_TOKEN_MIC  : op = @bsmText6 ; break;
            case BSMX_TOKEN_SPEAKER  : op = @bsmText7 ; break;
            case BSMX_TOKEN_TREBLE   : op = @bsmText8 ; break;
            case BSMX_TOKEN_BASS : op = @bsmText9 ; break;
            case BSMX_TOKEN_IN_FLT   : op = @bsmText10 ; break;
            case BSMX_TOKEN_LOWPASS  : op = @bsmText11 ; break;
            case BSMX_TOKEN_INP_SRC  : op = @bsmText12 ; break;
            case BSMX_TOKEN_OUT_FLT  : op = @bsmText13 ; break;
            case BSMX_TOKEN_STEREO   : op = @bsmText14 ; break;
            case BSMX_TOKEN_OUT_MX_SW : op = @bsmText15 ; break;
            case BSMX_TOKEN_IN_MX_SW_L: op = @bsmText16 ; break;
            case BSMX_TOKEN_IN_MX_SW_R: op = @bsmText17 ; break;
            case BSMX_TOKEN_IN_GAIN_L : op = @bsmText18 ; break;
            case BSMX_TOKEN_IN_GAIN_R : op = @bsmText19 ; break;
            case BSMX_TOKEN_OUT_GAIN_L: op = @bsmText20 ; break;
            case BSMX_TOKEN_OUT_GAIN_R: op = @bsmText21 ; break;
            case BSMX_TOKEN_AGC  : op = @bsmText22 ; break;
            case BSMX_TOKEN_MIDI_L   : op = @bsmText23 ; break;
            case BSMX_TOKEN_MIDI_R   : op = @bsmText24 ; break;
            case BSMX_TOKEN_LINE_L   : op = @bsmText25 ; break;
            case BSMX_TOKEN_LINE_R   : op = @bsmText26 ; break;
            case BSMX_TOKEN_CD_L : op = @bsmText27 ; break;
            case BSMX_TOKEN_CD_R : op = @bsmText28 ; break;
            case BSMX_TOKEN_GAIN_0   : op = @bsmText29 ; break;
            case BSMX_TOKEN_GAIN_1   : op = @bsmText30 ; break;
            case BSMX_TOKEN_GAIN_2   : op = @bsmText31 ; break;
            case BSMX_TOKEN_GAIN_3   : op = @bsmText32 ; break;
            case BSMX_TOKEN_OFF  : op = @bsmText33 ; break;
            case BSMX_TOKEN_ON   : op = @bsmText34 ; break;
            case BSMX_TOKEN_ACTIVE   : op = @bsmText35 ; break;
            case BSMX_TOKEN_INACT    : op = @bsmText36 ; break;
            default          : op = @bsmText0  ;

        };

        //Ask the driver for the string if the token was unknown
        if ((token > 49) && (demoModus == 0))
        {
            MixAsmTokenToText(token, MIX_FARPTR(char, tokenText));
        }
        else
        {
            //Known token or demo mode
            //Copy string
            textPtr = LMemDeref(op);
            strcpy (tokenText,textPtr);
        };

        //Unlock token text resource
        MemUnlock(OptrToHandle(@bsmText1));
}

/********************************
 *  BSMixerGetSubToken  *
 *              *
 * Determine token for boolean/item *
 *              *
 * IN   word    token       *
 *  word    identifier  *
 * OUT  tokenText       *
 ********************************/

word _pascal _export BSMixerGetSubToken(word token, word identifier)
{
        word    subToken;

        //demo mode = no calls to the driver
        if (demoModus)
        {
            //demo mode
            subToken = 0;
        }
        else
        {
            //Call driver
            subToken = MixAsmGetSubToken(token, identifier);
        };

        //End
        return (subToken);
}

/********************************
 *  BSMixerSpecValue    *
 *              *
 * IN   word    valNum      *
 *  char    *tokenText  *
 * OUT  tokenText       *
 ********************************/

void _pascal _export BSMixerSpecValue(word valNum, MixerValue *value)
{
        //demo mode = no calls to the driver
        if (demoModus)
        {
            //demo mode
            value->valVisible = TRUE;       //Visibility
            value->valStereoFlag = FALSE;   //FALSE = mono
            value->valTarget = 1;       //1=Mixer 2=Record 3=Other
            value->valRange = 255;      //(word)Value range
            value->valToken = valNum+1;     //(word)Text token 1,2,3,...32
            value->valType = 1;         //0=none 1=Slider 2=Item 3=Boolean
            value->valPos = valNum;     //Slider position 0,1,2...
            /* */
        }
        else
        {
            MixAsmSpecValue(
                valNum,
                MIX_FARPTR(word, &value->valRange),
                MIX_FARPTR(word, &value->valToken),
                MIX_FARPTR(byte, &value->valTarget),
                MIX_FARPTR(byte, &value->valType),
                MIX_FARPTR(byte, &value->valPos),
                MIX_FARPTR(byte, &value->valVisible),
                MIX_FARPTR(byte, &value->valStereoFlag)
            );
        };

        //End
}

/********************************
 *  BSMixerGetState     *
 *              *
 * Check driver connectivity *
 *              *
 * OUT  word    state       *
 *  0x8000  demo mode    *
 *  0x4000  no mixer support *
 *              *
 ********************************/

word _pascal _export BSMixerGetState(void)
{
    word    state;

    //demo mode = no calls to the driver
    if (demoModus)
    {
        //demo mode
        state = 0x8000;
    }
    else
    {
        state = MixAsmGetState();

        //Evaluate response
        if (state == 2)
        {
            state = 0;      //Driver supports the mixer!
        }
        else
        {
            state = 0x4000;     //No mixer support!
            demoModus = TRUE;   //Therefore, demo mode!
        };
    };

    //End
    return (state);
}

