/***************************************************************
 *  qoa_play.goc â€” QOA player that uses BSNWAV internally
 *  App calls BSNWavPlayQOAFile(); this feeds PCM to BSNWAV via callback.
 ***************************************************************/
@include <qoa.goh>
@include <bsnwav.goh>

#include <Ansi/string.h>
#include <Ansi/stdio.h>
#include <library.h>
#include <system.h>
#include <file.h>
#include <heap.h>
#include "../fmem_compat.h"

/* ------------ Internal static playback context ------------ */
/* BSNWAV's callback type has no user-data -> keep a static handle. */
#define QOA_SCRATCH_FRAMES          2048

static QOAHandle     *s_qoaHandle = 0;
static word           s_qoaChannels = 1;
static dword          s_totalFramesDecoded = 0;
static MemHandle      s_qoaScratchH = NullHandle;
static signed short  *s_qoaScratchP = 0;
static word           s_qoaScratchCapacityBytes = 0;

static Boolean QOA_VerifyDecoder(QOAHandle *qh, const QOAInfo *info);
static void    QOA_FreeScratch(void);
static Boolean QOA_EnsureScratch(word channels);

static void QOA_FreeScratch(void)
{
    if (s_qoaScratchH != NullHandle)
    {
        if (s_qoaScratchP)
        {
            MemUnlock(s_qoaScratchH);
        }
        MemFree(s_qoaScratchH);
    }

    s_qoaScratchH = NullHandle;
    s_qoaScratchP = 0;
    s_qoaScratchCapacityBytes = 0;
}

static Boolean QOA_EnsureScratch(word channels)
{
    word neededBytes;
    MemHandle scratchH;
    signed short *scratchP;

    if (channels == 0)
    {
        return FALSE;
    }

    neededBytes = (word)(QOA_SCRATCH_FRAMES * (word)channels * (word)sizeof(signed short));
    if (neededBytes == 0)
    {
        neededBytes = (word)((word)channels * (word)sizeof(signed short));
    }

    if (s_qoaScratchH != NullHandle &&
        s_qoaScratchP &&
        s_qoaScratchCapacityBytes >= neededBytes)
    {
        return TRUE;
    }

    QOA_FreeScratch();

    scratchH = MemAlloc(neededBytes, HF_SWAPABLE, HAF_ZERO_INIT);
    if (scratchH == NullHandle)
    {
        return FALSE;
    }

    scratchP = (signed short *)MemLock(scratchH);
    if (!scratchP)
    {
        MemFree(scratchH);
        return FALSE;
    }

    s_qoaScratchH = scratchH;
    s_qoaScratchP = scratchP;
    s_qoaScratchCapacityBytes = neededBytes;
    return TRUE;
}

static Boolean QOA_VerifyDecoder(QOAHandle *qh, const QOAInfo *info)
{
    MemHandle      bufferH;
    signed short  *bufferP;
    dword          framesRequested;
    dword          framesDecoded;
    word           bufferSize;
    Boolean        success;

    framesRequested = 4096;
    success = FALSE;

    if (!info || info->channels == 0)
    {
        return FALSE;
    }

    bufferSize = (word)(framesRequested * (dword)info->channels * sizeof(signed short));
    if (bufferSize == 0)
    {
        return FALSE;
    }

    bufferH = MemAlloc(bufferSize, HF_SWAPABLE, HAF_ZERO_INIT);
    if (bufferH == NullHandle)
    {
        return FALSE;
    }

    bufferP = (signed short*)MemLock(bufferH);
    if (!bufferP)
    {
        MemFree(bufferH);
        return FALSE;
    }

    framesDecoded = qoaReadS16(qh, framesRequested, bufferP);
    if (framesDecoded > 0)
    {
        success = TRUE;
    }

    MemUnlock(bufferH);
    MemFree(bufferH);

    if (!qoaSeek(qh, 0))
    {
        // failed to seek to start
        success = FALSE;
    }

    return success;
}

void _pascal QOA_ResetStaticState(void)
{
    QOA_FreeScratch();

    s_qoaHandle = 0;
    s_qoaChannels = 1;
    s_totalFramesDecoded = 0;
}

/* BSNWAV will invoke this */
static Boolean _pascal BSNWavQOACallback(void *dstBuf, word wantBytes)
{
    byte far *dstFar;
    word blockAlign;
    word totalFramesWanted;
    word framesProduced;
    Boolean finished;
    word producedBytes;

    if (!s_qoaHandle || !dstBuf || wantBytes == 0 || s_qoaChannels == 0)
    {
        return 1; /* signal error -> BSNW stops */
    }

    blockAlign = (word)(s_qoaChannels * 2u);
    if (blockAlign == 0)
    {
        return 1;
    }

    if (!QOA_EnsureScratch(s_qoaChannels))
    {
        return 1;
    }

    dstFar = (byte far *)dstBuf;
    totalFramesWanted = (word)(wantBytes / blockAlign);
    framesProduced = 0;
    finished = FALSE;

    while (framesProduced < totalFramesWanted)
    {
        word framesRemaining;
        word scratchFrames;
        dword framesDecoded;
        word bytesToCopy;
        word producedBytes;

        scratchFrames = (word)(s_qoaScratchCapacityBytes / blockAlign);
        if (scratchFrames == 0)
        {
            finished = TRUE;
            break;
        }

        framesRemaining = (word)(totalFramesWanted - framesProduced);
        if (scratchFrames > framesRemaining)
        {
            scratchFrames = framesRemaining;
        }

        framesDecoded = qoaReadS16(s_qoaHandle,
                                   (dword)scratchFrames,
                                   s_qoaScratchP);
        if (framesDecoded == 0)
        {
            finished = TRUE;
            break;
        }

        bytesToCopy = (word)(framesDecoded * (dword)blockAlign);
        producedBytes = (word)(framesProduced * blockAlign);

        _fmemcpy(dstFar + producedBytes,
                 s_qoaScratchP,
                 bytesToCopy);

        framesProduced += (word)framesDecoded;
        s_totalFramesDecoded += framesDecoded;

        if (framesDecoded < (dword)scratchFrames)
        {
            finished = TRUE;
            break;
        }
    }

    producedBytes = (word)(framesProduced * blockAlign);
    if ((dword)producedBytes < (dword)wantBytes)
    {
        _fmemset(dstFar + producedBytes,
                    0,
                    (word)((dword)wantBytes - producedBytes));
    }

    return finished;
}

/* ------------ Public player API ------------ */

int _pascal _export BSNWavPlayQOAFile(FileHandle fh, word playFlags, optr parent)
{
    QOAHandle      *qh;
    QOAInfo         info;
    BSWavFormChunk  fmt;
    dword           totalBytes;
    int             status;

    qh = qoaOpenGEOS(fh, &info);
    if (!qh)
    {
        return BSNW_UNKNOWN_WAVE_FORMAT;
    }

    s_qoaHandle   = qh;
    s_qoaChannels = info.channels;

    if (!QOA_VerifyDecoder(qh, &info))
    {
        qoaClose(qh);
        QOA_ResetStaticState();
        return BSNW_UNKNOWN_WAVE_FORMAT;
    }

    if (!QOA_EnsureScratch(info.channels))
    {
        qoaClose(qh);
        QOA_ResetStaticState();
        return BSNW_MEMORY_ERROR;
    }

    fmt.BWFC_dataFormat    = 1; /* PCM */
    fmt.BWFC_channels      = info.channels;
    fmt.BWFC_sampleRate    = info.sampleRate;
    fmt.BWFC_bitsPerSample = 16;
    fmt.BWFC_blockAlign    = (word)(info.channels * 2);
    fmt.BWFC_avgRate       = (dword)fmt.BWFC_blockAlign * info.sampleRate;

    totalBytes = (dword)info.totalFrames * (dword)fmt.BWFC_blockAlign;

    status = BSNWavePlayCallback(&fmt,
                                 totalBytes,
                                 playFlags,
                                 parent,
                                 (PlayCallbackFunctionType*) BSNWavQOACallback);
    qoaClose(qh);

    QOA_ResetStaticState();
    return status;
}

void _pascal _export BSNWavStopQOA(void)
{
    BSNWaveStop();
    QOA_ResetStaticState();
}
