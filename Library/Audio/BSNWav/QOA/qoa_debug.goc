#include "qoa_debug.h"

#ifndef QOA_DEBUG_LOGGING
#define QOA_DEBUG_LOGGING 0
#endif

#ifdef QOA_DEBUG_LOGGING

#include <stdarg.h>
#include <Ansi/string.h>
#include <Ansi/stdio.h>
#include <file.h>

#define QOA_DEBUG_BUFFER_SIZE      4096
#define QOA_DEBUG_MAX_FILENAME     32
#define QOA_DEBUG_MAX_LINE         160

typedef struct
{
    char            fileName[QOA_DEBUG_MAX_FILENAME];
    unsigned short  bufferUsed;
    unsigned short  droppedCount;
    unsigned char   sessionActive;
    unsigned char   needTruncate;
    char            buffer[QOA_DEBUG_BUFFER_SIZE];
} QOADebugState;

static QOADebugState gQoaDebugState = {
    "QOA.LOG",
    0,
    0,
    0,
    1,
    {0}
};
static Boolean gQoaVerboseEnabled = (QOA_DEBUG_VERBOSE ? TRUE : FALSE);

static void QOADebugCopyName(const char *fileName)
{
    if (fileName && fileName[0])
    {
        strncpy(gQoaDebugState.fileName,
                fileName,
                (QOA_DEBUG_MAX_FILENAME - 1));
        gQoaDebugState.fileName[QOA_DEBUG_MAX_FILENAME - 1] = '\0';
    }
    else
    {
        strcpy(gQoaDebugState.fileName, "QOA.LOG");
    }
}

void QOADebug_Reset(const char *fileName)
{
    if (gQoaDebugState.sessionActive)
    {
        QOADebug_Flush();
    }

    gQoaDebugState.bufferUsed = 0;
    gQoaDebugState.droppedCount = 0;
    gQoaDebugState.sessionActive = 1;
    gQoaDebugState.needTruncate = 1;
    QOADebugCopyName(fileName);
}

void QOADebug_Log(const char *fmt, ...)
{
    va_list ap;

    va_start(ap, fmt);
    QOADebug_LogV(fmt, ap);
    va_end(ap);
}

void QOADebug_LogV(const char *fmt, va_list ap)
{
    char line[QOA_DEBUG_MAX_LINE];
    unsigned short len;

    if (!gQoaDebugState.sessionActive || !fmt)
    {
        return;
    }

    vsprintf(line, fmt, ap);

    len = (unsigned short)strlen(line);
    if (len > (QOA_DEBUG_MAX_LINE - 3))
    {
        len = (QOA_DEBUG_MAX_LINE - 3);
        line[len] = '\0';
    }

    line[len++] = '\r';
    line[len++] = '\n';
    line[len] = '\0';

    if (len > (QOA_DEBUG_BUFFER_SIZE - gQoaDebugState.bufferUsed))
    {
        gQoaDebugState.droppedCount++;
        return;
    }

    memcpy(gQoaDebugState.buffer + gQoaDebugState.bufferUsed,
           line,
           len);
    gQoaDebugState.bufferUsed += len;
}

#if QOA_DEBUG_VERBOSE
void QOADebug_LogVerbose(const char *fmt, ...)
{
    va_list ap;

    if (!gQoaVerboseEnabled)
    {
        return;
    }

    va_start(ap, fmt);
    QOADebug_LogV(fmt, ap);
    va_end(ap);
}

void QOADebug_LogVerboseV(const char *fmt, va_list ap)
{
    if (!gQoaVerboseEnabled)
    {
        return;
    }

    QOADebug_LogV(fmt, ap);
}
#else
void QOADebug_LogVerbose(const char *fmt, ...)
{
    (void)fmt;
}

void QOADebug_LogVerboseV(const char *fmt, va_list ap)
{
    (void)fmt;
    (void)ap;
}
#endif

void QOADebug_Flush(void)
{
    FileHandle      fh;
    FileCreateFlags flags;
    char            dropLine[40];

    if (!gQoaDebugState.sessionActive)
    {
        return;
    }

    if ((gQoaDebugState.bufferUsed == 0) &&
        (gQoaDebugState.droppedCount == 0))
    {
        return;
    }

    flags = (FILE_ACCESS_RW | FILE_DENY_NONE | FCF_NATIVE);
    if (gQoaDebugState.needTruncate)
    {
        flags |= FILE_CREATE_TRUNCATE;
    }
    else
    {
        flags |= FILE_CREATE_NO_TRUNCATE;
    }

    FilePushDir();
    FileSetStandardPath(SP_DOCUMENT);
    fh = FileCreate(gQoaDebugState.fileName, flags, FA_ARCHIVE);
    FilePopDir();

    if (!fh)
    {
        fh = FileCreate(gQoaDebugState.fileName, flags, FA_ARCHIVE);
        if (!fh)
        {
            return;
        }
    }

    if (!gQoaDebugState.needTruncate)
    {
        FilePos(fh, 0, FILE_POS_END);
    }
    gQoaDebugState.needTruncate = 0;

    if (gQoaDebugState.bufferUsed > 0)
    {
        FileWrite(fh,
                  (void*)(gQoaDebugState.buffer),
                  gQoaDebugState.bufferUsed,
                  FALSE);
        gQoaDebugState.bufferUsed = 0;
    }

    if (gQoaDebugState.droppedCount > 0)
    {
        unsigned short dropLen;

        sprintf(dropLine,
                "[drops:%u]",
                gQoaDebugState.droppedCount);
        dropLen = (unsigned short)strlen(dropLine);
        dropLine[dropLen++] = '\r';
        dropLine[dropLen++] = '\n';
        FileWrite(fh, (void*)dropLine, dropLen, FALSE);
        gQoaDebugState.droppedCount = 0;
    }

    FileClose(fh, TRUE);
}

void QOADebug_EndSession(void)
{
    if (!gQoaDebugState.sessionActive)
    {
        return;
    }

    QOADebug_Flush();
    gQoaDebugState.sessionActive = 0;
}

void QOADebug_SetVerbose(Boolean enable)
{
    gQoaVerboseEnabled = enable ? TRUE : FALSE;
}

Boolean QOADebug_IsVerbose(void)
{
    return gQoaVerboseEnabled;
}

#else  /* QOA_DEBUG_LOGGING */

void QOADebug_Reset(const char *fileName)
{
    (void)fileName;
}

void QOADebug_Log(const char *fmt, ...)
{
    (void)fmt;
}

void QOADebug_LogV(const char *fmt, va_list ap)
{
    (void)fmt;
    (void)ap;
}

void QOADebug_LogVerbose(const char *fmt, ...)
{
    (void)fmt;
}

void QOADebug_LogVerboseV(const char *fmt, va_list ap)
{
    (void)fmt;
    (void)ap;
}

void QOADebug_Flush(void)
{
}

void QOADebug_EndSession(void)
{
}

void QOADebug_SetVerbose(Boolean enable)
{
    (void)enable;
}

Boolean QOADebug_IsVerbose(void)
{
    return FALSE;
}

#endif /* QOA_DEBUG_LOGGING */
