/***************************************************************
 *  qoa_decode.goc — Pure QOA decoder (no sound output)
 *  PC/GEOS, GOC/C89, small memory footprint, streaming decode.
 ***************************************************************/

@include <qoa.goh>

#include <library.h>
#include <driver.h>
#include <initfile.h>
#include <geode.h>
#include <ec.h>
#include <system.h>

#include <Ansi/string.h>
#include <Ansi/stdio.h>
#include <file.h>
#include <heap.h>

/* ---------- QOA on-wire constants ---------- */
#define QOA_MAGIC               0x716f6166UL /* 'qoaf' big-endian */
#define QOA_MAX_CHANNELS        8
#define QOA_LMS_LEN             4
#define QOA_SLICE_LEN           20          /* samples per slice */
#define QOA_SLICES_PER_FRAME    256         /* maximum slices in a frame */

/* ---------- Dequantization table (from reference) ---------- */
static const int qoa_dequant_tab[16][8] = {
    {   1,   -1,    3,   -3,    5,   -5,    7,   -7},
    {   5,   -5,   18,  -18,   32,  -32,   49,  -49},
    {  16,  -16,   53,  -53,   95,  -95,  147, -147},
    {  34,  -34,  113, -113,  203, -203,  315, -315},
    {  63,  -63,  210, -210,  378, -378,  588, -588},
    { 104, -104,  345, -345,  621, -621,  966, -966},
    { 158, -158,  528, -528,  950, -950, 1477,-1477},
    { 228, -228,  760, -760, 1368,-1368, 2128,-2128},
    { 316, -316, 1053,-1053, 1895,-1895, 2947,-2947},
    { 422, -422, 1405,-1405, 2529,-2529, 3934,-3934},
    { 548, -548, 1828,-1828, 3290,-3290, 5117,-5117},
    { 696, -696, 2320,-2320, 4176,-4176, 6496,-6496},
    { 868, -868, 2893,-2893, 5207,-5207, 8099,-8099},
    {1064,-1064, 3548,-3548, 6386,-6386, 9933,-9933},
    {1286,-1286, 4288,-4288, 7718,-7718,12005,-12005},
    {1536,-1536, 5120,-5120, 9216,-9216,14336,-14336},
};

/* ---------- LMS predictor (16-bit state, 32-bit accumulator) ---------- */
typedef struct
{
    short history[QOA_LMS_LEN];
    short weights[QOA_LMS_LEN];
} QOALMS;

static long QOA_LMS_Predict(QOALMS *l)
{
    long acc;
    acc = ((long)l->weights[0] * (long)l->history[0])
        + ((long)l->weights[1] * (long)l->history[1])
        + ((long)l->weights[2] * (long)l->history[2])
        + ((long)l->weights[3] * (long)l->history[3]);
    return acc >> 13;
}

static void QOA_LMS_Update(QOALMS *l, short sample, long residual)
{
    long delta;
    delta = residual >> 4;

    l->weights[0] += (l->history[0] < 0) ? (short)(-delta) : (short)delta;
    l->weights[1] += (l->history[1] < 0) ? (short)(-delta) : (short)delta;
    l->weights[2] += (l->history[2] < 0) ? (short)(-delta) : (short)delta;
    l->weights[3] += (l->history[3] < 0) ? (short)(-delta) : (short)delta;

    l->history[0] = l->history[1];
    l->history[1] = l->history[2];
    l->history[2] = l->history[3];
    l->history[3] = sample;
}

static short QOA_ClampS16(long v)
{
    if (v < -32768) return -32768;
    if (v > 32767) return 32767;
    return (short)v;
}

/* ---------- Bulk code unpacker ---------- */
static void QOA_Unpack20Codes(const byte *slice8, byte *codes20)
{
    word bitPos;
    word byteIdx;
    byte bitOfs;
    word i;

    /* QOA slice: byte 0 high nibble = scale, remaining 60 bits = 20×3-bit codes */
    /* Process MSB-first: codes are packed from byte 0 low nibble onward */

    bitPos = 4;  /* Start after 4-bit scale factor */

    for (i = 0; i < 20; i++)
    {
        byte code;

        byteIdx = bitPos >> 3;       /* bitPos / 8 */
        bitOfs = (byte)(bitPos & 7); /* bitPos % 8 */

        if (bitOfs <= 5)
        {
            /* Code fits within current byte */
            code = (byte)((slice8[byteIdx] >> (5 - bitOfs)) & 0x07);
        }
        else
        {
            /* Code spans two bytes */
            byte highBits;
            byte lowBits;
            byte shift;

            shift = (byte)(bitOfs - 5);
            highBits = (byte)((slice8[byteIdx] << shift) & 0x07);
            lowBits = (byte)(slice8[byteIdx + 1] >> (8 - shift));
            code = (byte)(highBits | lowBits);
        }

        codes20[i] = code;
        bitPos += 3;
    }
}

/* ---------- Optimized LMS decoder for one slice ---------- */
static void QOA_DecodeSliceC(QOALMS *lms, byte scalefactor, const byte *codes20,
                              word numSamples, short *outPCM)
{
    const int *dequant;
    word i;

    dequant = qoa_dequant_tab[scalefactor & 0x0F];

    for (i = 0; i < numSamples; i++)
    {
        long pred;
        long deq;
        long recon;
        short sample;

        deq = (long)dequant[codes20[i] & 0x07];
        pred = QOA_LMS_Predict(lms);
        recon = pred + deq;
        sample = QOA_ClampS16(recon);

        outPCM[i] = sample;
        QOA_LMS_Update(lms, sample, deq);
    }
}

/* ---------- Decoder state ---------- */
#define QOA_INPUT_BUF_SIZE 8192  /* 8 KiB ring buffer */

struct _QOAHandle
{
    MemHandle   selfHandle;
    FileHandle  fileH;
    QOAInfo     info;

    /* File-global */
    dword       pcmCursor;             /* frames output so far */
    Boolean     eofReached;

    /* Current frame header */
    word        frameChannels;
    dword       frameSampleRate;
    word        frameSamplesTotal;     /* fsamples for this frame */
    word        frameSamplesLeft;      /* remaining in this frame */
    word        frameDataBytesLeft;    /* bytes of slices remaining */

    QOALMS      lms[QOA_MAX_CHANNELS];

    /* Current slice group (one 8B slice per channel) */
    Boolean     sliceGroupActive;
    word        sliceGroupLen;         /* 1..20 */
    word        sliceGroupPos;         /* 0..sliceGroupLen */

    byte        scalefactor[QOA_MAX_CHANNELS];
    byte        lastSlice[QOA_MAX_CHANNELS][8];  /* cached slice data */
    short       decodeBuf[QOA_MAX_CHANNELS][QOA_SLICE_LEN];  /* decoded PCM cache */

    /* Input ring buffer for coalesced I/O */
    byte        inputBuf[QOA_INPUT_BUF_SIZE];
    word        inputBufPos;           /* read position */
    word        inputBufValid;         /* valid bytes in buffer */
};

/* ---------- Local helpers ---------- */
static int QOA_ReadN(QOAHandle *q, byte *dst, word len)
{
    word copied;

    copied = 0;

    while (copied < len)
    {
        word avail;
        word toCopy;

        avail = q->inputBufValid - q->inputBufPos;

        if (avail == 0)
        {
            word rd;

            /* Refill buffer */
            rd = FileRead(q->fileH, (void*)q->inputBuf, QOA_INPUT_BUF_SIZE, FALSE);
            if (rd == 0)
            {
                return 0;
            }

            q->inputBufPos = 0;
            q->inputBufValid = rd;
            avail = rd;
        }

        toCopy = (len - copied);
        if (toCopy > avail)
        {
            toCopy = avail;
        }

        (void)memcpy((void*)(dst + copied), (const void*)(q->inputBuf + q->inputBufPos), toCopy);
        q->inputBufPos += toCopy;
        copied += toCopy;
    }

    return 1;
}

static int  QOA_Read8(FileHandle fh, byte *dst, word len)
{
    word rd;
    rd = FileRead(fh, dst, len, FALSE);
    return (rd == len);
}

static int  QOA_ReadFileHeader(QOAHandle *q, dword *samplesOut)
{
    byte  hdr[8];
    dword magic;
    dword samples;

    if (!QOA_Read8(q->fileH, hdr, 8)) return 0;

    magic = ((dword)hdr[0] << 24) | ((dword)hdr[1] << 16) | ((dword)hdr[2] << 8) | (dword)hdr[3];
    if (magic != QOA_MAGIC) return 0;

    samples = ((dword)hdr[4] << 24) | ((dword)hdr[5] << 16) | ((dword)hdr[6] << 8) | (dword)hdr[7];
    *samplesOut = samples;
    return 1;
}

static int  QOA_PeekFirstFrameHeader(QOAHandle *q, word *channelsOut, dword *rateOut)
{
    byte  fh[8];
    dword savedPos;
    word  ch;
    dword sr;

    savedPos = FilePos(q->fileH, 0, FILE_POS_RELATIVE);
    FilePos(q->fileH, 8, FILE_POS_START);

    if (!QOA_Read8(q->fileH, fh, 8))
    {
        FilePos(q->fileH, savedPos, FILE_POS_START);
        return 0;
    }

    ch = (word)fh[0];
    sr = ((dword)fh[1] << 16) | ((dword)fh[2] << 8) | (dword)fh[3];

    *channelsOut = ch;
    *rateOut     = sr;

    FilePos(q->fileH, savedPos, FILE_POS_START);
    return 1;
}

static int  QOA_LoadNextFrame(QOAHandle *q)
{
    byte fh[8];
    dword channels;
    dword samplerate;
    word  fsamples;
    word  fsize;
    word  dataBytes;
    word  expectedBytes;
    word  slices;
    word  c;
    byte  buf[8];

    if (!QOA_ReadN(q, fh, 8))
    {
        q->eofReached = TRUE;
        return 0;
    }

    channels   = (dword)fh[0];
    samplerate = ((dword)fh[1] << 16) | ((dword)fh[2] << 8) | (dword)fh[3];
    fsamples   = (word)(((dword)fh[4] << 8) | (dword)fh[5]);
    fsize      = (word)(((dword)fh[6] << 8) | (dword)fh[7]);

    if (channels == 0 || channels > QOA_MAX_CHANNELS)
    {
        q->eofReached = TRUE;
        return 0;
    }

    if (samplerate == 0)
    {
        q->eofReached = TRUE;
        return 0;
    }

    if ((word)channels != q->info.channels || samplerate != q->info.sampleRate)
    {
        // QOA frame mismatch
        q->eofReached = TRUE;
        return 0;
    }

    if (fsamples == 0 || fsamples > (QOA_SLICES_PER_FRAME * QOA_SLICE_LEN))
    {
        // QOA fsamples invalid
        q->eofReached = TRUE;
        return 0;
    }

    if (fsize < (word)(8 + QOA_LMS_LEN * 4 * (word)channels))
    {
        // QOA fsize too small
        q->eofReached = TRUE;
        return 0;
    }

    dataBytes = (word)(fsize - 8 - QOA_LMS_LEN * 4 * (word)channels);

    slices = (word)((fsamples + (QOA_SLICE_LEN - 1)) / QOA_SLICE_LEN);
    expectedBytes = (word)(slices * (word)channels * 8);

    if (dataBytes != expectedBytes)
    {
        // QOA data len mismatch
        q->eofReached = TRUE;
        return 0;
    }

    for (c = 0; c < (word)channels; c++)
    {
        word i;
        short v;

        if (!QOA_ReadN(q, buf, 8)) { q->eofReached = TRUE; return 0; }
        for (i = 0; i < QOA_LMS_LEN; i++)
        {
            v = (short)(((word)buf[i*2] << 8) | (word)buf[i*2 + 1]);
            q->lms[c].history[i] = v;
        }

        if (!QOA_ReadN(q, buf, 8)) { q->eofReached = TRUE; return 0; }
        for (i = 0; i < QOA_LMS_LEN; i++)
        {
            v = (short)(((word)buf[i*2] << 8) | (word)buf[i*2 + 1]);
            q->lms[c].weights[i] = v;
        }
    }

    q->frameChannels      = (word)channels;
    q->frameSampleRate    = samplerate;
    q->frameSamplesTotal  = fsamples;
    q->frameSamplesLeft   = fsamples;
    q->frameDataBytesLeft = dataBytes;

    q->sliceGroupActive   = FALSE;
    q->sliceGroupLen      = 0;
    q->sliceGroupPos      = 0;

    return 1;
}

static int  QOA_LoadNextSliceGroup(QOAHandle *q)
{
    word c;

    if (q->frameSamplesLeft == 0)
    {
        return 0;
    }

    q->sliceGroupLen = (q->frameSamplesLeft > QOA_SLICE_LEN) ? QOA_SLICE_LEN : q->frameSamplesLeft;
    q->sliceGroupPos = 0;

    for (c = 0; c < q->frameChannels; c++)
    {
        if (q->frameDataBytesLeft < 8)
        {
            q->eofReached = TRUE;
            return 0;
        }

        if (!QOA_ReadN(q, q->lastSlice[c], 8))
        {
            q->eofReached = TRUE;
            return 0;
        }

        q->frameDataBytesLeft -= 8;
        q->scalefactor[c] = (byte)((q->lastSlice[c][0] >> 4) & 0x0F);
    }

    q->sliceGroupActive = TRUE;
    return 1;
}

static word QOA_ProduceFromFrame(QOAHandle *q, word maxFrames, signed short *outPCM)
{
    word produced;
    word channels;
    signed short *frameDst;
    QOALMS *lms;

    produced = 0;
    channels = q->frameChannels;
    frameDst = outPCM;
    lms = q->lms;

    while ((produced < maxFrames) && (q->frameSamplesLeft > 0))
    {
        word framesThis;
        word i;

        if (!q->sliceGroupActive)
        {
            if (!QOA_LoadNextSliceGroup(q))
            {
                break;
            }
        }

        /* Decode entire slice into buffer on first access */
        if (q->sliceGroupPos == 0)
        {
            word ch;
            byte codes[20];

            for (ch = 0; ch < channels; ch++)
            {
                QOA_Unpack20Codes(q->lastSlice[ch], codes);
                QOA_DecodeSliceC(&lms[ch], q->scalefactor[ch], codes,
                                 q->sliceGroupLen, q->decodeBuf[ch]);
            }
        }

        /* Serve from decode buffer */
        framesThis = q->sliceGroupLen - q->sliceGroupPos;
        if (framesThis > (word)(maxFrames - produced))
        {
            framesThis = (word)(maxFrames - produced);
        }

        /* Copy interleaved samples from decode buffer */
        for (i = 0; i < framesThis; i++)
        {
            word ch;
            word srcIdx;

            srcIdx = q->sliceGroupPos + i;
            for (ch = 0; ch < channels; ch++)
            {
                *frameDst++ = q->decodeBuf[ch][srcIdx];
            }
        }

        q->sliceGroupPos += framesThis;
        q->frameSamplesLeft -= framesThis;
        produced += framesThis;

        if (q->sliceGroupPos >= q->sliceGroupLen)
        {
            q->sliceGroupActive = FALSE;
        }
    }

    return produced;
}

/* ---------- Public decoder API ---------- */

QOAHandle * _pascal qoaOpenGEOS(FileHandle fh, QOAInfo *outInfo)
{
    QOAHandle *q;
    MemHandle  h;
    dword      samples;
    word       ch;
    dword      sr;

    h = MemAlloc((word)sizeof(QOAHandle), HF_SWAPABLE, HAF_ZERO_INIT);
    if (h == NullHandle)
    {
        return 0;
    }

    q = (QOAHandle*)MemLock(h);
    if (!q)
    {
        MemFree(h);
        return 0;
    }

    q->selfHandle = h;
    q->fileH      = fh;
    q->eofReached = FALSE;
    q->pcmCursor  = 0;
    q->inputBufPos = 0;
    q->inputBufValid = 0;

    if (!QOA_ReadFileHeader(q, &samples))
    {
        MemUnlock(h);
        MemFree(h);
        return 0;
    }

    if (!QOA_PeekFirstFrameHeader(q, &ch, &sr))
    {
        MemUnlock(h);
        MemFree(h);
        return 0;
    }

    if (ch == 0)
    {
        MemUnlock(h);
        MemFree(h);
        return 0;
    }

    q->info.channels      = ch;
    q->info.sampleRate    = sr;
    q->info.bitsPerSample = 16;
    q->info.totalFrames   = 0;

    /* Convert total sample count to per-channel frame count, rounding down.
     * Leave totalFrames at zero if the metadata is malformed so later checks fail. */
    if (samples >= (dword)ch)
    {
        q->info.totalFrames = samples / (dword)ch;
    }

    FilePos(q->fileH, 8, FILE_POS_START);

    if (!QOA_LoadNextFrame(q))
    {
        MemUnlock(h);
        MemFree(h);
        return 0;
    }

    if (outInfo)
    {
        *outInfo = q->info;
    }

    /* Keep locked for simplicity; this object is small. */
    return q;
}

dword _pascal qoaReadS16(QOAHandle *q, dword framesToRead, signed short *dst)
{
    dword produced;
    word  chunk;

    produced = 0;

    if (!q || !dst || framesToRead == 0)
    {
        return 0;
    }

    while (framesToRead > 0)
    {
        word got;

        if (q->frameSamplesLeft == 0)
        {
            if (!QOA_LoadNextFrame(q))
            {
                // qoaReadS16: no more frames
                break;
            }
        }

        chunk = (framesToRead > 512UL) ? 512 : (word)framesToRead;
        got = QOA_ProduceFromFrame(q, chunk, dst);

        if (got == 0)
        {
            break;
        }

        dst          += (dword)got * (dword)q->info.channels;
        framesToRead -= got;
        produced     += got;
        q->pcmCursor += got;
    }

    return produced;
}

int _pascal qoaSeek(QOAHandle *q, dword frameIndex)
{
    dword remaining;
    MemHandle scratchH;
    signed short *scratchP;

    if (!q)
    {
        return 0;
    }

    if (frameIndex > q->info.totalFrames)
    {
        frameIndex = q->info.totalFrames;
    }

    /* Reset to first frame */
    FilePos(q->fileH, 8, FILE_POS_START);

    q->eofReached = FALSE;
    q->pcmCursor  = 0;
    q->inputBufPos = 0;
    q->inputBufValid = 0;

    if (!QOA_LoadNextFrame(q))
    {
        return 0;
    }

    remaining = frameIndex;

    scratchH = MemAlloc((word)(512U * q->info.channels * sizeof(signed short)),
                        HF_SWAPABLE, HAF_ZERO_INIT);
    if (scratchH == NullHandle)
    {
        return 0;
    }
    scratchP = (signed short*)MemLock(scratchH);
    if (!scratchP)
    {
        MemFree(scratchH);
        return 0;
    }

    while (remaining > 0)
    {
        word want;
        word got;

        want = (remaining > 512UL) ? 512 : (word)remaining;
        got  = (word)qoaReadS16(q, (dword)want, scratchP);
        if (got == 0)
        {
            break;
        }
        remaining -= got;
    }

    MemUnlock(scratchH);
    MemFree(scratchH);

    q->pcmCursor = frameIndex;
    return 1;
}

Boolean _pascal _export BSNWavProbeQOAFile(FileHandle fh, QOAInfo *outInfo)
{
    QOAHandle *qh;
    QOAInfo    tmp;
    Boolean    ok;

    if (!fh)
    {
        return FALSE;
    }

    FilePos(fh, 0, FILE_POS_START);

    qh = qoaOpenGEOS(fh, &tmp);
    if (!qh)
    {
        FilePos(fh, 0, FILE_POS_START);
        return FALSE;
    }

    if (outInfo)
    {
        *outInfo = tmp;
    }

    qoaClose(qh);
    ok = TRUE;

    FilePos(fh, 0, FILE_POS_START);
    return ok;
}

void _pascal qoaClose(QOAHandle *q)
{
    MemHandle h;

    if (!q) return;

    h = q->selfHandle;
    if (h == NullHandle)
    {
        return;
    }

    q->selfHandle = NullHandle;
    MemUnlock(h);
    MemFree(h);
}
