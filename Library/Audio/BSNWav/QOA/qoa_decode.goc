/***************************************************************
 *  qoa_decode.goc â€” Pure QOA decoder (no sound output)
 *  PC/GEOS, GOC/C89, small memory footprint, streaming decode.
 ***************************************************************/

@include <qoa.goh>

#include <library.h>
#include <driver.h>
#include <initfile.h>
#include <geode.h>
#include <ec.h>
#include <system.h>

#include <Ansi/string.h>
#include <Ansi/stdio.h>
#include <file.h>
#include <heap.h>

/* ---------- QOA on-wire constants ---------- */
#define QOA_MAGIC               0x716f6166UL /* 'qoaf' big-endian */
#define QOA_MAX_CHANNELS        8
#define QOA_LMS_LEN             4
#define QOA_SLICE_LEN           20          /* samples per slice */
#define QOA_SLICES_PER_FRAME    256         /* maximum slices in a frame */

/* ---------- Dequantization table (from reference) ---------- */
static const int qoa_dequant_tab[16][8] = {
    {   1,   -1,    3,   -3,    5,   -5,    7,   -7},
    {   5,   -5,   18,  -18,   32,  -32,   49,  -49},
    {  16,  -16,   53,  -53,   95,  -95,  147, -147},
    {  34,  -34,  113, -113,  203, -203,  315, -315},
    {  63,  -63,  210, -210,  378, -378,  588, -588},
    { 104, -104,  345, -345,  621, -621,  966, -966},
    { 158, -158,  528, -528,  950, -950, 1477,-1477},
    { 228, -228,  760, -760, 1368,-1368, 2128,-2128},
    { 316, -316, 1053,-1053, 1895,-1895, 2947,-2947},
    { 422, -422, 1405,-1405, 2529,-2529, 3934,-3934},
    { 548, -548, 1828,-1828, 3290,-3290, 5117,-5117},
    { 696, -696, 2320,-2320, 4176,-4176, 6496,-6496},
    { 868, -868, 2893,-2893, 5207,-5207, 8099,-8099},
    {1064,-1064, 3548,-3548, 6386,-6386, 9933,-9933},
    {1286,-1286, 4288,-4288, 7718,-7718,12005,-12005},
    {1536,-1536, 5120,-5120, 9216,-9216,14336,-14336},
};

/* ---------- LMS predictor ---------- */
typedef struct
{
    long history[QOA_LMS_LEN];
    long weights[QOA_LMS_LEN];
} QOALMS;

static long QOA_LMS_Predict(QOALMS *l)
{
    return (  (l->weights[0] * l->history[0])
            + (l->weights[1] * l->history[1])
            + (l->weights[2] * l->history[2])
            + (l->weights[3] * l->history[3]) ) >> 13;
}

static void QOA_LMS_Update(QOALMS *l, long sample, long residual)
{
    long delta;
    long *weights;
    long *history;

    delta   = residual >> 4;
    weights = l->weights;
    history = l->history;

    weights[0] += (history[0] < 0) ? -delta : delta;
    weights[1] += (history[1] < 0) ? -delta : delta;
    weights[2] += (history[2] < 0) ? -delta : delta;
    weights[3] += (history[3] < 0) ? -delta : delta;

    history[0] = history[1];
    history[1] = history[2];
    history[2] = history[3];
    history[3] = sample;
}

static int QOA_ClampS16(long v)
{
    if (v < -32768)
    {
        return -32768;
    }
    if (v > 32767)
    {
        return 32767;
    }
    return (int)v;
}

/* ---------- 8-byte MSB-first slice bit reader ---------- */
typedef struct
{
    byte data[8];
    byte bytePos; /* 0..7 */
    byte bitPos;  /* 0..7, 0 = MSB */
} QOABitsBE;

static void QBR_Init(QOABitsBE *br, const byte *src8)
{
    (void)memcpy((void*)br->data, (const void*)src8, 8);
    br->bytePos = 0;
    br->bitPos = 0;
}

static unsigned long QBR_Get(QOABitsBE *br, word nbits, int *ok)
{
    unsigned long val;
    word n;
    val = 0;
    n = nbits;

    while (n > 0)
    {
        byte cur;
        byte avail;
        byte take;
        byte mask;
        byte shift;
        byte bitsVal;

        if (br->bytePos >= 8)
        {
            *ok = 0;
            return 0;
        }

        cur = br->data[br->bytePos];
        avail = (byte)(8 - br->bitPos);
        take = (n < avail) ? (byte)n : avail;

        shift = (byte)(8 - br->bitPos - take);
        mask = (byte)(((1u << take) - 1u) << shift);
        bitsVal = (byte)((cur & mask) >> shift);

        val = (val << take) | bitsVal;

        br->bitPos += take;
        if (br->bitPos == 8)
        {
            br->bitPos = 0;
            br->bytePos++;
        }

        n -= take;
    }

    *ok = 1;
    return val;
}

/* ---------- Decoder state ---------- */
struct _QOAHandle
{
    MemHandle   selfHandle;
    FileHandle  fileH;
    QOAInfo     info;

    /* File-global */
    dword       pcmCursor;             /* frames output so far */
    Boolean     eofReached;

    /* Current frame header */
    word        frameChannels;
    dword       frameSampleRate;
    word        frameSamplesTotal;     /* fsamples for this frame */
    word        frameSamplesLeft;      /* remaining in this frame */
    word        frameDataBytesLeft;    /* bytes of slices remaining */

    QOALMS      lms[QOA_MAX_CHANNELS];

    /* Current slice group (one 8B slice per channel) */
    Boolean     sliceGroupActive;
    word        sliceGroupLen;         /* 1..20 */
    word        sliceGroupPos;         /* 0..sliceGroupLen */

    byte        scalefactor[QOA_MAX_CHANNELS];
    QOABitsBE   sliceBits[QOA_MAX_CHANNELS];
};

/* ---------- Local helpers ---------- */
static int  QOA_Read8(FileHandle fh, byte *dst, word len)
{
    word rd;
    rd = FileRead(fh, dst, len, FALSE);
    return (rd == len);
}

static int  QOA_ReadFileHeader(QOAHandle *q, dword *samplesOut)
{
    byte  hdr[8];
    dword magic;
    dword samples;

    if (!QOA_Read8(q->fileH, hdr, 8)) return 0;

    magic = ((dword)hdr[0] << 24) | ((dword)hdr[1] << 16) | ((dword)hdr[2] << 8) | (dword)hdr[3];
    if (magic != QOA_MAGIC) return 0;

    samples = ((dword)hdr[4] << 24) | ((dword)hdr[5] << 16) | ((dword)hdr[6] << 8) | (dword)hdr[7];
    *samplesOut = samples;
    return 1;
}

static int  QOA_PeekFirstFrameHeader(QOAHandle *q, word *channelsOut, dword *rateOut)
{
    byte  fh[8];
    dword savedPos;
    word  ch;
    dword sr;

    savedPos = FilePos(q->fileH, 0, FILE_POS_RELATIVE);
    FilePos(q->fileH, 8, FILE_POS_START);

    if (!QOA_Read8(q->fileH, fh, 8))
    {
        FilePos(q->fileH, savedPos, FILE_POS_START);
        return 0;
    }

    ch = (word)fh[0];
    sr = ((dword)fh[1] << 16) | ((dword)fh[2] << 8) | (dword)fh[3];

    *channelsOut = ch;
    *rateOut     = sr;

    FilePos(q->fileH, savedPos, FILE_POS_START);
    return 1;
}

static int  QOA_LoadNextFrame(QOAHandle *q)
{
    byte fh[8];
    dword channels;
    dword samplerate;
    word  fsamples;
    word  fsize;
    word  dataBytes;
    word  expectedBytes;
    word  slices;
    word  c;
    byte  buf[8];

    if (!QOA_Read8(q->fileH, fh, 8))
    {
        q->eofReached = TRUE;
        return 0;
    }

    channels   = (dword)fh[0];
    samplerate = ((dword)fh[1] << 16) | ((dword)fh[2] << 8) | (dword)fh[3];
    fsamples   = (word)(((dword)fh[4] << 8) | (dword)fh[5]);
    fsize      = (word)(((dword)fh[6] << 8) | (dword)fh[7]);

    if (channels == 0 || channels > QOA_MAX_CHANNELS)
    {
        q->eofReached = TRUE;
        return 0;
    }

    if (samplerate == 0)
    {
        q->eofReached = TRUE;
        return 0;
    }

    if ((word)channels != q->info.channels || samplerate != q->info.sampleRate)
    {
        // QOA frame mismatch
        q->eofReached = TRUE;
        return 0;
    }

    if (fsamples == 0 || fsamples > (QOA_SLICES_PER_FRAME * QOA_SLICE_LEN))
    {
        // QOA fsamples invalid
        q->eofReached = TRUE;
        return 0;
    }

    if (fsize < (word)(8 + QOA_LMS_LEN * 4 * (word)channels))
    {
        // QOA fsize too small
        q->eofReached = TRUE;
        return 0;
    }

    dataBytes = (word)(fsize - 8 - QOA_LMS_LEN * 4 * (word)channels);

    slices = (word)((fsamples + (QOA_SLICE_LEN - 1)) / QOA_SLICE_LEN);
    expectedBytes = (word)(slices * (word)channels * 8);

    if (dataBytes != expectedBytes)
    {
        // QOA data len mismatch
        q->eofReached = TRUE;
        return 0;
    }

    for (c = 0; c < (word)channels; c++)
    {
        word i;
        short v;

        if (!QOA_Read8(q->fileH, buf, 8)) { q->eofReached = TRUE; return 0; }
        for (i = 0; i < QOA_LMS_LEN; i++)
        {
            v = (short)(((word)buf[i*2] << 8) | (word)buf[i*2 + 1]);
            q->lms[c].history[i] = (long)v;
        }

        if (!QOA_Read8(q->fileH, buf, 8)) { q->eofReached = TRUE; return 0; }
        for (i = 0; i < QOA_LMS_LEN; i++)
        {
            v = (short)(((word)buf[i*2] << 8) | (word)buf[i*2 + 1]);
            q->lms[c].weights[i] = (long)v;
        }
    }

    q->frameChannels      = (word)channels;
    q->frameSampleRate    = samplerate;
    q->frameSamplesTotal  = fsamples;
    q->frameSamplesLeft   = fsamples;
    q->frameDataBytesLeft = dataBytes;

    q->sliceGroupActive   = FALSE;
    q->sliceGroupLen      = 0;
    q->sliceGroupPos      = 0;

    return 1;
}

static int  QOA_LoadNextSliceGroup(QOAHandle *q)
{
    word c;
    byte slice8[8];
    int  ok;

    if (q->frameSamplesLeft == 0)
    {
        return 0;
    }

    q->sliceGroupLen = (q->frameSamplesLeft > QOA_SLICE_LEN) ? QOA_SLICE_LEN : q->frameSamplesLeft;
    q->sliceGroupPos = 0;

    for (c = 0; c < q->frameChannels; c++)
    {
        if (q->frameDataBytesLeft < 8)
        {
            // slice: not enough bytes
            q->eofReached = TRUE;
            return 0;
        }

        if (!QOA_Read8(q->fileH, slice8, 8))
        {
            // slice: read failure
            q->eofReached = TRUE;
            return 0;
        }

        q->frameDataBytesLeft -= 8;

        QBR_Init(&q->sliceBits[c], slice8);
        ok = 1;
        q->scalefactor[c] = (byte)QBR_Get(&q->sliceBits[c], 4, &ok);
        if (!ok)
        {
            // slice scalefactor error
            q->eofReached = TRUE;
            return 0;
        }
    }

    q->sliceGroupActive = TRUE;
    return 1;
}

static word QOA_ProduceFromFrame(QOAHandle *q, word maxFrames, signed short *outPCM)
{
    word produced;
    word channels;
    signed short *frameDst;
    QOABitsBE    *sliceBits;
    QOALMS       *lms;
    byte         *scaleFactors;

    produced = 0;
    channels = q->frameChannels;
    frameDst = outPCM;
    sliceBits = q->sliceBits;
    lms = q->lms;
    scaleFactors = q->scalefactor;

    while ((produced < maxFrames) && (q->frameSamplesLeft > 0))
    {
        word framesThis;
        word i;

        if (!q->sliceGroupActive)
        {
            if (!QOA_LoadNextSliceGroup(q))
            {
                // failed to load slice group
                break;
            }
        }

        framesThis = q->sliceGroupLen - q->sliceGroupPos;
        if (framesThis > (word)(maxFrames - produced))
        {
            framesThis = (word)(maxFrames - produced);
        }

        if (channels == 2)
        {
            QOABitsBE *bits0;
            QOABitsBE *bits1;
            QOALMS    *lms0;
            QOALMS    *lms1;
            byte       scale0;
            byte       scale1;
            signed short *dstPtr;

            bits0  = &sliceBits[0];
            bits1  = &sliceBits[1];
            lms0   = &lms[0];
            lms1   = &lms[1];
            scale0 = scaleFactors[0];
            scale1 = scaleFactors[1];
            dstPtr = frameDst;

            for (i = 0; i < framesThis; i++)
            {
                int            ok;
                unsigned long  code3;
                long           deq;
                long           pred;
                long           recon;
                signed short   s0;
                signed short   s1;

                ok = 1;
                code3 = QBR_Get(bits0, 3, &ok);
                if (!ok)
                {
                    q->eofReached = TRUE;
                    return produced;
                }
                deq  = (long)qoa_dequant_tab[scale0 & 0x0f][(int)(code3 & 7)];
                pred = QOA_LMS_Predict(lms0);
                recon = (long)QOA_ClampS16(pred + deq);
                s0 = (signed short)recon;
                QOA_LMS_Update(lms0, (long)s0, deq);

                ok = 1;
                code3 = QBR_Get(bits1, 3, &ok);
                if (!ok)
                {
                    q->eofReached = TRUE;
                    return produced;
                }
                deq  = (long)qoa_dequant_tab[scale1 & 0x0f][(int)(code3 & 7)];
                pred = QOA_LMS_Predict(lms1);
                recon = (long)QOA_ClampS16(pred + deq);
                s1 = (signed short)recon;
                QOA_LMS_Update(lms1, (long)s1, deq);

                dstPtr[0] = s0;
                dstPtr[1] = s1;
                dstPtr   += 2;
            }

            frameDst = dstPtr;
        }
        else
        {
            for (i = 0; i < framesThis; i++)
            {
                word ch;
                signed short *dstPtr;

                dstPtr = frameDst;
                for (ch = 0; ch < channels; ch++)
                {
                    int            ok;
                    unsigned long  code3;
                    long           deq;
                    long           pred;
                    long           recon;
                    signed short   s;

                    ok = 1;
                    code3 = QBR_Get(&sliceBits[ch], 3, &ok);
                    if (!ok)
                    {
                        // bits read error
                        q->eofReached = TRUE;
                        return produced;
                    }

                    deq  = (long)qoa_dequant_tab[scaleFactors[ch] & 0x0f][(int)(code3 & 7)];
                    pred = QOA_LMS_Predict(&lms[ch]);
                    recon = (long)QOA_ClampS16(pred + deq);
                    s = (signed short)recon;

                    *dstPtr++ = s;

                    QOA_LMS_Update(&lms[ch], (long)s, deq);
                }
                frameDst += channels;
            }
        }

        q->sliceGroupPos    += framesThis;
        q->frameSamplesLeft -= framesThis;
        produced            += framesThis;

        if (q->sliceGroupPos >= q->sliceGroupLen)
        {
            q->sliceGroupActive = FALSE;
        }
    }

    return produced;
}

/* ---------- Public decoder API ---------- */

QOAHandle * _pascal qoaOpenGEOS(FileHandle fh, QOAInfo *outInfo)
{
    QOAHandle *q;
    MemHandle  h;
    dword      samples;
    word       ch;
    dword      sr;

    h = MemAlloc((word)sizeof(QOAHandle), HF_SWAPABLE, HAF_ZERO_INIT);
    if (h == NullHandle)
    {
        return 0;
    }

    q = (QOAHandle*)MemLock(h);
    if (!q)
    {
        MemFree(h);
        return 0;
    }

    q->selfHandle = h;
    q->fileH      = fh;
    q->eofReached = FALSE;
    q->pcmCursor  = 0;

    if (!QOA_ReadFileHeader(q, &samples))
    {
        MemUnlock(h);
        MemFree(h);
        return 0;
    }

    if (!QOA_PeekFirstFrameHeader(q, &ch, &sr))
    {
        MemUnlock(h);
        MemFree(h);
        return 0;
    }

    q->info.channels      = ch;
    q->info.sampleRate    = sr;
    q->info.totalFrames   = samples;
    q->info.bitsPerSample = 16;

    FilePos(q->fileH, 8, FILE_POS_START);

    if (!QOA_LoadNextFrame(q))
    {
        MemUnlock(h);
        MemFree(h);
        return 0;
    }

    if (outInfo)
    {
        *outInfo = q->info;
    }

    /* Keep locked for simplicity; this object is small. */
    return q;
}

dword _pascal qoaReadS16(QOAHandle *q, dword framesToRead, signed short *dst)
{
    dword produced;
    word  chunk;

    produced = 0;

    if (!q || !dst || framesToRead == 0)
    {
        return 0;
    }

    while (framesToRead > 0)
    {
        word got;

        if (q->frameSamplesLeft == 0)
        {
            if (!QOA_LoadNextFrame(q))
            {
                // qoaReadS16: no more frames
                break;
            }
        }

        chunk = (framesToRead > 512UL) ? 512 : (word)framesToRead;
        got = QOA_ProduceFromFrame(q, chunk, dst);

        if (got == 0)
        {
            break;
        }

        dst          += (dword)got * (dword)q->info.channels;
        framesToRead -= got;
        produced     += got;
        q->pcmCursor += got;
    }

    return produced;
}

int _pascal qoaSeek(QOAHandle *q, dword frameIndex)
{
    dword remaining;
    MemHandle scratchH;
    signed short *scratchP;

    if (!q)
    {
        return 0;
    }

    if (frameIndex > q->info.totalFrames)
    {
        frameIndex = q->info.totalFrames;
    }

    /* Reset to first frame */
    FilePos(q->fileH, 8, FILE_POS_START);

    q->eofReached = FALSE;
    q->pcmCursor  = 0;

    if (!QOA_LoadNextFrame(q))
    {
        return 0;
    }

    remaining = frameIndex;

    scratchH = MemAlloc((word)(512U * q->info.channels * sizeof(signed short)),
                        HF_SWAPABLE, HAF_ZERO_INIT);
    if (scratchH == NullHandle)
    {
        return 0;
    }
    scratchP = (signed short*)MemLock(scratchH);
    if (!scratchP)
    {
        MemFree(scratchH);
        return 0;
    }

    while (remaining > 0)
    {
        word want;
        word got;

        want = (remaining > 512UL) ? 512 : (word)remaining;
        got  = (word)qoaReadS16(q, (dword)want, scratchP);
        if (got == 0)
        {
            break;
        }
        remaining -= got;
    }

    MemUnlock(scratchH);
    MemFree(scratchH);

    q->pcmCursor = frameIndex;
    return 1;
}

Boolean _pascal _export BSNWavProbeQOAFile(FileHandle fh, QOAInfo *outInfo)
{
    QOAHandle *qh;
    QOAInfo    tmp;
    Boolean    ok;

    if (!fh)
    {
        return FALSE;
    }

    FilePos(fh, 0, FILE_POS_START);

    qh = qoaOpenGEOS(fh, &tmp);
    if (!qh)
    {
        FilePos(fh, 0, FILE_POS_START);
        return FALSE;
    }

    if (outInfo)
    {
        *outInfo = tmp;
    }

    qoaClose(qh);
    ok = TRUE;

    FilePos(fh, 0, FILE_POS_START);
    return ok;
}

void _pascal qoaClose(QOAHandle *q)
{
    MemHandle h;

    if (!q) return;

    h = q->selfHandle;
    if (h == NullHandle)
    {
        return;
    }

    q->selfHandle = NullHandle;
    MemUnlock(h);
    MemFree(h);
}
