// #pragma noroot
/************************************************
 * mp3_play.goc
 * - Open file, prime minimp3 stream, run BSNWav callback
 ************************************************/

#include <geos.h>
#include <geoworks.h>
#include <file.h>
#include <mem.h>
#include <sound.h>
#include <system.h>
#include <Ansi/string.h>
#include <Ansi/stdio.h>

@include <bsnwav.goh>
@include <mp3.goh>

#include "mp3_internal.h"

#define MP3_SCRATCH_FRAMES         2048
#define MP3_CALLBACK_LOG_DELAY     4

static MP3Handle    *s_mp3Handle       = 0;
static word          s_mp3Channels     = 0;
static MemHandle     s_mp3ScratchH     = NullHandle;
static sword        *s_mp3ScratchP     = 0;
static word          s_mp3ScratchBytes = 0;
static Boolean       s_mp3CallbackLogged = FALSE;
static word          s_mp3CallbackSkip   = MP3_CALLBACK_LOG_DELAY;

static WWFixed   _pascal BSNWavMP3VolumeFromPercent(word pct);
static Boolean          MP3_VerifyStream(MP3Handle *handleP);
static Boolean          MP3_EnsureScratch(word channels);
static void             MP3_FreeScratch(void);
static void             MP3_ResetStaticState(void);
static Boolean _pascal  BSNWavMP3Callback(void *dstBuf, word wantBytes);

static WWFixed _pascal
BSNWavMP3VolumeFromPercent(word pct)
{
    WWFixed w;

    if (pct >= 100)
    {
        WWFixedToInt(w) = 1;
        WWFixedToFrac(w) = 0;
        return w;
    }
    WWFixedToInt(w) = 0;
    WWFixedToFrac(w) = (word)((pct * 655u) + ((pct >= 50) ? 36u : 0u));
    return w;
}

static Boolean
MP3_VerifyStream(MP3Handle *handleP)
{
    word blockAlign;

    if (handleP == (MP3Handle *)0)
    {
        return FALSE;
    }

    blockAlign = MP3_StreamBlockAlign(handleP);
    if (blockAlign == 0)
    {
        return FALSE;
    }

    if (!handleP->primed)
    {
        return FALSE;
    }

    if ((MP3_StreamChannels(handleP) == 0) ||
        (MP3_StreamSampleRate(handleP) == 0))
    {
        return FALSE;
    }

    return TRUE;
}

static Boolean
MP3_EnsureScratch(word channels)
{
    word neededBytes;
    MemHandle scratchH;
    sword *scratchP;

    if (channels == 0)
    {
        return FALSE;
    }

    neededBytes = (word)(MP3_SCRATCH_FRAMES *
                         (word)channels *
                         (word)sizeof(sword));
    if (neededBytes == 0)
    {
        neededBytes = (word)((word)channels * (word)sizeof(sword));
    }

    if (s_mp3ScratchH != NullHandle &&
        s_mp3ScratchP != (sword *)0 &&
        s_mp3ScratchBytes >= neededBytes)
    {
        return TRUE;
    }

    MP3_FreeScratch();

    scratchH = MemAlloc(neededBytes, HF_SWAPABLE, HAF_ZERO_INIT);
    if (scratchH == NullHandle)
    {
        return FALSE;
    }

    scratchP = (sword *)MemLock(scratchH);
    if (!scratchP)
    {
        MemFree(scratchH);
        return FALSE;
    }

    s_mp3ScratchH = scratchH;
    s_mp3ScratchP = scratchP;
    s_mp3ScratchBytes = neededBytes;
    return TRUE;
}

static void
MP3_FreeScratch(void)
{
    if (s_mp3ScratchH != NullHandle)
    {
        if (s_mp3ScratchP != (sword *)0)
        {
            MemUnlock(s_mp3ScratchH);
        }
        MemFree(s_mp3ScratchH);
    }
    s_mp3ScratchH = NullHandle;
    s_mp3ScratchP = (sword *)0;
    s_mp3ScratchBytes = 0;
}

static void
MP3_ResetStaticState(void)
{
    MP3_FreeScratch();
    s_mp3Handle   = 0;
    s_mp3Channels = 0;
    s_mp3CallbackLogged = FALSE;
    s_mp3CallbackSkip   = MP3_CALLBACK_LOG_DELAY;
}

static Boolean _pascal
BSNWavMP3Callback(void *dstBuf, word wantBytes)
{
    word blockAlign;
    word totalFramesWanted;
    word framesProduced;
    Boolean finished;
    byte far *dstFar;

    if (!s_mp3Handle || !dstBuf || wantBytes == 0 || s_mp3Channels == 0)
    {
        return TRUE;
    }

    blockAlign = MP3_StreamBlockAlign(s_mp3Handle);
    if (blockAlign == 0)
    {
        return TRUE;
    }

    if (!MP3_EnsureScratch(s_mp3Channels))
    {
        return TRUE;
    }

    totalFramesWanted = (word)(wantBytes / blockAlign);
    framesProduced = 0;
    finished = FALSE;
    dstFar = (byte far *)dstBuf;

    while (framesProduced < totalFramesWanted)
    {
        word framesRemaining;
        word scratchFrames;
        dword framesDecoded;
        word bytesToCopy;
        word producedBytes;

        scratchFrames = (word)(s_mp3ScratchBytes / blockAlign);
        if (scratchFrames == 0)
        {
            finished = TRUE;
            break;
        }

        framesRemaining = (word)(totalFramesWanted - framesProduced);
        if (scratchFrames > framesRemaining)
        {
            scratchFrames = framesRemaining;
        }

        framesDecoded = MP3_ReadS16(s_mp3Handle,
                                    (dword)scratchFrames,
                                    s_mp3ScratchP);
        if (framesDecoded == 0)
        {
            finished = TRUE;
            break;
        }

        bytesToCopy = (word)(framesDecoded * (dword)blockAlign);
        producedBytes = (word)(framesProduced * blockAlign);

        _fmemcpy(dstFar + producedBytes,
                 s_mp3ScratchP,
                 bytesToCopy);

        framesProduced += (word)framesDecoded;

        if (framesDecoded < (dword)scratchFrames)
        {
            /* still data buffered or request trimmed; keep looping */
        }
    }

    {
        word producedBytes;

        producedBytes = (word)(framesProduced * blockAlign);
        if (producedBytes < wantBytes)
        {
            _fmemset(dstFar + producedBytes,
                     0,
                     (word)(wantBytes - producedBytes));
        }
    }

    if (!s_mp3CallbackLogged && (framesProduced > 0))
    {
        if (s_mp3CallbackSkip > 0)
        {
            s_mp3CallbackSkip--;
        }
        if ((s_mp3CallbackSkip == 0) && (wantBytes >= sizeof(sword)))
        {
            FileHandle dbgFH;
            char dbgBuf[256];
            word dbgLen;
            word sampleCount;
            word i;
            sword far *samplesP;

            dbgFH = FileOpen("mp3dbg.txt", FILE_ACCESS_RW | FILE_DENY_NONE);
            if (dbgFH == 0)
            {
                dbgFH = FileCreate("mp3dbg.txt",
                                   FILE_CREATE_NO_TRUNCATE |
                                   FILE_ACCESS_RW |
                                   FILE_DENY_NONE |
                                   FCF_NATIVE,
                                   FILE_ATTR_NORMAL);
            }
            if (dbgFH != 0)
            {
                (void)FilePos(dbgFH, 0L, FILE_POS_END);
                samplesP = (sword far *)dstBuf;
                sampleCount = (word)(wantBytes / (word)sizeof(sword));
                if (sampleCount > 32)
                {
                    sampleCount = 32;
                }
                dbgLen = (word)sprintf(dbgBuf,
                                       "callback want=%u produced=%u samples=",
                                       (unsigned)wantBytes,
                                       (unsigned)(framesProduced * blockAlign));
                FileWrite(dbgFH, dbgBuf, dbgLen, FALSE);
                for (i = 0; i < sampleCount; i++)
                {
                    dbgLen = (word)sprintf(dbgBuf,
                                           (i == 0) ? "%d" : " %d",
                                           (int)samplesP[i]);
                    FileWrite(dbgFH, dbgBuf, dbgLen, FALSE);
                }
                FileWrite(dbgFH, "\r\n", 2, FALSE);
                FileClose(dbgFH, TRUE);
                s_mp3CallbackLogged = TRUE;
            }
        }
    }

    return finished;
}

int _pascal _export
BSNWavPlayMP3FileHandle(FileHandle fh, MP3PlayOptions *optsP)
{
    WWFixed vol;
    Boolean mono;
    word flags;
    optr parent;
    MP3Handle *handleP;
    BSWavFormChunk fmt;
    int rc;

    if (fh == 0)
    {
        return BSNW_UNKNOWN_WAVE_FORMAT;
    }

    if (optsP == (MP3PlayOptions *)(void *)0)
    {
        vol = BSNWavMP3VolumeFromPercent(100);
        mono = FALSE;
        flags = 0;
        parent = NullOptr;
    }
    else
    {
        vol = optsP->volume;
        mono = optsP->forceMono;
        flags = optsP->playFlags;
        parent = optsP->parent;
    }

    handleP = MP3_OpenStream(fh, vol, mono);
    if (!handleP)
    {
        return BSNW_UNKNOWN_WAVE_FORMAT;
    }

    if (!MP3_VerifyStream(handleP))
    {
        MP3_CloseStream(handleP);
        MP3_ResetStaticState();
        return BSNW_UNKNOWN_WAVE_FORMAT;
    }

    if (!MP3_EnsureScratch(MP3_StreamChannels(handleP)))
    {
        MP3_CloseStream(handleP);
        MP3_ResetStaticState();
        return BSNW_MEMORY_ERROR;
    }

    _fmemset(&fmt, 0, sizeof(fmt));
    fmt.BWFC_dataFormat    = BSWN_FORMAT_PCM;
    fmt.BWFC_channels      = MP3_StreamChannels(handleP);
    fmt.BWFC_sampleRate    = (dword)MP3_StreamSampleRate(handleP);
    fmt.BWFC_bitsPerSample = 16;
    fmt.BWFC_blockAlign    = MP3_StreamBlockAlign(handleP);
    fmt.BWFC_avgRate       = (dword)fmt.BWFC_blockAlign * fmt.BWFC_sampleRate;

    s_mp3Handle   = handleP;
    s_mp3Channels = fmt.BWFC_channels;

    rc = BSNWavePlayCallback(&fmt,
                             (dword)0,
                             flags,
                             parent,
                             (PlayCallbackFunctionType *)BSNWavMP3Callback);

    MP3_CloseStream(handleP);
    MP3_ResetStaticState();
    return rc;
}

int _pascal _export
BSNWavPlayMP3File(const char *pathP, MP3PlayOptions *optsP)
{
    FileHandle fh;
    int rc;

    if ((pathP == (const char *)(void *)0) || (*pathP == '\0'))
    {
        return BSNW_UNKNOWN_WAVE_FORMAT;
    }

    fh = FileOpen(pathP, FILE_ACCESS_R | FILE_DENY_NONE);
    if (fh == 0)
    {
        return BSNW_UNKNOWN_WAVE_FORMAT;
    }

    rc = BSNWavPlayMP3FileHandle(fh, optsP);

    FileClose(fh, TRUE);
    return rc;
}
