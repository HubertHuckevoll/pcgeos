#pragma noroot
/************************************************
 * mp3_decode.goc
 * - Minimp3 integration + BSNWav pull-callback
 * - Small, swappable buffers; C89; early returns
 ************************************************/

#include <geos.h>
#include <geoworks.h>
#include <mem.h>
#include <file.h>
#include <sound.h>
#include <Ansi/string.h>

@include <bsnwav.goh>

#include "mp3_internal.h"

/* ---- Buffer sizing under 8 KB ---- */
#define MP3_INBUF_SIZE              6144
#define MP3_FRAME_SAMPLES_MAX       (MINIMP3_MAX_SAMPLES_PER_FRAME) /* ~2304 int16 */
#define MP3_PCM_FRAME_BYTES         (MP3_FRAME_SAMPLES_MAX * 2)     /* ~4608 B */

/* One active session (simple) */
static MP3Ctx *g_activeCtxP = (MP3Ctx *)(void *)0;

/* ---- WWFixed volume scaling (in-place int16) ---- */
static void
MP3_ScalePcmWithWWFixed(sword *samplesP, word sampleCount, WWFixed volume)
{
    word i;
    long prod;
    sword s;

    if ((volume.FXwhole == 1) && (volume.FXfrac == 0))
    {
        return;
    }
    for (i = 0; i < sampleCount; i++)
    {
        s = samplesP[i];
        prod = ((long)s * (long)volume.FXwhole) << 16;
        prod += ((long)s * (long)volume.FXfrac);
        prod >>= 16;
        if (prod > 32767)
        {
            prod = 32767;
        }
        if (prod < -32768)
        {
            prod = -32768;
        }
        samplesP[i] = (sword)prod;
    }
}

/* stereo (interleaved) -> mono in-place, returns new byte length */
static word
MP3_MixStereoToMonoInPlace(sword *pcmP, word stereoSamples)
{
    word i;
    long L;
    long R;
    long m;

    for (i = 0; i < stereoSamples; i++)
    {
        L = (long)pcmP[2 * i + 0];
        R = (long)pcmP[2 * i + 1];
        m = (L + R) / 2;
        if (m > 32767)
        {
            m = 32767;
        }
        if (m < -32768)
        {
            m = -32768;
        }
        pcmP[i] = (sword)m;
    }
    return (word)(stereoSamples * 2); /* mono bytes */
}

/* Compact + refill input window */
static void
MP3_RefillInput(MP3Ctx *ctxP)
{
    word moveLen;
    word need;
    word got;

    if (ctxP->inFill > ctxP->inPos)
    {
        moveLen = (word)(ctxP->inFill - ctxP->inPos);
        _fmemmove(ctxP->inBufP, ctxP->inBufP + ctxP->inPos, moveLen);
        ctxP->inFill = moveLen;
    }
    else
    {
        ctxP->inFill = 0;
    }
    ctxP->inPos = 0;

    need = (word)(MP3_INBUF_SIZE - ctxP->inFill);
    if (need > 0)
    {
        got = FileRead(ctxP->fh, ctxP->inBufP + ctxP->inFill, need);
        ctxP->inFill += got;
        if (got == 0)
        {
            ctxP->eofSeen = TRUE;
        }
    }
    else
    {
        ctxP->eofSeen = TRUE;
    }
}

/* Decode one frame; TRUE if PCM produced into frameP/frameBytes */
static Boolean
MP3_DecodeNextFrame(MP3Ctx *ctxP)
{
    int decodedSamples;
    word avail;

    avail = (word)(ctxP->inFill - ctxP->inPos);
    if ((avail < 64) && !ctxP->eofSeen)
    {
        MP3_RefillInput(ctxP);
        avail = (word)(ctxP->inFill - ctxP->inPos);
    }
    if ((avail == 0) && ctxP->eofSeen)
    {
        ctxP->frameBytes = 0;
        ctxP->frameOff = 0;
        return FALSE;
    }

    _fmemset(&(ctxP->fi), 0, sizeof(ctxP->fi));
    decodedSamples = mp3dec_decode_frame(&(ctxP->dec),
                        (const unsigned char *)(ctxP->inBufP + ctxP->inPos),
                        (int)avail,
                        ctxP->frameP,
                        &(ctxP->fi));

    if (ctxP->fi.frame_bytes > 0)
    {
        ctxP->inPos += (word)ctxP->fi.frame_bytes;
        if (ctxP->inPos > ctxP->inFill)
        {
            ctxP->inPos = ctxP->inFill;
        }
    }
    else
    {
        if (avail > 0)
        {
            ctxP->inPos += 1; /* resync */
        }
        ctxP->frameBytes = 0;
        ctxP->frameOff = 0;
        return FALSE;
    }

    if (decodedSamples <= 0)
    {
        ctxP->frameBytes = 0;
        ctxP->frameOff = 0;
        return FALSE;
    }

    if (ctxP->outRate == 0)
    {
        ctxP->outRate = (word)ctxP->fi.hz;
        ctxP->outCh   = (word)ctxP->fi.channels;
        if (ctxP->forceMono && (ctxP->outCh == 2))
        {
            ctxP->outCh = 1;
        }
    }

    if (ctxP->forceMono && (ctxP->fi.channels == 2))
    {
        ctxP->frameBytes = MP3_MixStereoToMonoInPlace(ctxP->frameP,
                                                      (word)(decodedSamples / 2));
    }
    else
    {
        ctxP->frameBytes = (word)(decodedSamples * 2);
    }

    MP3_ScalePcmWithWWFixed(ctxP->frameP,
                            (word)(ctxP->frameBytes / 2),
                            ctxP->volume);
    ctxP->frameOff = 0;
    return TRUE;
}

/* ---- BSNWav callback: must fill exactly wantBytes per call. TRUE=continue, FALSE=stop ---- */
Boolean _pascal
MP3_BSNWavFill(void *dstBuf, word wantBytes)
{
    MP3Ctx *ctxP;
    word produced;
    word toCopy;

    if (dstBuf == (void *)0)
    {
        return TRUE;
    }
    if (wantBytes == 0)
    {
        return FALSE;
    }
    if (g_activeCtxP == (MP3Ctx *)(void *)0)
    {
        _fmemset(dstBuf, 0, wantBytes);
        return TRUE;
    }
    ctxP = g_activeCtxP;
    produced = 0;

    while (produced < wantBytes)
    {
        if (ctxP->frameOff < ctxP->frameBytes)
        {
            toCopy = (word)(ctxP->frameBytes - ctxP->frameOff);
            if ((word)(wantBytes - produced) < toCopy)
            {
                toCopy = (word)(wantBytes - produced);
            }
            _fmemcpy((byte *)dstBuf + produced,
                     (byte *)(ctxP->frameP) + ctxP->frameOff,
                     toCopy);
            ctxP->frameOff += toCopy;
            produced += toCopy;
        }
        else
        {
            if (!MP3_DecodeNextFrame(ctxP))
            {
                _fmemset((byte *)dstBuf + produced,
                         0,
                         (word)(wantBytes - produced));
                return TRUE;
            }
        }
    }
    return FALSE;
}

void _pascal
MP3_SetActiveCtxInternal(MP3Ctx *ctxP)
{
    g_activeCtxP = ctxP;
}

Boolean _pascal
MP3_InitContextAndPrime(MP3Ctx *ctxP,
                        const char *pathP,
                        WWFixed volume,
                        Boolean forceMono)
{
    Handle inH;
    Handle frH;
    byte *inP;
    sword *frP;

    _fmemset(ctxP, 0, sizeof(MP3Ctx));

    ctxP->fh = FileOpen(pathP, FO_READ_ONLY);
    if (ctxP->fh == 0)
    {
        return FALSE;
    }

    inH = MemAlloc(MP3_INBUF_SIZE, HF_SWAPABLE, HAF_ZERO_INIT);
    if (inH == 0)
    {
        FileClose(ctxP->fh, TRUE);
        ctxP->fh = 0;
        return FALSE;
    }
    inP = (byte *)MemLock(inH);
    if (inP == (byte *)(void *)0)
    {
        MemFree(inH);
        FileClose(ctxP->fh, TRUE);
        ctxP->fh = 0;
        return FALSE;
    }
    ctxP->inBufH = inH;
    ctxP->inBufP = inP;
    ctxP->inFill = (word)FileRead(ctxP->fh, inP, MP3_INBUF_SIZE);
    ctxP->inPos  = 0;
    ctxP->eofSeen = (ctxP->inFill == 0) ? TRUE : FALSE;

    frH = MemAlloc(MP3_PCM_FRAME_BYTES, HF_SWAPABLE, HAF_ZERO_INIT);
    if (frH == 0)
    {
        MemUnlock(inH);
        MemFree(inH);
        ctxP->inBufH = 0;
        ctxP->inBufP = (byte *)(void *)0;
        FileClose(ctxP->fh, TRUE);
        ctxP->fh = 0;
        return FALSE;
    }
    frP = (sword *)MemLock(frH);
    if (frP == (sword *)(void *)0)
    {
        MemFree(frH);
        MemUnlock(inH);
        MemFree(inH);
        ctxP->frameH = 0;
        ctxP->frameP = (sword *)(void *)0;
        ctxP->inBufH = 0;
        ctxP->inBufP = (byte *)(void *)0;
        FileClose(ctxP->fh, TRUE);
        ctxP->fh = 0;
        return FALSE;
    }
    ctxP->frameH = frH;
    ctxP->frameP = frP;

    ctxP->volume    = volume;
    ctxP->forceMono = forceMono;

    mp3dec_init(&(ctxP->dec));

    if (!MP3_DecodeNextFrame(ctxP))
    {
        MemUnlock(ctxP->frameH);
        MemFree(ctxP->frameH);
        MemUnlock(ctxP->inBufH);
        MemFree(ctxP->inBufH);
        ctxP->frameH = 0;
        ctxP->frameP = (sword *)(void *)0;
        ctxP->inBufH = 0;
        ctxP->inBufP = (byte *)(void *)0;
        FileClose(ctxP->fh, TRUE);
        ctxP->fh = 0;
        return FALSE;
    }

    MP3_SetActiveCtxInternal(ctxP);
    return TRUE;
}

void _pascal
MP3_CleanupContext(MP3Ctx *ctxP)
{
    g_activeCtxP = (MP3Ctx *)(void *)0;

    if (ctxP->fh != 0)
    {
        FileClose(ctxP->fh, TRUE);
        ctxP->fh = 0;
    }
    if (ctxP->frameH != 0)
    {
        MemUnlock(ctxP->frameH);
        MemFree(ctxP->frameH);
        ctxP->frameH = 0;
        ctxP->frameP = (sword *)(void *)0;
    }
    if (ctxP->inBufH != 0)
    {
        MemUnlock(ctxP->inBufH);
        MemFree(ctxP->inBufH);
        ctxP->inBufH = 0;
        ctxP->inBufP = (byte *)(void *)0;
    }
    ctxP->frameBytes = 0;
    ctxP->frameOff = 0;
}
