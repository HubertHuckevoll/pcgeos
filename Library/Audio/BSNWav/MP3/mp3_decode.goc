// #pragma noroot
/************************************************
 * mp3_decode.goc
 * - Minimp3 streaming helpers for BSNWav glue
 ************************************************/

#include <geos.h>
#include <geoworks.h>
#include <mem.h>
#include <heap.h>
#include <file.h>
#include <sound.h>
#include <system.h>
#include <Ansi/string.h>
#include <Ansi/stdio.h>

#ifndef FP_SEG
#define FP_SEG(fp) ((unsigned short)((unsigned long)(void far *)(fp) >> 16))
#endif
#ifndef FP_OFF
#define FP_OFF(fp) ((unsigned short)(fp))
#endif

#define MINIMP3_IMPLEMENTATION

#include "mp3_internal.h"

// defined in minimp3.h
// mp3dec_scratch_t _far *g_minimp3_scratch_ptr = (mp3dec_scratch_t _far *)0;

void MP3_TraceWrite(const char *text);
void MP3_TraceWriteHex(const char *label,
                       const byte *data,
                       word count);
void MP3_TraceWriteSamples(const char *label,
                           const sword *data,
                           word count);
void MP3_TraceWriteFloatHex(const char *label,
                            const float *data,
                            word count);
static Boolean MP3_SkipId3Tag(MP3Handle *handleP);
word s_mp3DumpFrames = 0;
static Boolean s_mp3TraceInitialized = FALSE;
word s_mp3ClampLogs = 0;
word s_mp3ScaleLogs = 0;
word s_mp3SynthLogs = 0;
static Boolean s_loggedSizes = FALSE;

/* ---- Local helpers ---- */
static void     MP3_ResetDecoderState(MP3Handle *handleP);
static void     MP3_RefillInput(MP3Handle *handleP);
static Boolean  MP3_PrimeStream(MP3Handle *handleP);
static Boolean  MP3_DecodeNextFrame(MP3Handle *handleP);
static Boolean  MP3_SkipId3Tag(MP3Handle *handleP);
static void     MP3_ScalePcmWithWWFixed(sword *samplesP,
                                        word sampleCount,
                                        WWFixed volume);
static word     MP3_MixStereoToMonoInPlace(sword *pcmP,
                                           word stereoSamples);
static Boolean  MP3_EnsureDecoderScratch(MP3Handle *handleP);
static void     MP3_FreeDecoderScratch(MP3Handle *handleP);
#ifdef MINIMP3_FLOAT_OUTPUT
static void _pascal MP3_ConvertFloatToS16(const float *srcP,
                                          sword *dstP,
                                          word sampleCount);
#endif

/* ---- Implementation ---- */

MP3Handle * _pascal
MP3_OpenStream(FileHandle fh, WWFixed volume, Boolean forceMono)
{
    MemHandle memH;
    MP3Handle *handleP;

    if (fh == 0)
    {
        return (MP3Handle *)0;
    }

    memH = MemAlloc((word)sizeof(MP3Handle), HF_SWAPABLE, HAF_ZERO_INIT);
    if (memH == NullHandle)
    {
        return (MP3Handle *)0;
    }

    handleP = (MP3Handle *)MemLock(memH);
    if (handleP == (MP3Handle *)0)
    {
        MemFree(memH);
        return (MP3Handle *)0;
    }
    if (!s_loggedSizes)
    {
        char sizeLine[128];
        sprintf(sizeLine,
                "sizes int=%u long=%u float=%u\r\n",
                (unsigned)sizeof(int),
                (unsigned)sizeof(long),
                (unsigned)sizeof(float));
        MP3_TraceWrite(sizeLine);
        s_loggedSizes = TRUE;
    }

    _fmemset(handleP, 0, (word)sizeof(MP3Handle));
    handleP->selfHandle = memH;
    handleP->volume     = volume;
    handleP->forceMono  = forceMono;

    handleP->fh = fh;

    MP3_ResetDecoderState(handleP);
    if (!MP3_EnsureDecoderScratch(handleP))
    {
        MP3_CloseStream(handleP);
        return (MP3Handle *)0;
    }

    if (!MP3_PrimeStream(handleP))
    {
        MP3_CloseStream(handleP);
        return (MP3Handle *)0;
    }

    return handleP;
}

void _pascal
MP3_CloseStream(MP3Handle *handleP)
{
    MemHandle memH;

    if (handleP == (MP3Handle *)0)
    {
        return;
    }

    MP3_FreeDecoderScratch(handleP);

    memH = handleP->selfHandle;
    handleP->selfHandle = NullHandle;

    if (memH != NullHandle)
    {
        MemUnlock(memH);
        MemFree(memH);
    }
}

Boolean _pascal
MP3_RewindStream(MP3Handle *handleP)
{
    if (handleP == (MP3Handle *)0 || handleP->fh == 0)
    {
        return FALSE;
    }

    if (!MP3_EnsureDecoderScratch(handleP))
    {
        return FALSE;
    }

    FilePos(handleP->fh, 0L, FILE_POS_START);
    MP3_ResetDecoderState(handleP);

    return MP3_PrimeStream(handleP);
}

word _pascal
MP3_StreamChannels(const MP3Handle *handleP)
{
    if (handleP == (const MP3Handle *)0)
    {
        return 0;
    }
    return handleP->outCh;
}

word _pascal
MP3_StreamSampleRate(const MP3Handle *handleP)
{
    if (handleP == (const MP3Handle *)0)
    {
        return 0;
    }
    return handleP->outRate;
}

word _pascal
MP3_StreamBlockAlign(const MP3Handle *handleP)
{
    word ch;

    ch = MP3_StreamChannels(handleP);
    return (word)(ch * 2u);
}

dword _pascal
MP3_ReadS16(MP3Handle *handleP, dword framesToRead, sword *dst)
{
    dword producedFrames;
    dword producedBytes;
    word blockAlign;
    byte far *dstFar;

    if ((handleP == (MP3Handle *)0) ||
        (dst == (sword *)0) ||
        (framesToRead == 0))
    {
        return 0;
    }

    blockAlign = MP3_StreamBlockAlign(handleP);
    if (blockAlign == 0)
    {
        return 0;
    }

    producedFrames = 0;
    producedBytes  = 0;
    dstFar = (byte far *)dst;

    while (framesToRead > 0)
    {
        word availableBytes;
        word availableFrames;
        word framesNow;
        word bytesNow;

        if (handleP->frameOff >= handleP->frameBytes)
        {
            if (!MP3_DecodeNextFrame(handleP))
            {
                break;
            }
        }

        availableBytes = (word)(handleP->frameBytes - handleP->frameOff);
        availableFrames = (word)(availableBytes / blockAlign);
        if (availableFrames == 0)
        {
            handleP->frameOff = handleP->frameBytes;
            continue;
        }

        framesNow = availableFrames;
        if ((dword)framesNow > framesToRead)
        {
            framesNow = (word)framesToRead;
        }
        bytesNow = (word)(framesNow * blockAlign);

        _fmemcpy(dstFar + producedBytes,
                 (byte far *)(handleP->frameBuf) + handleP->frameOff,
                 bytesNow);

        handleP->frameOff += bytesNow;
        producedFrames += framesNow;
        producedBytes  += bytesNow;
        framesToRead   -= framesNow;
    }

    return producedFrames;
}

/* ---- Static helpers ---- */

static Boolean
MP3_EnsureDecoderScratch(MP3Handle *handleP)
{
    int scratchSize;

    if (handleP == (MP3Handle *)0)
    {
        return FALSE;
    }

    if ((handleP->scratchMemH != NullHandle) &&
        (handleP->scratchMemP != (void _far *)0))
    {
        g_minimp3_scratch_ptr = (mp3dec_scratch_t _far *)(handleP->scratchMemP);
        return TRUE;
    }

    scratchSize = (int)sizeof(mp3dec_scratch_t);
    if (scratchSize <= 0 || scratchSize > 0xFFFF)
    {
        return FALSE;
    }

    handleP->scratchMemH = MemAlloc((word)scratchSize,
                                    HF_SWAPABLE,
                                    HAF_ZERO_INIT);
    if (handleP->scratchMemH == NullHandle)
    {
        return FALSE;
    }

    handleP->scratchMemP = (void _far *)MemLock(handleP->scratchMemH);
    if (handleP->scratchMemP == (void _far *)0)
    {
        MemFree(handleP->scratchMemH);
        handleP->scratchMemH = NullHandle;
        return FALSE;
    }

    g_minimp3_scratch_ptr = (mp3dec_scratch_t _far *)(handleP->scratchMemP);

    return TRUE;
}

static void
MP3_FreeDecoderScratch(MP3Handle *handleP)
{
    if (handleP == (MP3Handle *)0)
    {
        return;
    }

    if (handleP->scratchMemH != NullHandle)
    {
        if (handleP->scratchMemP != (void _far *)0)
        {
            MemUnlock(handleP->scratchMemH);
        }
        MemFree(handleP->scratchMemH);
    }

    handleP->scratchMemH = NullHandle;
    handleP->scratchMemP = (void _far *)0;

    g_minimp3_scratch_ptr = (mp3dec_scratch_t _far *)0;
}

static Boolean
MP3_SkipId3Tag(MP3Handle *handleP)
{
    byte *buf;
    dword tagSize;
    word remain;

    if ((handleP == (MP3Handle *)0) ||
        ((handleP->inFill - handleP->inPos) < 10))
    {
        return FALSE;
    }

    buf = handleP->inBuf + handleP->inPos;
    if ((buf[0] != 'I') || (buf[1] != 'D') || (buf[2] != '3'))
    {
        return FALSE;
    }

    tagSize = ((dword)(buf[6] & 0x7F) << 21) |
              ((dword)(buf[7] & 0x7F) << 14) |
              ((dword)(buf[8] & 0x7F) << 7) |
              ((dword)(buf[9] & 0x7F));
    tagSize += 10UL;
    if (buf[5] & 0x10)
    {
        tagSize += 10UL;
    }

    {
        char line[96];
        sprintf(line, "skip ID3 size=%lu\r\n", (unsigned long)tagSize);
        MP3_TraceWrite(line);
    }

    remain = (word)(handleP->inFill - handleP->inPos);

    if (tagSize <= (dword)remain)
    {
        handleP->inPos = (word)(handleP->inPos + (word)tagSize);
        return TRUE;
    }

    {
        long adjust;

        adjust = (long)(tagSize - (dword)remain);
        if (adjust != 0)
        {
            FilePos(handleP->fh, adjust, FILE_POS_RELATIVE);
        }
    }

    handleP->inPos = 0;
    handleP->inFill = 0;
    handleP->eofSeen = FALSE;
    MP3_RefillInput(handleP);
    return TRUE;
}

void
MP3_TraceWrite(const char *text)
{
    FileHandle fh;
    word len;

    if (!s_mp3TraceInitialized)
    {
        fh = FileCreate("mp3trace.txt",
                        FILE_CREATE_TRUNCATE |
                        FILE_ACCESS_RW |
                        FILE_DENY_NONE |
                        FCF_NATIVE,
                        FILE_ATTR_NORMAL);
        s_mp3TraceInitialized = TRUE;
    }
    else
    {
        fh = FileOpen("mp3trace.txt", FILE_ACCESS_RW | FILE_DENY_NONE);
        if (fh == 0)
        {
            fh = FileCreate("mp3trace.txt",
                            FILE_CREATE_NO_TRUNCATE |
                            FILE_ACCESS_RW |
                            FILE_DENY_NONE |
                            FCF_NATIVE,
                            FILE_ATTR_NORMAL);
        }
    }
    if (fh != 0)
    {
        (void)FilePos(fh, 0L, FILE_POS_END);
        len = (word)strlen(text);
        if (len > 0)
        {
            FileWrite(fh, text, len, FALSE);
        }
        FileClose(fh, TRUE);
    }
}

void
MP3_TraceWriteHex(const char *label, const byte *data, word count)
{
    char line[256];
    word i;
    word entries;
    int written;
    int pos;

    entries = (count > 16) ? 16 : count;
    pos = sprintf(line, "%s:", label);
    for (i = 0; i < entries; i++)
    {
        written = sprintf(line + pos, " %02X", data[i]);
        pos += written;
        if (pos >= (int)(sizeof(line) - 5))
        {
            break;
        }
    }
    if (count > entries)
    {
        written = sprintf(line + pos, " ...");
        pos += written;
    }
    line[pos++] = '\r';
    line[pos++] = '\n';
    line[pos] = '\0';
    MP3_TraceWrite(line);
}

void
MP3_TraceWriteSamples(const char *label, const sword *data, word count)
{
    char line[256];
    word i;
    word entries;
    int written;
    int pos;

    entries = (count > 16) ? 16 : count;
    pos = sprintf(line, "%s:", label);
    for (i = 0; i < entries; i++)
    {
        written = sprintf(line + pos, " %d", data[i]);
        pos += written;
        if (pos >= (int)(sizeof(line) - 8))
        {
            break;
        }
    }
    if (count > entries)
    {
        written = sprintf(line + pos, " ...");
        pos += written;
    }
    line[pos++] = '\r';
    line[pos++] = '\n';
    line[pos] = '\0';
    MP3_TraceWrite(line);
}

void
MP3_TraceWriteFloatHex(const char *label, const float *data, word count)
{
    char line[256];
    union
    {
        float f;
        dword raw;
    } conv;
    word i;
    word entries;
    int written;
    int pos;

    entries = (count > 16) ? 16 : count;
    pos = sprintf(line, "%s:", label);
    for (i = 0; i < entries; i++)
    {
        conv.f = data[i];
        written = sprintf(line + pos, " %08lX", (unsigned long)conv.raw);
        pos += written;
        if (pos >= (int)(sizeof(line) - 10))
        {
            break;
        }
    }
    if (count > entries)
    {
        written = sprintf(line + pos, " ...");
        pos += written;
    }
    line[pos++] = '\r';
    line[pos++] = '\n';
    line[pos] = '\0';
    MP3_TraceWrite(line);
}

static void
MP3_ResetDecoderState(MP3Handle *handleP)
{
    handleP->inPos      = 0;
    handleP->inFill     = 0;
    handleP->eofSeen    = FALSE;
    handleP->frameBytes = 0;
    handleP->frameOff   = 0;
    handleP->outRate    = 0;
    handleP->outCh      = 0;
    handleP->primed     = FALSE;

    _fmemset(&(handleP->fi), 0, sizeof(handleP->fi));
    mp3dec_init(&(handleP->dec));
    s_mp3TraceInitialized = FALSE;
    s_mp3ClampLogs = 0;
    s_mp3DumpFrames = 3;
    s_mp3ScaleLogs = 0;
    s_mp3SynthLogs = 0;
}

static Boolean
MP3_PrimeStream(MP3Handle *handleP)
{
    if (handleP == (MP3Handle *)0)
    {
        return FALSE;
    }

    while (!handleP->primed)
    {
        if (!MP3_DecodeNextFrame(handleP))
        {
            if (handleP->eofSeen && handleP->frameBytes == 0)
            {
                break;
            }
        }
    }

    return handleP->primed;
}

static void
MP3_RefillInput(MP3Handle *handleP)
{
    word moveLen;
    word need;
    word got;

    if (handleP->inFill > handleP->inPos)
    {
        moveLen = (word)(handleP->inFill - handleP->inPos);
        _fmemmove(handleP->inBuf,
                  handleP->inBuf + handleP->inPos,
                  moveLen);
        handleP->inFill = moveLen;
    }
    else
    {
        handleP->inFill = 0;
    }
    handleP->inPos = 0;

    need = (word)(MP3_INBUF_SIZE - handleP->inFill);
    if (need > 0)
    {
        got = FileRead(handleP->fh,
                       handleP->inBuf + handleP->inFill,
                       need,
                       FALSE);
        handleP->inFill += got;
        if (got == 0)
        {
            handleP->eofSeen = TRUE;
        }
    }
    else
    {
        handleP->eofSeen = TRUE;
    }
}

static Boolean
MP3_DecodeNextFrame(MP3Handle *handleP)
{
    int decodedSamples;
    word avail;

    if (!MP3_EnsureDecoderScratch(handleP))
    {
        return FALSE;
    }

    while (TRUE)
    {
        avail = (word)(handleP->inFill - handleP->inPos);
        if ((avail < 64) && !handleP->eofSeen)
        {
            MP3_RefillInput(handleP);
            avail = (word)(handleP->inFill - handleP->inPos);
        }
        if ((avail == 0) && handleP->eofSeen)
        {
            handleP->frameBytes = 0;
            handleP->frameOff = 0;
            return FALSE;
        }
        if (!MP3_SkipId3Tag(handleP))
        {
            break;
        }
    }

    _fmemset(&(handleP->fi), 0, sizeof(handleP->fi));

    if (s_mp3DumpFrames > 0)
    {
        byte *hdr;
        word hdrLen;
        char line[160];

        hdr = handleP->inBuf + handleP->inPos;
        hdrLen = (word)((avail < 16) ? avail : 16);

        sprintf(line,
                "call bytes=%u avail=%u inPos=%u inFill=%u\r\n",
                (unsigned)avail,
                (unsigned)avail,
                (unsigned)handleP->inPos,
                (unsigned)handleP->inFill);
        MP3_TraceWrite(line);
        MP3_TraceWriteHex("hdr", hdr, hdrLen);
        sprintf(line,
                "scratch=%04X:%04X\r\n",
                (unsigned)FP_SEG(handleP->scratchMemP),
                (unsigned)FP_OFF(handleP->scratchMemP));
        MP3_TraceWrite(line);
        sprintf(line,
                "gScratch=%04X:%04X\r\n",
                (unsigned)FP_SEG(g_minimp3_scratch_ptr),
                (unsigned)FP_OFF(g_minimp3_scratch_ptr));
        MP3_TraceWrite(line);
    }

    decodedSamples = mp3dec_decode_frame(&(handleP->dec),
                        (const unsigned char *)(handleP->inBuf + handleP->inPos),
                        (int)avail,
#ifdef MINIMP3_FLOAT_OUTPUT
                        handleP->frameFloatBuf,
#else
                        handleP->frameBuf,
#endif
                        &(handleP->fi));
#ifdef MINIMP3_FLOAT_OUTPUT
    if ((decodedSamples > 0) && (handleP->fi.channels > 0))
    {
        int totalSamples;

        totalSamples = decodedSamples * (int)handleP->fi.channels;
        MP3_ConvertFloatToS16(handleP->frameFloatBuf,
                              handleP->frameBuf,
                              (word)totalSamples);
    }
    else
    {
        _fmemset(handleP->frameBuf, 0, MP3_PCM_FRAME_BYTES);
    }
#endif
    if (s_mp3DumpFrames > 0)
    {
        char line[160];
        word sampleCount;

        sprintf(line,
                "inPos=%u inFill=%u frameBytes=%u decoded=%d ch=%u\r\n",
                (unsigned)handleP->inPos,
                (unsigned)handleP->inFill,
                (unsigned)handleP->fi.frame_bytes,
                decodedSamples,
                (unsigned)handleP->fi.channels);
        MP3_TraceWrite(line);

        if ((decodedSamples > 0) && (handleP->fi.channels > 0))
        {
            sampleCount = (word)((dword)decodedSamples *
                                 (dword)handleP->fi.channels);
        }
        else
        {
            sampleCount = 16;
        }
#ifdef MINIMP3_FLOAT_OUTPUT
        MP3_TraceWriteFloatHex("frameBufF32",
                               handleP->frameFloatBuf,
                               sampleCount);
#endif
        MP3_TraceWriteSamples("frameBuf", handleP->frameBuf, sampleCount);
        if (s_mp3DumpFrames > 0)
        {
            s_mp3DumpFrames--;
        }
    }

    if (handleP->fi.frame_bytes > 0)
    {
        handleP->inPos += (word)handleP->fi.frame_bytes;
        if (handleP->inPos > handleP->inFill)
        {
            handleP->inPos = handleP->inFill;
        }
    }
    else
    {
        if (avail > 0)
        {
            handleP->inPos += 1;
        }
        handleP->frameBytes = 0;
        handleP->frameOff = 0;
        return FALSE;
    }

    if (decodedSamples <= 0)
    {
        handleP->frameBytes = 0;
        handleP->frameOff = 0;
        return FALSE;
    }

    if (handleP->outRate == 0)
    {
        handleP->outRate = (word)handleP->fi.hz;
        handleP->outCh   = (word)handleP->fi.channels;
        if (handleP->forceMono && (handleP->outCh == 2))
        {
            handleP->outCh = 1;
        }
    }

    if (handleP->forceMono && (handleP->fi.channels == 2))
    {
        word stereoSamples;

        stereoSamples = (word)decodedSamples;
        handleP->frameBytes = MP3_MixStereoToMonoInPlace(handleP->frameBuf,
                                                         stereoSamples);
    }
    else
    {
        dword totalSamples;

        totalSamples = (dword)decodedSamples * (dword)handleP->outCh;
        handleP->frameBytes = (word)(totalSamples * (dword)sizeof(sword));
    }

    MP3_ScalePcmWithWWFixed(handleP->frameBuf,
                            (word)(handleP->frameBytes / 2),
                            handleP->volume);

    handleP->frameOff = 0;
    handleP->primed = TRUE;
    return TRUE;
}

#ifdef MINIMP3_FLOAT_OUTPUT
static void _pascal
MP3_ConvertFloatToS16(const float *srcP, sword *dstP, word sampleCount)
{
    word i;

    if ((srcP == (const float *)(void *)0) ||
        (dstP == (sword *)(void *)0) ||
        (sampleCount == 0))
    {
        return;
    }

    for (i = 0; i < sampleCount; i++)
    {
        float scaled;

        scaled = srcP[i] * 32768.0f;
        if (scaled >= 32766.5f)
        {
            dstP[i] = 32767;
        }
        else if (scaled <= -32767.5f)
        {
            dstP[i] = -32768;
        }
        else
        {
            /*
             * Bias toward the sign before truncating so we follow
             * minimp3's "round away from zero" behaviour.
             */
            scaled += (scaled >= 0.0f) ? 0.5f : -0.5f;
            dstP[i] = (sword)scaled;
        }
    }
}
#endif

static void
MP3_ScalePcmWithWWFixed(sword *samplesP, word sampleCount, WWFixed volume)
{
    word i;
    long prod;
    sword s;

    if ((WWFixedToInt(volume) == 1) && (WWFixedToFrac(volume) == 0))
    {
        return;
    }
    for (i = 0; i < sampleCount; i++)
    {
        s = samplesP[i];
        prod = ((long)s * (long)WWFixedToInt(volume)) << 16;
        prod += ((long)s * (long)WWFixedToFrac(volume));
        prod >>= 16;
        if (prod > 32767)
        {
            prod = 32767;
        }
        if (prod < -32768)
        {
            prod = -32768;
        }
        samplesP[i] = (sword)prod;
    }
}

static word
MP3_MixStereoToMonoInPlace(sword *pcmP, word stereoSamples)
{
    word i;
    long L;
    long R;
    long m;

    for (i = 0; i < stereoSamples; i++)
    {
        L = (long)pcmP[2 * i + 0];
        R = (long)pcmP[2 * i + 1];
        m = (L + R) / 2;
        if (m > 32767)
        {
            m = 32767;
        }
        if (m < -32768)
        {
            m = -32768;
        }
        pcmP[i] = (sword)m;
    }
    return (word)(stereoSamples * 2);
}
