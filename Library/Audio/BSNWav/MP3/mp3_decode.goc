// #pragma noroot
/************************************************
 * mp3_decode.goc
 * - Minimp3 streaming helpers for BSNWav glue
 ************************************************/

#include <geos.h>
#include <geoworks.h>
#include <mem.h>
#include <heap.h>
#include <file.h>
#include <sound.h>
#include <system.h>
#include <Ansi/string.h>

#include "mp3_internal.h"

/* ---- Local helpers ---- */
static void     MP3_ResetDecoderState(MP3Handle *handleP);
static void     MP3_RefillInput(MP3Handle *handleP);
static Boolean  MP3_PrimeStream(MP3Handle *handleP);
static Boolean  MP3_DecodeNextFrame(MP3Handle *handleP);
static void     MP3_ScalePcmWithWWFixed(sword *samplesP,
                                        word sampleCount,
                                        WWFixed volume);
static word     MP3_MixStereoToMonoInPlace(sword *pcmP,
                                           word stereoSamples);

/* ---- Implementation ---- */

MP3Handle * _pascal
MP3_OpenStream(FileHandle fh, WWFixed volume, Boolean forceMono)
{
    MemHandle memH;
    MP3Handle *handleP;

    if (fh == 0)
    {
        return (MP3Handle *)0;
    }

    memH = MemAlloc((word)sizeof(MP3Handle), HF_SWAPABLE, HAF_ZERO_INIT);
    if (memH == NullHandle)
    {
        return (MP3Handle *)0;
    }

    handleP = (MP3Handle *)MemLock(memH);
    if (handleP == (MP3Handle *)0)
    {
        MemFree(memH);
        return (MP3Handle *)0;
    }

    _fmemset(handleP, 0, (word)sizeof(MP3Handle));
    handleP->selfHandle = memH;
    handleP->volume     = volume;
    handleP->forceMono  = forceMono;

    handleP->fh = fh;

    MP3_ResetDecoderState(handleP);

    if (!MP3_PrimeStream(handleP))
    {
        MP3_CloseStream(handleP);
        return (MP3Handle *)0;
    }

    return handleP;
}

void _pascal
MP3_CloseStream(MP3Handle *handleP)
{
    MemHandle memH;

    if (handleP == (MP3Handle *)0)
    {
        return;
    }

    memH = handleP->selfHandle;
    handleP->selfHandle = NullHandle;

    if (memH != NullHandle)
    {
        MemUnlock(memH);
        MemFree(memH);
    }
}

Boolean _pascal
MP3_RewindStream(MP3Handle *handleP)
{
    if (handleP == (MP3Handle *)0 || handleP->fh == 0)
    {
        return FALSE;
    }

    FilePos(handleP->fh, 0L, FILE_POS_START);
    MP3_ResetDecoderState(handleP);

    return MP3_PrimeStream(handleP);
}

word _pascal
MP3_StreamChannels(const MP3Handle *handleP)
{
    if (handleP == (const MP3Handle *)0)
    {
        return 0;
    }
    return handleP->outCh;
}

word _pascal
MP3_StreamSampleRate(const MP3Handle *handleP)
{
    if (handleP == (const MP3Handle *)0)
    {
        return 0;
    }
    return handleP->outRate;
}

word _pascal
MP3_StreamBlockAlign(const MP3Handle *handleP)
{
    word ch;

    ch = MP3_StreamChannels(handleP);
    return (word)(ch * 2u);
}

dword _pascal
MP3_ReadS16(MP3Handle *handleP, dword framesToRead, sword *dst)
{
    dword producedFrames;
    dword producedBytes;
    word blockAlign;
    byte far *dstFar;

    if ((handleP == (MP3Handle *)0) ||
        (dst == (sword *)0) ||
        (framesToRead == 0))
    {
        return 0;
    }

    blockAlign = MP3_StreamBlockAlign(handleP);
    if (blockAlign == 0)
    {
        return 0;
    }

    producedFrames = 0;
    producedBytes  = 0;
    dstFar = (byte far *)dst;

    while (framesToRead > 0)
    {
        word availableBytes;
        word availableFrames;
        word framesNow;
        word bytesNow;

        if (handleP->frameOff >= handleP->frameBytes)
        {
            if (!MP3_DecodeNextFrame(handleP))
            {
                break;
            }
        }

        availableBytes = (word)(handleP->frameBytes - handleP->frameOff);
        availableFrames = (word)(availableBytes / blockAlign);
        if (availableFrames == 0)
        {
            handleP->frameOff = handleP->frameBytes;
            continue;
        }

        framesNow = availableFrames;
        if ((dword)framesNow > framesToRead)
        {
            framesNow = (word)framesToRead;
        }
        bytesNow = (word)(framesNow * blockAlign);

        _fmemcpy(dstFar + producedBytes,
                 (byte far *)(handleP->frameBuf) + handleP->frameOff,
                 bytesNow);

        handleP->frameOff += bytesNow;
        producedFrames += framesNow;
        producedBytes  += bytesNow;
        framesToRead   -= framesNow;
    }

    return producedFrames;
}

/* ---- Static helpers ---- */

static void
MP3_ResetDecoderState(MP3Handle *handleP)
{
    handleP->inPos      = 0;
    handleP->inFill     = 0;
    handleP->eofSeen    = FALSE;
    handleP->frameBytes = 0;
    handleP->frameOff   = 0;
    handleP->outRate    = 0;
    handleP->outCh      = 0;
    handleP->primed     = FALSE;

    _fmemset(&(handleP->fi), 0, sizeof(handleP->fi));
    mp3dec_init(&(handleP->dec));
}

static Boolean
MP3_PrimeStream(MP3Handle *handleP)
{
    if (handleP == (MP3Handle *)0)
    {
        return FALSE;
    }

    while (!handleP->primed)
    {
        if (!MP3_DecodeNextFrame(handleP))
        {
            if (handleP->eofSeen && handleP->frameBytes == 0)
            {
                break;
            }
        }
    }

    return handleP->primed;
}

static void
MP3_RefillInput(MP3Handle *handleP)
{
    word moveLen;
    word need;
    word got;

    if (handleP->inFill > handleP->inPos)
    {
        moveLen = (word)(handleP->inFill - handleP->inPos);
        _fmemmove(handleP->inBuf,
                  handleP->inBuf + handleP->inPos,
                  moveLen);
        handleP->inFill = moveLen;
    }
    else
    {
        handleP->inFill = 0;
    }
    handleP->inPos = 0;

    need = (word)(MP3_INBUF_SIZE - handleP->inFill);
    if (need > 0)
    {
        got = FileRead(handleP->fh,
                       handleP->inBuf + handleP->inFill,
                       need,
                       FALSE);
        handleP->inFill += got;
        if (got == 0)
        {
            handleP->eofSeen = TRUE;
        }
    }
    else
    {
        handleP->eofSeen = TRUE;
    }
}

static Boolean
MP3_DecodeNextFrame(MP3Handle *handleP)
{
    int decodedSamples;
    word avail;

    avail = (word)(handleP->inFill - handleP->inPos);
    if ((avail < 64) && !handleP->eofSeen)
    {
        MP3_RefillInput(handleP);
        avail = (word)(handleP->inFill - handleP->inPos);
    }
    if ((avail == 0) && handleP->eofSeen)
    {
        handleP->frameBytes = 0;
        handleP->frameOff = 0;
        return FALSE;
    }

    _fmemset(&(handleP->fi), 0, sizeof(handleP->fi));

    decodedSamples = mp3dec_decode_frame(&(handleP->dec),
                        (const unsigned char *)(handleP->inBuf + handleP->inPos),
                        (int)avail,
                        handleP->frameBuf,
                        &(handleP->fi));

    SysNotify(SNF_CONTINUE, "we are", "here");


    if (handleP->fi.frame_bytes > 0)
    {
        handleP->inPos += (word)handleP->fi.frame_bytes;
        if (handleP->inPos > handleP->inFill)
        {
            handleP->inPos = handleP->inFill;
        }
    }
    else
    {
        if (avail > 0)
        {
            handleP->inPos += 1;
        }
        handleP->frameBytes = 0;
        handleP->frameOff = 0;
        return FALSE;
    }

    if (decodedSamples <= 0)
    {
        handleP->frameBytes = 0;
        handleP->frameOff = 0;
        return FALSE;
    }

    if (handleP->outRate == 0)
    {
        handleP->outRate = (word)handleP->fi.hz;
        handleP->outCh   = (word)handleP->fi.channels;
        if (handleP->forceMono && (handleP->outCh == 2))
        {
            handleP->outCh = 1;
        }
    }

    if (handleP->forceMono && (handleP->fi.channels == 2))
    {
        handleP->frameBytes = MP3_MixStereoToMonoInPlace(handleP->frameBuf,
                                                         (word)(decodedSamples / 2));
    }
    else
    {
        handleP->frameBytes = (word)(decodedSamples * 2);
    }

    MP3_ScalePcmWithWWFixed(handleP->frameBuf,
                            (word)(handleP->frameBytes / 2),
                            handleP->volume);

    handleP->frameOff = 0;
    handleP->primed = TRUE;
    return TRUE;
}

static void
MP3_ScalePcmWithWWFixed(sword *samplesP, word sampleCount, WWFixed volume)
{
    word i;
    long prod;
    sword s;

    if ((WWFixedToInt(volume) == 1) && (WWFixedToFrac(volume) == 0))
    {
        return;
    }
    for (i = 0; i < sampleCount; i++)
    {
        s = samplesP[i];
        prod = ((long)s * (long)WWFixedToInt(volume)) << 16;
        prod += ((long)s * (long)WWFixedToFrac(volume));
        prod >>= 16;
        if (prod > 32767)
        {
            prod = 32767;
        }
        if (prod < -32768)
        {
            prod = -32768;
        }
        samplesP[i] = (sword)prod;
    }
}

static word
MP3_MixStereoToMonoInPlace(sword *pcmP, word stereoSamples)
{
    word i;
    long L;
    long R;
    long m;

    for (i = 0; i < stereoSamples; i++)
    {
        L = (long)pcmP[2 * i + 0];
        R = (long)pcmP[2 * i + 1];
        m = (L + R) / 2;
        if (m > 32767)
        {
            m = 32767;
        }
        if (m < -32768)
        {
            m = -32768;
        }
        pcmP[i] = (sword)m;
    }
    return (word)(stereoSamples * 2);
}
