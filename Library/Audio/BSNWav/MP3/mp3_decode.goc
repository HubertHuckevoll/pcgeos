// #pragma noroot
/************************************************
 * mp3_decode.goc
 * - Minimp3 streaming helpers for BSNWav glue
 ************************************************/

#include <geos.h>
#include <geoworks.h>
#include <mem.h>
#include <heap.h>
#include <file.h>
#include <sound.h>
#include <system.h>
#include <Ansi/string.h>
#include <Ansi/stdio.h>

#ifndef FP_SEG
#define FP_SEG(fp) ((unsigned short)((unsigned long)(void far *)(fp) >> 16))
#endif
#ifndef FP_OFF
#define FP_OFF(fp) ((unsigned short)(fp))
#endif

#define MP3_TRACE_FRAME

#define MINIMP3_IMPLEMENTATION

#include "mp3_internal.h"

// defined in minimp3.h
// mp3dec_scratch_t _far *g_minimp3_scratch_ptr = (mp3dec_scratch_t _far *)0;

/* ---- Local helpers ---- */
static void     MP3_ResetDecoderState(MP3Handle *handleP);
static void     MP3_RefillInput(MP3Handle *handleP);
static Boolean  MP3_PrimeStream(MP3Handle *handleP);
static Boolean  MP3_DecodeNextFrame(MP3Handle *handleP);
static void     MP3_ScalePcmWithWWFixed(sword *samplesP,
                                        word sampleCount,
                                        WWFixed volume);
static word     MP3_MixStereoToMonoInPlace(sword *pcmP,
                                           word stereoSamples);
static Boolean  MP3_EnsureDecoderScratch(MP3Handle *handleP);
static void     MP3_FreeDecoderScratch(MP3Handle *handleP);

static Boolean  s_mp3LoggedInfo   = FALSE;

/* ---- Implementation ---- */

MP3Handle * _pascal
MP3_OpenStream(FileHandle fh, WWFixed volume, Boolean forceMono)
{
    MemHandle memH;
    MP3Handle *handleP;

    if (fh == 0)
    {
        return (MP3Handle *)0;
    }

    memH = MemAlloc((word)sizeof(MP3Handle), HF_SWAPABLE, HAF_ZERO_INIT);
    if (memH == NullHandle)
    {
        return (MP3Handle *)0;
    }

    handleP = (MP3Handle *)MemLock(memH);
    if (handleP == (MP3Handle *)0)
    {
        MemFree(memH);
        return (MP3Handle *)0;
    }

    _fmemset(handleP, 0, (word)sizeof(MP3Handle));
    handleP->selfHandle = memH;
    handleP->volume     = volume;
    handleP->forceMono  = forceMono;

    handleP->fh = fh;

    MP3_ResetDecoderState(handleP);
    s_mp3LoggedInfo   = FALSE;
    if (!MP3_EnsureDecoderScratch(handleP))
    {
        MP3_CloseStream(handleP);
        return (MP3Handle *)0;
    }

    if (!MP3_PrimeStream(handleP))
    {
        MP3_CloseStream(handleP);
        return (MP3Handle *)0;
    }

    return handleP;
}

void _pascal
MP3_CloseStream(MP3Handle *handleP)
{
    MemHandle memH;

    if (handleP == (MP3Handle *)0)
    {
        return;
    }

    MP3_FreeDecoderScratch(handleP);

    memH = handleP->selfHandle;
    handleP->selfHandle = NullHandle;

    if (memH != NullHandle)
    {
        MemUnlock(memH);
        MemFree(memH);
    }
}

Boolean _pascal
MP3_RewindStream(MP3Handle *handleP)
{
    if (handleP == (MP3Handle *)0 || handleP->fh == 0)
    {
        return FALSE;
    }

    if (!MP3_EnsureDecoderScratch(handleP))
    {
        return FALSE;
    }

    FilePos(handleP->fh, 0L, FILE_POS_START);
    MP3_ResetDecoderState(handleP);

    return MP3_PrimeStream(handleP);
}

word _pascal
MP3_StreamChannels(const MP3Handle *handleP)
{
    if (handleP == (const MP3Handle *)0)
    {
        return 0;
    }
    return handleP->outCh;
}

word _pascal
MP3_StreamSampleRate(const MP3Handle *handleP)
{
    if (handleP == (const MP3Handle *)0)
    {
        return 0;
    }
    return handleP->outRate;
}

word _pascal
MP3_StreamBlockAlign(const MP3Handle *handleP)
{
    word ch;

    ch = MP3_StreamChannels(handleP);
    return (word)(ch * 2u);
}

dword _pascal
MP3_ReadS16(MP3Handle *handleP, dword framesToRead, sword *dst)
{
    dword producedFrames;
    dword producedBytes;
    word blockAlign;
    byte far *dstFar;

    if ((handleP == (MP3Handle *)0) ||
        (dst == (sword *)0) ||
        (framesToRead == 0))
    {
        return 0;
    }

    blockAlign = MP3_StreamBlockAlign(handleP);
    if (blockAlign == 0)
    {
        return 0;
    }

    producedFrames = 0;
    producedBytes  = 0;
    dstFar = (byte far *)dst;

    while (framesToRead > 0)
    {
        word availableBytes;
        word availableFrames;
        word framesNow;
        word bytesNow;

        if (handleP->frameOff >= handleP->frameBytes)
        {
            if (!MP3_DecodeNextFrame(handleP))
            {
                break;
            }
        }

        availableBytes = (word)(handleP->frameBytes - handleP->frameOff);
        availableFrames = (word)(availableBytes / blockAlign);
        if (availableFrames == 0)
        {
            handleP->frameOff = handleP->frameBytes;
            continue;
        }

        framesNow = availableFrames;
        if ((dword)framesNow > framesToRead)
        {
            framesNow = (word)framesToRead;
        }
        bytesNow = (word)(framesNow * blockAlign);

        _fmemcpy(dstFar + producedBytes,
                 (byte far *)(handleP->frameBuf) + handleP->frameOff,
                 bytesNow);

        handleP->frameOff += bytesNow;
        producedFrames += framesNow;
        producedBytes  += bytesNow;
        framesToRead   -= framesNow;
    }

    return producedFrames;
}

/* ---- Static helpers ---- */

static Boolean
MP3_EnsureDecoderScratch(MP3Handle *handleP)
{
    int scratchSize;

    if (handleP == (MP3Handle *)0)
    {
        return FALSE;
    }

    if ((handleP->scratchMemH != NullHandle) &&
        (handleP->scratchMemP != (void _far *)0))
    {
        g_minimp3_scratch_ptr = (mp3dec_scratch_t _far *)(handleP->scratchMemP);
        return TRUE;
    }

    scratchSize = (int)sizeof(mp3dec_scratch_t);
    if (scratchSize <= 0 || scratchSize > 0xFFFF)
    {
        return FALSE;
    }

    handleP->scratchMemH = MemAlloc((word)scratchSize,
                                    HF_SWAPABLE,
                                    HAF_ZERO_INIT);
    if (handleP->scratchMemH == NullHandle)
    {
        return FALSE;
    }

    handleP->scratchMemP = (void _far *)MemLock(handleP->scratchMemH);
    if (handleP->scratchMemP == (void _far *)0)
    {
        MemFree(handleP->scratchMemH);
        handleP->scratchMemH = NullHandle;
        return FALSE;
    }

    g_minimp3_scratch_ptr = (mp3dec_scratch_t _far *)(handleP->scratchMemP);

    return TRUE;
}

static void
MP3_FreeDecoderScratch(MP3Handle *handleP)
{
    if (handleP == (MP3Handle *)0)
    {
        return;
    }

    if (handleP->scratchMemH != NullHandle)
    {
        if (handleP->scratchMemP != (void _far *)0)
        {
            MemUnlock(handleP->scratchMemH);
        }
        MemFree(handleP->scratchMemH);
    }

    handleP->scratchMemH = NullHandle;
    handleP->scratchMemP = (void _far *)0;

    g_minimp3_scratch_ptr = (mp3dec_scratch_t _far *)0;
}

static void
MP3_ResetDecoderState(MP3Handle *handleP)
{
    handleP->inPos      = 0;
    handleP->inFill     = 0;
    handleP->eofSeen    = FALSE;
    handleP->frameBytes = 0;
    handleP->frameOff   = 0;
    handleP->outRate    = 0;
    handleP->outCh      = 0;
    handleP->primed     = FALSE;

    _fmemset(&(handleP->fi), 0, sizeof(handleP->fi));
    mp3dec_init(&(handleP->dec));
}

static Boolean
MP3_PrimeStream(MP3Handle *handleP)
{
    if (handleP == (MP3Handle *)0)
    {
        return FALSE;
    }

    while (!handleP->primed)
    {
        if (!MP3_DecodeNextFrame(handleP))
        {
            if (handleP->eofSeen && handleP->frameBytes == 0)
            {
                break;
            }
        }
    }

    return handleP->primed;
}

static void
MP3_RefillInput(MP3Handle *handleP)
{
    word moveLen;
    word need;
    word got;

    if (handleP->inFill > handleP->inPos)
    {
        moveLen = (word)(handleP->inFill - handleP->inPos);
        _fmemmove(handleP->inBuf,
                  handleP->inBuf + handleP->inPos,
                  moveLen);
        handleP->inFill = moveLen;
    }
    else
    {
        handleP->inFill = 0;
    }
    handleP->inPos = 0;

    need = (word)(MP3_INBUF_SIZE - handleP->inFill);
    if (need > 0)
    {
        got = FileRead(handleP->fh,
                       handleP->inBuf + handleP->inFill,
                       need,
                       FALSE);
        handleP->inFill += got;
        if (got == 0)
        {
            handleP->eofSeen = TRUE;
        }
    }
    else
    {
        handleP->eofSeen = TRUE;
    }
}

static Boolean
MP3_DecodeNextFrame(MP3Handle *handleP)
{
    int decodedSamples;
    word avail;

    if (!MP3_EnsureDecoderScratch(handleP))
    {
        return FALSE;
    }

    avail = (word)(handleP->inFill - handleP->inPos);
    if ((avail < 64) && !handleP->eofSeen)
    {
        MP3_RefillInput(handleP);
        avail = (word)(handleP->inFill - handleP->inPos);
    }
    if ((avail == 0) && handleP->eofSeen)
    {
        handleP->frameBytes = 0;
        handleP->frameOff = 0;
        return FALSE;
    }

    _fmemset(&(handleP->fi), 0, sizeof(handleP->fi));

    decodedSamples = mp3dec_decode_frame(&(handleP->dec),
                        (const unsigned char *)(handleP->inBuf + handleP->inPos),
                        (int)avail,
                        handleP->frameBuf,
                        &(handleP->fi));

    #ifdef MP3_TRACE_FRAME
    if (!s_mp3LoggedInfo)
    {
        FileHandle        dbgFH;
        char              dbgBuf[256];
        word              dbgLen;
        word              sampleCount;
        word              i;
        mp3dec_scratch_t _far *scratch;

        dbgFH = FileCreate("mp3trace.txt",
                           FILE_CREATE_TRUNCATE |
                           FILE_ACCESS_RW |
                           FILE_DENY_NONE |
                           FCF_NATIVE,
                           FILE_ATTR_NORMAL);
        if (dbgFH != 0)
        {
            long raw;

            scratch = g_minimp3_scratch_ptr;
            dbgLen = (word)sprintf(dbgBuf,
                                   "inPos=%u inFill=%u frameBytes=%lu decoded=%d ch=%u reserv=%lu freeFmt=%lu mdb=%lu part23=%lu\r\n",
                                   handleP->inPos,
                                   handleP->inFill,
                                   (unsigned long)handleP->fi.frame_bytes,
                                   decodedSamples,
                                   (unsigned)handleP->fi.channels,
                                   (unsigned long)handleP->dec.reserv,
                                   (unsigned long)handleP->dec.free_format_bytes,
                                   (unsigned long)handleP->dec.debug_main_data_begin,
                                   (unsigned long)handleP->dec.debug_part23_sum);
            FileWrite(dbgFH, dbgBuf, dbgLen, FALSE);

            if (scratch != (mp3dec_scratch_t _far *)0)
            {
                dbgLen = (word)sprintf(dbgBuf,
                                       "bs.pos=%lu bs.limit=%lu gr0_p23=%u gr0_big=%u gr0_gain=%u\r\n",
                                       (unsigned long)scratch->bs.pos,
                                       (unsigned long)scratch->bs.limit,
                                       scratch->gr_info[0].part_23_length,
                                       scratch->gr_info[0].big_values,
                                       scratch->gr_info[0].global_gain);
                FileWrite(dbgFH, dbgBuf, dbgLen, FALSE);

                dbgLen = (word)sprintf(dbgBuf, "grbuf:");
                FileWrite(dbgFH, dbgBuf, dbgLen, FALSE);
                for (i = 0; i < 8; i++)
                {
                    memcpy(&raw, &scratch->grbuf[0][i], sizeof(long));
                    dbgLen = (word)sprintf(dbgBuf, " %08lX", raw);
                    FileWrite(dbgFH, dbgBuf, dbgLen, FALSE);
                }
                FileWrite(dbgFH, "\r\n", 2, FALSE);
            }

            dbgLen = (word)sprintf(dbgBuf, "pcm:");
            FileWrite(dbgFH, dbgBuf, dbgLen, FALSE);

            sampleCount = (decodedSamples > 0)
                          ? (word)((dword)decodedSamples * (dword)handleP->fi.channels)
                          : 0;
            for (i = 0; (i < 16) && (i < sampleCount); i++)
            {
                dbgLen = (word)sprintf(dbgBuf, " %d", handleP->frameBuf[i]);
                FileWrite(dbgFH, dbgBuf, dbgLen, FALSE);
            }
            FileWrite(dbgFH, "\r\n", 2, FALSE);
            FileClose(dbgFH, TRUE);
        }
        s_mp3LoggedInfo = TRUE;
    }
    #endif /* MP3_TRACE_FRAME */

    if (handleP->fi.frame_bytes > 0)
    {
        handleP->inPos += (word)handleP->fi.frame_bytes;
        if (handleP->inPos > handleP->inFill)
        {
            handleP->inPos = handleP->inFill;
        }
    }
    else
    {
        if (avail > 0)
        {
            handleP->inPos += 1;
        }
        handleP->frameBytes = 0;
        handleP->frameOff = 0;
        return FALSE;
    }

    if (decodedSamples <= 0)
    {
        handleP->frameBytes = 0;
        handleP->frameOff = 0;
        return FALSE;
    }

    if (handleP->outRate == 0)
    {
        handleP->outRate = (word)handleP->fi.hz;
        handleP->outCh   = (word)handleP->fi.channels;
        if (handleP->forceMono && (handleP->outCh == 2))
        {
            handleP->outCh = 1;
        }
    }

    if (handleP->forceMono && (handleP->fi.channels == 2))
    {
        word stereoSamples;

        stereoSamples = (word)decodedSamples;
        handleP->frameBytes = MP3_MixStereoToMonoInPlace(handleP->frameBuf,
                                                         stereoSamples);
    }
    else
    {
        dword totalSamples;

        totalSamples = (dword)decodedSamples * (dword)handleP->outCh;
        handleP->frameBytes = (word)(totalSamples * (dword)sizeof(sword));
    }

    MP3_ScalePcmWithWWFixed(handleP->frameBuf,
                            (word)(handleP->frameBytes / 2),
                            handleP->volume);

    handleP->frameOff = 0;
    handleP->primed = TRUE;
    return TRUE;
}

static void
MP3_ScalePcmWithWWFixed(sword *samplesP, word sampleCount, WWFixed volume)
{
    word i;
    long prod;
    sword s;

    if ((WWFixedToInt(volume) == 1) && (WWFixedToFrac(volume) == 0))
    {
        return;
    }
    for (i = 0; i < sampleCount; i++)
    {
        s = samplesP[i];
        prod = ((long)s * (long)WWFixedToInt(volume)) << 16;
        prod += ((long)s * (long)WWFixedToFrac(volume));
        prod >>= 16;
        if (prod > 32767)
        {
            prod = 32767;
        }
        if (prod < -32768)
        {
            prod = -32768;
        }
        samplesP[i] = (sword)prod;
    }
}

static word
MP3_MixStereoToMonoInPlace(sword *pcmP, word stereoSamples)
{
    word i;
    long L;
    long R;
    long m;

    for (i = 0; i < stereoSamples; i++)
    {
        L = (long)pcmP[2 * i + 0];
        R = (long)pcmP[2 * i + 1];
        m = (L + R) / 2;
        if (m > 32767)
        {
            m = 32767;
        }
        if (m < -32768)
        {
            m = -32768;
        }
        pcmP[i] = (sword)m;
    }
    return (word)(stereoSamples * 2);
}
