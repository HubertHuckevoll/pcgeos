// #pragma noroot
/************************************************
 * mp3_decode.goc
 * - Minimp3 streaming helpers for BSNWav glue
 ************************************************/

#include <geos.h>
#include <geoworks.h>
#include <mem.h>
#include <heap.h>
#include <file.h>
#include <sound.h>
#include <system.h>
#include <Ansi/string.h>
#include <Ansi/stdio.h>

#ifndef FP_SEG
#define FP_SEG(fp) ((unsigned short)((unsigned long)(void far *)(fp) >> 16))
#endif
#ifndef FP_OFF
#define FP_OFF(fp) ((unsigned short)(fp))
#endif

#define MINIMP3_IMPLEMENTATION

#include "mp3_internal.h"

// mp3dec_scratch_t *g_minimp3_scratch_ptr;

/* ---- Local helpers ---- */
static void     MP3_ResetDecoderState(MP3Handle *handleP);
static void     MP3_RefillInput(MP3Handle *handleP);
static Boolean  MP3_PrimeStream(MP3Handle *handleP);
static Boolean  MP3_DecodeNextFrame(MP3Handle *handleP);
static void     MP3_ScalePcmWithWWFixed(sword *samplesP,
                                        word sampleCount,
                                        WWFixed volume);
static word     MP3_MixStereoToMonoInPlace(sword *pcmP,
                                           word stereoSamples);
static Boolean  MP3_EnsureDecoderScratch(MP3Handle *handleP);
static void     MP3_FreeDecoderScratch(MP3Handle *handleP);

static Boolean  s_mp3DumpedToFile = FALSE;
static Boolean  s_mp3LoggedInfo   = FALSE;

/* ---- Implementation ---- */

MP3Handle * _pascal
MP3_OpenStream(FileHandle fh, WWFixed volume, Boolean forceMono)
{
    MemHandle memH;
    MP3Handle *handleP;

    if (fh == 0)
    {
        return (MP3Handle *)0;
    }

    memH = MemAlloc((word)sizeof(MP3Handle), HF_SWAPABLE, HAF_ZERO_INIT);
    if (memH == NullHandle)
    {
        return (MP3Handle *)0;
    }

    handleP = (MP3Handle *)MemLock(memH);
    if (handleP == (MP3Handle *)0)
    {
        MemFree(memH);
        return (MP3Handle *)0;
    }

    _fmemset(handleP, 0, (word)sizeof(MP3Handle));
    handleP->selfHandle = memH;
    handleP->volume     = volume;
    handleP->forceMono  = forceMono;

    handleP->fh = fh;

    MP3_ResetDecoderState(handleP);
    s_mp3DumpedToFile = FALSE;
    s_mp3LoggedInfo   = FALSE;
    if (!MP3_EnsureDecoderScratch(handleP))
    {
        MP3_CloseStream(handleP);
        return (MP3Handle *)0;
    }

    if (!MP3_PrimeStream(handleP))
    {
        MP3_CloseStream(handleP);
        return (MP3Handle *)0;
    }

    return handleP;
}

void _pascal
MP3_CloseStream(MP3Handle *handleP)
{
    MemHandle memH;

    if (handleP == (MP3Handle *)0)
    {
        return;
    }

    MP3_FreeDecoderScratch(handleP);

    memH = handleP->selfHandle;
    handleP->selfHandle = NullHandle;

    if (memH != NullHandle)
    {
        MemUnlock(memH);
        MemFree(memH);
    }
}

Boolean _pascal
MP3_RewindStream(MP3Handle *handleP)
{
    if (handleP == (MP3Handle *)0 || handleP->fh == 0)
    {
        return FALSE;
    }

    if (!MP3_EnsureDecoderScratch(handleP))
    {
        return FALSE;
    }

    FilePos(handleP->fh, 0L, FILE_POS_START);
    MP3_ResetDecoderState(handleP);

    return MP3_PrimeStream(handleP);
}

word _pascal
MP3_StreamChannels(const MP3Handle *handleP)
{
    if (handleP == (const MP3Handle *)0)
    {
        return 0;
    }
    return handleP->outCh;
}

word _pascal
MP3_StreamSampleRate(const MP3Handle *handleP)
{
    if (handleP == (const MP3Handle *)0)
    {
        return 0;
    }
    return handleP->outRate;
}

word _pascal
MP3_StreamBlockAlign(const MP3Handle *handleP)
{
    word ch;

    ch = MP3_StreamChannels(handleP);
    return (word)(ch * 2u);
}

dword _pascal
MP3_ReadS16(MP3Handle *handleP, dword framesToRead, sword *dst)
{
    dword producedFrames;
    dword producedBytes;
    word blockAlign;
    byte far *dstFar;

    if ((handleP == (MP3Handle *)0) ||
        (dst == (sword *)0) ||
        (framesToRead == 0))
    {
        return 0;
    }

    blockAlign = MP3_StreamBlockAlign(handleP);
    if (blockAlign == 0)
    {
        return 0;
    }

    producedFrames = 0;
    producedBytes  = 0;
    dstFar = (byte far *)dst;

    while (framesToRead > 0)
    {
        word availableBytes;
        word availableFrames;
        word framesNow;
        word bytesNow;

        if (handleP->frameOff >= handleP->frameBytes)
        {
            if (!MP3_DecodeNextFrame(handleP))
            {
                break;
            }
        }

        availableBytes = (word)(handleP->frameBytes - handleP->frameOff);
        availableFrames = (word)(availableBytes / blockAlign);
        if (availableFrames == 0)
        {
            handleP->frameOff = handleP->frameBytes;
            continue;
        }

        framesNow = availableFrames;
        if ((dword)framesNow > framesToRead)
        {
            framesNow = (word)framesToRead;
        }
        bytesNow = (word)(framesNow * blockAlign);

        _fmemcpy(dstFar + producedBytes,
                 (byte far *)(handleP->frameBuf) + handleP->frameOff,
                 bytesNow);

        handleP->frameOff += bytesNow;
        producedFrames += framesNow;
        producedBytes  += bytesNow;
        framesToRead   -= framesNow;
    }

    return producedFrames;
}

/* ---- Static helpers ---- */

static Boolean
MP3_EnsureDecoderScratch(MP3Handle *handleP)
{
    int scratchSize;

    if (handleP == (MP3Handle *)0)
    {
        return FALSE;
    }

    if ((handleP->scratchMemH != NullHandle) &&
        (handleP->scratchMemP != (void *)0))
    {
        g_minimp3_scratch_ptr = handleP->scratchMemP;
        return TRUE;
    }

    scratchSize = (int)sizeof(mp3dec_scratch_t);
    if (scratchSize <= 0 || scratchSize > 0xFFFF)
    {
        return FALSE;
    }

    handleP->scratchMemH = MemAlloc((word)scratchSize,
                                    HF_SWAPABLE,
                                    HAF_ZERO_INIT);
    if (handleP->scratchMemH == NullHandle)
    {
        return FALSE;
    }

    handleP->scratchMemP = (void *)MemLock(handleP->scratchMemH);
    if (handleP->scratchMemP == (void *)0)
    {
        MemFree(handleP->scratchMemH);
        handleP->scratchMemH = NullHandle;
        return FALSE;
    }

    g_minimp3_scratch_ptr = handleP->scratchMemP;

    return TRUE;
}

static void
MP3_FreeDecoderScratch(MP3Handle *handleP)
{
    if (handleP == (MP3Handle *)0)
    {
        return;
    }

    if (handleP->scratchMemH != NullHandle)
    {
        if (handleP->scratchMemP != (void *)0)
        {
            MemUnlock(handleP->scratchMemH);
        }
        MemFree(handleP->scratchMemH);
    }

    handleP->scratchMemH = NullHandle;
    handleP->scratchMemP = (void *)0;

    g_minimp3_scratch_ptr = (void *)0;
    // mp3dec_assign_scratch((void *)0);
}

static void
MP3_ResetDecoderState(MP3Handle *handleP)
{
    handleP->inPos      = 0;
    handleP->inFill     = 0;
    handleP->eofSeen    = FALSE;
    handleP->frameBytes = 0;
    handleP->frameOff   = 0;
    handleP->outRate    = 0;
    handleP->outCh      = 0;
    handleP->primed     = FALSE;

    _fmemset(&(handleP->fi), 0, sizeof(handleP->fi));
    mp3dec_init(&(handleP->dec));
}

static Boolean
MP3_PrimeStream(MP3Handle *handleP)
{
    if (handleP == (MP3Handle *)0)
    {
        return FALSE;
    }

    while (!handleP->primed)
    {
        if (!MP3_DecodeNextFrame(handleP))
        {
            if (handleP->eofSeen && handleP->frameBytes == 0)
            {
                break;
            }
        }
    }

    return handleP->primed;
}

static void
MP3_RefillInput(MP3Handle *handleP)
{
    word moveLen;
    word need;
    word got;

    if (handleP->inFill > handleP->inPos)
    {
        moveLen = (word)(handleP->inFill - handleP->inPos);
        _fmemmove(handleP->inBuf,
                  handleP->inBuf + handleP->inPos,
                  moveLen);
        handleP->inFill = moveLen;
    }
    else
    {
        handleP->inFill = 0;
    }
    handleP->inPos = 0;

    need = (word)(MP3_INBUF_SIZE - handleP->inFill);
    if (need > 0)
    {
        got = FileRead(handleP->fh,
                       handleP->inBuf + handleP->inFill,
                       need,
                       FALSE);
        handleP->inFill += got;
        if (got == 0)
        {
            handleP->eofSeen = TRUE;
        }
    }
    else
    {
        handleP->eofSeen = TRUE;
    }
}

static Boolean
MP3_DecodeNextFrame(MP3Handle *handleP)
{
    int decodedSamples;
    word avail;

    if (!MP3_EnsureDecoderScratch(handleP))
    {
        return FALSE;
    }

    avail = (word)(handleP->inFill - handleP->inPos);
    if ((avail < 64) && !handleP->eofSeen)
    {
        MP3_RefillInput(handleP);
        avail = (word)(handleP->inFill - handleP->inPos);
    }
    if ((avail == 0) && handleP->eofSeen)
    {
        handleP->frameBytes = 0;
        handleP->frameOff = 0;
        return FALSE;
    }

    _fmemset(&(handleP->fi), 0, sizeof(handleP->fi));

    decodedSamples = mp3dec_decode_frame(&(handleP->dec),
                        (const unsigned char *)(handleP->inBuf + handleP->inPos),
                        (int)avail,
                        handleP->frameBuf,
                        &(handleP->fi));

    if (handleP->fi.frame_bytes > 0)
    {
        handleP->inPos += (word)handleP->fi.frame_bytes;
        if (handleP->inPos > handleP->inFill)
        {
            handleP->inPos = handleP->inFill;
        }
    }
    else
    {
        if (avail > 0)
        {
            handleP->inPos += 1;
        }
        handleP->frameBytes = 0;
        handleP->frameOff = 0;
        return FALSE;
    }

    if (decodedSamples <= 0)
    {
        handleP->frameBytes = 0;
        handleP->frameOff = 0;
        return FALSE;
    }

    if (handleP->outRate == 0)
    {
        handleP->outRate = (word)handleP->fi.hz;
        handleP->outCh   = (word)handleP->fi.channels;
        if (handleP->forceMono && (handleP->outCh == 2))
        {
            handleP->outCh = 1;
        }
    }

    if (handleP->forceMono && (handleP->fi.channels == 2))
    {
        handleP->frameBytes = MP3_MixStereoToMonoInPlace(handleP->frameBuf,
                                                         (word)(decodedSamples / 2));
    }
    else
    {
        handleP->frameBytes = (word)(decodedSamples * 2);
    }

    MP3_ScalePcmWithWWFixed(handleP->frameBuf,
                            (word)(handleP->frameBytes / 2),
                            handleP->volume);

#ifdef MP3_DUMP_PCM
    if (!s_mp3LoggedInfo && handleP->frameBytes > 0)
    {
        FileHandle dbgFH;
        char       dbgBuf[200];
        word       dbgLen;
        word       sampleCount;
        void far  *globalPtr;
        word       segAssigned;
        word       offAssigned;
        word       segGlobal;
        word       offGlobal;
        int        i;

        globalPtr   = g_minimp3_scratch_ptr;
        segAssigned = FP_SEG(handleP->scratchMemP);
        offAssigned = FP_OFF(handleP->scratchMemP);
        segGlobal   = FP_SEG(globalPtr);
        offGlobal   = FP_OFF(globalPtr);
        sampleCount = (word)(handleP->frameBytes / 2);

        dbgFH = FileCreate("mp3dbg.txt",
                           FILE_CREATE_TRUNCATE |
                           FILE_ACCESS_RW |
                           FILE_DENY_NONE |
                           FCF_NATIVE,
                           FILE_ATTR_NORMAL);
        if (dbgFH != 0)
        {
            dbgLen = (word)sprintf(dbgBuf,
                                   "assigned=%04X:%04X global=%04X:%04X decoded=%d frameBytes=%u\r\n",
                                   segAssigned,
                                   offAssigned,
                                   segGlobal,
                                   offGlobal,
                                   decodedSamples,
                                   handleP->frameBytes);
            FileWrite(dbgFH, dbgBuf, dbgLen, FALSE);

            dbgLen = (word)sprintf(dbgBuf, "samples:");
            FileWrite(dbgFH, dbgBuf, dbgLen, FALSE);

            for (i = 0; (i < 16) && (i < sampleCount); i++)
            {
                dbgLen = (word)sprintf(dbgBuf, " %d", handleP->frameBuf[i]);
                FileWrite(dbgFH, dbgBuf, dbgLen, FALSE);
            }
            FileWrite(dbgFH, "\r\n", 2, FALSE);
            FileClose(dbgFH, TRUE);
        }
        s_mp3LoggedInfo = TRUE;
    }

    if (!s_mp3DumpedToFile && handleP->frameBytes > 0)
    {
        FileHandle dumpFH;

        dumpFH = FileCreate("mp3.raw",
                            FILE_CREATE_TRUNCATE |
                            FILE_ACCESS_RW |
                            FILE_DENY_NONE |
                            FCF_NATIVE,
                            FILE_ATTR_NORMAL);
        if (dumpFH != 0)
        {
            FileWrite(dumpFH,
                      handleP->frameBuf,
                      handleP->frameBytes,
                      FALSE);
            FileClose(dumpFH, TRUE);
            s_mp3DumpedToFile = TRUE;
        }
    }
#endif

    handleP->frameOff = 0;
    handleP->primed = TRUE;
    return TRUE;
}

static void
MP3_ScalePcmWithWWFixed(sword *samplesP, word sampleCount, WWFixed volume)
{
    word i;
    long prod;
    sword s;

    if ((WWFixedToInt(volume) == 1) && (WWFixedToFrac(volume) == 0))
    {
        return;
    }
    for (i = 0; i < sampleCount; i++)
    {
        s = samplesP[i];
        prod = ((long)s * (long)WWFixedToInt(volume)) << 16;
        prod += ((long)s * (long)WWFixedToFrac(volume));
        prod >>= 16;
        if (prod > 32767)
        {
            prod = 32767;
        }
        if (prod < -32768)
        {
            prod = -32768;
        }
        samplesP[i] = (sword)prod;
    }
}

static word
MP3_MixStereoToMonoInPlace(sword *pcmP, word stereoSamples)
{
    word i;
    long L;
    long R;
    long m;

    for (i = 0; i < stereoSamples; i++)
    {
        L = (long)pcmP[2 * i + 0];
        R = (long)pcmP[2 * i + 1];
        m = (L + R) / 2;
        if (m > 32767)
        {
            m = 32767;
        }
        if (m < -32768)
        {
            m = -32768;
        }
        pcmP[i] = (sword)m;
    }
    return (word)(stereoSamples * 2);
}
