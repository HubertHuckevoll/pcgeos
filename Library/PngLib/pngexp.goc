/********************************************************************
 A simple and pretty incomplete PNG import libray for PC/GEOS.
 Started in 08/2024 by MeyerK for the FreeGEOS project.

 The code itself was written from scratch - relying heavily
 on ChatGPT for the PNG-specific parts.
 *******************************************************************/

// Include our API
#include "pnglib.h"
@include <giflib.goh>
@include <extgraph.goh>

// "Local headers"
static inline unsigned long swapEndian(unsigned long val);

/********************************************************************
    API
********************************************************************/
Boolean _pascal _export pngExportBitmap(VMFileHandle srcfile, VMBlockHandle bmpblock, FileLongName destname, FileHandle destfile)
{
    void *lineptr;
    word size;
    GifStreamHandle handle;
    GifError stat = GE_NO_ERROR;
    int width, height;
    BMType bmptype;
    BMFormat bitform;
    SizeAsDWord size_xy;
    word y;

    // determine bitmap size
    size_xy = BmpGetBitmapSize(srcfile, bmpblock, &stat);
    if(stat != GE_NO_ERROR) return(stat);
    width = DWORD_WIDTH(size_xy);
    height = DWORD_HEIGHT(size_xy);

    // determine type
    bmptype = BmpGetBitmapType(srcfile, bmpblock, &stat);
    if(stat != GE_NO_ERROR) return(stat);
    bitform = bmptype & BMT_FORMAT;

    if(bmptype & BMT_PALETTE)
    {
        RGBValue *palptr;
        MemHandle palmem;

        // get palette of this bitmap here
        if(bitform == BMF_4BIT)
        {
            palmem = MemAlloc(sizeof(RGBValue) * 16, HF_FIXED, 0);

            if(palmem)
            {
                palptr = (RGBValue*) MemDeref(palmem);
                if(palptr) BmpGetBitmapPalette(srcfile, bmpblock, palptr, 16, &stat);
            }
        }
        else // (bitform == BMF_8BIT)
        {
            palmem = MemAlloc(sizeof(RGBValue) * 256, HF_FIXED, 0);
            if(palmem)
            {
                palptr = (RGBValue*) MemDeref(palmem);
                if(palptr) BmpGetBitmapPalette(srcfile, bmpblock, palptr, 256, &stat);
            }
        }

        if((palmem) && (palptr))
        {
            if(stat == GE_NO_ERROR)
            {
                // handle = GifExportStreamCreate(bitform, width, height, destname, destfile, palptr, &stat);
            }
            else
            {
                stat = GE_BLOCK_LOCK_FAILURE;
            }

            MemFree(palmem);
        }
        else
        {
            return(GE_OUT_OF_MEMORY);
        }
    }
    else
    {
        //handle = GifExportStreamCreate(bitform, width, height, destname, destfile, 0, &stat);
    }

    if(stat != GE_NO_ERROR) return(stat);

    // loop reading all pixels
    y = 0;
    while((y != height) && (stat == GE_NO_ERROR))
    {
        if(HAL_COUNT(HugeArrayLock(srcfile, bmpblock, y , &lineptr, &size)))
        {
            // stat = GifExportStreamWriteLine(handle, lineptr);
            HugeArrayUnlock(lineptr);
        }
        else
        {
            // GifExportStreamDestroy(handle, TRUE);
            return(GE_INVALID_BITMAP);
        }

        y++;
    }

    // finish writing the file
    // stat = GifExportStreamDestroy(handle, FALSE);

    return(stat);
}

/*********************************************************************/
Boolean _pascal _export pngExportBitmapFName(VMFileHandle srcfile, VMBlockHandle bmpblock, PathName destname)
{
	GifError stat = GE_NO_ERROR;
	stat = pngExportBitmap(srcfile, bmpblock, destname, 0);

	return(stat);
}

/*********************************************************************/

Boolean _pascal _export pngExportBitmapFHandle(VMFileHandle srcfile, VMBlockHandle bmpblock, FileHandle destfile)
{
	GifError stat = GE_NO_ERROR;
	stat = pngExportBitmap(srcfile, bmpblock, 0, destfile);

	return(stat);
}

/*********************************************************************
    Internal functions
**********************************************************************/

Boolean _pascal writePngHeader(FileHandle file)
{
    word bytesWritten;

    // Write the PNG signature to the file
    bytesWritten = FileWrite(file, PNG_SIGNATURE, sizeof(PNG_SIGNATURE), FALSE);
    if (bytesWritten != sizeof(PNG_SIGNATURE))
    {
        return FALSE; // Failed to write signature
    }

    return TRUE; // Successfully wrote PNG header
}

Boolean _pascal writePLTEChunk(FileHandle file, RGBValue *palette, word numEntries)
{
    pngChunkHeader header;
    dword crc;
    word bytesWritten;
    word i;

    if (numEntries == 0 || numEntries > PNG_MAX_PALETTE_ENTRIES)
    {
        return FALSE;
    }

    // Write chunk header
    header.length = swapEndian((dword)(numEntries * 3));  // Each entry is 3 bytes (RGB)
    header.type = swapEndian((dword)PNG_CHUNK_PLTE);

    bytesWritten = FileWrite(file, &header, sizeof(header), FALSE);
    if (bytesWritten != sizeof(header))
    {
        return FALSE;
    }

    // Write palette data
    for (i = 0; i < numEntries; i++)
    {
        bytesWritten = FileWrite(file, &palette[i], 3, FALSE);
        if (bytesWritten != 3)
        {
            return FALSE;
        }
    }

    // Compute and write CRC
    crc = crc32(0, (unsigned char *)&header.type, sizeof(header.type));
    crc = crc32(crc, (unsigned char *)palette, (dword)(numEntries * 3));

    crc = swapEndian(crc);
    bytesWritten = FileWrite(file, &crc, sizeof(crc), FALSE);
    if (bytesWritten != sizeof(crc))
    {
        return FALSE;
    }

    return TRUE;
}





// swap endianness
static inline unsigned long swapEndian(unsigned long val)
{
    return ((val >> 24) & 0x000000FF) |
           ((val >> 8) & 0x0000FF00) |
           ((val << 8) & 0x00FF0000) |
           ((val << 24) & 0xFF000000);
}

