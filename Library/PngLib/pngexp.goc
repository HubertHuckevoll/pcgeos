/********************************************************************
 PNG export.
 Started in 03/2025 by MeyerK for the FreeGEOS project.

 The code itself was written from scratch - relying heavily
 on ChatGPT for the PNG-specific parts, again.
 *******************************************************************/

// Includes
#include "pnglib.h"
#include "pngexp.h"
#include "common.h"
@include <extgraph.goh>

/********************************************************************
    API
********************************************************************/
PngError _pascal pngExportBitmap(VMFileHandle srcfile, VMBlockHandle bmpblock, FileLongName destname, FileHandle destfile)
{
    dword width;
    dword height;
    BMType bmptype;
    BMFormat bitform;
    SizeAsDWord size_xy;
    PngError stat = PE_NO_ERROR;
    EGError egStat = EGE_NO_ERROR;
    pngIHDRData ihdrData = {0};

    // Determine bitmap size
    size_xy = BmpGetBitmapSize(srcfile, bmpblock, &egStat);
    if (stat != EGE_NO_ERROR) return PE_INVALID_BITMAP;
    width = DWORD_WIDTH(size_xy);
    height = DWORD_HEIGHT(size_xy);

    // Determine type
    bmptype = BmpGetBitmapType(srcfile, bmpblock, &egStat);
    if (stat != EGE_NO_ERROR) return PE_INVALID_BITMAP;
    bitform = bmptype & BMT_FORMAT;

    // Set up ihdrData - we will need it a lot
    // Determine color type from GEOS format
    ihdrData.colorType = mapGEOSToPNGColorType(bmptype);

    // Determine bit depth based on BMFormat
    switch (bitform)
    {
        case BMF_MONO:  ihdrData.bitDepth = 1; break;
        case BMF_4BIT:  ihdrData.bitDepth = 4; break;
        case BMF_8BIT:  ihdrData.bitDepth = 8; break;
        case BMF_24BIT: ihdrData.bitDepth = 8; break; // 8 bits per channel in truecolor
        default:        return FALSE; // Unsupported format
    }

    // Set PNG standard fields
    ihdrData.width = swapEndian(width);
    ihdrData.height = swapEndian(height);
    ihdrData.compressionMethod = 0; // Default PNG compression method
    ihdrData.filterMethod = 0; // PNG allows adaptive filtering, default is 0
    ihdrData.interlaceMethod = 0; // No interlacing

    // start writing chunks
    if (!writePngHeader(destfile))
    {
        stat = PE_WRITE_PROBLEM;
    }

    // Write IHDR chunk
    if (!writeIHDRChunk(destfile, &ihdrData))
    {
        stat = PE_WRITE_PROBLEM;
    }

    // Write PLTE chunk (if applicable)
    writePLTEChunk(destfile, srcfile, bmpblock, bmptype, bitform);

    // Write IDAT chunk (handles scanline processing, filtering, and compression)
    if (!writeIDATChunk(destfile, srcfile, bmpblock, &ihdrData))
    {
        stat = PE_WRITE_PROBLEM;
    }

    // Write IEND chunk
    if (!writeIENDChunk(destfile)) stat = PE_WRITE_PROBLEM;

    return stat;
}

/*********************************************************************/
PngError _pascal _export pngExportBitmapFName(VMFileHandle srcfile, VMBlockHandle bmpblock, PathName destname)
{
	PngError stat = PE_NO_ERROR;
	stat = pngExportBitmap(srcfile, bmpblock, destname, 0);

	return(stat);
}

/*********************************************************************/
PngError _pascal _export pngExportBitmapFHandle(VMFileHandle srcfile, VMBlockHandle bmpblock, FileHandle destfile)
{
	PngError stat = PE_NO_ERROR;
	stat = pngExportBitmap(srcfile, bmpblock, 0, destfile);

	return(stat);
}

/*********************************************************************
    Chunk writing functions
**********************************************************************/
Boolean _pascal writePngHeader(FileHandle file)
{
    word bytesWritten;

    // make sure we are at the beginning of the file
    FilePos(file, 0, FILE_POS_START);

    // Write the PNG signature to the file
    bytesWritten = FileWrite(file, PNG_SIGNATURE, sizeof(PNG_SIGNATURE), FALSE);
    if (bytesWritten != sizeof(PNG_SIGNATURE))
    {
        return FALSE; // Failed to write signature
    }

    return TRUE; // Successfully wrote PNG header
}

/*********************************************************************/
Boolean _pascal writeIHDRChunk(FileHandle file, pngIHDRData* ihdrData)
{
    pngChunkHeader ihdrHeader;
    dword crc;

    // Prepare IHDR chunk header
    ihdrHeader.length = swapEndian(sizeof(pngIHDRData));
    ihdrHeader.type = swapEndian(PNG_CHUNK_IHDR);

    // Write IHDR chunk header
    if (FileWrite(file, &ihdrHeader, sizeof(ihdrHeader), FALSE) != sizeof(ihdrHeader))
    {
        return FALSE; // Failed to write IHDR header
    }

    // Initialize CRC calculation
    crc = crc32(0, (byte *)&ihdrHeader.type, sizeof(ihdrHeader.type));
    crc = crc32(crc, (byte *)ihdrData, sizeof(*ihdrData));

    // Write IHDR data
    if (FileWrite(file, ihdrData, sizeof(pngIHDRData), FALSE) != sizeof(pngIHDRData))
    {
        return FALSE; // Failed to write IHDR data
    }

    // Write CRC at the end of the IHDR chunk
    crc = swapEndian(crc);
    if (FileWrite(file, &crc, sizeof(crc), FALSE) != sizeof(crc))
    {
        return FALSE; // Failed to write IHDR CRC
    }

    return TRUE;
}

/*********************************************************************/
Boolean _pascal writePLTEChunk(FileHandle file, VMFileHandle srcfile, VMBlockHandle bmpblock, BMType bmptype, BMFormat bitform)
{
    pngChunkHeader header;
    dword crc;
    word bytesWritten;
    word i;
    word numEntries = 0;
    RGBValue *palPtr;
    MemHandle palMem;
    PngError stat = PE_NO_ERROR;
    byte rgb[3];

    if (bmptype & BMT_PALETTE)
    {
        numEntries = (bitform == BMF_4BIT) ? 16 : 256;

        // Get palette of this bitmap
        palMem = MemAlloc((sizeof(RGBValue) * numEntries), HF_SWAPABLE, HAF_ZERO_INIT);
        if (!palMem)
        {
            return FALSE; // Memory allocation failed
        }

        palPtr = (RGBValue*) MemLock(palMem);
        if (!palPtr)
        {
            MemFree(palMem);
            return FALSE; // Memory lock failed
        }

        BmpGetBitmapPalette(srcfile, bmpblock, palPtr, numEntries, &stat);

        if (numEntries == 0 || numEntries > PNG_MAX_PALETTE_ENTRIES)
        {
            MemFree(palMem);
            return FALSE;
        }

        // Write chunk header
        header.length = swapEndian((dword)(numEntries * 3));  // Each entry is 3 bytes (RGB)
        header.type = swapEndian((dword)PNG_CHUNK_PLTE);

        bytesWritten = FileWrite(file, &header, sizeof(header), FALSE);
        if (bytesWritten != sizeof(header))
        {
            MemFree(palMem);
            return FALSE;
        }

        // Initialize CRC calculation
        crc = crc32(0, (byte *)&header.type, sizeof(header.type));

        // Write palette data and update CRC per byte
        for (i = 0; i < numEntries; i++)
        {
            rgb[0] = palPtr[i].RGB_red;
            rgb[1] = palPtr[i].RGB_green;
            rgb[2] = palPtr[i].RGB_blue;

            bytesWritten = FileWrite(file, rgb, 3, FALSE);
            if (bytesWritten != 3)
            {
                MemFree(palMem);
                return FALSE;
            }

            crc = crc32(crc, rgb, 3); // Update CRC correctly for each RGB triplet
        }

        MemFree(palMem);

        // Finalize CRC
        crc = swapEndian(crc);
        bytesWritten = FileWrite(file, &crc, sizeof(crc), FALSE);
        if (bytesWritten != sizeof(crc))
        {
            return FALSE;
        }
    }

    return TRUE;
}

/*********************************************************************/
Boolean _pascal writeIDATChunk(FileHandle file, VMFileHandle srcfile, VMBlockHandle bmpblock, pngIHDRData* ihdrData)
{
    void *lineptr;
    word size;
    dword idatChunkSize = 0;
    dword idatChunkPos = 0;
    dword crc = 0;
    z_stream zstrm;
    word y = 0;
    pngChunkHeader idatHeader;
    Boolean stat = TRUE;

    MemHandle scanlineMem;
    MemHandle prevLineMem;
    byte *scanlineBuffer;
    byte *prevLine;
    word scanlineSize;

    byte* temp = (byte*) 0;


    if (HAL_COUNT(HugeArrayLock(srcfile, bmpblock, 0, &lineptr, &size)))
    {
        scanlineSize = size + 1; // +1 for PNG filter byte
        if (scanlineSize == 0)
            return FALSE; // Invalid format or scanline too large

        // Allocate memory for the output scanline buffer and previous scanline buffer
        scanlineMem = MemAlloc(scanlineSize, HF_SWAPABLE, HAF_ZERO_INIT);
        if (!scanlineMem)
            return FALSE; // Memory allocation failed

        prevLineMem = MemAlloc(scanlineSize, HF_SWAPABLE, HAF_ZERO_INIT);
        if (!prevLineMem)
        {
            MemFree(scanlineMem);
            return FALSE; // Memory allocation failed
        }

        // Lock the memory
        scanlineBuffer = MemLock(scanlineMem);
        prevLine = MemLock(prevLineMem);

        // Unlock source scanline
        HugeArrayUnlock(lineptr);
    }
    else
    {
        return FALSE; // Failed to lock scanline
    }

    // Initiate IDAT chunk
    idatHeader.length = 0; // Placeholder for size
    idatHeader.type = swapEndian(PNG_CHUNK_IDAT);

    // Store position of IDAT chunk size field
    idatChunkPos = FilePos(file, 0, FILE_POS_RELATIVE);

    // Write IDAT chunk header (size will be updated later)
    if (FileWrite(file, &idatHeader, sizeof(idatHeader), FALSE) != sizeof(idatHeader))
    {
        stat = FALSE; // Failed to write chunk header
        goto onerror;
    }

    // Initialize CRC calculation
    crc = crc32(0, (byte *)&idatHeader.type, sizeof(idatHeader.type));

    // Initialize Zlib
    zstrm.zalloc = Z_NULL;
    zstrm.zfree = Z_NULL;
    zstrm.opaque = Z_NULL;
    if (deflateInit(&zstrm, Z_DEFAULT_COMPRESSION) != Z_OK)
    {
        stat = FALSE; // Compression initialization failed
        goto onerror;
    }

    // Loop through all scanlines
    for (y = 0; y < ihdrData->height; y++)
    {
        if (HAL_COUNT(HugeArrayLock(srcfile, bmpblock, y, &lineptr, &size)))
        {
            // Apply best PNG filter
            // filterScanline(lineptr, scanlineBuffer, prevLine, ihdrData->width, 1);

            scanlineBuffer[0] = PNG_FILTER_NONE;
            memcpy(scanlineBuffer + 1, lineptr, scanlineSize);

            // Deflate and append to IDAT chunk
            if (!deflateScanline(scanlineBuffer, scanlineSize, &zstrm, file, &idatChunkSize, &crc))
            {
                HugeArrayUnlock(lineptr);
                stat = FALSE; // Compression failed
                break;
            }

            // Swap scanline buffers
            // memcpy(prevLine, scanlineBuffer, scanlineSize);
            temp = prevLine;
            prevLine = scanlineBuffer;
            scanlineBuffer = temp;

            // Unlock source scanline
            HugeArrayUnlock(lineptr);
        }
        else
        {
            break; // whatever the reason, this is a REGULAR exit...
        }
    }

    // Finalize deflation
    deflateEnd(&zstrm);

    // Update IDAT chunk length
    idatHeader.length = swapEndian(idatChunkSize);
    FilePos(file, idatChunkPos, FILE_POS_START);
    if (FileWrite(file, &idatHeader.length, sizeof(idatHeader.length), FALSE) != sizeof(idatHeader.length))
    {
        stat = FALSE; // Failed to update chunk length
        goto onerror;
    }
    FilePos(file, 0, FILE_POS_END);

    // Write CRC at the end of the IDAT chunk
    crc = swapEndian(crc);
    if (FileWrite(file, &crc, sizeof(crc), FALSE) != sizeof(crc))
    {
        stat = FALSE; // Failed to write CRC
        goto onerror;
    }

onerror:
    MemFree(scanlineMem);
    MemFree(prevLineMem);

    return stat;
}

Boolean _pascal writePPMDebugFile(dword width, dword height, VMFileHandle srcfile, VMBlockHandle bmpblock, BMFormat bitform)
{
    FileHandle debugFile;
    void *lineptr;
    word size, y;
    char header[32] = {0};

    // Only process 24-bit RGB images
    if (bitform != BMF_24BIT)
    {
        return FALSE; // Unsupported format
    }

	FilePushDir();
	FileSetStandardPath(SP_DOCUMENT);
	debugFile = FileCreate("debug.ppm", FCF_NATIVE | FILE_CREATE_TRUNCATE | FILE_ACCESS_RW | FILE_DENY_RW, 0);
    if (!debugFile)
    {
        return FALSE; // Failed to create file
    }

    // Write PPM Header (P6 format)
    sprintf(header, "P6\n%lu %lu\n255\n", width, height);
    if (FileWrite(debugFile, header, strlen(header), FALSE) != strlen(header))
    {
        FileClose(debugFile, 0);
        return FALSE; // Failed to write header
    }

    // Write each scanline as raw RGB data
    for (y = 0; y < height; y++)
    {
        if (HAL_COUNT(HugeArrayLock(srcfile, bmpblock, y, &lineptr, &size)))
        {
            // Directly write the RGB scanline data (already in 24-bit format)
            if (FileWrite(debugFile, lineptr, size, FALSE) != size)
            {
                HugeArrayUnlock(lineptr);
                FileClose(debugFile, 0);
                return FALSE; // Writing failed
            }

            HugeArrayUnlock(lineptr);
        }
        else
        {
            FileClose(debugFile, 0);
            return FALSE; // Failed to lock scanline
        }
    }

    // Close the file after writing all data
    FileClose(debugFile, 0);
    FilePopDir();

    return TRUE;
}

/*********************************************************************/
Boolean _pascal writeIENDChunk(FileHandle file)
{
    pngChunkHeader iendHeader;
    dword crc;

    // Prepare IEND chunk header
    iendHeader.length = 0; // IEND has no data
    iendHeader.type = swapEndian(PNG_CHUNK_IEND);

    // Write IEND chunk header
    if (FileWrite(file, &iendHeader, sizeof(iendHeader), FALSE) != sizeof(iendHeader))
    {
        return FALSE; // Failed to write IEND header
    }

    // Calculate CRC for IEND chunk
    crc = crc32(0, (byte *)&iendHeader.type, sizeof(iendHeader.type));
    crc = swapEndian(crc);

    // Write CRC at the end of the IEND chunk
    if (FileWrite(file, &crc, sizeof(crc), FALSE) != sizeof(crc))
    {
        return FALSE; // Failed to write IEND CRC
    }

    return TRUE;
}

/*********************************************************************
    The "worker" functions
*********************************************************************/
dword _pascal calculateScanlineBufferSize(dword width, BMFormat bitform)
{
    dword rowSize;

    // Determine base scanline size
    switch (bitform & BMT_FORMAT)
    {
        case BMF_MONO:  rowSize = (width + 7) / 8; break;  // 1-bit per pixel
        case BMF_4BIT:  rowSize = (width + 1) / 2; break;  // 4-bit per pixel
        case BMF_8BIT:  rowSize = width; break;           // 8-bit per pixel
        case BMF_24BIT: rowSize = width * 3; break;       // 24-bit RGB
        default: return 0;  // Invalid format
    }

    // If mask bit is set, switch to RGBA (4 bytes per pixel)
    if (bitform & BMT_MASK)
    {
        rowSize = width * 4;
    }

    return rowSize;
}

/*********************************************************************/
void _pascal filterScanline(byte *lineptr, byte *scanlineBuffer, byte *prevLine, dword width, word bytesPerPixel)
{
    word x;
    byte *out = (byte *)scanlineBuffer;
    byte *in = (byte *)lineptr;

    // Force PNG_FILTER_NONE
    out[0] = PNG_FILTER_NONE;

    // Copy raw scanline data as-is
    for (x = 0; x < width * bytesPerPixel; x++)
    {
        out[x + 1] = in[x];
    }
}

/*
void _pascal filterScanline(void *lineptr, void *scanlineBuffer, void *prevLine, word width, word bytesPerPixel)
{
    word filterTypes[] = {PNG_FILTER_NONE, PNG_FILTER_SUB, PNG_FILTER_UP, PNG_FILTER_AVERAGE, PNG_FILTER_PAETH};
    word bestFilter = PNG_FILTER_NONE;
    dword bestSum = 0xFFFFFFFF; // Large initial value
    word i, x;
    byte testBuffer[PNG_MAX_SCANLINE_SIZE];

    byte *out = (byte *)scanlineBuffer;
    byte *in = (byte *)lineptr;
    byte *prev = (byte *)prevLine;

    // Determine the best filter dynamically
    for (i = 0; i < 5; i++)
    {
        dword sum = 0;

        // Apply the filter temporarily to testBuffer
        testBuffer[0] = (byte)filterTypes[i];

        switch (filterTypes[i])
        {
            case PNG_FILTER_NONE:
                for (x = 0; x < width * bytesPerPixel; x++)
                    testBuffer[x + 1] = in[x];
                break;

            case PNG_FILTER_SUB:
                for (x = 0; x < width * bytesPerPixel; x++)
                {
                    byte left = (x >= bytesPerPixel) ? in[x - bytesPerPixel] : 0;
                    testBuffer[x + 1] = in[x] - left;
                }
                break;

            case PNG_FILTER_UP:
                for (x = 0; x < width * bytesPerPixel; x++)
                {
                    byte above = prev ? prev[x] : 0;
                    testBuffer[x + 1] = in[x] - above;
                }
                break;

            case PNG_FILTER_AVERAGE:
                for (x = 0; x < width * bytesPerPixel; x++)
                {
                    byte left = (x >= bytesPerPixel) ? in[x - bytesPerPixel] : 0;
                    byte above = prev ? prev[x] : 0;
                    testBuffer[x + 1] = in[x] - ((left + above) / 2);
                }
                break;

            case PNG_FILTER_PAETH:
                for (x = 0; x < width * bytesPerPixel; x++)
                {
                    byte left = (x >= bytesPerPixel) ? in[x - bytesPerPixel] : 0;
                    byte above = prev ? prev[x] : 0;
                    byte aboveLeft = (prev && x >= bytesPerPixel) ? prev[x - bytesPerPixel] : 0;
                    testBuffer[x + 1] = in[x] - paethPredictor(left, above, aboveLeft);
                }
                break;
        }

        // Calculate sum of absolute values for better compression estimation
        for (x = 1; x <= width * bytesPerPixel; x++) // Ignore first byte (filter type)
        {
            sum += abs((sword)testBuffer[x]);
        }

        // Choose the filter that produces the smallest sum
        if (sum < bestSum)
        {
            bestSum = sum;
            bestFilter = filterTypes[i];
        }
    }

    // Apply the best filter to the actual scanlineBuffer
    out[0] = (byte)bestFilter;

    switch (bestFilter)
    {
        case PNG_FILTER_NONE:
            for (x = 0; x < width * bytesPerPixel; x++)
                out[x + 1] = in[x];
            break;

        case PNG_FILTER_SUB:
            for (x = 0; x < width * bytesPerPixel; x++)
            {
                byte left = (x >= bytesPerPixel) ? in[x - bytesPerPixel] : 0;
                out[x + 1] = in[x] - left;
            }
            break;

        case PNG_FILTER_UP:
            for (x = 0; x < width * bytesPerPixel; x++)
            {
                byte above = prev ? prev[x] : 0;
                out[x + 1] = in[x] - above;
            }
            break;

        case PNG_FILTER_AVERAGE:
            for (x = 0; x < width * bytesPerPixel; x++)
            {
                byte left = (x >= bytesPerPixel) ? in[x - bytesPerPixel] : 0;
                byte above = prev ? prev[x] : 0;
                out[x + 1] = in[x] - ((left + above) / 2);
            }
            break;

        case PNG_FILTER_PAETH:
            for (x = 0; x < width * bytesPerPixel; x++)
            {
                byte left = (x >= bytesPerPixel) ? in[x - bytesPerPixel] : 0;
                byte above = prev ? prev[x] : 0;
                byte aboveLeft = (prev && x >= bytesPerPixel) ? prev[x - bytesPerPixel] : 0;
                out[x + 1] = in[x] - paethPredictor(left, above, aboveLeft);
            }
            break;
    }
}
*/
/*********************************************************************/
Boolean _pascal deflateScanline(void *scanlineBuffer, word scanlineSize, z_stream *zstrm, FileHandle file, dword *idatChunkSize, dword *crc)
{
    int ret;
    dword compressedSize;
    MemHandle outBufferMem;
    byte *outBuffer;

    // Allocate memory for the output buffer
    outBufferMem = MemAlloc(PNG_CHUNK_SIZE_OUT, HF_SWAPABLE, HAF_ZERO_INIT);
    if (!outBufferMem)
    {
        return FALSE; // Memory allocation failed
    }

    outBuffer = (byte *)MemLock(outBufferMem);
    if (!outBuffer)
    {
        MemFree(outBufferMem);
        return FALSE; // Memory lock failed
    }

    // Set input for deflation
    zstrm->next_in = (byte *)scanlineBuffer;
    zstrm->avail_in = scanlineSize;

    // Deflate and append to IDAT chunk
    do
    {
        zstrm->next_out = outBuffer;
        zstrm->avail_out = PNG_CHUNK_SIZE_OUT;

        ret = deflate(zstrm, Z_SYNC_FLUSH); // Ensure all output is flushed
        if (ret != Z_OK && ret != Z_STREAM_END)
        {
            MemFree(outBufferMem);
            return FALSE; // Compression failed
        }

        // Calculate the number of compressed bytes
        compressedSize = PNG_CHUNK_SIZE_OUT - zstrm->avail_out;

        // Write compressed data to the file
        if (FileWrite(file, outBuffer, compressedSize, FALSE) != compressedSize)
        {
            MemFree(outBufferMem);
            return FALSE; // Writing failed
        }

        // Update CRC and chunk size
        *crc = crc32(*crc, outBuffer, compressedSize);
        *idatChunkSize += compressedSize;

    } while (zstrm->avail_in > 0);

    // Free memory
    MemFree(outBufferMem);

    return TRUE;
}

/*********************************************************************/
word _pascal mapGEOSToPNGColorType(BMType bmptype)
{
    switch (bmptype & BMT_FORMAT)
    {
        case BMF_MONO:
            return PNG_COLOR_TYPE_GREY; // 1-bit grayscale (monochrome)

        case BMF_4BIT:
        case BMF_8BIT:
            return (bmptype & BMT_MASK) ? PNG_COLOR_TYPE_GREY_ALPHA : PNG_COLOR_TYPE_PALETTE; // Indexed or grayscale+alpha

        case BMF_24BIT:
            return (bmptype & BMT_MASK) ? PNG_COLOR_TYPE_RGBA : PNG_COLOR_TYPE_RGB; // RGB or RGBA

        default:
            return 0xFFFF; // Invalid format
    }
}

