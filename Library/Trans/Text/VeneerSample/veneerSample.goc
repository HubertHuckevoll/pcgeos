/***********************************************************************
 *
 * PROJECT:       Veneer Sample Translator
 * FILE:          veneerSample.goc
 *
 * DESCRIPTION:
 *      Minimal helpers that demonstrate the shared Impex veneer.
 *
 ***********************************************************************/

@include <stdapp.goh>
@include <Objects/clipbrd.goh>
@include <impex.goh>
#include <lmem.h>
#include <vm.h>
#include <file.h>
#include <localize.h>
#include <xlatLib.h>
#include <transCommonVeneer.goh>

#define VENEER_FORMAT_INFO_FLAGS 0xC000
#define VENEER_FORMAT_COUNT 2

typedef struct
{
    ChunkHandle formatName;
    ChunkHandle formatMask;
    optr importUI;
    optr exportUI;
    word formatInfo;
} VeneerFormatInfoEntry;

#define VENEER_IMPORT_BOOLEAN_UPPERCASE 0
#define VENEER_IMPORT_BOOLEAN_TRIM 1
#define VENEER_EXPORT_BOOLEAN_HEADER 0
#define VENEER_EXPORT_BOOLEAN_WRAP 1

typedef struct
{
    Boolean uppercase;
    Boolean trimWhitespace;
} VeneerImportOptions;

typedef struct
{
    Boolean includeHeader;
    Boolean wrapLines;
} VeneerExportOptions;

typedef struct
{
    ChunkHandle defaultMask;
    ChunkHandle maskTable;
    word maskCount;
} VeneerFormatExtensionInfoEntry;

typedef struct
{
    VeneerImportOptions importOptions;
    VeneerExportOptions exportOptions;
} VeneerFormatOptionsCacheEntry;

static VeneerFormatOptionsCacheEntry veneerOptionsCache[VENEER_FORMAT_COUNT] =
{
    {
        { FALSE, TRUE },
        { TRUE, TRUE }
    },
    {
        { FALSE, FALSE },
        { FALSE, TRUE }
    }
};

@start InfoResource;

@chunk char VeneerPlainTextName[] = "Plain text";
@chunk char VeneerPlainTextMaskTxt[] = "*.txt";
@chunk char VeneerPlainTextMaskText[] = "*.text";
@chunk char VeneerPlainTextMaskAsc[] = "*.asc";

@chunk char VeneerMarkdownName[] = "Markdown";
@chunk char VeneerMarkdownMaskMd[] = "*.md";
@chunk char VeneerMarkdownMaskMarkdown[] = "*.markdown";

@chunk ChunkHandle VeneerPlainTextMaskHandles[] =
{
    @VeneerPlainTextMaskTxt,
    @VeneerPlainTextMaskText,
    @VeneerPlainTextMaskAsc
};

@chunk ChunkHandle VeneerMarkdownMaskHandles[] =
{
    @VeneerMarkdownMaskMd,
    @VeneerMarkdownMaskMarkdown
};

@chunk VeneerFormatExtensionInfoEntry VeneerFormatExtensionInfoTable[] =
{
    {
        @VeneerPlainTextMaskTxt,
        @VeneerPlainTextMaskHandles,
        3
    },
    {
        @VeneerMarkdownMaskMd,
        @VeneerMarkdownMaskHandles,
        2
    }
};

@chunk VeneerFormatInfoEntry VeneerInfoTable[] =
{
    {
        @VeneerPlainTextName,
        @VeneerPlainTextMaskTxt,
        @VeneerImportDialog,
        @VeneerExportDialog,
        VENEER_FORMAT_INFO_FLAGS
    },
    {
        @VeneerMarkdownName,
        @VeneerMarkdownMaskMd,
        @VeneerImportDialog,
        @VeneerExportDialog,
        VENEER_FORMAT_INFO_FLAGS
    }
};

@end InfoResource;

@start VeneerUI;

@visMoniker VeneerImportDialogMoniker = "Import sample options";
@visMoniker VeneerExportDialogMoniker = "Export sample options";
@visMoniker VeneerImportUppercaseMoniker = "Convert imported text to uppercase";
@visMoniker VeneerImportTrimMoniker = "Trim leading and trailing whitespace";
@visMoniker VeneerExportHeaderMoniker = "Write a header comment";
@visMoniker VeneerExportWrapMoniker = "Wrap long lines at column 72";

@object GenInteractionClass VeneerImportDialog =
{
    GI_visMoniker = @VeneerImportDialogMoniker;
    GI_comp = @VeneerImportOptionsGroup;
    GII_type = GIT_PROPERTIES;
    GII_visibility = GIV_DIALOG;
    GII_attrs = @default | GIA_MODAL;
    HINT_CENTER_CHILDREN_HORIZONTALLY;
    HINT_CENTER_CHILDREN_VERTICALLY;
    HINT_INTERACTION_SIMPLE_PROPERTIES;
}

@object GenBooleanGroupClass VeneerImportOptionsGroup =
{
    GI_comp =
        @VeneerImportUppercase,
        @VeneerImportTrimWhitespace;
    HINT_BOOLEAN_GROUP_CHECKBOX_STYLE;
}

@object GenBooleanClass VeneerImportUppercase =
{
    GI_visMoniker = @VeneerImportUppercaseMoniker;
    GBI_identifier = VENEER_IMPORT_BOOLEAN_UPPERCASE;
}

@object GenBooleanClass VeneerImportTrimWhitespace =
{
    GI_visMoniker = @VeneerImportTrimMoniker;
    GBI_identifier = VENEER_IMPORT_BOOLEAN_TRIM;
}

@object GenInteractionClass VeneerExportDialog =
{
    GI_visMoniker = @VeneerExportDialogMoniker;
    GI_comp = @VeneerExportOptionsGroup;
    GII_type = GIT_PROPERTIES;
    GII_visibility = GIV_DIALOG;
    GII_attrs = @default | GIA_MODAL;
    HINT_CENTER_CHILDREN_HORIZONTALLY;
    HINT_CENTER_CHILDREN_VERTICALLY;
    HINT_INTERACTION_SIMPLE_PROPERTIES;
}

@object GenBooleanGroupClass VeneerExportOptionsGroup =
{
    GI_comp =
        @VeneerExportHeader,
        @VeneerExportWrapLines;
    HINT_BOOLEAN_GROUP_CHECKBOX_STYLE;
}

@object GenBooleanClass VeneerExportHeader =
{
    GI_visMoniker = @VeneerExportHeaderMoniker;
    GBI_identifier = VENEER_EXPORT_BOOLEAN_HEADER;
}

@object GenBooleanClass VeneerExportWrapLines =
{
    GI_visMoniker = @VeneerExportWrapMoniker;
    GBI_identifier = VENEER_EXPORT_BOOLEAN_WRAP;
}

@end VeneerUI;

static word VeneerClampFormatIndex(word requestedFormat)
{
    word formatIndex;

    formatIndex = requestedFormat;
    if (formatIndex >= VENEER_FORMAT_COUNT)
    {
        formatIndex = 0;
    }
    return formatIndex;
}

static const char *VeneerFindExtensionStart(const char *fileName)
{
    const char *extensionP;
    const char *scanP;

    if (fileName == NULL)
    {
        return NULL;
    }

    extensionP = NULL;
    scanP = fileName;
    while (*scanP != '\0')
    {
        if (*scanP == '.')
        {
            extensionP = scanP + 1;
        }
        scanP++;
    }

    if ((extensionP == NULL) || (*extensionP == '\0'))
    {
        return NULL;
    }

    return extensionP;
}

static Boolean VeneerMaskMatchesExtension(const char *maskString, const char *extensionString)
{
    const char *maskExtensionP;
    const char *scanP;

    if ((maskString == NULL) || (extensionString == NULL))
    {
        return FALSE;
    }

    maskExtensionP = maskString;
    scanP = maskString;
    while (*scanP != '\0')
    {
        if (*scanP == '.')
        {
            maskExtensionP = scanP + 1;
        }
        scanP++;
    }

    if ((*maskExtensionP == '*') && (maskExtensionP[1] == '\0'))
    {
        return TRUE;
    }

    if (*maskExtensionP == '\0')
    {
        return FALSE;
    }

    return (LocalCmpStringsNoCase(maskExtensionP, extensionString, 0) == 0) ? TRUE : FALSE;
}

static sword VeneerResolveFormatFromExtension(const char *extensionString)
{
    MemHandle infoResourceH;
    void *lockedResourceP;
    VeneerFormatExtensionInfoEntry *extensionInfoP;
    ChunkHandle *maskHandleListP;
    char *maskStringP;
    word formatIndex;
    word maskIndex;
    sword result;

    result = NO_IDEA_FORMAT;
    if (extensionString == NULL)
    {
        return result;
    }

    infoResourceH = HandleOf(@VeneerFormatExtensionInfoTable);
    lockedResourceP = (void *)MemLock(infoResourceH);
    if (lockedResourceP == (void *)NULL)
    {
        return result;
    }

    extensionInfoP = (VeneerFormatExtensionInfoEntry *)(void *)LMemDerefHandles(infoResourceH, @VeneerFormatExtensionInfoTable);
    if (extensionInfoP == NULL)
    {
        MemUnlock(infoResourceH);
        return result;
    }

    formatIndex = 0;
    while (formatIndex < VENEER_FORMAT_COUNT)
    {
        if (extensionInfoP[formatIndex].maskTable != NullChunk)
        {
            maskIndex = 0;
            maskHandleListP = (ChunkHandle *)(void *)LMemDerefHandles(infoResourceH, extensionInfoP[formatIndex].maskTable);
            while ((maskHandleListP != NULL) && (maskIndex < extensionInfoP[formatIndex].maskCount))
            {
                maskStringP = (char *)(void *)LMemDerefHandles(infoResourceH, maskHandleListP[maskIndex]);
                if ((maskStringP != NULL) && (VeneerMaskMatchesExtension(maskStringP, extensionString) == TRUE))
                {
                    MemUnlock(infoResourceH);
                    return (sword)formatIndex;
                }
                maskIndex++;
            }
        }
        formatIndex++;
    }

    MemUnlock(infoResourceH);
    return result;
}

word _pascal _export ExportProcedure(ExportFrame *frame)
{
    VeneerExportOptions activeOptions;
    VeneerExportOptions *optionsP;
    MemHandle optionsH;
    word formatIndex;
    word result;

    optionsP = NULL;
    optionsH = frame->EF_exportOptions;
    formatIndex = VeneerClampFormatIndex(frame->EF_formatNumber);
    activeOptions = veneerOptionsCache[formatIndex].exportOptions;
    if (optionsH != NullHandle)
    {
        optionsP = (VeneerExportOptions *)(void *)MemLock(optionsH);
        if (optionsP != NULL)
        {
            activeOptions = *optionsP;
            MemUnlock(optionsH);
        }
        MemFree(optionsH);
        frame->EF_exportOptions = NullHandle;
    }

    veneerOptionsCache[formatIndex].exportOptions = activeOptions;

    (void)activeOptions;

    result = TE_NO_ERROR;
    return result;
}

dword _pascal _export ImportProcedure(ImportFrame *frame, VMChain *resultChain)
{
    VeneerImportOptions activeOptions;
    VeneerImportOptions *optionsP;
    MemHandle optionsH;
    VMChain emptyChain;
    word clipboardFormat;
    dword result;
    word formatIndex;

    optionsP = NULL;
    optionsH = frame->IF_importOptions;
    formatIndex = VeneerClampFormatIndex(frame->IF_formatNumber);
    activeOptions = veneerOptionsCache[formatIndex].importOptions;
    if (optionsH != NullHandle)
    {
        optionsP = (VeneerImportOptions *)(void *)MemLock(optionsH);
        if (optionsP != NULL)
        {
            activeOptions = *optionsP;
            MemUnlock(optionsH);
        }
        MemFree(optionsH);
        frame->IF_importOptions = NullHandle;
    }

    veneerOptionsCache[formatIndex].importOptions = activeOptions;

    emptyChain = 0L;
    *resultChain = emptyChain;
    clipboardFormat = CIF_TEXT;

    (void)activeOptions;

    result = ((dword)clipboardFormat << 16) | (dword)TE_NO_ERROR;
    return result;
}

dword _pascal _export GetFormat(FileHandle file)
{
    FileLongName fileName;
    word attributeError;
    const char *extensionP;
    sword format;
    TransError error;
    dword result;

    attributeError = FileGetHandleExtAttributes(file, FEA_NAME, (void *)fileName, sizeof(FileLongName));
    if (attributeError != 0)
    {
        format = NO_IDEA_FORMAT;
        error = TE_FILE_ERROR;
        result = ((dword)((word)format) << 16) | (dword)error;
        return result;
    }

    extensionP = VeneerFindExtensionStart(fileName);
    format = VeneerResolveFormatFromExtension(extensionP);
    error = TE_NO_ERROR;
    result = ((dword)((word)format) << 16) | (dword)error;
    return result;
}

void _pascal _export TransGetImportUIHelper(word format, optr *outTree, ClassStruct **outClass)
{
    (void)format;
    if (outTree != NULL)
    {
        *outTree = @VeneerImportDialog;
    }
    if (outClass != NULL)
    {
        *outClass = NULL;
    }
}

void _pascal _export TransGetExportUIHelper(word format, optr *outTree, ClassStruct **outClass)
{
    (void)format;
    if (outTree != NULL)
    {
        *outTree = @VeneerExportDialog;
    }
    if (outClass != NULL)
    {
        *outClass = NULL;
    }
}

void _pascal _export TransInitImportUIHelper(optr duplicatedUI)
{
    optr booleanGroup;
    word defaultMask;

    if (duplicatedUI == NullOptr)
    {
        return;
    }
    booleanGroup = ConstructOptr(OptrToHandle(duplicatedUI), OptrToChunk(@VeneerImportOptionsGroup));
    defaultMask = (word)(1 << VENEER_IMPORT_BOOLEAN_TRIM);
    @call booleanGroup::MSG_GEN_BOOLEAN_GROUP_SET_GROUP_STATE(defaultMask, 0);
}

void _pascal _export TransInitExportUIHelper(optr duplicatedUI)
{
    optr booleanGroup;
    word defaultMask;

    if (duplicatedUI == NullOptr)
    {
        return;
    }
    booleanGroup = ConstructOptr(OptrToHandle(duplicatedUI), OptrToChunk(@VeneerExportOptionsGroup));
    defaultMask = (word)((1 << VENEER_EXPORT_BOOLEAN_HEADER) | (1 << VENEER_EXPORT_BOOLEAN_WRAP));
    @call booleanGroup::MSG_GEN_BOOLEAN_GROUP_SET_GROUP_STATE(defaultMask, 0);
}

static word VeneerReadBooleanSelections(MemHandle uiHandle, ChunkHandle groupChunk)
{
    optr groupOptr;

    if (uiHandle == NullHandle)
    {
        return 0;
    }

    groupOptr = ConstructOptr(uiHandle, groupChunk);
    return @call groupOptr::MSG_GEN_BOOLEAN_GROUP_GET_SELECTED_BOOLEANS();
}

MemHandle _pascal _export TransGetImportOptionsHelper(word format, MemHandle uiHandle)
{
    VeneerImportOptions options;
    VeneerImportOptions *optionsP;
    MemHandle optionsH;
    word selectedBooleans;
    word formatIndex;

    optionsP = NULL;
    formatIndex = VeneerClampFormatIndex(format);
    options = veneerOptionsCache[formatIndex].importOptions;

    selectedBooleans = VeneerReadBooleanSelections(uiHandle, OptrToChunk(@VeneerImportOptionsGroup));
    options.uppercase = (selectedBooleans & (1 << VENEER_IMPORT_BOOLEAN_UPPERCASE)) ? TRUE : FALSE;
    options.trimWhitespace = (selectedBooleans & (1 << VENEER_IMPORT_BOOLEAN_TRIM)) ? TRUE : FALSE;

    optionsH = MemAlloc(sizeof(VeneerImportOptions), HF_SWAPABLE, HAF_ZERO_INIT);
    if (optionsH == NullHandle)
    {
        veneerOptionsCache[formatIndex].importOptions = options;
        return NullHandle;
    }

    optionsP = (VeneerImportOptions *)(void *)MemLock(optionsH);
    if (optionsP != NULL)
    {
        *optionsP = options;
        MemUnlock(optionsH);
    }

    veneerOptionsCache[formatIndex].importOptions = options;
    return optionsH;
}

MemHandle _pascal _export TransGetExportOptionsHelper(word format, MemHandle uiHandle)
{
    VeneerExportOptions options;
    VeneerExportOptions *optionsP;
    MemHandle optionsH;
    word selectedBooleans;
    word formatIndex;

    optionsP = NULL;
    formatIndex = VeneerClampFormatIndex(format);
    options = veneerOptionsCache[formatIndex].exportOptions;

    selectedBooleans = VeneerReadBooleanSelections(uiHandle, OptrToChunk(@VeneerExportOptionsGroup));
    options.includeHeader = (selectedBooleans & (1 << VENEER_EXPORT_BOOLEAN_HEADER)) ? TRUE : FALSE;
    options.wrapLines = (selectedBooleans & (1 << VENEER_EXPORT_BOOLEAN_WRAP)) ? TRUE : FALSE;

    optionsH = MemAlloc(sizeof(VeneerExportOptions), HF_SWAPABLE, HAF_ZERO_INIT);
    if (optionsH == NullHandle)
    {
        veneerOptionsCache[formatIndex].exportOptions = options;
        return NullHandle;
    }

    optionsP = (VeneerExportOptions *)(void *)MemLock(optionsH);
    if (optionsP != NULL)
    {
        *optionsP = options;
        MemUnlock(optionsH);
    }

    veneerOptionsCache[formatIndex].exportOptions = options;
    return optionsH;
}
