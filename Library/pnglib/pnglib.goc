#include <pnglib.goh>

unsigned long swapEndian(unsigned long val)
{
    return ((val & 0xFF000000) >> 24) |
           ((val & 0x00FF0000) >> 8)  |
           ((val & 0x0000FF00) << 8)  |
           ((val & 0x000000FF) << 24);
}

int abs(int x)
{
    return x >= 0 ? x : -x;
}

void unfilterImage(unsigned char *imageDataPtr, unsigned long width, unsigned long height, unsigned char bpp, void (*callback)(unsigned char *data, size_t length))
{
    unsigned long rowBytes = width * bpp;
    unsigned long rowPitch = rowBytes + 1;
    unsigned long lineIx;

    for (lineIx = 0; lineIx < height; ++lineIx) {
        enum LineFilter filter = (enum LineFilter)(*imageDataPtr++);
        unsigned char *row = imageDataPtr;
        unsigned long i;

        if (filter == LFSub) {
            for (i = bpp; i < rowBytes; i++) {
                row[i] += row[i - bpp];
            }
        } else if (filter == LFUp && lineIx > 0) {
            for (i = 0; i < rowBytes; i++) {
                row[i] += row[i - rowPitch];
            }
        } else if (filter == LFAverage) {
            if (lineIx == 0) {
                for (i = bpp; i < rowBytes; i++) {
                    row[i] += row[i - bpp] >> 1;
                }
            } else {
                for (i = 0; i < rowBytes; i++) {
                    unsigned char left = (i >= bpp) ? row[i - bpp] : 0;
                    unsigned char above = row[i - rowPitch];
                    row[i] += (left + above) >> 1;
                }
            }
        } else if (filter == LFPaeth) {
            if (lineIx == 0) {
                for (i = bpp; i < rowBytes; i++) {
                    row[i] += row[i - bpp];
                }
            } else {
                for (i = 0; i < rowBytes; i++) {
                    int a = (i >= bpp) ? row[i - bpp] : 0;
                    int b = row[i - rowPitch];
                    int c = (i >= bpp) ? row[i - bpp - rowPitch] : 0;
                    int p = a + b - c;
                    int pa = abs(p - a);
                    int pb = abs(p - b);
                    int pc = abs(p - c);
                    if (pa <= pb && pa <= pc)
                        row[i] += a;
                    else if (pb <= pc)
                        row[i] += b;
                    else
                        row[i] += c;
                }
            }
        }

        // Invoke callback with slices of the unfiltered row
        for (i = 0; i < rowBytes; i += CHUNK_SIZE) {
            size_t chunkLen = (i + CHUNK_SIZE < rowBytes) ? CHUNK_SIZE : rowBytes - i;
            callback(row + i, chunkLen);
        }

        imageDataPtr += rowBytes;
    }
}

void processPNGChunks(FileHandle file, void (*callback)(unsigned char *data, size_t length))
{
    z_stream strm;

    MemHandle bufferHan = NullHandle;
    unsigned char *buffer;

    MemHandle chunkDataHan = NullHandle;
    unsigned char *chunkData;

    unsigned long width = 0, height = 0, bpp = 0;
    unsigned long rowBytes = 0;
    int ret;
    struct ChunkHeader chdr;
    unsigned char *current;
    unsigned char *end;
    unsigned long dataSize;
    size_t have;

    // Initialize zlib stream
    memset(&strm, 0, sizeof(strm));
    ret = inflateInit(&strm);
    if (ret != Z_OK) {
        return;
    }

    chunkDataHan = MemAlloc(CHUNK_SIZE, HF_DYNAMIC, 0);
    chunkData = MemLock(chunkDataHan);

    bufferHan = MemAlloc(CHUNK_SIZE, HF_DYNAMIC, 0);
    buffer = MemLock(bufferHan);

    while (1)
    {
        size_t bytesRead = FileRead(file, buffer, CHUNK_SIZE, FALSE);
        if (bytesRead == 0)
        {
            break;  // End of file
        }

        current = buffer;
        end = buffer + bytesRead;

        while (current < end)
        {
            if ((current + sizeof(struct ChunkHeader)) > end)
            {
                inflateEnd(&strm);
                return;  // Unexpected end of chunk header
            }

            memcpy(&chdr, current, sizeof(struct ChunkHeader));
            chdr.dataSize = swapEndian(chdr.dataSize);
            dataSize = chdr.dataSize;
            current += sizeof(struct ChunkHeader);

            writePPMChunk(_TEXT("dummy!"), 6);

            if ((current + dataSize) > end)
            {
                inflateEnd(&strm);
                MemUnlock(bufferHan); MemFree(bufferHan);
                MemUnlock(chunkDataHan); MemFree(chunkDataHan);
                return;  // Chunk data extends beyond buffer boundary
            }

            if (chdr.chunkType == HEADER_CHUNK)
            {
                struct IHDRChunk ihdr;

                memcpy(&ihdr, current, sizeof(struct IHDRChunk));
                width = swapEndian(ihdr.Width);
                height = swapEndian(ihdr.Height);

                switch (ihdr.ColorType) {
                    case 2: bpp = 3; break;  // RGB
                    case 4: bpp = 2; break;  // Grayscale + Alpha
                    case 6: bpp = 4; break;  // RGBA
                    default: bpp = 1; break; // Grayscale
                }

                rowBytes = width * bpp;
            }
            else if (chdr.chunkType == IMAGE_DATA_CHUNK)
            {
                strm.avail_in = dataSize;
                strm.next_in = current;

                while (strm.avail_in > 0)
                {
                    strm.avail_out = CHUNK_SIZE;
                    strm.next_out = chunkData;

                    ret = inflate(&strm, Z_NO_FLUSH);
                    if (ret != Z_OK && ret != Z_STREAM_END)
                    {
                        inflateEnd(&strm);
                        MemUnlock(bufferHan); MemFree(bufferHan);
                        MemUnlock(chunkDataHan); MemFree(chunkDataHan);
                        return;
                    }

                    have = CHUNK_SIZE - strm.avail_out;
                    if (have > 0)
                    {
                        unfilterImage(chunkData, width, height, bpp, callback);
                    }

                    if (ret == Z_STREAM_END)
                    {
                        break;
                    }
                }
            }
            else if (chdr.chunkType == END_CHUNK)
            {
                break;
            }

            current += dataSize + 4;  // Move to the next chunk, skip CRC
        }
    }

    inflateEnd(&strm);
    MemUnlock(bufferHan); MemFree(bufferHan);
    MemUnlock(chunkDataHan); MemFree(chunkDataHan);
}

void writePPMChunk(unsigned char *data, size_t length) {
    static FileHandle out = NULL;

    if (!out) {
        out = FileCreate("output.ppm", (FCF_NATIVE | FILE_ACCESS_W | FILE_DENY_RW | FILE_CREATE_TRUNCATE), 0);
        if (!out) {
            return;
        }
    }

    FileWrite(out, data, length, FALSE);
}

int _pascal _export convertPNG()
{
    FileHandle file;

    FilePushDir();
    FileSetStandardPath(SP_DOCUMENT);

    file = FileOpen("FLUGZEUG.PNG", FILE_ACCESS_R | FILE_DENY_RW);
    if (file == NullHandle) return 1;

    processPNGChunks(file, writePPMChunk);

    FileClose(file, FALSE);
    FilePopDir();

    return 0;
}
