#include <pnglib.goh>

int abs(int x)
{
    return x >= 0 ? x : -x;
}

unsigned long swapEndian(unsigned long val)
{
    return ((val >> 24) & 0x000000FF) |
           ((val >> 8) & 0x0000FF00) |
           ((val << 8) & 0x00FF0000) |
           ((val << 24) & 0xFF000000);
}

// Funktion zum Überprüfen des PNG-Headers
int checkPNGHeader(FileHandle file)
{
    unsigned char header[8];

    // Lese die ersten 8 Bytes ein
    if (FileRead(file, header, 8, FALSE) != 8) {
        return 0;
    }

    // Vergleiche die gelesenen Bytes mit der PNG-Signatur
    if (memcmp(header, PNG_SIGNATURE, 8) != 0) {
        return 0;
    }

    // PNG-Signatur ist korrekt
    return 1;
}

// Paeth-Prädiktor-Funktion
static inline unsigned char paethPredictor(int a, int b, int c)
{
    int p = a + b - c;
    int pa = abs(p - a);
    int pb = abs(p - b);
    int pc = abs(p - c);

    if (pa <= pb && pa <= pc) return (unsigned char)a;
    else if (pb <= pc) return (unsigned char)b;
    else return (unsigned char)c;
}

// Unfilter-Funktion zur Verarbeitung der PNG-Bilddaten
void unfilterImage(unsigned char *data, unsigned long width, unsigned long height, unsigned char bpp, unsigned char *previousRow, void (*callback)(unsigned char *data, unsigned long length))
{
    unsigned char *currentRow = data;
    unsigned char filterType = *currentRow;
    unsigned long rowBytes = width * bpp;
    unsigned long i;


    // Pointer zum ersten Byte nach dem Filtertyp
    currentRow++;

    // Filter anwenden
    switch (filterType)
    {
        case FILTER_NONE:
            // Kein Filter, Daten direkt kopieren
            break;
        case FILTER_SUB:
            for (i = bpp; i < rowBytes; i++) {
                currentRow[i] += currentRow[i - bpp];
            }
            break;
        case FILTER_UP:
            for (i = 0; i < rowBytes; i++) {
                currentRow[i] += previousRow[i];
            }
            break;
        case FILTER_AVERAGE:
            for (i = 0; i < rowBytes; i++)
            {
                unsigned char left = (i >= bpp) ? currentRow[i - bpp] : 0;
                unsigned char up = previousRow[i];
                currentRow[i] += (left + up) / 2;
            }
            break;
        case FILTER_PAETH:
            for (i = 0; i < rowBytes; i++)
            {
                unsigned char left = (i >= bpp) ? currentRow[i - bpp] : 0;
                unsigned char up = previousRow[i];
                unsigned char upLeft = (i >= bpp) ? previousRow[i - bpp] : 0;
                currentRow[i] += paethPredictor(left, up, upLeft);
            }
            break;
        default:
            // Ungültiger Filtertyp
            return;
    }

    // Rufe den Callback mit den dekodierten Bilddaten auf
    //callback(currentRow, rowBytes);
    writePPMChunk(currentRow, rowBytes);

    // Zeilenzeiger aktualisieren
    memcpy(previousRow, currentRow, rowBytes);
}

// Verarbeitung von IDAT-Chunks
void processIDATChunks(FileHandle file, unsigned long length, unsigned long width, unsigned long height, unsigned char bpp, void (*callback)(unsigned char *data, unsigned long length))
{
    z_stream strm;
    int ret;
    unsigned long have;
    unsigned long bytesToRead;
    MemHandle inHan = NullHandle;
    unsigned char *in = NULL;
    MemHandle outHan = NullHandle;
    unsigned char *out = NULL;
    MemHandle previousRowHandle = NullHandle;
    unsigned char *previousRow = NULL;

    // Speicher für die vorherige Zeile (wenn noch nicht zugewiesen)
    if (!previousRow)
    {
        previousRowHandle = MemAlloc((width * bpp), HF_SHARABLE | HF_SWAPABLE, HAF_ZERO_INIT);
        previousRow = MemLock(previousRowHandle);

        if (previousRow == NULL) {
            return;
        }
    }

    inHan = MemAlloc(CHUNK_SIZE, HF_SHARABLE | HF_SWAPABLE, HAF_ZERO_INIT);
    in = MemLock(inHan);

    outHan = MemAlloc(CHUNK_SIZE, HF_SHARABLE | HF_SWAPABLE, HAF_ZERO_INIT);
    out = MemLock(outHan);

    // Zlib Stream initialisieren
    strm.zalloc = Z_NULL;
    strm.zfree = Z_NULL;
    strm.opaque = Z_NULL;
    strm.avail_in = 0;
    strm.next_in = Z_NULL;

    //ret = inflateInit(&strm);
    ret = inflateInit2(&strm, 15);
    if (ret != Z_OK) {
        // Fehler bei der Initialisierung von zlib
        return;
    }

    // Verarbeite den IDAT-Chunk in Häppchen
    while (length > 0)
    {
        bytesToRead = (length < CHUNK_SIZE) ? length : CHUNK_SIZE;

        if (FileRead(file, in, bytesToRead, FALSE) != bytesToRead)
        {
            // Fehler beim Lesen der PNG-Daten.
            MemFree(inHan);
            MemFree(outHan);
            MemFree(previousRowHandle);
            inflateEnd(&strm);
            return;
        }
        strm.avail_in = bytesToRead;
        strm.next_in = in;

        do
        {
            strm.avail_out = CHUNK_SIZE;
            strm.next_out = out;
            ret = inflate(&strm, Z_NO_FLUSH);
            if (ret != Z_OK && ret != Z_STREAM_END)
            {
                // Dekomprimierungsfehler
                MemFree(inHan);
                MemFree(outHan);
                MemFree(previousRowHandle);
                inflateEnd(&strm);
                return;
            }
            have = CHUNK_SIZE - strm.avail_out;
            if (have > 0)
            {
                unfilterImage(out, width, height, bpp, previousRow, callback);
            }
        } while (strm.avail_out == 0);

        length -= bytesToRead;
    }

    // Bereinige Zlib
    inflateEnd(&strm);

    MemFree(inHan);
    MemFree(outHan);
    MemFree(previousRowHandle);
}


// Hauptfunktion zur Verarbeitung von PNG-Chunks
void processPNGChunks(FileHandle file, void (*callback)(unsigned char *data, unsigned long length))
{
    IHDRData ihdrData;
    ChunkHeader chdr;

    while (FileRead(file, &chdr, sizeof(chdr), FALSE))
    {
        chdr.length = swapEndian(chdr.length);
        chdr.type = swapEndian(chdr.type);

        switch (chdr.type)
        {
            case CHUNK_IHDR:
            {
                // Lese und speichere die IHDR-Daten
                if (FileRead(file, &ihdrData, sizeof(ihdrData), FALSE) != sizeof(ihdrData))
                {
                    // Fehler beim Lesen des IHDR-Chunks.
                    return;
                }

                ihdrData.width = swapEndian(ihdrData.width);
                ihdrData.height = swapEndian(ihdrData.height);
                FilePos(file, chdr.length - sizeof(IHDRData), FILE_POS_RELATIVE);
                break;
            }
            case CHUNK_IDAT:
            {
                // Verarbeite IDAT-Chunks und rufe den Callback für die Bilddaten auf
                processIDATChunks(file, chdr.length, ihdrData.width, ihdrData.height, ihdrData.bitDepth / 8, callback);
                break;
            }
            case CHUNK_IEND:
            {
                // Beende die Verarbeitung bei IEND
                return;
            }
            default:
            {
                // Überspringe unbekannte Chunks
                FilePos(file, chdr.length, FILE_POS_RELATIVE);
                break;
            }
        }

        // Überspringe CRC (4 Bytes)
        FilePos(file, 4, FILE_POS_RELATIVE);
    }
}

// Callback-Funktion zum Schreiben der Bilddaten ins NetPBM-Format (PPM)
void writePPMChunk(unsigned char *data, unsigned long length)
{
    FileHandle outputFile;

    outputFile = FileCreate("png.ppm", (FCF_NATIVE | FILE_ACCESS_W | FILE_DENY_RW), 0);


    // PPM-Header schreiben (Angenommen RGB, 8-Bit pro Kanal)
    // FileWrite(outputFile, "P6\n%lu %lu\n255\n", width, height);
    if (outputFile)
    {
        // Schreibe die dekomprimierten Bilddaten ins PPM-Format
        if (FileWrite(outputFile, data, length, FALSE) != length)
        {
            // Fehler beim Schreiben in die Ausgabedatei
            // return;
        }

        FileClose(outputFile, FALSE);
    }

    return;
}

int convertPNG()
{
    FileHandle file = NULL;

    FilePushDir();
    FileSetStandardPath(SP_DOCUMENT);

    file = FileOpen("FLUGZEUG.PNG", FILE_ACCESS_R | FILE_DENY_RW);
    if (file == NullHandle) return 1;

    if (checkPNGHeader(file)) processPNGChunks(file, writePPMChunk);

    FileClose(file, FALSE);
    FilePopDir();

    return 0;
}
