#include <pnglib.goh>

/**
 * Reading and processing the PNG file
 ********************************************************************
 */

VMBlockHandle convertPNG(FileHandle fileHan, VMFileHandle vmFile)
{
    IHDRData ihdrData;
    VMBlockHandle vmBlock = NullHandle;
    IDATChunkEntry idatChunks[MAX_IDAT_CHUNKS] = {0};
    int idatNumChunks = 0;
    IDATState state = {0};
    MemHandle rowBufferHan = NullHandle;
    unsigned char* rowBuffer;

    if (checkPNGHeader(fileHan))
    {
        // Read PNG Chunks, get overview
        processPNGChunks(fileHan, vmFile, &ihdrData, &idatChunks, &idatNumChunks, &vmBlock);

        // Initialize the IDAT state
        state = initIDATState(fileHan, idatChunks, idatNumChunks, ihdrData);

        // Allocate memory for the rowBuffer externally
        rowBufferHan = MemAlloc(calcBytesPerRow(ihdrData.width, ihdrData.colorType, ihdrData.bitDepth) + 1, HF_SHARABLE | HF_SWAPABLE, HAF_ZERO_INIT); // +1 for filterByte
        rowBuffer = MemLock(rowBufferHan);

        // Process each scanline
        while (processNextScanline(&state, rowBuffer) == 1)
        {
            // Now rowBuffer contains the current scanline without the filter byte
            // Process or display rowBuffer as needed

            // Convert RGBA to RGB if needed
            if (state.ihdr.colorType == 6)
            {
                convertRGBAtoRGB(rowBuffer, state.ihdr.width);
            }

            // Convert 16-bit to 8-bit if needed
            if (state.bytesPerPixel == 6)
            {
                convert16BitLineTo8Bit(rowBuffer, state.ihdr.width);
            }

            // Write the processed scanline (without the filter byte) to the VMFile
            writePixelLine(vmFile, vmBlock, state.lineNo - 1, rowBuffer);
        }

        // Clean up resources
        cleanupIDATState(&state);
        MemFree(rowBufferHan);

        return vmBlock;
    }

    return NullHandle;
}

// Funktion zum Überprüfen des PNG-Headers
int checkPNGHeader(FileHandle file)
{
    unsigned char header[8];

    // Lese die ersten 8 Bytes ein
    if (FileRead(file, header, 8, FALSE) != 8) {
        return 0;
    }

    // Vergleiche die gelesenen Bytes mit der PNG-Signatur
    if (memcmp(header, PNG_SIGNATURE, 8) != 0) {
        return 0;
    }

    // PNG-Signatur ist korrekt
    return 1;
}

// main function for processing PNG-Chunks
void processPNGChunks(FileHandle file, VMFileHandle vmFile, IHDRData* ihdrData, IDATChunkEntry (*idatChunks)[MAX_IDAT_CHUNKS], int *idatNumChunks, VMBlockHandle* vmBlock)
{
    ChunkHeader chdr = {0};
    int idatChunkIdx = 0;

    while (FileRead(file, &chdr, sizeof(ChunkHeader), FALSE))
    {
        // Swap endianness for chunk length and type
        chdr.length = swapEndian(chdr.length);
        chdr.type = swapEndian(chdr.type);

        switch (chdr.type)
        {
            case CHUNK_IHDR:
            {
                // Read and store IHDR data
                if (FileRead(file, ihdrData, sizeof(IHDRData), FALSE) != sizeof(IHDRData))
                {
                    // Error reading IHDR chunk
                    return;
                }

                ihdrData->width = swapEndian(ihdrData->width);
                ihdrData->height = swapEndian(ihdrData->height);

                // Move file pointer forward by the remaining part of the IHDR chunk
                FilePos(file, chdr.length - sizeof(IHDRData), FILE_POS_RELATIVE);

                // Initialize output bitmap
                *vmBlock = initiateOutputBitmap(vmFile, ihdrData->width, ihdrData->height, ihdrData->bitDepth);

                break;
            }

            case CHUNK_PLTE:
            {
                // Read PLTE chunk
                readPLTEChunk(file, chdr.length, vmFile, *vmBlock);
                break;
            }

            case CHUNK_IDAT:
            {
                if (idatChunkIdx < MAX_IDAT_CHUNKS) // Prevent buffer overflow
                {
                    (*idatChunks)[idatChunkIdx].length = chdr.length;
                    (*idatChunks)[idatChunkIdx].chunkPos = FilePos(file, 0, FILE_POS_RELATIVE); // Store current position

                    idatChunkIdx++;
                    *idatNumChunks = idatChunkIdx;
                }
                else
                {
                    // Handle error: too many IDAT chunks
                    return;
                }

                // Skip the IDAT chunk's data only, but not the CRC (CRC will be skipped outside the switch)
                FilePos(file, chdr.length, FILE_POS_RELATIVE);
                break;
            }

            case CHUNK_IEND:
            {
                // Stop processing at IEND
                return;
            }

            default:
            {
                // Skip unknown chunks
                FilePos(file, chdr.length, FILE_POS_RELATIVE);
                break;
            }
        }

        // Skip the CRC (4 bytes) for all chunks
        FilePos(file, 4, FILE_POS_RELATIVE);
    }

    return;
}

IDATState initIDATState(FileHandle file, IDATChunkEntry* idatChunks, int idatNumChunks, IHDRData ihdr)
{
    IDATState state;

    // Initialize the zlib stream
    state.strm.zalloc = Z_NULL;
    state.strm.zfree = Z_NULL;
    state.strm.opaque = Z_NULL;
    state.strm.avail_in = 0;
    state.strm.next_in = Z_NULL;

    //inflateInit2(&state.strm, 15 + 32);
    inflateInit2(&state.strm, 15);

    state.inHan = MemAlloc(CHUNK_SIZE, HF_SHARABLE | HF_SWAPABLE, HAF_ZERO_INIT);
    state.in = MemLock(state.inHan);

    state.outHan = MemAlloc(CHUNK_SIZE, HF_SHARABLE | HF_SWAPABLE, HAF_ZERO_INIT);
    state.out = MemLock(state.outHan);

    state.previousRowHandle = MemAlloc(calcBytesPerRow(ihdr.width, ihdr.colorType, ihdr.bitDepth) + 1, HF_SHARABLE | HF_SWAPABLE, HAF_ZERO_INIT);
    state.previousRow = MemLock(state.previousRowHandle);

    state.rowBytes = calcBytesPerRow(ihdr.width, ihdr.colorType, ihdr.bitDepth);
    state.bytesPerPixel = calcBytesPerPixel(ihdr.colorType, ihdr.bitDepth);

    state.rowBufferOffset = 0;
    state.lineNo = 0;
    state.file = file;
    state.ihdr = ihdr;
    state.have = 0;
    state.outBufferPos = 0;

    state.idatNumChunks = idatNumChunks;
    state.idatChunkIdx = 0;
    memcpy(state.idatChunks, idatChunks, state.idatNumChunks * sizeof(IDATChunkEntry));

    state.length = state.idatChunks[state.idatChunkIdx].length;
    FilePos(state.file, state.idatChunks[state.idatChunkIdx].chunkPos, FILE_POS_START);

    return state;
}

// Verarbeitung von IDAT-Chunks
int processNextScanline(IDATState* state, unsigned char *rowBuffer)
{
    unsigned long have;  // Amount of data decompressed into the output buffer
    unsigned char *src;  // Pointer to the current position in the output buffer
    int ret;  // Return value of the zlib inflate function

    unsigned long rowBytes = state->rowBytes;  // Total number of bytes per scanline (excluding the filter byte)

    do
    {
        // If there is previously decompressed data remaining in the output buffer, process it first
        if (state->have > 0)
        {
            src = state->out + state->outBufferPos;  // Start processing from where we left off in the output buffer
            have = state->have;  // Set the remaining decompressed data to be processed

            // Loop to process the remaining data in the output buffer
            while (have > 0)
            {
                // Calculate how many bytes to copy into the row buffer (excluding the filter byte)
                unsigned long toCopy = (rowBytes + 1 - state->rowBufferOffset) < have ? (rowBytes + 1 - state->rowBufferOffset) : have;
                memcpy(rowBuffer + state->rowBufferOffset, src, toCopy);  // Copy data from output buffer to row buffer
                state->rowBufferOffset += toCopy;  // Update the row buffer offset
                src += toCopy;  // Move source pointer forward
                have -= toCopy;  // Decrease the remaining data to be processed

                // If we have a full scanline (including the filter byte), process the scanline
                if (state->rowBufferOffset == rowBytes + 1)
                {
                    // Unfilter the scanline using the previous row's data
                    unfilterRow(rowBuffer, state->previousRow, state->bytesPerPixel, rowBytes);

                    // Move the pixel data in the row buffer to skip the filter byte
                    memmove(rowBuffer, rowBuffer + 1, rowBytes);

                    // Save the current scanline (after unfiltering) to use in the next unfilter operation
                    memcpy(state->previousRow, rowBuffer, rowBytes);

                    // Reset the row buffer offset for the next scanline
                    state->rowBufferOffset = 0;

                    // Store the remaining data in the output buffer for the next call
                    state->have = have;
                    state->outBufferPos = src - state->out;  // Update the position in the output buffer

                    state->lineNo++;  // Increment the line number (note: NOT zero-based)

                    return 1;  // Successfully processed one scanline
                }
            }

            // If all remaining decompressed data has been processed, reset the state
            state->have = 0;
            state->outBufferPos = 0;
        }

        // If there is still data to read from the file or data left in the zlib stream, continue processing
        while (state->length > 0 || state->strm.avail_in > 0)
        {
            // If there is no more input data in the zlib stream, read more from the file
            if (state->strm.avail_in == 0 && state->length > 0)
            {
                unsigned long bytesToRead = (state->length < CHUNK_SIZE) ? state->length : CHUNK_SIZE;

                // Read the next chunk of compressed data from the file
                if (FileRead(state->file, state->in, bytesToRead, FALSE) != bytesToRead)
                {
                    inflateEnd(&state->strm);  // Clean up if there is an error
                    return -1;  // Return error code
                }

                // Set the input data for the zlib stream
                state->strm.avail_in = bytesToRead;
                state->strm.next_in = state->in;
                state->length -= bytesToRead;  // Decrease the remaining length of the compressed data
            }

            // Set up the output buffer for decompression
            state->strm.avail_out = CHUNK_SIZE;
            state->strm.next_out = state->out;

            // Decompress the data from the input buffer into the output buffer
            ret = inflate(&state->strm, Z_NO_FLUSH);

            if (ret != Z_OK && ret != Z_STREAM_END)
            {
                inflateEnd(&state->strm);  // Clean up if decompression error occurs
                return -1;  // Return error code
            }

            // Calculate how much data was decompressed
            have = CHUNK_SIZE - state->strm.avail_out;
            src = state->out;  // Point to the start of the decompressed data

            // Process the decompressed data in the output buffer
            while (have > 0)
            {
                // Calculate how many bytes to copy into the row buffer
                unsigned long toCopy = (rowBytes + 1 - state->rowBufferOffset) < have ? (rowBytes + 1 - state->rowBufferOffset) : have;
                memcpy(rowBuffer + state->rowBufferOffset, src, toCopy);  // Copy the decompressed data to the row buffer
                state->rowBufferOffset += toCopy;  // Update the row buffer offset
                src += toCopy;  // Move the source pointer forward
                have -= toCopy;  // Decrease the remaining decompressed data to process

                // If a full scanline (including the filter byte) has been accumulated, process it
                if (state->rowBufferOffset == rowBytes + 1)
                {
                    // Unfilter the scanline
                    unfilterRow(rowBuffer, state->previousRow, state->bytesPerPixel, rowBytes);

                    // Move the pixel data to skip the filter byte
                    memmove(rowBuffer, rowBuffer + 1, rowBytes);

                    // Save the current scanline for future unfiltering
                    memcpy(state->previousRow, rowBuffer, rowBytes);

                    // Reset the row buffer offset for the next scanline
                    state->rowBufferOffset = 0;

                    // Store the remaining decompressed data for the next call
                    state->have = have;
                    state->outBufferPos = src - state->out;  // Update the position in the output buffer

                    state->lineNo++;  // Increment the line number (not zero-based)

                    return 1;  // Successfully processed one scanline
                }
            }
        }
    }
    while(nextIDATChunk(state));

    // Return 0 when all scanlines are processed
    return 0;
}

int nextIDATChunk(IDATState* state)
{
    if (state->idatChunkIdx + 1 < state->idatNumChunks) // zero based!
    {
        state->idatChunkIdx++;
        state->length = state->idatChunks[state->idatChunkIdx].length;
        FilePos(state->file, state->idatChunks[state->idatChunkIdx].chunkPos, FILE_POS_START);
        return 1;
    }

    return 0;
}

void cleanupIDATState(IDATState* state)
{
    inflateEnd(&state->strm);
    MemFree(state->inHan);
    MemFree(state->outHan);
    MemFree(state->previousRowHandle);
}

void readPLTEChunk(FileHandle file, unsigned long length, VMFileHandle vmFile, VMBlockHandle vmBlock)
{
    byte* palette = NULL;
    MemHandle paletteHan = NullHandle;
    MemHandle bmmem;
    word offset;
    byte *bmblock;

    // Make sure the length is divisible by 3 (each color is 3 bytes)
    if (length % 3 != 0 || (length / 3) > MAX_PALETTE_ENTRIES)
    {
        return;  // Invalid palette length
    }

    // Create our temp. palette storage
    paletteHan = MemAlloc(length, HF_SHARABLE | HF_SWAPABLE, HAF_ZERO_INIT);
    palette = MemLock(paletteHan);

    // Read the palette data
    FileRead(file, palette, length, FALSE);

    // Copy palette data to Bitmap VM File
    bmblock = VMLock(vmFile, vmBlock, &bmmem);
    offset = bmblock[0x28]+256*(bmblock[0x29]); // WHUT?!
    offset += 0x1c;
    memcpy(&(bmblock[offset]), palette, length);
    VMDirty(bmmem);
    VMUnlock(bmmem);

    // Free Palette mem, no unlock needed
    MemFree(paletteHan);
}

/**
 * Writing the GEOS Bitmap
 ********************************************************************
 */

VMBlockHandle initiateOutputBitmap(VMFileHandle vmFile, unsigned long width, unsigned long height, unsigned char bitDepth)
{
    /*
    ; case BMT_FORMAT:
    ;    BMF_MONO:   #bytes = ((width+7)>>3) * height
    ;    BMF_4BIT:   #bytes = ((width+1)>>1) * height
    ;    BMF_8BIT:   #bytes = width * height
    ;    BMF_24BIT:  #bytes = width * height * 3

    typedef ByteFlags BMType;
    #define BMT_PALETTE	0x40
    #define BMT_HUGE	0x20
    #define BMT_MASK	0x10
    #define BMT_COMPLEX	0x08
    #define BMT_FORMAT	0x07

    // MONO: BMF_MONO | BMT_COMPLEX | BMT_PALETTE
    // 4 BIT: BMF_4BIT | BMT_COMPLEX | BMT_PALETTE
    // 8 BIT: BMF_8BIT | BMT_COMPLEX | BMT_PALETTE
    // 24 BIT: BMF_24BIT | BMT_COMPLEX
*/
    GStateHandle bmstate;
    VMBlockHandle vmBlock;

    vmBlock = GrCreateBitmap(
        // BMF_MONO | BMT_COMPLEX | BMT_PALETTE,
        // BMF_4BIT | BMT_COMPLEX | BMT_PALETTE,
        // BMF_8BIT | BMT_COMPLEX | BMT_PALETTE,
        BMF_24BIT | BMT_COMPLEX,
        width, height,
        vmFile,
        0,
        &bmstate
    );

    //GrDestroyBitmap(bmstate, BMD_LEAVE_DATA);

    return vmBlock;
}

void writePixelLine(VMFileHandle vmFile, VMBlockHandle vmBlock, unsigned long lineNo, unsigned char* rowData)
{
    //unsigned char *lineptr;
    void *lineptr;
    word size;

    HugeArrayLock(
        vmFile,
        vmBlock,
        (dword) lineNo,
        &lineptr,
        &size
    );

    // CopyAndDither(lineptr, buffer[0], size) ;

    memcpy(lineptr, rowData, size);

    HugeArrayDirty(lineptr);
    HugeArrayUnlock(lineptr);
}


/**
 * Helpers and processing of image data itself
 ********************************************************************
 */

int abs(int x)
{
    return x >= 0 ? x : -x;
}

unsigned long swapEndian(unsigned long val)
{
    return ((val >> 24) & 0x000000FF) |
           ((val >> 8) & 0x0000FF00) |
           ((val << 8) & 0x00FF0000) |
           ((val << 24) & 0xFF000000);
}

// Calculate the number of bits per pixel based on bitDepth and colorType
unsigned long calcBytesPerRow(unsigned long width, unsigned char colorType, unsigned char bitDepth)
{
    unsigned long bitsPerPixel;
    unsigned long rowBytes;

    switch (colorType) {
        case 0: // Grayscale
            bitsPerPixel = bitDepth;
            break;
        case 2: // Truecolor (RGB)
            bitsPerPixel = 3 * bitDepth;
            break;
        case 3: // Indexed color
            bitsPerPixel = bitDepth;
            break;
        case 4: // Grayscale with Alpha
            bitsPerPixel = 2 * bitDepth;
            break;
        case 6: // Truecolor with Alpha (RGBA)
            bitsPerPixel = 4 * bitDepth;
            break;
        default:
            // Unsupported color type
            return 0;
    }

    rowBytes = (width * bitsPerPixel + 7) / 8; // Round up to the next whole byte

    return rowBytes;
}

// Bytes per Pixel.
unsigned long calcBytesPerPixel(unsigned char colorType, unsigned char bitDepth)
{
    return calcBytesPerRow(1, colorType, bitDepth);
}

// Paeth-Prädiktor-Funktion
static inline unsigned char paethPredictor(int a, int b, int c)
{
    int p = a + b - c;
    int pa = abs(p - a);
    int pb = abs(p - b);
    int pc = abs(p - c);

    if (pa <= pb && pa <= pc) return (unsigned char)a;
    else if (pb <= pc) return (unsigned char)b;
    else return (unsigned char)c;
}

void convertRGBAtoRGB(unsigned char *data, unsigned long width)
{
    unsigned long j;
    unsigned char *src = data;           // Start at the first pixel (RGBA)
    unsigned char *dst = data;

    for (j = 0; j < width; j++)
    {
        unsigned char r = src[0];
        unsigned char g = src[1];
        unsigned char b = src[2];
        unsigned char a = src[3];  // Alpha value

        // Blend the RGB values with a white background
        dst[0] = (r * a + 255 * (255 - a)) / 255;  // Red channel
        dst[1] = (g * a + 255 * (255 - a)) / 255;  // Green channel
        dst[2] = (b * a + 255 * (255 - a)) / 255;  // Blue channel

        // Move the source pointer forward by 4 (skip the alpha channel)
        src += 4;
        // Move the destination pointer forward by 3 (RGB only)
        dst += 3;
    }
}

void convert16BitLineTo8Bit(unsigned char *line, unsigned long width)
{
    unsigned long i;

    MemHandle dstHan = NullHandle;
    unsigned char *dst = NULL;
    unsigned char *dstStart = NULL;

    // Allocate memory for the destination buffer (3 bytes per pixel for 8-bit RGB)
    dstHan = MemAlloc(3 * width, HF_SHARABLE | HF_SWAPABLE, HAF_ZERO_INIT);
    dst = MemLock(dstHan);
    dstStart = dst;

    // Process from front to back
    for (i = 0; i < width; i++)
    {
        unsigned long index16 = i * 6;  // 16-bit indices (6 bytes per pixel, 2 bytes per channel: R, G, B)
        unsigned long index8 = i * 3;   // 8-bit indices (3 bytes per pixel for RGB)

        // Combine two consecutive bytes to form the 16-bit value, then convert to 8-bit
        unsigned short red16   = (line[index16 + 0] << 8) | line[index16 + 1];  // Combine high and low byte for Red
        unsigned short green16 = (line[index16 + 2] << 8) | line[index16 + 3];  // Combine high and low byte for Green
        unsigned short blue16  = (line[index16 + 4] << 8) | line[index16 + 5];  // Combine high and low byte for Blue

        // Convert 16-bit values to 8-bit by right-shifting 8 bits
        dst[index8 + 0] = red16 >> 8;   // Red
        dst[index8 + 1] = green16 >> 8; // Green
        dst[index8 + 2] = blue16 >> 8;  // Blue
    }

    // Copy the converted 8-bit values back to the original buffer
    memcpy(line, dstStart, 3 * width);

    // Free the memory allocated for the destination buffer
    MemFree(dstHan);
}

// Unfilter-Funktion zur Verarbeitung der PNG-Bilddaten
void unfilterRow(unsigned char *data, unsigned char *previousRow, unsigned long bytesPerPixel, unsigned long rowBytes)
{
    unsigned char *currentRow = data;
    unsigned char filterType = *currentRow;
    unsigned long i;

    // Pointer to the first byte after the filter type
    currentRow++;

    // Apply the filter
    switch (filterType)
    {
        case FILTER_NONE:
            // No filter, data is already in place
            break;
        case FILTER_SUB:
            for (i = bytesPerPixel; i < rowBytes; i++) {
                currentRow[i] += currentRow[i - bytesPerPixel];
            }
            break;
        case FILTER_UP:
            for (i = 0; i < rowBytes; i++) {
                currentRow[i] += previousRow[i];
            }
            break;
        case FILTER_AVERAGE:
            for (i = 0; i < rowBytes; i++)
            {
                unsigned char left = (i >= bytesPerPixel) ? currentRow[i - bytesPerPixel] : 0;
                unsigned char up = previousRow[i];
                currentRow[i] += (left + up) / 2;
            }
            break;
        case FILTER_PAETH:
            for (i = 0; i < rowBytes; i++)
            {
                unsigned char left = (i >= bytesPerPixel) ? currentRow[i - bytesPerPixel] : 0;
                unsigned char up = previousRow[i];
                unsigned char upLeft = (i >= bytesPerPixel) ? previousRow[i - bytesPerPixel] : 0;
                currentRow[i] += paethPredictor(left, up, upLeft);
            }
            break;
        default:
            // Invalid filter type
            return;
    }
}

