#include <pnglib.goh>

/**
 * Reading and processing the PNG file
 ********************************************************************
 */

VMBlockHandle convertPNG(FileHandle fileHan, VMFileHandle vmFile)
{
    IHDRData ihdrData;;
    ChunkHeader chdr;
    VMBlockHandle vmBlock = NullHandle;
    unsigned long idatChunkPos = NULL;
    IDATState state;
    MemHandle rowBufferHan = NullHandle;
    unsigned char* rowBuffer;
    int status = NULL;

    if (checkPNGHeader(fileHan))
    {
        // Read PNG Chunks, get overview
        processPNGChunks(fileHan, vmFile, &chdr, &ihdrData, &idatChunkPos, &vmBlock);

        // Initialize the IDAT state
        state = initIDATState(fileHan, idatChunkPos, chdr.length, ihdrData);

        // Allocate memory for the rowBuffer externally
        rowBufferHan = MemAlloc(calcBytesPerRow(ihdrData.width, ihdrData.colorType, ihdrData.bitDepth) + 1, HF_SHARABLE | HF_SWAPABLE, HAF_ZERO_INIT); // +1 for filterByte
        rowBuffer = MemLock(rowBufferHan);

        // Process each scanline
        while ((status = processNextScanline(state, rowBuffer)) == Z_OK)
        {
            // Now rowBuffer contains the current scanline without the filter byte
            // Process or display rowBuffer as needed

            // Convert RGBA to RGB if needed
            if (state.ihdr.colorType == 6)
            {
                convertRGBAtoRGB(rowBuffer, state.ihdr.width);
            }

            // Convert 16-bit to 8-bit if needed
            if (state.bytesPerPixel == 6)
            {
                convert16BitLineTo8Bit(rowBuffer, state.ihdr.width);
            }

            // Write the processed scanline (without the filter byte) to the VMFile
            writePixelLine(vmFile, vmBlock, state.lineNo, rowBuffer);
        }

        // Clean up resources
        cleanupIDATState(state);
        MemFree(rowBufferHan);

        return vmBlock;
    }

    return NullHandle;
}

// Funktion zum Überprüfen des PNG-Headers
int checkPNGHeader(FileHandle file)
{
    unsigned char header[8];

    // Lese die ersten 8 Bytes ein
    if (FileRead(file, header, 8, FALSE) != 8) {
        return 0;
    }

    // Vergleiche die gelesenen Bytes mit der PNG-Signatur
    if (memcmp(header, PNG_SIGNATURE, 8) != 0) {
        return 0;
    }

    // PNG-Signatur ist korrekt
    return 1;
}

// Hauptfunktion zur Verarbeitung von PNG-Chunks
void processPNGChunks(FileHandle file, VMFileHandle vmFile, ChunkHeader* chdr, IHDRData* ihdrData, unsigned long* idatChunkPos, VMBlockHandle* vmBlock)
{
    while (FileRead(file, chdr, sizeof(ChunkHeader), FALSE))
    {
        chdr->length = swapEndian(chdr->length);
        chdr->type = swapEndian(chdr->type);

        switch (chdr->type)
        {
            case CHUNK_IHDR:
            {
                // Lese und speichere die IHDR-Daten
                if (FileRead(file, ihdrData, sizeof(IHDRData), FALSE) != sizeof(IHDRData))
                {
                    // Fehler beim Lesen des IHDR-Chunks.
                    return;
                }

                ihdrData->width = swapEndian(ihdrData->width);
                ihdrData->height = swapEndian(ihdrData->height);
                FilePos(file, chdr->length - sizeof(IHDRData), FILE_POS_RELATIVE);
                *vmBlock = initiateOutputBitmap(vmFile, ihdrData->width, ihdrData->height, ihdrData->bitDepth);

                break;
            }

            case CHUNK_PLTE:
            {
                readPLTEChunk(file, chdr->length, vmFile, *vmBlock);
                break;
            }

            case CHUNK_IDAT:
            {
                *idatChunkPos = FilePos(file, 0, FILE_POS_RELATIVE); //FIXME prepare for multiple iIDAT Chunks, currently only the last one is catched
                break;
            }

            case CHUNK_IEND:
            {
                // Beende die Verarbeitung bei IEND
                return;
            }

            default:
            {
                // Überspringe unbekannte Chunks
                FilePos(file, chdr->length, FILE_POS_RELATIVE);
                break;
            }
        }

        // Überspringe CRC (4 Bytes)
        FilePos(file, 4, FILE_POS_RELATIVE);
    }

    return;
}

void readPLTEChunk(FileHandle file, unsigned long length, VMFileHandle vmFile, VMBlockHandle vmBlock)
{
    byte* palette = NULL;
    MemHandle paletteHan = NullHandle;
    MemHandle bmmem;
    word offset;
    byte *bmblock;

    // Make sure the length is divisible by 3 (each color is 3 bytes)
    if (length % 3 != 0 || (length / 3) > MAX_PALETTE_ENTRIES)
    {
        return;  // Invalid palette length
    }

    // Create our temp. palette storage
    paletteHan = MemAlloc(length, HF_SHARABLE | HF_SWAPABLE, HAF_ZERO_INIT);
    palette = MemLock(paletteHan);

    // Read the palette data
    FileRead(file, palette, length, FALSE);

    // Copy palette data to Bitmap VM File
    bmblock = VMLock(vmFile, vmBlock, &bmmem);
    offset = bmblock[0x28]+256*(bmblock[0x29]); // WHUT?!
    offset += 0x1c;
    memcpy(&(bmblock[offset]), palette, length);
    VMDirty(bmmem);
    VMUnlock(bmmem);

    // Free Palette mem, no unlock needed
    MemFree(paletteHan);
}


IDATState initIDATState(FileHandle file, unsigned long idatChunkPos, unsigned long length, IHDRData ihdr)
{
    IDATState state;

    // Initialize the zlib stream
    state.strm.zalloc = Z_NULL;
    state.strm.zfree = Z_NULL;
    state.strm.opaque = Z_NULL;
    state.strm.avail_in = 0;
    state.strm.next_in = Z_NULL;

    inflateInit2(&state.strm, 15);

    state.inHan = MemAlloc(CHUNK_SIZE, HF_SHARABLE | HF_SWAPABLE, HAF_ZERO_INIT);
    state.in = MemLock(state.inHan);

    state.outHan = MemAlloc(CHUNK_SIZE, HF_SHARABLE | HF_SWAPABLE, HAF_ZERO_INIT);
    state.out = MemLock(state.outHan);

    state.previousRowHandle = MemAlloc(calcBytesPerRow(ihdr.width, ihdr.colorType, ihdr.bitDepth) + 1, HF_SHARABLE | HF_SWAPABLE, HAF_ZERO_INIT);
    state.previousRow = MemLock(state.previousRowHandle);

    state.rowBytes = calcBytesPerRow(ihdr.width, ihdr.colorType, ihdr.bitDepth);
    state.bytesPerPixel = calcBytesPerPixel(ihdr.colorType, ihdr.bitDepth);

    state.rowBufferOffset = 0;
    state.lineNo = 0;
    state.length = length;
    state.file = file;
    state.ihdr = ihdr;

    FilePos(file, idatChunkPos, FILE_POS_START);

    return state;
}

// Verarbeitung von IDAT-Chunks
int processNextScanline(IDATState state, unsigned char *rowBuffer)
{
    int ret;
    unsigned long have;
    unsigned long toCopy;
    unsigned char *src;

    if (state.length == 0)
    {
        // No more data to read
        return Z_STREAM_END;
    }

    // If we need more input data, read it from the file
    if (state.strm.avail_in == 0)
    {
        state.bytesToRead = (state.length < CHUNK_SIZE) ? state.length : CHUNK_SIZE;

        if (FileRead(state.file, &state.in, state.bytesToRead, FALSE) != state.bytesToRead)
        {
            // Error reading PNG data
            inflateEnd(&state.strm);
            return Z_ERRNO;
        }

        state.strm.avail_in = state.bytesToRead;
        state.strm.next_in = state.in;
        state.length -= state.bytesToRead;
    }

    // Inflate until we have a complete scanline or we run out of output buffer space
    do {
        state.strm.avail_out = CHUNK_SIZE;
        state.strm.next_out = state.out;
        ret = inflate(&state.strm, Z_NO_FLUSH);

        if (ret != Z_OK && ret != Z_STREAM_END)
        {
            // Decompression error
            inflateEnd(&state.strm);
            return ret;
        }

        have = CHUNK_SIZE - state.strm.avail_out;
        if (have > 0)
        {
            src = state.out;
            while (have > 0)
            {
                toCopy = ((state.rowBytes + 1 - state.rowBufferOffset) < have) ? (state.rowBytes + 1 - state.rowBufferOffset) : have;
                memcpy(rowBuffer + state.rowBufferOffset, src, toCopy);
                state.rowBufferOffset += toCopy;
                src += toCopy;
                have -= toCopy;

                if (state.rowBufferOffset == state.rowBytes + 1)
                {
                    // We have a complete row with the filter byte
                    unfilterRow(rowBuffer, state.previousRow, state.bytesPerPixel, state.rowBytes);

                    // Move the row data to skip the filter byte
                    memmove(rowBuffer, rowBuffer + 1, state.rowBytes); // Skip the filter byte

                    // Copy the current row (without the filter byte) to previousRow for the next scanline
                    memcpy(state.previousRow, rowBuffer, state.rowBytes);

                    // next line!
                    state.lineNo++;

                    // Reset for the next line
                    state.rowBufferOffset = 0;
                    return Z_OK; // Processed one scanline
                }
            }
        }
    } while (state.strm.avail_out == 0);

    return ret; // Return the status of the stream (Z_OK, Z_STREAM_END, etc.)
}


void cleanupIDATState(IDATState state)
{
    inflateEnd(&state.strm);
    MemFree(state.inHan);
    MemFree(state.outHan);
    MemFree(state.previousRowHandle);
}


/**
 * Writing the GEOS Bitmap
 ********************************************************************
 */

VMBlockHandle initiateOutputBitmap(VMFileHandle vmFile, unsigned long width, unsigned long height, unsigned char bitDepth)
{
    /*
    ; case BMT_FORMAT:
    ;    BMF_MONO:   #bytes = ((width+7)>>3) * height
    ;    BMF_4BIT:   #bytes = ((width+1)>>1) * height
    ;    BMF_8BIT:   #bytes = width * height
    ;    BMF_24BIT:  #bytes = width * height * 3

    typedef ByteFlags BMType;
    #define BMT_PALETTE	0x40
    #define BMT_HUGE	0x20
    #define BMT_MASK	0x10
    #define BMT_COMPLEX	0x08
    #define BMT_FORMAT	0x07

    // MONO: BMF_MONO | BMT_COMPLEX | BMT_PALETTE
    // 4 BIT: BMF_4BIT | BMT_COMPLEX | BMT_PALETTE
    // 8 BIT: BMF_8BIT | BMT_COMPLEX | BMT_PALETTE
    // 24 BIT: BMF_24BIT | BMT_COMPLEX
*/
    GStateHandle bmstate;
    VMBlockHandle vmBlock;

    vmBlock = GrCreateBitmap(
        // BMF_MONO | BMT_COMPLEX | BMT_PALETTE,
        BMF_4BIT | BMT_COMPLEX | BMT_PALETTE,
        // BMF_8BIT | BMT_COMPLEX | BMT_PALETTE,
        // BMF_24BIT | BMT_COMPLEX,
        width, height,
        vmFile,
        0,
        &bmstate
    );

    //GrDestroyBitmap(bmstate, BMD_LEAVE_DATA);

    return vmBlock;
}

void writePixelLine(VMFileHandle vmFile, VMBlockHandle vmBlock, unsigned long lineNo, unsigned char* rowData)
{
    //unsigned char *lineptr;
    void *lineptr;
    word size;

    HugeArrayLock(
        vmFile,
        vmBlock,
        (dword) lineNo - 1,
        &lineptr,
        &size
    );

    // CopyAndDither(lineptr, buffer[0], size) ;

    memcpy(lineptr, rowData, size);

    HugeArrayDirty(lineptr);
    HugeArrayUnlock(lineptr);
}


/**
 * Helpers and processing of image data itself
 ********************************************************************
 */

int abs(int x)
{
    return x >= 0 ? x : -x;
}

unsigned long swapEndian(unsigned long val)
{
    return ((val >> 24) & 0x000000FF) |
           ((val >> 8) & 0x0000FF00) |
           ((val << 8) & 0x00FF0000) |
           ((val << 24) & 0xFF000000);
}

// Calculate the number of bits per pixel based on bitDepth and colorType
unsigned long calcBytesPerRow(unsigned long width, unsigned char colorType, unsigned char bitDepth)
{
    unsigned long bitsPerPixel;
    unsigned long rowBytes;

    switch (colorType) {
        case 0: // Grayscale
            bitsPerPixel = bitDepth;
            break;
        case 2: // Truecolor (RGB)
            bitsPerPixel = 3 * bitDepth;
            break;
        case 3: // Indexed color
            bitsPerPixel = bitDepth;
            break;
        case 4: // Grayscale with Alpha
            bitsPerPixel = 2 * bitDepth;
            break;
        case 6: // Truecolor with Alpha (RGBA)
            bitsPerPixel = 4 * bitDepth;
            break;
        default:
            // Unsupported color type
            return 0;
    }

    rowBytes = (width * bitsPerPixel + 7) / 8; // Round up to the next whole byte

    return rowBytes;
}

// Bytes per Pixel.
unsigned long calcBytesPerPixel(unsigned char colorType, unsigned char bitDepth)
{
    return calcBytesPerRow(1, colorType, bitDepth);
}

// Paeth-Prädiktor-Funktion
static inline unsigned char paethPredictor(int a, int b, int c)
{
    int p = a + b - c;
    int pa = abs(p - a);
    int pb = abs(p - b);
    int pc = abs(p - c);

    if (pa <= pb && pa <= pc) return (unsigned char)a;
    else if (pb <= pc) return (unsigned char)b;
    else return (unsigned char)c;
}

void convertRGBAtoRGB(unsigned char *data, unsigned long width)
{
    unsigned long j;
    unsigned char *src = data;           // Start at the first pixel (RGBA)
    unsigned char *dst = data;

    for (j = 0; j < width; j++)
    {
        unsigned char r = src[0];
        unsigned char g = src[1];
        unsigned char b = src[2];
        unsigned char a = src[3];  // Alpha value

        // Blend the RGB values with a white background
        dst[0] = (r * a + 255 * (255 - a)) / 255;  // Red channel
        dst[1] = (g * a + 255 * (255 - a)) / 255;  // Green channel
        dst[2] = (b * a + 255 * (255 - a)) / 255;  // Blue channel

        // Move the source pointer forward by 4 (skip the alpha channel)
        src += 4;
        // Move the destination pointer forward by 3 (RGB only)
        dst += 3;
    }
}

void convert16BitLineTo8Bit(unsigned char *line, unsigned long width)
{
    unsigned long i;

    MemHandle dstHan = NullHandle;
    unsigned char *dst = NULL;
    unsigned char *dstStart = NULL;

    // Allocate memory for the destination buffer (3 bytes per pixel for 8-bit RGB)
    dstHan = MemAlloc(3 * width, HF_SHARABLE | HF_SWAPABLE, HAF_ZERO_INIT);
    dst = MemLock(dstHan);
    dstStart = dst;

    // Process from front to back
    for (i = 0; i < width; i++)
    {
        unsigned long index16 = i * 6;  // 16-bit indices (6 bytes per pixel, 2 bytes per channel: R, G, B)
        unsigned long index8 = i * 3;   // 8-bit indices (3 bytes per pixel for RGB)

        // Combine two consecutive bytes to form the 16-bit value, then convert to 8-bit
        unsigned short red16   = (line[index16 + 0] << 8) | line[index16 + 1];  // Combine high and low byte for Red
        unsigned short green16 = (line[index16 + 2] << 8) | line[index16 + 3];  // Combine high and low byte for Green
        unsigned short blue16  = (line[index16 + 4] << 8) | line[index16 + 5];  // Combine high and low byte for Blue

        // Convert 16-bit values to 8-bit by right-shifting 8 bits
        dst[index8 + 0] = red16 >> 8;   // Red
        dst[index8 + 1] = green16 >> 8; // Green
        dst[index8 + 2] = blue16 >> 8;  // Blue
    }

    // Copy the converted 8-bit values back to the original buffer
    memcpy(line, dstStart, 3 * width);

    // Free the memory allocated for the destination buffer
    MemFree(dstHan);
}

// Unfilter-Funktion zur Verarbeitung der PNG-Bilddaten
void unfilterRow(unsigned char *data, unsigned char *previousRow, unsigned long bytesPerPixel, unsigned long rowBytes)
{
    unsigned char *currentRow = data;
    unsigned char filterType = *currentRow;
    unsigned long i;

    // Pointer to the first byte after the filter type
    currentRow++;

    // Apply the filter
    switch (filterType)
    {
        case FILTER_NONE:
            // No filter, data is already in place
            break;
        case FILTER_SUB:
            for (i = bytesPerPixel; i < rowBytes; i++) {
                currentRow[i] += currentRow[i - bytesPerPixel];
            }
            break;
        case FILTER_UP:
            for (i = 0; i < rowBytes; i++) {
                currentRow[i] += previousRow[i];
            }
            break;
        case FILTER_AVERAGE:
            for (i = 0; i < rowBytes; i++)
            {
                unsigned char left = (i >= bytesPerPixel) ? currentRow[i - bytesPerPixel] : 0;
                unsigned char up = previousRow[i];
                currentRow[i] += (left + up) / 2;
            }
            break;
        case FILTER_PAETH:
            for (i = 0; i < rowBytes; i++)
            {
                unsigned char left = (i >= bytesPerPixel) ? currentRow[i - bytesPerPixel] : 0;
                unsigned char up = previousRow[i];
                unsigned char upLeft = (i >= bytesPerPixel) ? previousRow[i - bytesPerPixel] : 0;
                currentRow[i] += paethPredictor(left, up, upLeft);
            }
            break;
        default:
            // Invalid filter type
            return;
    }
}

