#include <pnglib.goh>

int abs(int x)
{
    return x >= 0 ? x : -x;
}

unsigned long swapEndian(unsigned long val)
{
    return ((val >> 24) & 0x000000FF) |
           ((val >> 8) & 0x0000FF00) |
           ((val << 8) & 0x00FF0000) |
           ((val << 24) & 0xFF000000);
}

// Funktion zum Überprüfen des PNG-Headers
int checkPNGHeader(FileHandle file)
{
    unsigned char header[8];

    // Lese die ersten 8 Bytes ein
    if (FileRead(file, header, 8, FALSE) != 8) {
        return 0;
    }

    // Vergleiche die gelesenen Bytes mit der PNG-Signatur
    if (memcmp(header, PNG_SIGNATURE, 8) != 0) {
        return 0;
    }

    // PNG-Signatur ist korrekt
    return 1;
}

// Paeth-Prädiktor-Funktion
static inline unsigned char paethPredictor(int a, int b, int c)
{
    int p = a + b - c;
    int pa = abs(p - a);
    int pb = abs(p - b);
    int pc = abs(p - c);

    if (pa <= pb && pa <= pc) return (unsigned char)a;
    else if (pb <= pc) return (unsigned char)b;
    else return (unsigned char)c;
}

// Unfilter-Funktion zur Verarbeitung der PNG-Bilddaten
void unfilterImage(unsigned char *data, unsigned long width, unsigned char bitDepth, unsigned char colorType, unsigned char *previousRow)
{
    unsigned char *currentRow = data;
    unsigned char filterType = *currentRow;
    unsigned long rowBytes;
    unsigned long bytesPerPixel; // Bytes per Pixel
    unsigned long i;

    // Calculate bytesPerPixel based on colorType and bitDepth
    switch (colorType) {
        case 0: // Grayscale
            bytesPerPixel = (bitDepth + 7) / 8; // Round up to full bytes
            break;
        case 2: // Truecolor (RGB)
            bytesPerPixel = 3 * ((bitDepth + 7) / 8);
            break;
        case 3: // Indexed color
            bytesPerPixel = (bitDepth + 7) / 8;
            break;
        case 4: // Grayscale with Alpha
            bytesPerPixel = 2 * ((bitDepth + 7) / 8);
            break;
        case 6: // Truecolor with Alpha (RGBA)
            bytesPerPixel = 4 * ((bitDepth + 7) / 8);
            break;
        default:
            // Unsupported color type
            return;
    }

    rowBytes = width * bytesPerPixel;

    // Pointer to the first byte after the filter type
    currentRow++;

    // Apply the filter
    switch (filterType)
    {
        case FILTER_NONE:
            // No filter, data is already in place
            break;
        case FILTER_SUB:
            for (i = bytesPerPixel; i < rowBytes; i++) {
                currentRow[i] += currentRow[i - bytesPerPixel];
            }
            break;
        case FILTER_UP:
            for (i = 0; i < rowBytes; i++) {
                currentRow[i] += previousRow[i];
            }
            break;
        case FILTER_AVERAGE:
            for (i = 0; i < rowBytes; i++)
            {
                unsigned char left = (i >= bytesPerPixel) ? currentRow[i - bytesPerPixel] : 0;
                unsigned char up = previousRow[i];
                currentRow[i] += (left + up) / 2;
            }
            break;
        case FILTER_PAETH:
            for (i = 0; i < rowBytes; i++)
            {
                unsigned char left = (i >= bytesPerPixel) ? currentRow[i - bytesPerPixel] : 0;
                unsigned char up = previousRow[i];
                unsigned char upLeft = (i >= bytesPerPixel) ? previousRow[i - bytesPerPixel] : 0;
                currentRow[i] += paethPredictor(left, up, upLeft);
            }
            break;
        default:
            // Invalid filter type
            return;
    }

    // Write out the unfiltered image data (without the filter byte)
    writePPMChunk(currentRow, rowBytes, width, 1); // Adjust rowBytes by -1 to exclude the filter byte
}

// Verarbeitung von IDAT-Chunks
void processIDATChunks(FileHandle file, unsigned long length, unsigned long width, unsigned long height, unsigned char bitDepth, unsigned char colorType)
{
    z_stream strm;
    int ret;
    unsigned long have;
    unsigned long bytesToRead;
    unsigned long rowBytes;
    MemHandle inHan = NullHandle;
    unsigned char *in = NULL;
    MemHandle outHan = NullHandle;
    unsigned char *out = NULL;
    MemHandle rowBufferHan = NullHandle;
    unsigned char *rowBuffer = NULL;
    unsigned long rowBufferOffset = 0;
    MemHandle previousRowHandle = NullHandle;
    unsigned char *previousRow = NULL;
    unsigned long toCopy;
    unsigned char *src = out;

    // Calculate the number of bits per pixel based on bitDepth and colorType
    unsigned long bitsPerPixel;
    switch (colorType) {
        case 0: // Grayscale
            bitsPerPixel = bitDepth;
            break;
        case 2: // Truecolor (RGB)
            bitsPerPixel = 3 * bitDepth;
            break;
        case 3: // Indexed color
            bitsPerPixel = bitDepth;
            break;
        case 4: // Grayscale with Alpha
            bitsPerPixel = 2 * bitDepth;
            break;
        case 6: // Truecolor with Alpha (RGBA)
            bitsPerPixel = 4 * bitDepth;
            break;
        default:
            // Unsupported color type
            return;
    }

    rowBytes = (width * bitsPerPixel + 7) / 8; // Round up to the next whole byte

    // Allocate memory for the previous row
    previousRowHandle = MemAlloc(rowBytes, HF_SHARABLE | HF_SWAPABLE, HAF_ZERO_INIT);
    previousRow = MemLock(previousRowHandle);

    // Input - decoded zlib data
    inHan = MemAlloc(CHUNK_SIZE, HF_SHARABLE | HF_SWAPABLE, HAF_ZERO_INIT);
    in = MemLock(inHan);

    // Output - undecoded data
    outHan = MemAlloc(CHUNK_SIZE, HF_SHARABLE | HF_SWAPABLE, HAF_ZERO_INIT);
    out = MemLock(outHan);

    // Accumulated output - one row of data (scanline)
    rowBufferHan = MemAlloc(rowBytes + 1, HF_SHARABLE | HF_SWAPABLE, HAF_ZERO_INIT); // +1 to account for filter byte
    rowBuffer = MemLock(rowBufferHan);

    // Initialize zlib stream
    strm.zalloc = Z_NULL;
    strm.zfree = Z_NULL;
    strm.opaque = Z_NULL;
    strm.avail_in = 0;
    strm.next_in = Z_NULL;

    ret = inflateInit2(&strm, 15);
    if (ret != Z_OK) {
        // Error initializing zlib
        return;
    }

    // Process the IDAT chunk in chunks
    while (length > 0)
    {
        bytesToRead = (length < CHUNK_SIZE) ? length : CHUNK_SIZE;

        if (FileRead(file, in, bytesToRead, FALSE) != bytesToRead)
        {
            // Error reading PNG data
            inflateEnd(&strm);
            MemFree(inHan);
            MemFree(outHan);
            MemFree(rowBufferHan);
            MemFree(previousRowHandle);
            return;
        }
        strm.avail_in = bytesToRead;
        strm.next_in = in;

        do
        {
            strm.avail_out = CHUNK_SIZE;
            strm.next_out = out;
            ret = inflate(&strm, Z_NO_FLUSH);
            if (ret != Z_OK && ret != Z_STREAM_END)
            {
                // Decompression error
                inflateEnd(&strm);
                MemFree(inHan);
                MemFree(outHan);
                MemFree(rowBufferHan);
                MemFree(previousRowHandle);
                return;
            }
            have = CHUNK_SIZE - strm.avail_out;

            if (have > 0)
            {
                src = out;

                while (have > 0)
                {
                    toCopy = ((rowBytes + 1 - rowBufferOffset) < have) ? (rowBytes + 1 - rowBufferOffset) : have;
                    memcpy(rowBuffer + rowBufferOffset, src, toCopy);
                    rowBufferOffset += toCopy;
                    src += toCopy;
                    have -= toCopy;

                    if (rowBufferOffset == rowBytes + 1) // +1 to include the filter byte
                    {
                        unfilterImage(rowBuffer, width, bitDepth, colorType, previousRow);
                        memcpy(previousRow, rowBuffer + 1, rowBytes); // +1 to skip the filter byte
                        rowBufferOffset = 0;
                    }
                }
            }
        } while (strm.avail_out == 0);

        length -= bytesToRead;
    }

    // Clean up zlib
    inflateEnd(&strm);

    MemFree(inHan);
    MemFree(outHan);
    MemFree(rowBufferHan);
    MemFree(previousRowHandle);
}


// Hauptfunktion zur Verarbeitung von PNG-Chunks
void processPNGChunks(FileHandle file)
{
    IHDRData ihdrData;
    ChunkHeader chdr;

    while (FileRead(file, &chdr, sizeof(chdr), FALSE))
    {
        chdr.length = swapEndian(chdr.length);
        chdr.type = swapEndian(chdr.type);

        switch (chdr.type)
        {
            case CHUNK_IHDR:
            {
                // Lese und speichere die IHDR-Daten
                if (FileRead(file, &ihdrData, sizeof(ihdrData), FALSE) != sizeof(ihdrData))
                {
                    // Fehler beim Lesen des IHDR-Chunks.
                    return;
                }

                ihdrData.width = swapEndian(ihdrData.width);
                ihdrData.height = swapEndian(ihdrData.height);
                FilePos(file, chdr.length - sizeof(IHDRData), FILE_POS_RELATIVE);
                break;
            }
            case CHUNK_IDAT:
            {
                // Verarbeite IDAT-Chunks und rufe den Callback für die Bilddaten auf
                processIDATChunks(file, chdr.length, ihdrData.width, ihdrData.height, ihdrData.bitDepth, ihdrData.colorType);
                break;
            }
            case CHUNK_IEND:
            {
                // Beende die Verarbeitung bei IEND
                return;
            }
            default:
            {
                // Überspringe unbekannte Chunks
                FilePos(file, chdr.length, FILE_POS_RELATIVE);
                break;
            }
        }

        // Überspringe CRC (4 Bytes)
        FilePos(file, 4, FILE_POS_RELATIVE);
    }
}

// Callback-Funktion zum Schreiben der Bilddaten ins NetPBM-Format (PPM)
void writePPMChunk(unsigned char *data, unsigned long length, unsigned long width, unsigned long height)
{
    FileHandle outputFile;
    unsigned long i, j;
    char header[50];
    char pixelData[20];
    unsigned long rowBytes = width * 3; // 3 Bytes pro Pixel (RGB)

    // PPM-ASCII-Format (P3)
    outputFile = FileCreate("output.ppm", (FCF_NATIVE | FILE_ACCESS_W | FILE_DENY_RW | FILE_CREATE_NO_TRUNCATE), 0);
    FilePos(outputFile, 0, FILE_POS_END);

    if (outputFile)
    {
        // PPM-Header schreiben (P3 Format)
        // sprintf(header, "P3\n%lu %lu\n255\n", width, height);
        // FileWrite(outputFile, header, strlen(header), FALSE);

        // Bilddaten schreiben
        for (i = 0; i < height; i++)
        {
            for (j = 0; j < width * 3; j += 3)
            {
                // Schreibe die RGB-Werte als Text
                sprintf(pixelData, "%d %d %d\n", data[i * rowBytes + j], data[i * rowBytes + j + 1], data[i * rowBytes + j + 2]);
                FileWrite(outputFile, pixelData, strlen(pixelData), FALSE);
            }
        }

        FileClose(outputFile, FALSE);
    }

    return;
}

int convertPNG()
{
    FileHandle file = NULL;

    FilePushDir();
    FileSetStandardPath(SP_DOCUMENT);

    file = FileOpen("FLUGZEUG.PNG", FILE_ACCESS_R | FILE_DENY_RW);
    if (file == NullHandle) return 1;

    if (checkPNGHeader(file)) processPNGChunks(file);

    FileClose(file, FALSE);
    FilePopDir();

    return 0;
}
