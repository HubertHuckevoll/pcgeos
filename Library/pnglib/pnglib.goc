#include <pnglib.goh>

unsigned long swapEndian(unsigned long val)
{
    return ((val & 0xFF000000) >> 24) |
           ((val & 0x00FF0000) >> 8)  |
           ((val & 0x0000FF00) << 8)  |
           ((val & 0x000000FF) << 24);
}

int abs(int x)
{
  if ( x >= 0 )
  {
    return(x);
  }
  else
  {
    return(0 - x);
  }
} /* abs */

void unfilterImage(unsigned char *imageDataPtr, unsigned long width, unsigned long height, unsigned char bpp)
{
    unsigned long rowBytes = width * bpp;
    unsigned long rowPitch = rowBytes + 1;
    unsigned long lineIx;

    for (lineIx = 0; lineIx < height; ++lineIx) {
        enum LineFilter filter = (enum LineFilter)(*imageDataPtr++);
        unsigned char *row = imageDataPtr;
        unsigned long i;

        if (filter == LFSub) {
            for (i = bpp; i < rowBytes; i++) {
                row[i] += row[i - bpp];
            }
        } else if (filter == LFUp && lineIx > 0) {
            for (i = 0; i < rowBytes; i++) {
                row[i] += row[i - rowPitch];
            }
        } else if (filter == LFAverage) {
            if (lineIx == 0) {
                for (i = bpp; i < rowBytes; i++) {
                    row[i] += row[i - bpp] >> 1;
                }
            } else {
                for (i = 0; i < rowBytes; i++) {
                    unsigned char left = (i >= bpp) ? row[i - bpp] : 0;
                    unsigned char above = row[i - rowPitch];
                    row[i] += (left + above) >> 1;
                }
            }
        } else if (filter == LFPaeth) {
            if (lineIx == 0) {
                for (i = bpp; i < rowBytes; i++) {
                    row[i] += row[i - bpp];
                }
            } else {
                for (i = 0; i < rowBytes; i++) {
                    int a = (i >= bpp) ? row[i - bpp] : 0;
                    int b = row[i - rowPitch];
                    int c = (i >= bpp) ? row[i - bpp - rowPitch] : 0;
                    int p = a + b - c;
                    int pa = abs(p - a);
                    int pb = abs(p - b);
                    int pc = abs(p - c);
                    if (pa <= pb && pa <= pc)
                        row[i] += a;
                    else if (pb <= pc)
                        row[i] += b;
                    else
                        row[i] += c;
                }
            }
        }
        imageDataPtr += rowBytes;
    }
}

void writePPM(const char *filename, unsigned char *imageData, unsigned long width, unsigned long height, unsigned char bpp) {
    FileHandle out;
    unsigned long rowBytes = width * bpp;
    unsigned long y;
    unsigned long x;
    const char buf[25] = {0};

    out = FileCreate(filename, (FCF_NATIVE | FILE_ACCESS_W | FILE_DENY_RW | FILE_CREATE_TRUNCATE), 0);
    if (!out) {
        //printf("Error opening output file.\n");
        return;
    }

    //fprintf(out, "P3\n%lu %lu\n255\n", width, height);

    for (y = 0; y < height; ++y)
    {
        unsigned char *row = imageData + y * (rowBytes + 1);
        for (x = 0; x < width; ++x)
        {
            unsigned char r = row[x * bpp];
            unsigned char g = (bpp > 1) ? row[x * bpp + 1] : r;
            unsigned char b = (bpp > 2) ? row[x * bpp + 2] : r;
            sprintf(buf, "%u %u %u \n\0", r, g, b);
            FileWrite(out, buf, strlen(buf) + 1, FALSE);
        }
    }

    FileClose(out, FALSE);
}

// int argc, char *argv[]
int _pascal convertPNG()
{
    //FILE *file;
    z_stream strm;
    unsigned char buffer[CHUNK_SIZE];

    MemHandle chunkDataHan = NullHandle;
    unsigned char *chunkData = NULL;
    unsigned long width = 0, height = 0, bpp = 0;
    unsigned long rowBytes = 0;
    unsigned long compressedSize = 0;
    unsigned long totalDataSize = 0;
    // unsigned long chunkDataSize = 0;
    int ret;
    struct ChunkHeader chdr;
    unsigned char *current;
    unsigned char *end;
    unsigned long dataSize;
    size_t bytesRead;
    FileHandle file;


    file = FileOpen("FLUGZEUG.PNG", FILE_ACCESS_R | FILE_DENY_RW);
    if (file == NullHandle) return 1;


    // Initialize zlib stream
    memset(&strm, 0, sizeof(strm));

    ret = inflateInit(&strm);
    if (ret != Z_OK) {
        //printf("Error initializing zlib.\n");
        FileClose(file, FALSE);
        return 1;
    }


    // chunkData = (unsigned char *)malloc(DECOMPRESSED_CHUNK_SIZE);
    chunkDataHan = MemAlloc(DECOMPRESSED_CHUNK_SIZE, HF_DYNAMIC, 0);
    chunkData = (unsigned char *) MemLock(chunkDataHan);
    if (!chunkData) {
        //printf("Memory allocation failed.\n");
        inflateEnd(&strm);
        FileClose(file, FALSE);
        return 1;
    }

    /*

    // Process PNG file
    while (1)
    {
        // size_t bytesRead = fread(buffer, 1, CHUNK_SIZE, file);
        bytesRead = FileRead(file, buffer, CHUNK_SIZE, FALSE); // -1: we will need to add a zero in the end, so we can't max out

        if (bytesRead == 0)
        {
            //printf("Error reading file.\n");
            free(chunkData);
            inflateEnd(&strm);
            FileClose(file, FALSE);
            return 1;
        }
        if (bytesRead == 0)
        {
            break;  // End of file
        }

        *current = (unsigned char) buffer;
        *end = (unsigned char) buffer + bytesRead;

        while (current < end)
        {
            if (current + sizeof(struct ChunkHeader) > end)
            {
                //printf("Unexpected end of chunk header.\n");
                free(chunkData);
                inflateEnd(&strm);
                FileClose(file, FALSE);
                return 1;
            }

            memcpy(&chdr, current, sizeof(struct ChunkHeader));
            chdr.dataSize = swapEndian(chdr.dataSize);
            dataSize = chdr.dataSize;
            current += sizeof(struct ChunkHeader);

            if (current + dataSize > end)
            {
                //printf("Chunk data extends beyond buffer boundary.\n");
                free(chunkData);
                inflateEnd(&strm);
                FileClose(file, FALSE);
                return 1;
            }

            if (chdr.chunkType == HEADER_CHUNK)
            {
                struct IHDRChunk ihdr;
                memcpy(&ihdr, current, sizeof(struct IHDRChunk));
                width = swapEndian(ihdr.Width);
                height = swapEndian(ihdr.Height);
                // assert(ihdr.BitDepth == 8);
                // assert(ihdr.Compression == 0 && ihdr.Filter == 0 && ihdr.Interlace == 0);

                switch (ihdr.ColorType) {
                    case 2: bpp = 3; break;  // RGB
                    case 4: bpp = 2; break;  // Grayscale + Alpha
                    case 6: bpp = 4; break;  // RGBA
                    default: bpp = 1; break; // Grayscale
                }

                rowBytes = width * bpp;
                totalDataSize = (width * bpp + 1) * height;
            }
            else if (chdr.chunkType == IMAGE_DATA_CHUNK)
            {
                unsigned long remainingDataSize = dataSize;
                while (remainingDataSize > 0)
                {
                    size_t chunkSize = (remainingDataSize < CHUNK_SIZE) ? remainingDataSize : CHUNK_SIZE;
                    if (compressedSize + chunkSize > totalDataSize)
                    {
                        //printf("Compressed data too large.\n");
                        free(chunkData);
                        inflateEnd(&strm);
                        FileClose(file, FALSE);
                        return 1;
                    }

                    memcpy(chunkData + compressedSize, current, chunkSize);
                    compressedSize += chunkSize;
                    current += chunkSize;
                    remainingDataSize -= chunkSize;

                    // Decompress data if enough data is accumulated
                    if (compressedSize >= totalDataSize)
                    {
                        strm.avail_in = compressedSize;
                        strm.next_in = chunkData;
                        strm.avail_out = totalDataSize;
                        strm.next_out = chunkData;

                        ret = inflate(&strm, Z_NO_FLUSH);
                        if (ret != Z_OK && ret != Z_STREAM_END)
                        {
                            //printf("Error decompressing image data.\n");
                            free(chunkData);
                            inflateEnd(&strm);
                            FileClose(file, FALSE);
                            return 1;
                        }

                        // Unfilter and write data
                        unfilterImage(chunkData, width, height, bpp);
                        writePPM("output.ppm", chunkData, width, height, bpp);

                        // Reset for the next chunk
                        compressedSize = 0;
                        totalDataSize = (width * bpp + 1) * height;
                    }
                }
            }
            else if (chdr.chunkType == END_CHUNK)
            {
                break;
            }

            current += dataSize + 4;  // Move to the next chunk, skip CRC
        }
    }

    // Clean up
    inflateEnd(&strm);
*/
    MemUnlock(chunkDataHan);
    MemFree(chunkDataHan);

    FileClose(file, FALSE);

    return 0;
}
