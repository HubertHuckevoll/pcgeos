#include <geos.h>
#include <file.h>
#include <timedate.h>
#include <Ansi/string.h>
#include <Ansi/stdio.h>
#include <localize.h>
#include <dbglog.h>

#define LOG_FILENAME "dbglog.txt"

FileHandle _pascal _export _DbgOpenLogFile(Boolean truncate)
{
    FileHandle fh;

    FilePushDir();
    FileSetStandardPath(SP_DOCUMENT);

    if (truncate) {
        FileDelete(LOG_FILENAME);
    }

    fh = FileOpen(LOG_FILENAME, FILE_ACCESS_RW | FILE_DENY_W);
    if (fh == NullHandle) {
        fh = FileCreate(LOG_FILENAME,
                        (FILE_CREATE_TRUNCATE | FCF_NATIVE) |
                        (FILE_ACCESS_RW | FILE_DENY_W),
                        0);
    }

    FilePopDir();
    return fh;
}

static void _writeToFile(const char *line)
{
    FileHandle fh = _DbgOpenLogFile(FALSE);
    if (fh == NullHandle) return;

    FilePos(fh, 0L, FILE_POS_END);
    FileWrite(fh, (void *)line, strlen(line), FALSE);
    FileWrite(fh, (void *)"\r\n", 2, FALSE);
    FileClose(fh, FALSE);
}

void _pascal _export LogInit(void)
{
    FileHandle fh = _DbgOpenLogFile(TRUE);
    if (fh != NullHandle) {
        FileClose(fh, FALSE);
    }
}

void _pascal _export LogStart(void)
{
    char buffer[64];
    char logLine[96];
    TimerDateAndTime now;

    TimerGetDateAndTime(&now);
    LocalFormatDateTime(buffer, DTF_HMS_24HOUR, &now);

    sprintf(logLine, "=== LOG START: %s ===", buffer);
    _writeToFile(logLine);
}

void _pascal _export LogEnd(void)
{
    _writeToFile("=== LOG END ===\r\n");
}

void _pascal _export LogByte(const char *label, byte val)
{
    char buf[64];
    sprintf(buf, "%s: %u", label, (word)val);
    _writeToFile(buf);
}

void _pascal _export LogSByte(const char *label, sbyte val)
{
    char buf[64];
    sprintf(buf, "%s: %d", label, (sword)val);
    _writeToFile(buf);
}

void _pascal _export LogWord(const char *label, word val)
{
    char buf[64];
    sprintf(buf, "%s: %u (0x%04x)", label, val, val);
    _writeToFile(buf);
}

void _pascal _export LogSWord(const char *label, sword val)
{
    char buf[64];
    sprintf(buf, "%s: %d", label, val);
    _writeToFile(buf);
}

void _pascal _export LogDWord(const char *label, dword val)
{
    char buf[80];
    sprintf(buf, "%s: %lu (0x%08lx)", label, val, val);
    _writeToFile(buf);
}

void _pascal _export LogSDWord(const char *label, sdword val)
{
    char buf[80];
    sprintf(buf, "%s: %ld", label, val);
    _writeToFile(buf);
}

void _pascal _export LogBoolean(const char *label, Boolean val)
{
    char buf[64];
    sprintf(buf, "%s: %s", label, val ? "TRUE" : "FALSE");
    _writeToFile(buf);
}

void _pascal _export LogPtr(const char *label, void *ptr)
{
    char buf[64];
    sprintf(buf, "%s: %Fp", label, ptr);
    _writeToFile(buf);
}

void _pascal _export LogChunkHandle(const char *label, ChunkHandle ch)
{
    char buf[64];
    sprintf(buf, "%s: chunk 0x%04x", label, ch);
    _writeToFile(buf);
}

void _pascal _export LogMemHandle(const char *label, MemHandle mh)
{
    char buf[64];
    sprintf(buf, "%s: mem handle 0x%04x", label, mh);
    _writeToFile(buf);
}

void _pascal _export LogFileHandle(const char *label, FileHandle fh)
{
    char buf[64];
    sprintf(buf, "%s: file handle 0x%04x", label, fh);
    _writeToFile(buf);
}

void _pascal _export LogOptr(const char *label, optr o)
{
    char buf[80];
    sprintf(buf, "%s: optr 0x%08lx", label, o);
    _writeToFile(buf);
}

void _pascal _export LogStrSegment(const char *label, const char *str, DbgStrMode mode, word startOrLen, word end)
{
    char segment[256];
    char line[320];
    word len = strlen(str);
    word from = 0, to = len;

    switch (mode) {
        case DBG_STR_HEAD:
            to = (startOrLen < len) ? startOrLen : len;
            break;
        case DBG_STR_TAIL:
            from = (startOrLen < len) ? len - startOrLen : 0;
            break;
        case DBG_STR_RANGE:
            from = (startOrLen < len) ? startOrLen : 0;
            to = (end < len) ? end : len;
            break;
        case DBG_STR_ALL:
        default:
            break;
    }

    if ((to > from) && ((to - from) < sizeof(segment))) {
        memcpy(segment, str + from, to - from);
        segment[to - from] = '\0';
        sprintf(line, "%s: %s", label, segment);
        _writeToFile(line);
    } else {
        sprintf(line, "%s: [string empty or out of bounds]", label);
        _writeToFile(line);
    }
}

void _pascal _export LogStr(const char *label, const char *value)
{
    char buf[256] = {0};
    sprintf(buf, "%s: \"%s\"", label, value);
    _writeToFile(buf);
}

/*
void _pascal _export LogStr(const char *label, const char *str)
{
    LogStrSegment(label, str, DBG_STR_ALL, 0, 0);
}
    */

void _pascal _export LogStrHead(const char *label, const char *str, word len)
{
    LogStrSegment(label, str, DBG_STR_HEAD, len, 0);
}

void _pascal _export LogStrTail(const char *label, const char *str, word len)
{
    LogStrSegment(label, str, DBG_STR_TAIL, len, 0);
}

void _pascal _export LogStrRange(const char *label, const char *str, word from, word to)
{
    LogStrSegment(label, str, DBG_STR_RANGE, from, to);
}

