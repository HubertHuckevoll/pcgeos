#include <geos.h>
#include <heap.h>
#include <vm.h>
#include <file.h>
#include <hugearr.h>
#include <Ansi/string.h>
#include <graphics.h>
#include "config.h"
@include <extgraph.goh>

/**********************************************************************
*   QOI DEFINITIONS
**********************************************************************/

typedef enum {
    QE_NO_ERROR = 0,
    QE_CANT_OPEN_SOURCE_FILE,
    QE_INVALID_FILE,
    QE_WRONG_FILE_FORMAT,
    QE_OUT_OF_MEMORY,
    QE_OUT_OF_DATA,
    QE_BLOCK_LOCK_FAILURE,
    QE_PALETTE_WRITE_FAILURE
} QoiError;

/* QOI spec constants */
#define QOI_MAGIC_0 'q'
#define QOI_MAGIC_1 'o'
#define QOI_MAGIC_2 'i'
#define QOI_MAGIC_3 'f'

#define QOI_END_0 0x00
#define QOI_END_1 0x00
#define QOI_END_2 0x00
#define QOI_END_3 0x00
#define QOI_END_4 0x00
#define QOI_END_5 0x00
#define QOI_END_6 0x00
#define QOI_END_7 0x01

#define QOI_OP_INDEX  0x00 /* .. 0x3f */
#define QOI_OP_DIFF   0x40 /* .. 0x7f */
#define QOI_OP_LUMA   0x80 /* .. 0xbf */
#define QOI_OP_RUN    0xc0 /* .. 0xff */
#define QOI_OP_RGB    0xfe
#define QOI_OP_RGBA   0xff

#define QOI_MASK_2    0xC0

typedef struct
{
    byte     magic[4];     /* "qoif" */
    dword    widthBE;      /* big endian */
    dword    heightBE;     /* big endian */
    byte     channels;     /* 3 or 4 */
    byte     colorspace;   /* 0 or 1; informational */
} QoiHeaderOnDisk;

typedef struct
{
    VMFileHandle    QOS_file;
    VMBlockHandle   QOS_block;
    word            QOS_width;
    word            QOS_height;
    BMFormat        QOS_format;     /* BMF_8BIT (+BMT_MASK when alpha used) */
    MemHandle       QOS_line;       /* scanline: [mask?][indices] */
    word            QOS_maskoff;
    word            QOS_stride;     /* index bytes per line */
    Boolean         QOS_hasAlpha;   /* true if channels==4 and any A<255 seen */
    word            QOS_y;
} qoiOutStream;

typedef struct
{
    byte r, g, b, a;
} QoiRGBA;

typedef RGBValue qoiPalette[256];

/**********************************************************************
*   LOCAL HELPERS
**********************************************************************/

static Boolean
qoiReadByte(FileHandle fh, byte *out)
{
    int rd;
    rd = FileRead(fh, out, 1, 0);
    if (rd == 1) { return TRUE; }
    return FALSE;
}

static Boolean
qoiReadN(FileHandle fh, void *buf, word n)
{
    int rd;
    rd = FileRead(fh, buf, n, 0);
    if (rd == (int)n) { return TRUE; }
    return FALSE;
}

static dword
qoiBE32ToHost(dword be)
{
    dword v;
    byte *p;
    p = (byte*) &be;
    v = ((dword)p[0] << 24) | ((dword)p[1] << 16) | ((dword)p[2] << 8) | (dword)p[3];
    return v;
}

static word
qoiClampWordFromDword(dword v)
{
    if (v > 65535UL) { return 65535; }
    return (word)v;
}

/* hash per QOI spec: (r*3 + g*5 + b*7 + a*11) % 64 */
static byte
qoiHash(QoiRGBA px)
{
    word s;
    s = (word)px.r * 3 + (word)px.g * 5 + (word)px.b * 7 + (word)px.a * 11;
    return (byte)(s & 63);
}

/* simple palette map: exact-match if present, else append until 256, else nearest */
typedef struct
{
    qoiPalette     pal;
    word           count;
} qoiPalState;

static word
qoiPalFindExact(qoiPalState *ps, QoiRGBA px, Boolean *found)
{
    word i;
    RGBValue *p;
    p = ps->pal;
    for (i = 0; i < ps->count; i++)
    {
        if ((p[i].RGB_red == px.r) &&
            (p[i].RGB_green == px.g) &&
            (p[i].RGB_blue == px.b))
        {
            *found = TRUE;
            return i;
        }
    }
    *found = FALSE;
    return 0;
}

static word
qoiPalAddOrNearest(qoiPalState *ps, QoiRGBA px)
{
    Boolean found;
    word idx, i, bestI;
    long bestD, dr, dg, db, d;
    RGBValue *p;

    idx = qoiPalFindExact(ps, px, &found);
    if (found) { return idx; }

    if (ps->count < 256)
    {
        idx = ps->count;
        p = ps->pal;
        p[idx].RGB_red   = px.r;
        p[idx].RGB_green = px.g;
        p[idx].RGB_blue  = px.b;
        ps->count++;
        return idx;
    }

    /* nearest (euclidean, integer) */
    p = ps->pal;
    bestI = 0;
    dr = (long)p[0].RGB_red   - (long)px.r;
    dg = (long)p[0].RGB_green - (long)px.g;
    db = (long)p[0].RGB_blue  - (long)px.b;
    bestD = dr*dr + dg*dg + db*db;

    for (i = 1; i < 256; i++)
    {
        dr = (long)p[i].RGB_red   - (long)px.r;
        dg = (long)p[i].RGB_green - (long)px.g;
        db = (long)p[i].RGB_blue  - (long)px.b;
        d = dr*dr + dg*dg + db*db;
        if (d < bestD)
        {
            bestD = d;
            bestI = i;
        }
    }
    return bestI;
}

/**********************************************************************
*   CORE DECODER
**********************************************************************/

static QoiError
qoiDecodeTo8BitIndexed(FileHandle fh, qoiOutStream *os, byte channels)
{
    QoiRGBA index[64];
    QoiRGBA px;
    word x, y;
    dword total, emitted;
    dword run;
    byte *scan;
    byte *maskPtr;
    word maskIdx;
    byte maskBit;
    MemHandle line;
    qoiPalState ps;
    byte b, b2, b3;
    Boolean ok;
    word stride;
    word lineBytes;
    word maskBytes;
    word i;
    void *lineptr;
    word size;

    /* init index + prev pixel */
    for (i = 0; i < 64; i++)
    {
        index[i].r = 0; index[i].g = 0; index[i].b = 0; index[i].a = 255;
    }
    px.r = 0; px.g = 0; px.b = 0; px.a = 255;

    ps.count = 0;
    for (i = 0; i < 256; i++)
    {
        ps.pal[i].RGB_red = 0;
        ps.pal[i].RGB_green = 0;
        ps.pal[i].RGB_blue = 0;
    }

    lineBytes = os->QOS_width;                /* 1 byte index per pixel */
    maskBytes = (channels == 4) ? ((os->QOS_width + 7) / 8) : 0;
    stride    = lineBytes + maskBytes;

    os->QOS_maskoff = 0; /* mask first for GIF code; here we put mask first too */
    os->QOS_stride  = stride;

    line = os->QOS_line;
    scan = MemLock(line);
    if (scan == NULL)
    {
        return QE_OUT_OF_MEMORY;
    }
    maskPtr = scan;            /* mask bytes at start (if any) */
    scan    = scan + maskBytes;/* indices after mask */

    maskIdx = 0;
    maskBit = 0;

    total   = (dword)os->QOS_width * (dword)os->QOS_height;
    emitted = 0;
    run     = 0;

    for (y = 0; y < os->QOS_height; y++)
    {
        /* reset mask for the scanline */
        if (channels == 4)
        {
            for (i = 0; i < maskBytes; i++) { maskPtr[i] = 0; }
            maskIdx = 0;
            maskBit = 0;
        }

        for (x = 0; x < os->QOS_width; x++)
        {
            if (run > 0)
            {
                run--;
            }
            else
            {
                ok = qoiReadByte(fh, &b);
                if (!ok) { MemUnlock(line); return QE_OUT_OF_DATA; }

                if (b == QOI_OP_RGB)
                {
                    ok = qoiReadByte(fh, &px.r); if (!ok) { MemUnlock(line); return QE_OUT_OF_DATA; }
                    ok = qoiReadByte(fh, &px.g); if (!ok) { MemUnlock(line); return QE_OUT_OF_DATA; }
                    ok = qoiReadByte(fh, &px.b); if (!ok) { MemUnlock(line); return QE_OUT_OF_DATA; }
                }
                else if (b == QOI_OP_RGBA)
                {
                    ok = qoiReadByte(fh, &px.r); if (!ok) { MemUnlock(line); return QE_OUT_OF_DATA; }
                    ok = qoiReadByte(fh, &px.g); if (!ok) { MemUnlock(line); return QE_OUT_OF_DATA; }
                    ok = qoiReadByte(fh, &px.b); if (!ok) { MemUnlock(line); return QE_OUT_OF_DATA; }
                    ok = qoiReadByte(fh, &px.a); if (!ok) { MemUnlock(line); return QE_OUT_OF_DATA; }
                }
                else
                {
                    switch (b & QOI_MASK_2)
                    {
                        case QOI_OP_INDEX:
                        {
                            px = index[b];
                            break;
                        }
                        case QOI_OP_DIFF:
                        {
                            px.r = (byte)(px.r + (( (b >> 4) & 0x03) - 2));
                            px.g = (byte)(px.g + (( (b >> 2) & 0x03) - 2));
                            px.b = (byte)(px.b + ((  b       & 0x03) - 2));
                            break;
                        }
                        case QOI_OP_LUMA:
                        {
                            ok = qoiReadByte(fh, &b2); if (!ok) { MemUnlock(line); return QE_OUT_OF_DATA; }
                            {
                                int dg, dr, db;
                                dg = ((b & 0x3f) - 32);
                                dr = (int)((b2 >> 4) & 0x0f) - 8 + dg;
                                db = (int)( b2       & 0x0f) - 8 + dg;
                                px.g = (byte)((int)px.g + dg);
                                px.r = (byte)((int)px.r + dr);
                                px.b = (byte)((int)px.b + db);
                            }
                            break;
                        }
                        case QOI_OP_RUN:
                        {
                            run = (b & 0x3f);
                            break;
                        }
                    }
                }

                /* update index */
                index[qoiHash(px)] = px;
            }

            /* map to palette index */
            {
                word pi;
                if (channels == 4 && px.a < 255)
                {
                    /* transparent pixel: index still mapped for color (unused for draw),
                       mask bit set to 0 (transparent). */
                    os->QOS_hasAlpha = TRUE;
                    /* leave mask bit cleared for transparent; set bit for opaque */
                }
                else
                {
                    /* set mask bit to 1 for opaque pixel when mask present */
                    if (channels == 4)
                    {
                        maskPtr[maskIdx] |= (byte)(0x80 >> maskBit);
                    }
                }

                pi = qoiPalAddOrNearest(&ps, px);
                scan[x] = (byte)pi;

                if (channels == 4)
                {
                    maskBit++;
                    if (maskBit == 8)
                    {
                        maskBit = 0;
                        maskIdx++;
                    }
                }
            }

            emitted++;
        }

        /* write the scanline to the VM bitmap */
        if (HAL_COUNT(HugeArrayLock(os->QOS_file, os->QOS_block,
                                    (dword)y, &lineptr, &size)) != 0)
        {
            /* layout: mask then indices (like GIF code path) */
            memcpy(lineptr, MemDeref(line), os->QOS_stride);
            HugeArrayDirty(lineptr);
            HugeArrayUnlock(lineptr);
        }
        else
        {
            MemUnlock(line);
            return QE_INVALID_FILE;
        }
    }

    /* read and discard 8-byte end marker */
    {
        byte tail[8];
        ok = qoiReadN(fh, tail, 8);
        if (!ok) { MemUnlock(line); return QE_OUT_OF_DATA; }
        /* optional: verify equals 00 00 00 00 00 00 00 01 */
        /* lenient: no hard failure if encoder padded differently */
    }

    MemUnlock(line);

    /* install palette */
    {
        EGError egstat;
        egstat = BmpSetBitmapPalette(os->QOS_file, os->QOS_block,
                                     ps.pal, 0, (word)(ps.count ? ps.count : 1));
        if (egstat != EGE_NO_ERROR)
        {
            return QE_PALETTE_WRITE_FAILURE;
        }
    }

    return QE_NO_ERROR;
}

/**********************************************************************
*   PUBLIC API (mirrors GIF importer)
**********************************************************************/

VMBlockHandle _pascal _export
QoiImportBitmapFName(PathName srcname, VMFileHandle destfile, QoiError *error)
{
    FileHandle srcfile;
    QoiError stat;
    VMBlockHandle bmblock;

    srcfile = FileOpen(srcname, FILE_ACCESS_W | FILE_DENY_RW);
    if (srcfile)
    {
        bmblock = QoiImportBitmapFHandle(srcfile, destfile, &stat);
        FileClose(srcfile, 0);
    }
    else
    {
        stat = QE_CANT_OPEN_SOURCE_FILE;
        bmblock = 0;
    }

    if (error) { *error = stat; }
    return bmblock;
}

VMBlockHandle _pascal _export
QoiImportBitmapFHandle(FileHandle srcfile, VMFileHandle destfile, QoiError *error)
{
    QoiError stat = QE_NO_ERROR;
    QoiHeaderOnDisk hd;
    dword wBE, hBE;
    dword Wd, Hd;
    word W, H;
    byte channels;
    byte colorspace;
    qoiOutStream os;
    GStateHandle bmstate;
    BMFormat bmformat;
    MemHandle line;
    word lineBytes;
    word maskBytes;

    /* start of file */
    if (FilePos(srcfile, 0, FILE_POS_START) != 0)
    {
        stat = QE_INVALID_FILE;
        goto end;
    }

    if (!qoiReadN(srcfile, &hd, sizeof(QoiHeaderOnDisk)))
    {
        stat = QE_WRONG_FILE_FORMAT;
        goto end;
    }

    if (hd.magic[0] != QOI_MAGIC_0 ||
        hd.magic[1] != QOI_MAGIC_1 ||
        hd.magic[2] != QOI_MAGIC_2 ||
        hd.magic[3] != QOI_MAGIC_3)
    {
        stat = QE_WRONG_FILE_FORMAT;
        goto end;
    }

    wBE = hd.widthBE;
    hBE = hd.heightBE;
    Wd  = qoiBE32ToHost(wBE);
    Hd  = qoiBE32ToHost(hBE);

    /* clamp to GEOS word bitmap sizes */
    W = qoiClampWordFromDword(Wd);
    H = qoiClampWordFromDword(Hd);

    channels  = hd.channels;      /* 3 or 4 */
    colorspace= hd.colorspace;    /* ignored */

    if (!((channels == 3) || (channels == 4)))
    {
        stat = QE_WRONG_FILE_FORMAT;
        goto end;
    }

    bmformat = BMF_8BIT | BMT_PALETTE | BMT_COMPLEX;
    if (channels == 4)
    {
        bmformat |= BMT_MASK;     /* weâ€™ll populate mask bits during decode */
    }

    os.QOS_block = GrCreateBitmap(bmformat, W, H, destfile, 0, &bmstate);
    if (os.QOS_block == 0)
    {
        stat = QE_OUT_OF_MEMORY;
        GrDestroyBitmap(bmstate, BMD_LEAVE_DATA);
        goto end;
    }

    /* drop gstate; keep VM data */
    GrDestroyBitmap(bmstate, BMD_LEAVE_DATA);

    /* prepare line buffer: [mask?][index bytes] */
    lineBytes = W;                             /* 1 byte per pixel index */
    maskBytes = (channels == 4) ? ((W + 7) / 8) : 0;

    line = MemAlloc((word)(lineBytes + maskBytes), HF_SWAPABLE, 0);
    if (line == NULL)
    {
        VMFreeVMChain(destfile, VMCHAIN_MAKE_FROM_VM_BLOCK(os.QOS_block));
        stat = QE_OUT_OF_MEMORY;
        goto end;
    }

    os.QOS_file     = destfile;
    os.QOS_width    = W;
    os.QOS_height   = H;
    os.QOS_format   = (bmformat & ~BMT_MASK);
    os.QOS_line     = line;
    os.QOS_hasAlpha = (channels == 4) ? FALSE : FALSE;
    os.QOS_y        = 0;

    stat = qoiDecodeTo8BitIndexed(srcfile, &os, channels);

    /* free temp line buffer */
    MemFree(line);

    if (stat != QE_NO_ERROR)
    {
        VMFreeVMChain(destfile, VMCHAIN_MAKE_FROM_VM_BLOCK(os.QOS_block));
        os.QOS_block = 0;
        goto end;
    }

end:
    if (error) { *error = stat; }
    return os.QOS_block;
}

QoiError _pascal _export
QoiImportTestBitmapFName(PathName srcname)
{
    FileHandle srcfile;
    QoiError stat;

    srcfile = FileOpen(srcname, FILE_ACCESS_W | FILE_DENY_RW);
    if (srcfile)
    {
        stat = QoiImportTestBitmapFHandle(srcfile);
        FileClose(srcfile, 0);
    }
    else
    {
        stat = QE_CANT_OPEN_SOURCE_FILE;
    }

    return stat;
}

QoiError _pascal _export
QoiImportTestBitmapFHandle(FileHandle srcfile)
{
    byte magic[4];
    int rd;

    if (FilePos(srcfile, 0, FILE_POS_START) != 0)
        return QE_INVALID_FILE;

    rd = FileRead(srcfile, magic, 4, 0);
    if (rd != 4)
        return QE_WRONG_FILE_FORMAT;

    if (magic[0] == QOI_MAGIC_0 &&
        magic[1] == QOI_MAGIC_1 &&
        magic[2] == QOI_MAGIC_2 &&
        magic[3] == QOI_MAGIC_3)
    {
        return QE_NO_ERROR;
    }

    return QE_WRONG_FILE_FORMAT;
}
