/*
 *  qoilib.goc — QOI -> GEOS 24-bit bitmap importer
 *
 */

#include <geos.h>
#include <heap.h>
#include <vm.h>
#include <file.h>
#include <hugearr.h>
#include <Ansi/string.h>
#include <graphics.h>
@include <extgraph.goh>

#include "qoilib.goh"      /* public prototypes + QoiError */

/**********************************************************************
*   LOCAL HELPERS
**********************************************************************/

static Boolean
qoiReadByte(FileHandle fh, byte *out)
{
    int rd;
    rd = FileRead(fh, out, 1, 0);
    if (rd == 1) { return TRUE; }
    return FALSE;
}

static Boolean
qoiReadN(FileHandle fh, void *buf, word n)
{
    int rd;
    rd = FileRead(fh, buf, n, 0);
    if (rd == (int)n) { return TRUE; }
    return FALSE;
}

static dword
qoiBE32ToHost(dword be)
{
    dword v;
    byte *p;
    p = (byte*) &be;
    v = ((dword)p[0] << 24) | ((dword)p[1] << 16) | ((dword)p[2] << 8) | (dword)p[3];
    return v;
}

static word
qoiClampWordFromDword(dword v)
{
    if (v > 65535UL) { return 65535; }
    return (word)v;
}

/* hash per QOI spec: (r*3 + g*5 + b*7 + a*11) % 64 */
static byte
qoiHash(QoiRGBA px)
{
    word s;
    s = (word)px.r * 3 + (word)px.g * 5 + (word)px.b * 7 + (word)px.a * 11;
    return (byte)(s & 63);
}

/**********************************************************************
*   CORE DECODER — TRUE COLOR (24-bit + optional 1-bit mask)
**********************************************************************/

static QoiError
qoiDecodeTo24Bit(FileHandle fh, qoiOutStream *os, byte channels, byte alphaTreshold)
{
    QoiRGBA index[64];
    QoiRGBA px;
    word x, y, i;
    dword run;
    byte *scan;
    byte *maskPtr;
    word maskIdx;
    byte maskBit;
    MemHandle line;
    byte b, b2;
    Boolean ok;
    word maskBytes;
    void *lineptr;
    word size;
    word used;

    /* init index + prev pixel */
    for (i = 0; i < 64; i++)
    {
        index[i].r = 0; index[i].g = 0; index[i].b = 0; index[i].a = 255;
    }
    px.r = 0; px.g = 0; px.b = 0; px.a = 255;

    maskBytes = (channels == 4) ? ((os->QOS_width + 7) / 8) : 0;

    os->QOS_maskoff = 0; /* mask first (GEOS convention) */
    os->QOS_stride  = (word)(maskBytes + os->QOS_width * 3);

    line = os->QOS_line;
    scan = (byte*) MemLock(line);
    if (scan == NULL)
    {
        return QE_OUT_OF_MEMORY;
    }
    maskPtr = scan;                  /* mask bytes at start (if any) */
    scan    = scan + maskBytes;      /* RGB data after mask          */

    maskIdx = 0;
    maskBit = 0;
    run     = 0;

    for (y = 0; y < os->QOS_height; y++)
    {
        /* clear mask for this scanline */
        if (channels == 4)
        {
            for (i = 0; i < maskBytes; i++) { maskPtr[i] = 0; }
            maskIdx = 0;
            maskBit = 0;
        }

        for (x = 0; x < os->QOS_width; x++)
        {
            if (run > 0)
            {
                run--;
            }
            else
            {
                ok = qoiReadByte(fh, &b);
                if (!ok) { MemUnlock(line); return QE_OUT_OF_DATA; }

                if (b == QOI_OP_RGB)
                {
                    ok = qoiReadByte(fh, &px.r); if (!ok) { MemUnlock(line); return QE_OUT_OF_DATA; }
                    ok = qoiReadByte(fh, &px.g); if (!ok) { MemUnlock(line); return QE_OUT_OF_DATA; }
                    ok = qoiReadByte(fh, &px.b); if (!ok) { MemUnlock(line); return QE_OUT_OF_DATA; }
                }
                else if (b == QOI_OP_RGBA)
                {
                    ok = qoiReadByte(fh, &px.r); if (!ok) { MemUnlock(line); return QE_OUT_OF_DATA; }
                    ok = qoiReadByte(fh, &px.g); if (!ok) { MemUnlock(line); return QE_OUT_OF_DATA; }
                    ok = qoiReadByte(fh, &px.b); if (!ok) { MemUnlock(line); return QE_OUT_OF_DATA; }
                    ok = qoiReadByte(fh, &px.a); if (!ok) { MemUnlock(line); return QE_OUT_OF_DATA; }
                }
                else
                {
                    switch (b & QOI_MASK_2)
                    {
                        case QOI_OP_INDEX:
                        {
                            px = index[b];
                            break;
                        }
                        case QOI_OP_DIFF:
                        {
                            px.r = (byte)(px.r + (((b >> 4) & 0x03) - 2));
                            px.g = (byte)(px.g + (((b >> 2) & 0x03) - 2));
                            px.b = (byte)(px.b + ((  b       & 0x03) - 2));
                            break;
                        }
                        case QOI_OP_LUMA:
                        {
                            ok = qoiReadByte(fh, &b2); if (!ok) { MemUnlock(line); return QE_OUT_OF_DATA; }
                            {
                                int dg, dr, db;
                                dg = ((b & 0x3f) - 32);
                                dr = (int)((b2 >> 4) & 0x0f) - 8 + dg;
                                db = (int)( b2       & 0x0f) - 8 + dg;
                                px.g = (byte)((int)px.g + dg);
                                px.r = (byte)((int)px.r + dr);
                                px.b = (byte)((int)px.b + db);
                            }
                            break;
                        }
                        case QOI_OP_RUN:
                        {
                            run = (b & 0x3f);
                            break;
                        }
                    }
                }

                /* update index */
                index[qoiHash(px)] = px;
            }

            /* mask bit: opaque=1, any A<255 => transparent */
            if (channels == 4)
            {
                if (px.a >= alphaTreshold)
                {
                    maskPtr[maskIdx] |= (byte)(0x80 >> maskBit);
                }
                else
                {
                    os->QOS_hasAlpha = TRUE;
                }

                maskBit++;
                if (maskBit == 8)
                {
                    maskBit = 0;
                    maskIdx++;
                }
            }

            /* write RGB */
            {
                byte *p;
                p = scan + (x * 3);
                p[0] = px.r;
                p[1] = px.g;
                p[2] = px.b;
            }
        }

        // clean mask bits?
        if (channels == 4)
        {
            used = (word)(os->QOS_width & 7);
            if (used != 0) {
                maskPtr[maskBytes - 1] &= (byte)(0xFF << (8 - used));
            }
        }

        /* write the scanline to the VM bitmap */
        if (HAL_COUNT(HugeArrayLock(os->QOS_file, os->QOS_block,
                                    (dword)y, &lineptr, &size)) != 0)
        {
            memcpy(lineptr, (void*)MemDeref(line), os->QOS_stride);
            HugeArrayDirty(lineptr);
            HugeArrayUnlock(lineptr);
        }
        else
        {
            MemUnlock(line);
            return QE_INVALID_FILE;
        }
    }

    /* read and discard 8-byte end marker (lenient) */
    {
        byte tail[8];
        ok = qoiReadN(fh, tail, 8);
        if (!ok) { MemUnlock(line); return QE_OUT_OF_DATA; }
    }

    MemUnlock(line);
    return QE_NO_ERROR;
}

/**********************************************************************
*   PUBLIC API
**********************************************************************/

VMBlockHandle _pascal _export
QoiImportBitmapFName(PathName srcname, VMFileHandle destfile, byte alphaTreshold, QoiError *error)
{
    FileHandle srcfile;
    QoiError stat;
    VMBlockHandle bmblock;

    srcfile = FileOpen(srcname, FILE_ACCESS_W | FILE_DENY_RW);
    if (srcfile)
    {
        bmblock = QoiImportBitmapFHandle(srcfile, destfile, alphaTreshold, &stat);
        FileClose(srcfile, 0);
    }
    else
    {
        stat = QE_CANT_OPEN_SOURCE_FILE;
        bmblock = 0;
    }

    if (error) { *error = stat; }
    return bmblock;
}

VMBlockHandle _pascal _export
QoiImportBitmapFHandle(FileHandle srcfile, VMFileHandle destfile, byte alphaTreshold, QoiError *error)
{
    QoiError        stat = QE_NO_ERROR;
    QoiHeaderOnDisk hd;
    dword           Wd, Hd;
    word            W, H;
    byte            channels;
    byte            colorspace;
    qoiOutStream    os;
    GStateHandle    bmstate;
    BMFormat        bmformat;
    MemHandle       line = 0;
    word            lineBytes;
    word            maskBytes;

    os.QOS_block = 0;

    /* rewind and read header */
    if (FilePos(srcfile, 0, FILE_POS_START) != 0) {
        stat = QE_INVALID_FILE;
        goto done;
    }
    if (!qoiReadN(srcfile, (void*)&hd, (word)sizeof(QoiHeaderOnDisk))) {
        stat = QE_WRONG_FILE_FORMAT;
        goto done;
    }
    if (hd.magic[0] != QOI_MAGIC_0 || hd.magic[1] != QOI_MAGIC_1 ||
        hd.magic[2] != QOI_MAGIC_2 || hd.magic[3] != QOI_MAGIC_3) {
        stat = QE_WRONG_FILE_FORMAT;
        goto done;
    }

    Wd = qoiBE32ToHost(hd.widthBE);
    Hd = qoiBE32ToHost(hd.heightBE);
    W  = qoiClampWordFromDword(Wd);
    H  = qoiClampWordFromDword(Hd);

    channels   = hd.channels;      /* 3 or 4 */
    colorspace = hd.colorspace;    /* informational only */
    (void)colorspace;

    if (!(channels == 3 || channels == 4)) {
        stat = QE_WRONG_FILE_FORMAT;
        goto done;
    }

    /* 24-bit true color, optional mask */
    bmformat = (BMFormat)(BMF_24BIT | BMT_COMPLEX);
    if (channels == 4) {
        bmformat = (BMFormat)(bmformat | BMT_MASK);
    }

    /* create VM-backed complex bitmap + gstate */
    os.QOS_block = GrCreateBitmap(bmformat, W, H, destfile, 0, &bmstate);
    if (os.QOS_block == 0) {
        stat = QE_OUT_OF_MEMORY;
        goto done;
    }
    GrDestroyBitmap(bmstate, BMD_LEAVE_DATA);  /* keep VM data */

    /* temp scanline: [mask?][RGB*W] */
    lineBytes = (word)(W * 3);
    maskBytes = (channels == 4) ? (word)((W + 7) / 8) : 0;

    line = MemAlloc((word)(lineBytes + maskBytes), HF_SWAPABLE, 0);
    if (line == 0) {
        stat = QE_OUT_OF_MEMORY;
        goto fail_free_bitmap;
    }

    /* fill output stream */
    os.QOS_file     = destfile;
    os.QOS_width    = W;
    os.QOS_height   = H;
    os.QOS_format   = (BMFormat)(bmformat & ~BMT_MASK);
    os.QOS_line     = line;
    os.QOS_hasAlpha = FALSE;
    os.QOS_y        = 0;

    /* decode into the bitmap */
    stat = qoiDecodeTo24Bit(srcfile, &os, channels, alphaTreshold);

    /* release temp line */
    MemFree(line);
    line = 0;

    if (stat != QE_NO_ERROR) {
        goto fail_free_bitmap;
    }

    /* success */
    goto done;

fail_free_bitmap:
    if (os.QOS_block != 0) {
        VMFreeVMChain(destfile, VMCHAIN_MAKE_FROM_VM_BLOCK(os.QOS_block));
        os.QOS_block = 0;
    }

done:
    if (error) { *error = stat; }
    return os.QOS_block;
}

QoiError _pascal _export
QoiImportTestBitmapFName(PathName srcname)
{
    FileHandle srcfile;
    QoiError stat;

    srcfile = FileOpen(srcname, FILE_ACCESS_W | FILE_DENY_RW);
    if (srcfile)
    {
        stat = QoiImportTestBitmapFHandle(srcfile);
        FileClose(srcfile, 0);
    }
    else
    {
        stat = QE_CANT_OPEN_SOURCE_FILE;
    }

    return stat;
}

QoiError _pascal _export
QoiImportTestBitmapFHandle(FileHandle srcfile)
{
    byte magic[4];
    int rd;

    FilePos(srcfile, 0, FILE_POS_START);

    rd = FileRead(srcfile, (void*)&magic[0], 4, 0);
    if (rd != 4)
        return QE_INVALID_FILE;

    if (magic[0] == QOI_MAGIC_0 &&
        magic[1] == QOI_MAGIC_1 &&
        magic[2] == QOI_MAGIC_2 &&
        magic[3] == QOI_MAGIC_3)
    {
        return QE_NO_ERROR;
    }

    return QE_WRONG_FILE_FORMAT;
}
