/*
 *  qoiexp.goc â€” GEOS -> QOI exporter (RGB / RGBA only)
 *
 *  Input:  BMF_24BIT [| BMT_MASK], BMT_COMPLEX expected
 *  Output: QOI file written to 'destfile'
 *
 *  API:
 *      QoiError _pascal _export
 *      QoiExportBitmapFHandle(VMFileHandle srcfile, VMBlockHandle bmpblock, FileHandle destfile)
 */

#include <geos.h>
#include <heap.h>
#include <vm.h>
#include <file.h>
#include <hugearr.h>
#include <Ansi/string.h>
#include <graphics.h>
@include <extgraph.goh>

#include "qoilib.goh"      /* QoiError + import prototypes (export added above) */


/*============================= helpers ===============================*/

static dword qoiHostToBE32(dword v)
{
    return ( ((v & 0x000000ffUL) << 24) |
             ((v & 0x0000ff00UL) <<  8) |
             ((v & 0x00ff0000UL) >>  8) |
             ((v & 0xff000000UL) >> 24) );
}

/* safe write wrappers */
static Boolean qoiWriteN(FileHandle fh, const void *buf, word n)
{
    int wr;
    wr = FileWrite(fh, (void*)buf, n, 0);
    return (wr == (int)n);
}

static Boolean
qoiWriteByte(FileHandle fh, byte b)
{
    return qoiWriteN(fh, (void*)&b, 1);
}

/* hash per QOI spec: (r*3 + g*5 + b*7 + a*11) & 63 */
static byte
qoiHash(QoiRGBA px)
{
    word s;
    s = (word)px.r * 3 + (word)px.g * 5 + (word)px.b * 7 + (word)px.a * 11;
    return (byte)(s & 63);
}

/* emit helpers */
static Boolean
qoiEmitRun(FileHandle fh, dword *run)
{
    /* emit as many QOI_OP_RUN ops as needed (chunks of 62) */
    while (*run > 0)
    {
        byte len;
        byte op;
        len = (byte)((*run > 62) ? 62 : *run);
        op  = (byte)(QOI_OP_RUN | (len - 1));
        if (!qoiWriteByte(fh, op)) { return FALSE; }
        *run -= len;
    }
    return TRUE;
}

static Boolean
qoiEmitRGB(FileHandle fh, QoiRGBA px)
{
    byte op;
    op = QOI_OP_RGB;
    return qoiWriteN(fh, (void*)&op, 1) &&
           qoiWriteN(fh, (void*)&px.r, 1) &&
           qoiWriteN(fh, (void*)&px.g, 1) &&
           qoiWriteN(fh, (void*)&px.b, 1);
}

static Boolean
qoiEmitRGBA(FileHandle fh, QoiRGBA px)
{
    byte op;
    op = QOI_OP_RGBA;
    return qoiWriteN(fh, (void*)&op, 1) &&
           qoiWriteN(fh, (void*)&px.r, 1) &&
           qoiWriteN(fh, (void*)&px.g, 1) &&
           qoiWriteN(fh, (void*)&px.b, 1) &&
           qoiWriteN(fh, (void*)&px.a, 1);
}

/*============================= encoder ===============================*/

static QoiError
qoiEncodeBitmapToFile(FileHandle out,
                      VMFileHandle srcfile, VMBlockHandle bmpblock,
                      word W, word H, Boolean hasMask)
{
    QoiRGBA index[64];
    QoiRGBA pxPrev;
    QoiRGBA px;
    dword   run;
    word    y, x, i;
    void   *rowPtr;
    word    rowSize;
    word    maskBytes;
    byte   *maskPtr;
    byte   *rgbPtr;
    word    maskIdx;
    byte    maskBit;

    /* init index + starting pixel */
    for (i = 0; i < 64; i++)
    {
        index[i].r = 0; index[i].g = 0; index[i].b = 0; index[i].a = 255;
    }
    pxPrev.r = 0; pxPrev.g = 0; pxPrev.b = 0; pxPrev.a = 255;
    run = 0;

    maskBytes = hasMask ? (word)((W + 7) / 8) : 0;

    /* write QOI header */
    {
        QoiHeaderOnDisk hd;
        hd.magic[0]   = QOI_MAGIC_0;
        hd.magic[1]   = QOI_MAGIC_1;
        hd.magic[2]   = QOI_MAGIC_2;
        hd.magic[3]   = QOI_MAGIC_3;
        hd.widthBE    = qoiHostToBE32((dword)W);
        hd.heightBE   = qoiHostToBE32((dword)H);
        hd.channels   = hasMask ? 4 : 3;
        hd.colorspace = 0; /* sRGB w/ linear alpha */
        if (!qoiWriteN(out, (void*)&hd, (word)sizeof(QoiHeaderOnDisk)))
        {
            return QE_OUT_OF_DATA; /* write failure; reuse closest code */
        }
    }

    for (y = 0; y < H; y++)
    {
        if (HAL_COUNT(HugeArrayLock(srcfile, bmpblock, (dword)y, &rowPtr, &rowSize)) == 0)
        {
            return QE_BLOCK_LOCK_FAILURE;
        }

        maskPtr = (byte*)rowPtr;
        rgbPtr  = (byte*)rowPtr + maskBytes;
        maskIdx = 0;
        maskBit = 0;

        for (x = 0; x < W; x++)
        {
            byte hr;
            byte hg;
            byte hb;
            byte ha;
            byte hidx;
            int  dr, dg, db;

            hr = rgbPtr[x*3 + 0];
            hg = rgbPtr[x*3 + 1];
            hb = rgbPtr[x*3 + 2];

            if (hasMask)
            {
                byte m;
                m  = maskPtr[maskIdx];
                ha = ( (m & (byte)(0x80 >> maskBit)) ? 255 : 0 );

                maskBit++;
                if (maskBit == 8)
                {
                    maskBit = 0;
                    maskIdx++;
                }
            }
            else
            {
                ha = 255;
            }

            px.r = hr; px.g = hg; px.b = hb; px.a = ha;

            /* run-length? */
            if ((px.r == pxPrev.r) && (px.g == pxPrev.g) &&
                (px.b == pxPrev.b) && (px.a == pxPrev.a))
            {
                run++;
                /* flush run if maxed or last pixel */
                if (run == 62 || (x == (W-1) && y == (H-1)))
                {
                    if (!qoiEmitRun(out, &run)) { HugeArrayUnlock(rowPtr); return QE_OUT_OF_DATA; }
                }
                goto nextPixel;
            }

            /* flush pending run */
            if (run > 0)
            {
                if (!qoiEmitRun(out, &run)) { HugeArrayUnlock(rowPtr); return QE_OUT_OF_DATA; }
            }

            /* try index */
            hidx = qoiHash(px);
            if ( (index[hidx].r == px.r) &&
                 (index[hidx].g == px.g) &&
                 (index[hidx].b == px.b) &&
                 (index[hidx].a == px.a) )
            {
                if (!qoiWriteByte(out, hidx)) { HugeArrayUnlock(rowPtr); return QE_OUT_OF_DATA; }
                goto updateIndexAndPrev;
            }

            /* same alpha? try DIFF/LUMA, else emit RGBA */
            if (px.a == pxPrev.a)
            {
                dr = (int)px.r - (int)pxPrev.r;
                dg = (int)px.g - (int)pxPrev.g;
                db = (int)px.b - (int)pxPrev.b;

                /* DIFF: dr,dg,db in [-2..+1] */
                if ( (dr >= -2 && dr <= 1) &&
                     (dg >= -2 && dg <= 1) &&
                     (db >= -2 && db <= 1) )
                {
                    byte op;
                    op = (byte)(QOI_OP_DIFF |
                                ((dr + 2) << 4) |
                                ((dg + 2) << 2) |
                                ((db + 2)      ));
                    if (!qoiWriteByte(out, op)) { HugeArrayUnlock(rowPtr); return QE_OUT_OF_DATA; }
                    goto updateIndexAndPrev;
                }

                /* LUMA: dg in [-32..31], dr-dg and db-dg in [-8..7] */
                {
                    int dr_dg, db_dg;
                    dr_dg = dr - dg;
                    db_dg = db - dg;
                    if ( (dg >= -32 && dg <= 31) &&
                         (dr_dg >= -8 && dr_dg <= 7) &&
                         (db_dg >= -8 && db_dg <= 7) )
                    {
                        byte b1, b2;
                        b1 = (byte)(QOI_OP_LUMA | (dg + 32));
                        b2 = (byte)(((dr_dg + 8) << 4) | (db_dg + 8));
                        if (!qoiWriteByte(out, b1) || !qoiWriteByte(out, b2))
                        {
                            HugeArrayUnlock(rowPtr);
                            return QE_OUT_OF_DATA;
                        }
                        goto updateIndexAndPrev;
                    }
                }

                /* fallback: RGB */
                if (!qoiEmitRGB(out, px)) { HugeArrayUnlock(rowPtr); return QE_OUT_OF_DATA; }
            }
            else
            {
                /* alpha differs: RGBA */
                if (!qoiEmitRGBA(out, px)) { HugeArrayUnlock(rowPtr); return QE_OUT_OF_DATA; }
            }

updateIndexAndPrev:
            index[hidx] = px;
            pxPrev      = px;

nextPixel:
            ;
        }

        HugeArrayUnlock(rowPtr);
    }

    /* end marker: 00 00 00 00 00 00 00 01 */
    {
        byte tail[8];
        tail[0]=0; tail[1]=0; tail[2]=0; tail[3]=0;
        tail[4]=0; tail[5]=0; tail[6]=0; tail[7]=1;
        if (!qoiWriteN(out, (void*)&tail[0], 8)) { return QE_OUT_OF_DATA; }
    }

    return QE_NO_ERROR;
}

/*============================== PUBLIC API ============================*/

QoiError _pascal _export
QoiExportBitmapFHandle(VMFileHandle srcfile, VMBlockHandle bmpblock, FileHandle destfile)
{
    EGError     egStat;
    SizeAsDWord sizeXY;
    dword       Wd, Hd;
    word        W, H;
    BMType      bmptype;
    BMFormat    bmformat;
    Boolean     hasMask;
    QoiError    result;

    /* rewind dest file */
    FilePos(destfile, 0, FILE_POS_START);

    /* fetch size */
    sizeXY = BmpGetBitmapSize(srcfile, bmpblock, &egStat);
    if (egStat != EGE_NO_ERROR) {
        return QE_INVALID_FILE;
    }
    Wd = DWORD_WIDTH(sizeXY);
    Hd = DWORD_HEIGHT(sizeXY);
    W  = (Wd > 65535UL) ? 65535 : (word)Wd;
    H  = (Hd > 65535UL) ? 65535 : (word)Hd;

    /* fetch type */
    bmptype  = BmpGetBitmapType(srcfile, bmpblock, &egStat);
    if (egStat != EGE_NO_ERROR) {
        return QE_INVALID_FILE;
    }
    bmformat = (BMFormat)(bmptype & BMT_FORMAT);
    hasMask  = ( (bmptype & BMT_MASK) ? TRUE : FALSE );

    only support true color */
    if (bmformat != BMF_24BIT) {
        return QE_WRONG_FILE_FORMAT;
    }

    result = qoiEncodeBitmapToFile(destfile, srcfile, bmpblock, W, H, hasMask);
    return result;
}
