/********************************************************************
 *
 *      Copyright (c) FreeGEOS Crew 01/2023.
 *
 *
 *******************************************************************/

/********************************************************************
 *              Headers
 *******************************************************************/
@include <stdapp.goh>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define EOF     (-1)
#define INVALID (-2)


// single byte border, equals 7 bit ASCII
#define B1BORDER 0x80

// first byte of a 2-byte encoding starts with 110 and carries 5 bits of data
#define B2LEAD 0xC0 // 1100 0000
#define B2MASK 0x1F // 0001 1111

// first byte of a 3-byte encoding starts with 1110 and carries 4 bits of data
#define B3LEAD 0xE0 // 1110 0000
#define B3MASK 0x0F // 0000 1111

// first byte of a 4-byte encoding starts with 11110 and carries 3 bits of data
#define B4LEAD 0xF0 // 1111 0000
#define B4MASK 0x07 // 0000 0111

// non-first bytes start with 10 and carries 6 bits of data
#define MBLEAD 0x80 // 1000 0000
#define MBMASK 0x3F // 0011 1111

#define UTF8_CACHE 2000
#define PLACEHOLDER_CHAR 225

#define NUM_XLATE_ELEMS 126
@start xlateResource, data;

    @chunk dword xlateTable[NUM_XLATE_ELEMS] = {
        /*GEOS*/ /*UTF8*/
        /*128*/  196
        /*129*/ ,197
        /*130*/ ,199
        /*131*/ ,201
        /*132*/ ,209
        /*133*/ ,214
        /*134*/ ,220
        /*135*/ ,225
        /*136*/ ,224
        /*137*/ ,226
        /*138*/ ,228
        /*139*/ ,227
        /*140*/ ,229
        /*141*/ ,231
        /*142*/ ,233
        /*143*/ ,232
        /*144*/ ,234
        /*145*/ ,235
        /*146*/ ,237
        /*147*/ ,236
        /*148*/ ,238
        /*149*/ ,239
        /*150*/ ,241
        /*151*/ ,243
        /*152*/ ,242
        /*153*/ ,244
        /*154*/ ,246
        /*155*/ ,245
        /*156*/ ,250
        /*157*/ ,249
        /*158*/ ,251
        /*159*/ ,252
        /*160*/ ,8224
        /*161*/ ,176
        /*162*/ ,162
        /*163*/ ,163
        /*164*/ ,167
        /*165*/ ,8226
        /*166*/ ,182
        /*167*/ ,223
        /*168*/ ,174
        /*169*/ ,169
        /*170*/ ,8482
        /*171*/ ,180
        /*172*/ ,168
        /*173*/ ,8800
        /*174*/ ,198
        /*175*/ ,216
        /*176*/ ,8734
        /*177*/ ,177
        /*178*/ ,8804
        /*179*/ ,8805
        /*180*/ ,165
        /*181*/ ,181
        /*182*/ ,8706
        /*183*/ ,8721
        /*184*/ ,8719
        /*185*/ ,960
        /*186*/ ,8747
        /*187*/ ,170
        /*188*/ ,186
        /*189*/ ,937
        /*190*/ ,230
        /*191*/ ,248
        /*192*/ ,191
        /*193*/ ,161
        /*194*/ ,172
        /*195*/ ,8730
        /*196*/ ,402
        /*197*/ ,8776
        /*198*/ ,8710
        /*199*/ ,171
        /*200*/ ,187
        /*201*/ ,8230
        /*202*/ ,160
        /*203*/ ,192
        /*204*/ ,195
        /*205*/ ,213
        /*206*/ ,338
        /*207*/ ,339
        /*208*/ ,8211
        /*209*/ ,8212
        /*210*/ ,8220
        /*211*/ ,8221
        /*212*/ ,8216
        /*213*/ ,8217
        /*214*/ ,247
        /*215*/ ,9674
        /*216*/ ,255
        /*217*/ ,376
        /*218*/ ,8260
        /*219*/ ,8364
        /*220*/ ,8249
        /*221*/ ,8250
        /*222*/ ,221       // MacRoman: 64257
        /*223*/ ,253       // MacRoman: 64258
        /*224*/ ,8225
        /*225*/ ,183
        /*226*/ ,8218
        /*227*/ ,8222
        /*228*/ ,8240
        /*229*/ ,194
        /*230*/ ,202
        /*231*/ ,193
        /*232*/ ,203
        /*233*/ ,200
        /*234*/ ,205
        /*235*/ ,206
        /*236*/ ,207
        /*237*/ ,204
        /*238*/ ,211
        /*239*/ ,212
        /*240*/ ,63743
        /*241*/ ,210
        /*242*/ ,218
        /*243*/ ,219
        /*244*/ ,217
        /*245*/ ,305
        /*246*/ ,710
        /*247*/ ,732
        /*248*/ ,175
        /*249*/ ,728
        /*251*/ ,730
        /*252*/ ,184
        /*253*/ ,733
        /*254*/ ,731
    };
@end xlateResource;

/********************************************************************
 *              Class Definitions
 *******************************************************************/
 @class GContProcessClass, GenProcessClass;
 @endc;

   /*
    * Subclass this so we can intercept the
    * keyboard presses and respond properly to
    * the PgUp and PgDn keys.
    */
 @class GContViewClass, GenViewClass;
 @endc;

/********************************************************************
*              Class Declarations
*******************************************************************/
 @classdecl GContProcessClass, neverSaved;
 @classdecl GContViewClass;


/********************************************************************
 *              UI Object Resources
 *******************************************************************/

/********************************************************************
 *              AppResource Resource
 *******************************************************************/
@start AppResource;

@object GenApplicationClass GContApp = {
    GI_visMoniker = list { @GContTextMoniker };
    GI_comp = @GContPrimary;
    gcnList( MANUFACTURER_ID_GEOWORKS, GAGCNLT_WINDOWS ) =
        @GContPrimary;
}

@visMoniker GContTextMoniker = "GenContent";

@end AppResource;

/********************************************************************
 *              Interface Resource
 *******************************************************************/
@start Interface;

@object GenPrimaryClass GContPrimary = {
    GI_comp =   @GContView;
    HINT_SIZE_WINDOW_AS_DESIRED;
}

  /*
   * To have Gen objects in a scrolling "area"
   * we'll need to use a GenView. It's content
   * will be the GenContent below, which contains
   * all of the Gen objects we want to be scrollable.
   */
@object GContViewClass GContView = {
    GVI_content = @GContContent;
      /*
       * Set the flag for "generic contents" since we have
       * Gen objects as the content of this view.
       * Also set the flag so the view will be the same
       * color as the primary window, for appearances only.
       */
    GVI_attrs = @default | GVA_GENERIC_CONTENTS
                         | GVA_SAME_COLOR_AS_PARENT_WIN;
    GVI_vertAttrs = @default | GVDA_SCROLLABLE;
}

  /*
   * This is the content object which contains
   * all of the Gen objects that will be displayed
   * in the GenView.
   */
@object GenContentClass GContContent = {
    GI_comp = @GContValue1,
              @GContText1;
    GCI_genView = @GContView;
}

  /*
   * These are just some example Gen objects
   * that show that this concept really works.
   */
@object GenTextClass GContText1 = {
    GI_visMoniker = "Text 1:";
    GTXI_text = "";
}

@object GenValueClass GContValue1 = {
    GI_visMoniker = "Value 1:";
    GVLI_minimum = MakeWWFixed(-32767);
    GVLI_maximum = MakeWWFixed(32767);
    GVLI_value = MakeWWFixed(0);
}

@end Interface;


word TranslateCharNum(sdword num)
{
    dword *xlate_table;
    byte i = 0;
    word ret = PLACEHOLDER_CHAR; // if not found: middle dot.

    if (num < 128)
    {
        //if (num==10) ret = 13; // FIXME: this works for LF files, what about CR/LF?
        return (num >= 32 || num == 9 || num == 13) ? (word) num : ret;
    }

    MemLock(OptrToHandle(@xlateTable));
    xlate_table = LMemDeref(@xlateTable);

    for(i = 0; i < NUM_XLATE_ELEMS; i++)
    {
        if(xlate_table[i] == num)
        {
            ret = (word) (i + 128);
            break;
        }
    }

    MemUnlock(OptrToHandle(@xlateTable));
    return ret;
}

sdword GetUtf8CharFromFile(FileHandle fhandle)
{
    sdword result = 0;
    byte input[6] = {0};
    sbyte fError = 0;

    fError = FileRead(fhandle, &input[0], 1, FALSE);

    if (fError <= 0)
    {
        // The EOF was hit by the first character.
        return (sdword) EOF;
    }
    else if (
                ((input[0] & 0xC0) == 0x80)
            ||  ((input[0] & 0xfe) == 0xfe)
            )
    {
        // This is not the beginning of a multibyte sequence.
        // This is not a valid UTF-8 stream.
        return (sdword) INVALID;
    }
    else
    {
        if (input[0] < 0x80)
        {   // 1 byte encoding (7 bit ASCII character)
            result = (sdword) input[0];
        }
        else if (input[0] < 0xE0)
        {   // 2 byte encoding
            // first byte of a 2-byte encoding starts with 110 and carries 5 bits of data
            fError = FileRead(fhandle, &input[1], 1, FALSE);
            if (fError <= 0) return (sdword) EOF;

            result =    (sdword)    (input[0] & B2MASK) << 6
                        |           (input[1] & MBMASK);
        }
        else if(input[0] < 0xF0)
        {   // 3 byte encoding
            // first byte of a 3-byte encoding starts with 1110 and carries 4 bits of data
            fError = FileRead(fhandle, &input[1], 2, FALSE);
            if (fError <= 0) return (sdword) EOF;

            result =    (sdword)    (input[0] & B3MASK) << 12
                        |           (input[1] & MBMASK) << 6
                        |           (input[2] & MBMASK);
        }
        else
        {   // 4 byte encoding
            // first byte of a 4-byte encoding starts with 11110 and carries 3 bits of data
            fError = FileRead(fhandle, &input[1], 3, FALSE);
            if (fError <= 0) return (sdword) EOF;

            result =    (sdword)    (input[0] & B4MASK) << 18
                        |           (input[1] & MBMASK) << 12
                        |           (input[2] & MBMASK) << 6
                        |           (input[3] & MBMASK);
        }
    }

    return result;
}

void UTF8FileToGEOS()
{
    sdword      c=0;
    byte        gc=0;
    FileHandle  infile=0;
    FileHandle  outfile=0;
    byte        buf[255]={0};
    byte        charBuf[10]={0};
    byte        i=0;

    FilePushDir();
    FileSetStandardPath(SP_DOCUMENT);

    infile = FileOpen("UTEF.TXT", FILE_ACCESS_R | FILE_DENY_RW);
    //outfile = FileOpen("GEOSF.TXT", FILE_ACCESS_W | FILE_DENY_RW);
    outfile = FileCreate("GEOSF.TXT", (FCF_NATIVE | FILE_ACCESS_W | FILE_DENY_RW | FILE_CREATE_TRUNCATE), 0);


    if ((infile != NullHandle) && (outfile != NullHandle))
    {
        FilePos(infile, 0, FILE_POS_START);
        FilePos(outfile, 0, FILE_POS_START);

        while ((c != INVALID))
        {
            c = GetUtf8CharFromFile(infile);
            if (c == EOF) break;

            if (c != INVALID)
            {
                //sprintf(charBuf, "%ld", c);
                //@call GContText1::MSG_VIS_TEXT_APPEND_PTR(charBuf, 0);
                //@call GContText1::MSG_VIS_TEXT_APPEND_PTR(_TEXT(" - "), 0);

                gc = TranslateCharNum(c);

                //sprintf(charBuf, "%d", gc);
                //@call GContText1::MSG_VIS_TEXT_APPEND_PTR(charBuf, 0);
                //@call GContText1::MSG_VIS_TEXT_APPEND_PTR(_TEXT(" - "), 0);

                buf[0] = gc;
                buf[1] = 0;
                FileWrite(outfile, buf, 2, FALSE);
                //@call GContText1::MSG_VIS_TEXT_APPEND_PTR(buf, 0);
                //@call GContText1::MSG_VIS_TEXT_APPEND_PTR(_TEXT("\r"), 0);

                //buf[i] = gc;
                //i++;
            }
        }
        //buf[i] = 0;
        //@call GContText1::MSG_VIS_TEXT_APPEND_PTR(_TEXT("---\r"), 0);
        //@call GContText1::MSG_VIS_TEXT_APPEND_PTR(buf, 0);
        //@call GContText1::MSG_VIS_TEXT_APPEND_PTR(_TEXT("\r"), 0);
        FileClose(infile, FALSE);
        FileClose(outfile, FALSE);
    }
    FilePopDir();
}

sdword GetUtf8CharFromBuffer(MemHandle bufHan, word bufSize, word *bufIdx)
{
    #define     INPUT_BYTE(x) (bufPtr[*bufIdx+x])

    byte        *bufPtr = 0;
    sdword      result = 0;

    bufPtr = MemLock(bufHan);

    if (
                ((INPUT_BYTE(0) & B2LEAD) == B1BORDER) // This is not the beginning of a multibyte sequence.
            ||  ((INPUT_BYTE(0) & 0xFE) == 0xFE) // This is not a valid UTF-8 stream.
        )
    {
        result = (sdword) INVALID;
        *bufIdx = *bufIdx + 1;
    }
    else
    {
        if (INPUT_BYTE(0) < B1BORDER)
        {   // 1 byte encoding
            // (7 bit ASCII character)
            result = (sdword) INPUT_BYTE(0);

            *bufIdx = *bufIdx + 1;
        }
        else if (INPUT_BYTE(0) < B3LEAD)
        {   // 2 byte encoding
            // first byte of a 2-byte encoding starts with 110 and carries 5 bits of data
            result =   (sdword)    (INPUT_BYTE(0) & B2MASK) << 6
                        |          (INPUT_BYTE(1) & MBMASK);

            *bufIdx = *bufIdx + 2;
        }
        else if (INPUT_BYTE(0) < B4LEAD)
        {   // 3 byte encoding
            // first byte of a 3-byte encoding starts with 1110 and carries 4 bits of data
            result =   (sdword)    (INPUT_BYTE(0) & B3MASK) << 12
                        |          (INPUT_BYTE(1) & MBMASK) << 6
                        |          (INPUT_BYTE(2) & MBMASK);

            *bufIdx = *bufIdx + 3;
        }
        else
        {   // 4 byte encoding
            // first byte of a 4-byte encoding starts with 11110 and carries 3 bits of data
            result =   (sdword)    (INPUT_BYTE(0) & B4MASK) << 18
                        |          (INPUT_BYTE(1) & MBMASK) << 12
                        |          (INPUT_BYTE(2) & MBMASK) << 6
                        |          (INPUT_BYTE(3) & MBMASK);

            *bufIdx = *bufIdx + 4;
        }
    }

    MemUnlock(bufHan);

    return result;

    #undef INPUT_BYTE
}

void UTF8FileToGEOSBuffer()
{
    sdword      c=0;
    word        gc=0;
    FileHandle  infile=0;
    FileHandle  outfile=0;

    byte        buf[255]={0};
    byte        charBuf[25]={0};

    byte        i=0;

    MemHandle   inBufHan = 0;
    byte*       bufPtr = 0;
    word        bufSize = 0;
    word        bufIdx = 0;

    MemHandle   outBufHan = 0;
    byte*       outBufPtr = 0;
    word        outBufIdx = 0;

    dword       curFilePos = 0;

    inBufHan = MemAlloc(UTF8_CACHE, HF_SWAPABLE, HAF_ZERO_INIT);

    FilePushDir();
    FileSetStandardPath(SP_DOCUMENT);

    infile = FileOpen("UTEF.TXT", FILE_ACCESS_R | FILE_DENY_RW);
    outfile = FileCreate("GEOSF.TXT", (FCF_NATIVE | FILE_ACCESS_W | FILE_DENY_RW | FILE_CREATE_TRUNCATE), 0);

    if ((infile != NullHandle) && (outfile != NullHandle))
    {
        FilePos(infile, 0, FILE_POS_START);
        FilePos(outfile, 0, FILE_POS_START);

        do
        {
            //sprintf(charBuf, "%ld", curFilePos);
            //@call GContText1::MSG_VIS_TEXT_APPEND_PTR(charBuf, 0);
            //@call GContText1::MSG_VIS_TEXT_APPEND_PTR(_TEXT(" = curFilePos"), 0);

            FilePos(infile, curFilePos, FILE_POS_START); // go back if previous buffer didn't end on a lead byte

            bufPtr = MemLock(inBufHan);
            bufSize = FileRead(infile, bufPtr, UTF8_CACHE, FALSE);

            if (bufSize > 0)
            {
                bufIdx = bufSize - 1;
                while (bufIdx > 0)
                {
                    if (
                            ((bufPtr[bufIdx] & B1BORDER) == B1BORDER) ||
                            ((bufPtr[bufIdx] & B2LEAD) == B2LEAD) ||
                            ((bufPtr[bufIdx] & B3LEAD) == B3LEAD) ||
                            ((bufPtr[bufIdx] & B4LEAD) == B4LEAD)
                        )
                    {
                        bufSize = bufIdx - 1; // go one before the leading byte we just found
                        break;
                    }
                    bufIdx--;
                }
                MemUnlock(inBufHan);

                curFilePos = curFilePos + bufSize;
                bufIdx = 0;

                outBufHan = MemAlloc(UTF8_CACHE * 2, HF_SWAPABLE, HAF_ZERO_INIT);
                outBufIdx = 0;

                while(bufIdx < bufSize)
                {

                    //sprintf(charBuf, "%ld", bufIdx);
                    //@call GContText1::MSG_VIS_TEXT_APPEND_PTR(charBuf, 0);
                    //@call GContText1::MSG_VIS_TEXT_APPEND_PTR(_TEXT(" - "), 0);

                    c = GetUtf8CharFromBuffer(inBufHan, bufSize, &bufIdx);

                    sprintf(charBuf, "%ld", c);
                    @call GContText1::MSG_VIS_TEXT_APPEND_PTR(charBuf, 0);
                    @call GContText1::MSG_VIS_TEXT_APPEND_PTR(_TEXT(" - "), 0);

                    //sprintf(charBuf, "%ld", bufIdx);
                    //@call GContText1::MSG_VIS_TEXT_APPEND_PTR(charBuf, 0);
                    //@call GContText1::MSG_VIS_TEXT_APPEND_PTR(_TEXT(" - "), 0);

                    if (c != INVALID)
                    {
                        gc = TranslateCharNum(c);

                        //word	LocalGeosToDosChar(word	ch, word	defaultChar);
                        //word	LocalGeosToCodePageChar(word ch, DosCodePage codePage, word	defaultChar);

                        /*
                            CODE_PAGE_CURRENT		enum DosCodePage, 0
                            CODE_PAGE_US			enum DosCodePage, 437
                            CODE_PAGE_LATIN_1		enum DosCodePage, 819
                            CODE_PAGE_MULTILINGUAL		enum DosCodePage, 850
                            CODE_PAGE_MULTILINGUAL_EURO	enum DosCodePage, 858
                            CODE_PAGE_PORTUGUESE		enum DosCodePage, 860
                            CODE_PAGE_CANADIAN_FRENCH	enum DosCodePage, 863
                            CODE_PAGE_NORDIC		enum DosCodePage, 865
                        */

                        //gc = LocalGeosToCodePageChar(gc, CODE_PAGE_MULTILINGUAL_EURO, PLACEHOLDER_CHAR);

                        sprintf(charBuf, "%d", gc);
                        @call GContText1::MSG_VIS_TEXT_APPEND_PTR(charBuf, 0);
                        @call GContText1::MSG_VIS_TEXT_APPEND_PTR(_TEXT(" - "), 0);

                        outBufPtr = MemLock(outBufHan);

                        outBufPtr[outBufIdx] = (byte) gc;

                        buf[0] = gc;
                        buf[1] = 0;
                        //strcat((char*) outBufPtr, (char*) buf);

                        MemUnlock(outBufHan);
                        outBufIdx = outBufIdx + 1;

                        //sprintf(charBuf, "%d", outBufIdx);
                        //@call GContText1::MSG_VIS_TEXT_APPEND_PTR(charBuf, 0);
                        //@call GContText1::MSG_VIS_TEXT_APPEND_PTR(" - ", 0);

                        //buf[outBufIdx] = gc;
                        //FileWrite(outfile, buf, 2, FALSE);

                        @call GContText1::MSG_VIS_TEXT_APPEND_PTR(buf, 0);
                        @call GContText1::MSG_VIS_TEXT_APPEND_PTR("\r", 0);
                    }
                }

                if (outBufIdx > 0)
                {
                    //buf[outBufIdx] = 0;

                    outBufPtr = MemLock(outBufHan);
                    outBufPtr[outBufIdx] = 0;

                    //@call GContText1::MSG_VIS_TEXT_APPEND_PTR(outBufPtr, 0);
                    //@call GContText1::MSG_VIS_TEXT_APPEND_PTR(buf, 0);
                    //@call GContText1::MSG_VIS_TEXT_APPEND_PTR(_TEXT("\r"), 0);

                    //FileWrite(outfile, "Static\r\0", 8, FALSE);
                    //FileWrite(outfile, buf, outBufIdx, FALSE);
                    //FileWrite(outfile, "Dynamic\r\0", 9, FALSE);
                    FileWrite(outfile, "\0", 1, FALSE);
                    FileWrite(outfile, outBufPtr, outBufIdx, FALSE);
                    MemUnlock(outBufHan);
                }
                MemFree(outBufHan);

            }
            else
            {
                MemUnlock(inBufHan);
            }
        }
        while (bufSize > 0);

        MemFree(inBufHan);
        //MemFree(outBufHan);

        FileClose(infile, FALSE);
        FileClose(outfile, FALSE);
    }
    FilePopDir();
}


@method GContProcessClass, MSG_GEN_PROCESS_OPEN_APPLICATION
{
    @callsuper();
    UTF8FileToGEOSBuffer();
}
