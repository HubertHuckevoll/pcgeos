/********************************************************************
 *
 *      Copyright (c) FreeGEOS Crew 2023.
 *
 *
 *******************************************************************/

/********************************************************************
 *              Headers
 *******************************************************************/
@include <stdapp.goh>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// all codepoints up to 32 are not useable characters so we can use 1 and 2 as error codes
#define EOF     (-1)
#define INVALID (-2)

// first byte of a 2-byte encoding starts with 110 and carries 5 bits of data
//#define B2LEAD 0xC0 // 1100 0000
#define B2MASK 0x1F // 0001 1111

// first byte of a 3-byte encoding starts with 1110 and carries 4 bits of data
//#define B3LEAD 0xE0 // 1110 0000
#define B3MASK 0x0F // 0000 1111

// first byte of a 4-byte encoding starts with 11110 and carries 3 bits of data
//#define B4LEAD 0xF0 // 1111 0000
#define B4MASK 0x07 // 0000 0111

// non-first bytes start with 10 and carries 6 bits of data
//#define MBLEAD 0x80 // 1000 0000
#define MBMASK 0x3F // 0011 1111

#define NUM_XLATE_ELEMS 126
@start xlateResource, data;

    @chunk dword xlateTable[NUM_XLATE_ELEMS] = {
/*GEOS*/ /*UTF8*/
/*128*/  196
/*129*/ ,197
/*130*/ ,199
/*131*/ ,201
/*132*/ ,209
/*133*/ ,214
/*134*/ ,220
/*135*/ ,225
/*136*/ ,224
/*137*/ ,226
/*138*/ ,228
/*139*/ ,227
/*140*/ ,229
/*141*/ ,231
/*142*/ ,233
/*143*/ ,232
/*144*/ ,234
/*145*/ ,235
/*146*/ ,237
/*147*/ ,236
/*148*/ ,238
/*149*/ ,239
/*150*/ ,241
/*151*/ ,243
/*152*/ ,242
/*153*/ ,244
/*154*/ ,246
/*155*/ ,245
/*156*/ ,250
/*157*/ ,249
/*158*/ ,251
/*159*/ ,252
/*160*/ ,8224
/*161*/ ,176
/*162*/ ,162
/*163*/ ,163
/*164*/ ,167
/*165*/ ,8226
/*166*/ ,182
/*167*/ ,223
/*168*/ ,174
/*169*/ ,169
/*170*/ ,8482
/*171*/ ,180
/*172*/ ,168
/*173*/ ,8800
/*174*/ ,198
/*175*/ ,216
/*176*/ ,8734
/*177*/ ,177
/*178*/ ,8804
/*179*/ ,8805
/*180*/ ,165
/*181*/ ,181
/*182*/ ,8706
/*183*/ ,8721
/*184*/ ,8719
/*185*/ ,960
/*186*/ ,8747
/*187*/ ,170
/*188*/ ,186
/*189*/ ,937
/*190*/ ,230
/*191*/ ,248
/*192*/ ,191
/*193*/ ,161
/*194*/ ,172
/*195*/ ,8730
/*196*/ ,402
/*197*/ ,8776
/*198*/ ,8710
/*199*/ ,171
/*200*/ ,187
/*201*/ ,8230
/*202*/ ,160
/*203*/ ,192
/*204*/ ,195
/*205*/ ,213
/*206*/ ,338
/*207*/ ,339
/*208*/ ,8211
/*209*/ ,8212
/*210*/ ,8220
/*211*/ ,8221
/*212*/ ,8216
/*213*/ ,8217
/*214*/ ,247
/*215*/ ,9674
/*216*/ ,255
/*217*/ ,376
/*218*/ ,8260
/*219*/ ,8364
/*220*/ ,8249
/*221*/ ,8250
/*222*/ ,221       // MacRoman: 64257
/*223*/ ,253       // MacRoman: 64258
/*224*/ ,8225
/*225*/ ,183
/*226*/ ,8218
/*227*/ ,8222
/*228*/ ,8240
/*229*/ ,194
/*230*/ ,202
/*231*/ ,193
/*232*/ ,203
/*233*/ ,200
/*234*/ ,205
/*235*/ ,206
/*236*/ ,207
/*237*/ ,204
/*238*/ ,211
/*239*/ ,212
/*240*/ ,63743
/*241*/ ,210
/*242*/ ,218
/*243*/ ,219
/*244*/ ,217
/*245*/ ,305
/*246*/ ,710
/*247*/ ,732
/*248*/ ,175
/*249*/ ,728
/*251*/ ,730
/*252*/ ,184
/*253*/ ,733
/*254*/ ,731
    };
@end xlateResource;

/********************************************************************
 *              Class Definitions
 *******************************************************************/
 @class GContProcessClass, GenProcessClass;
 @endc;

   /*
    * Subclass this so we can intercept the
    * keyboard presses and respond properly to
    * the PgUp and PgDn keys.
    */
 @class GContViewClass, GenViewClass;
 @endc;

/********************************************************************
*              Class Declarations
*******************************************************************/
 @classdecl GContProcessClass, neverSaved;
 @classdecl GContViewClass;


/********************************************************************
 *              UI Object Resources
 *******************************************************************/

/********************************************************************
 *              AppResource Resource
 *******************************************************************/
@start AppResource;

@object GenApplicationClass GContApp = {
    GI_visMoniker = list { @GContTextMoniker };
    GI_comp = @GContPrimary;
    gcnList( MANUFACTURER_ID_GEOWORKS, GAGCNLT_WINDOWS ) =
        @GContPrimary;
}

@visMoniker GContTextMoniker = "GenContent";

@end AppResource;

/********************************************************************
 *              Interface Resource
 *******************************************************************/
@start Interface;

@object GenPrimaryClass GContPrimary = {
    GI_comp =   @GContView;
    HINT_SIZE_WINDOW_AS_DESIRED;
}

  /*
   * To have Gen objects in a scrolling "area"
   * we'll need to use a GenView. It's content
   * will be the GenContent below, which contains
   * all of the Gen objects we want to be scrollable.
   */
@object GContViewClass GContView = {
    GVI_content = @GContContent;
      /*
       * Set the flag for "generic contents" since we have
       * Gen objects as the content of this view.
       * Also set the flag so the view will be the same
       * color as the primary window, for appearances only.
       */
    GVI_attrs = @default | GVA_GENERIC_CONTENTS
                         | GVA_SAME_COLOR_AS_PARENT_WIN;
    GVI_vertAttrs = @default | GVDA_SCROLLABLE;
}

  /*
   * This is the content object which contains
   * all of the Gen objects that will be displayed
   * in the GenView.
   */
@object GenContentClass GContContent = {
    GI_comp = @GContValue1,
              @GContText1;
    GCI_genView = @GContView;
}

  /*
   * These are just some example Gen objects
   * that show that this concept really works.
   */
@object GenTextClass GContText1 = {
    GI_visMoniker = "Text 1:";
    GTXI_text = "";
}

@object GenValueClass GContValue1 = {
    GI_visMoniker = "Value 1:";
    GVLI_minimum = MakeWWFixed(-32767);
    GVLI_maximum = MakeWWFixed(32767);
	GVLI_value = MakeWWFixed(0);
}

@end Interface;


byte TranslateCharNum(sdword num)
{
    dword *xlate_table;
    byte i = 0;
    byte ret = 225; // if not found: middle dot.

    if (num < 128)
    {
        return (num>=32 || num==9 || num==13) ? (byte) num : ret;
    }

    MemLock(OptrToHandle(@xlateTable));
    xlate_table = LMemDeref(@xlateTable);

    for(i = 0; i < NUM_XLATE_ELEMS; i++)
    {
        if(xlate_table[i] == num)
        {
            ret = (byte) (i + 128);
            break;
        }
    }

    MemUnlock(OptrToHandle(@xlateTable));
    return ret;
}

sdword GetUtf8CharFromFile(FileHandle fhandle)
{
    sdword result = 0;
    byte input[6] = {0};
    sbyte fError = 0;

    fError = FileRead(fhandle, &input[0], 1, FALSE);

    if (fError <= 0)
    {
        // The EOF was hit by the first character.
        return (sdword) EOF;
    }
    else if (
                ((input[0] & 0xC0) == 0x80)
            ||  ((input[0] & 0xfe) == 0xfe)
            )
    {
        // This is not the beginning of the multibyte sequence.
        // This is not a valid UTF-8 stream.
        return INVALID;
    }
    else
    {
        if (input[0] < 0x80)
        {   // 1 byte encoding (7 bit ASCII character)
            result = (sdword) input[0];
        }
        else if (input[0] < 0xE0)
        {   // 2 byte encoding
            // first byte of a 2-byte encoding starts with 110 and carries 5 bits of data
            fError = FileRead(fhandle, &input[1], 1, FALSE);
            if (fError <= 0) return (sdword) EOF;

            result =    (sdword)    (input[0] & B2MASK) << 6
                        |           (input[1] & MBMASK);
        }
        else if(input[0] < 0xF0)
        {   // 3 byte encoding
            // first byte of a 3-byte encoding starts with 1110 and carries 4 bits of data
            fError = FileRead(fhandle, &input[1], 2, FALSE);
            if (fError <= 0) return (sdword) EOF;

            result =    (sdword)    (input[0] & B3MASK) << 12
                        |           (input[1] & MBMASK) << 6
                        |           (input[2] & MBMASK);
        }
        else
        {   // 4 byte encoding
            // first byte of a 4-byte encoding starts with 11110 and carries 3 bits of data
            fError = FileRead(fhandle, &input[1], 3, FALSE);
            if (fError <= 0) return (sdword) EOF;

            result =    (sdword)    (input[0] & B4MASK) << 18
                        |           (input[1] & MBMASK) << 12
                        |           (input[2] & MBMASK) << 6
                        |           (input[3] & MBMASK);
        }
    }

    return result;
}

void UTF8FileToGEOS()
{
    sdword      c=0;
    byte        gc=0;
    FileHandle  infile=0;
    FileHandle  outfile=0;
    byte        buf[255]={0};
    byte        charBuf[10]={0};
    byte        i=0;

    FilePushDir();
    FileSetStandardPath(SP_DOCUMENT);

    infile = FileOpen("UTEF.TXT", FILE_ACCESS_R | FILE_DENY_RW);
    //outfile = FileOpen("GEOSF.TXT", FILE_ACCESS_W | FILE_DENY_RW);
    outfile = FileCreate("GEOSF.TXT", (FCF_NATIVE | FILE_ACCESS_W | FILE_DENY_RW | FILE_CREATE_TRUNCATE), 0);


    if ((infile != NullHandle) && (outfile != NullHandle))
    {
        FilePos(infile, 0, FILE_POS_START);
        FilePos(outfile, 0, FILE_POS_START);

        while ((c != INVALID))
        {
            c = GetUtf8CharFromFile(infile);
            if (c == EOF) break;

            if (c != INVALID)
            {
                sprintf(charBuf, "%ld", c);
                @call GContText1::MSG_VIS_TEXT_APPEND_PTR(charBuf, 0);
                @call GContText1::MSG_VIS_TEXT_APPEND_PTR(_TEXT(" - "), 0);

                gc = TranslateCharNum(c);
                sprintf(charBuf, "%d", gc);
                @call GContText1::MSG_VIS_TEXT_APPEND_PTR(charBuf, 0);
                @call GContText1::MSG_VIS_TEXT_APPEND_PTR(_TEXT(" - "), 0);

                buf[0] = gc;
                buf[1] = 0;
                @call GContText1::MSG_VIS_TEXT_APPEND_PTR(buf, 0);
                @call GContText1::MSG_VIS_TEXT_APPEND_PTR(_TEXT("\r"), 0);

                //FileWrite(outfile, (void*)&gc, 1, FALSE);
                FileWrite(outfile, &buf, 2, FALSE);

                //buf[i] = gc;
                //i++;
            }
        }
        //buf[i] = 0;
        //@call GContText1::MSG_VIS_TEXT_APPEND_PTR(_TEXT("---\r"), 0);
        //@call GContText1::MSG_VIS_TEXT_APPEND_PTR(buf, 0);
        //@call GContText1::MSG_VIS_TEXT_APPEND_PTR(_TEXT("\r"), 0);
        FileClose(infile, FALSE);
        FileClose(outfile, FALSE);
    }
    FilePopDir();
}

@method GContProcessClass, MSG_GEN_PROCESS_OPEN_APPLICATION
{
    @callsuper();
    UTF8FileToGEOS();
}
