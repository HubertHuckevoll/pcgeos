/********************************************************************
 *
 *      Copyright (c) FreeGEOS Crew 01/2023.
 *
 *
 *******************************************************************/

/********************************************************************
 *              Headers
 *******************************************************************/
@include <stdapp.goh>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define EOF     (-1)
#define INVALID (-2)

// first byte of a 2-byte encoding starts with 110 and carries 5 bits of data
#define B2LEAD 0xC0 // 1100 0000
#define B2MASK 0x1F // 0001 1111

// first byte of a 3-byte encoding starts with 1110 and carries 4 bits of data
#define B3LEAD 0xE0 // 1110 0000
#define B3MASK 0x0F // 0000 1111

// first byte of a 4-byte encoding starts with 11110 and carries 3 bits of data
#define B4LEAD 0xF0 // 1111 0000
#define B4MASK 0x07 // 0000 0111

// non-first bytes start with 10 and carries 6 bits of data
#define MBLEAD 0x80 // 1000 0000
#define MBMASK 0x3F // 0011 1111

#define UTF8_CACHE 2000

#define NUM_XLATE_ELEMS 126
@start xlateResource, data;

    @chunk dword xlateTable[NUM_XLATE_ELEMS] = {
        /*GEOS*/ /*UTF8*/
        /*128*/  196
        /*129*/ ,197
        /*130*/ ,199
        /*131*/ ,201
        /*132*/ ,209
        /*133*/ ,214
        /*134*/ ,220
        /*135*/ ,225
        /*136*/ ,224
        /*137*/ ,226
        /*138*/ ,228
        /*139*/ ,227
        /*140*/ ,229
        /*141*/ ,231
        /*142*/ ,233
        /*143*/ ,232
        /*144*/ ,234
        /*145*/ ,235
        /*146*/ ,237
        /*147*/ ,236
        /*148*/ ,238
        /*149*/ ,239
        /*150*/ ,241
        /*151*/ ,243
        /*152*/ ,242
        /*153*/ ,244
        /*154*/ ,246
        /*155*/ ,245
        /*156*/ ,250
        /*157*/ ,249
        /*158*/ ,251
        /*159*/ ,252
        /*160*/ ,8224
        /*161*/ ,176
        /*162*/ ,162
        /*163*/ ,163
        /*164*/ ,167
        /*165*/ ,8226
        /*166*/ ,182
        /*167*/ ,223
        /*168*/ ,174
        /*169*/ ,169
        /*170*/ ,8482
        /*171*/ ,180
        /*172*/ ,168
        /*173*/ ,8800
        /*174*/ ,198
        /*175*/ ,216
        /*176*/ ,8734
        /*177*/ ,177
        /*178*/ ,8804
        /*179*/ ,8805
        /*180*/ ,165
        /*181*/ ,181
        /*182*/ ,8706
        /*183*/ ,8721
        /*184*/ ,8719
        /*185*/ ,960
        /*186*/ ,8747
        /*187*/ ,170
        /*188*/ ,186
        /*189*/ ,937
        /*190*/ ,230
        /*191*/ ,248
        /*192*/ ,191
        /*193*/ ,161
        /*194*/ ,172
        /*195*/ ,8730
        /*196*/ ,402
        /*197*/ ,8776
        /*198*/ ,8710
        /*199*/ ,171
        /*200*/ ,187
        /*201*/ ,8230
        /*202*/ ,160
        /*203*/ ,192
        /*204*/ ,195
        /*205*/ ,213
        /*206*/ ,338
        /*207*/ ,339
        /*208*/ ,8211
        /*209*/ ,8212
        /*210*/ ,8220
        /*211*/ ,8221
        /*212*/ ,8216
        /*213*/ ,8217
        /*214*/ ,247
        /*215*/ ,9674
        /*216*/ ,255
        /*217*/ ,376
        /*218*/ ,8260
        /*219*/ ,8364
        /*220*/ ,8249
        /*221*/ ,8250
        /*222*/ ,221       // MacRoman: 64257
        /*223*/ ,253       // MacRoman: 64258
        /*224*/ ,8225
        /*225*/ ,183
        /*226*/ ,8218
        /*227*/ ,8222
        /*228*/ ,8240
        /*229*/ ,194
        /*230*/ ,202
        /*231*/ ,193
        /*232*/ ,203
        /*233*/ ,200
        /*234*/ ,205
        /*235*/ ,206
        /*236*/ ,207
        /*237*/ ,204
        /*238*/ ,211
        /*239*/ ,212
        /*240*/ ,63743
        /*241*/ ,210
        /*242*/ ,218
        /*243*/ ,219
        /*244*/ ,217
        /*245*/ ,305
        /*246*/ ,710
        /*247*/ ,732
        /*248*/ ,175
        /*249*/ ,728
        /*251*/ ,730
        /*252*/ ,184
        /*253*/ ,733
        /*254*/ ,731
    };
@end xlateResource;

/********************************************************************
 *              Class Definitions
 *******************************************************************/
 @class GContProcessClass, GenProcessClass;
 @endc;

   /*
    * Subclass this so we can intercept the
    * keyboard presses and respond properly to
    * the PgUp and PgDn keys.
    */
 @class GContViewClass, GenViewClass;
 @endc;

/********************************************************************
*              Class Declarations
*******************************************************************/
 @classdecl GContProcessClass, neverSaved;
 @classdecl GContViewClass;


/********************************************************************
 *              UI Object Resources
 *******************************************************************/

/********************************************************************
 *              AppResource Resource
 *******************************************************************/
@start AppResource;

@object GenApplicationClass GContApp = {
    GI_visMoniker = list { @GContTextMoniker };
    GI_comp = @GContPrimary;
    gcnList( MANUFACTURER_ID_GEOWORKS, GAGCNLT_WINDOWS ) =
        @GContPrimary;
}

@visMoniker GContTextMoniker = "GenContent";

@end AppResource;

/********************************************************************
 *              Interface Resource
 *******************************************************************/
@start Interface;

@object GenPrimaryClass GContPrimary = {
    GI_comp =   @GContView;
    HINT_SIZE_WINDOW_AS_DESIRED;
}

  /*
   * To have Gen objects in a scrolling "area"
   * we'll need to use a GenView. It's content
   * will be the GenContent below, which contains
   * all of the Gen objects we want to be scrollable.
   */
@object GContViewClass GContView = {
    GVI_content = @GContContent;
      /*
       * Set the flag for "generic contents" since we have
       * Gen objects as the content of this view.
       * Also set the flag so the view will be the same
       * color as the primary window, for appearances only.
       */
    GVI_attrs = @default | GVA_GENERIC_CONTENTS
                         | GVA_SAME_COLOR_AS_PARENT_WIN;
    GVI_vertAttrs = @default | GVDA_SCROLLABLE;
}

  /*
   * This is the content object which contains
   * all of the Gen objects that will be displayed
   * in the GenView.
   */
@object GenContentClass GContContent = {
    GI_comp = @GContValue1,
              @GContText1;
    GCI_genView = @GContView;
}

  /*
   * These are just some example Gen objects
   * that show that this concept really works.
   */
@object GenTextClass GContText1 = {
    GI_visMoniker = "Text 1:";
    GTXI_text = "";
}

@object GenValueClass GContValue1 = {
    GI_visMoniker = "Value 1:";
    GVLI_minimum = MakeWWFixed(-32767);
    GVLI_maximum = MakeWWFixed(32767);
	GVLI_value = MakeWWFixed(0);
}

@end Interface;


byte TranslateCharNum(sdword num)
{
    dword *xlate_table;
    byte i = 0;
    byte ret = 225; // if not found: middle dot.

    if (num < 128)
    {
        if (num==10) ret = 13; // FIXME: this works for LF files, what about CR/LF?
        return (num >= 32 || num == 9 || num == 13) ? (byte) num : ret;
    }

    MemLock(OptrToHandle(@xlateTable));
    xlate_table = LMemDeref(@xlateTable);

    for(i = 0; i < NUM_XLATE_ELEMS; i++)
    {
        if(xlate_table[i] == num)
        {
            ret = (byte) (i + 128);
            break;
        }
    }

    MemUnlock(OptrToHandle(@xlateTable));
    return ret;
}

sdword GetUtf8CharFromFile(FileHandle fhandle)
{
    sdword result = 0;
    byte input[6] = {0};
    sbyte fError = 0;

    fError = FileRead(fhandle, &input[0], 1, FALSE);

    if (fError <= 0)
    {
        // The EOF was hit by the first character.
        return (sdword) EOF;
    }
    else if (
                ((input[0] & 0xC0) == 0x80)
            ||  ((input[0] & 0xfe) == 0xfe)
            )
    {
        // This is not the beginning of a multibyte sequence.
        // This is not a valid UTF-8 stream.
        return (sdword) INVALID;
    }
    else
    {
        if (input[0] < 0x80)
        {   // 1 byte encoding (7 bit ASCII character)
            result = (sdword) input[0];
        }
        else if (input[0] < 0xE0)
        {   // 2 byte encoding
            // first byte of a 2-byte encoding starts with 110 and carries 5 bits of data
            fError = FileRead(fhandle, &input[1], 1, FALSE);
            if (fError <= 0) return (sdword) EOF;

            result =    (sdword)    (input[0] & B2MASK) << 6
                        |           (input[1] & MBMASK);
        }
        else if(input[0] < 0xF0)
        {   // 3 byte encoding
            // first byte of a 3-byte encoding starts with 1110 and carries 4 bits of data
            fError = FileRead(fhandle, &input[1], 2, FALSE);
            if (fError <= 0) return (sdword) EOF;

            result =    (sdword)    (input[0] & B3MASK) << 12
                        |           (input[1] & MBMASK) << 6
                        |           (input[2] & MBMASK);
        }
        else
        {   // 4 byte encoding
            // first byte of a 4-byte encoding starts with 11110 and carries 3 bits of data
            fError = FileRead(fhandle, &input[1], 3, FALSE);
            if (fError <= 0) return (sdword) EOF;

            result =    (sdword)    (input[0] & B4MASK) << 18
                        |           (input[1] & MBMASK) << 12
                        |           (input[2] & MBMASK) << 6
                        |           (input[3] & MBMASK);
        }
    }

    return result;
}

void UTF8FileToGEOS()
{
    sdword      c=0;
    byte        gc=0;
    FileHandle  infile=0;
    FileHandle  outfile=0;
    byte        buf[255]={0};
    byte        charBuf[10]={0};
    byte        i=0;

    FilePushDir();
    FileSetStandardPath(SP_DOCUMENT);

    infile = FileOpen("UTEF.TXT", FILE_ACCESS_R | FILE_DENY_RW);
    //outfile = FileOpen("GEOSF.TXT", FILE_ACCESS_W | FILE_DENY_RW);
    outfile = FileCreate("GEOSF.TXT", (FCF_NATIVE | FILE_ACCESS_W | FILE_DENY_RW | FILE_CREATE_TRUNCATE), 0);


    if ((infile != NullHandle) && (outfile != NullHandle))
    {
        FilePos(infile, 0, FILE_POS_START);
        FilePos(outfile, 0, FILE_POS_START);

        while ((c != INVALID))
        {
            c = GetUtf8CharFromFile(infile);
            if (c == EOF) break;

            if (c != INVALID)
            {
                //sprintf(charBuf, "%ld", c);
                //@call GContText1::MSG_VIS_TEXT_APPEND_PTR(charBuf, 0);
                //@call GContText1::MSG_VIS_TEXT_APPEND_PTR(_TEXT(" - "), 0);

                gc = TranslateCharNum(c);

                //sprintf(charBuf, "%d", gc);
                //@call GContText1::MSG_VIS_TEXT_APPEND_PTR(charBuf, 0);
                //@call GContText1::MSG_VIS_TEXT_APPEND_PTR(_TEXT(" - "), 0);

                buf[0] = gc;
                buf[1] = 0;
                FileWrite(outfile, buf, 2, FALSE);
                //@call GContText1::MSG_VIS_TEXT_APPEND_PTR(buf, 0);
                //@call GContText1::MSG_VIS_TEXT_APPEND_PTR(_TEXT("\r"), 0);

                //buf[i] = gc;
                //i++;
            }
        }
        //buf[i] = 0;
        //@call GContText1::MSG_VIS_TEXT_APPEND_PTR(_TEXT("---\r"), 0);
        //@call GContText1::MSG_VIS_TEXT_APPEND_PTR(buf, 0);
        //@call GContText1::MSG_VIS_TEXT_APPEND_PTR(_TEXT("\r"), 0);
        FileClose(infile, FALSE);
        FileClose(outfile, FALSE);
    }
    FilePopDir();
}

sdword GetUtf8CharFromBuffer(MemHandle bufHan, word bufSize, word *bufIdx)
{
    byte        input[6] = {0};
    word        bufEnd = 0;
    byte        *bufPtr = 0;
    sdword      result = 0;

    bufPtr = MemLock(bufHan);

    input[0] = bufPtr[*bufIdx];

    if (
                ((input[0] & 0xC0) == 0x80)
            ||  ((input[0] & 0xfe) == 0xfe)
        )
    {
        // This is not the beginning of a multibyte sequence.
        // This is not a valid UTF-8 stream.
        result = (sdword) INVALID;
        *bufIdx = *bufIdx + 1;
    }
    else
    {
        if (input[0] < 0x80)
        {   // 1 byte encoding (7 bit ASCII character)
            result = (sdword) input[0];
            *bufIdx = *bufIdx + 1;
        }
        else if (input[0] < 0xE0)
        {   // 2 byte encoding
            // first byte of a 2-byte encoding starts with 110 and carries 5 bits of data
            //memcpy(input[1], bufPtr[*bufIdx], 1);
            input[1] = bufPtr[*bufIdx+1];
            *bufIdx = *bufIdx + 2;

            result =   (sdword)    (input[0] & B2MASK) << 6
                        |          (input[1] & MBMASK);
        }
        else if(input[0] < 0xF0)
        {   // 3 byte encoding
            // first byte of a 3-byte encoding starts with 1110 and carries 4 bits of data
            //memcpy(input[1], bufPtr[*bufIdx], 2);
            input[1] = bufPtr[*bufIdx+1];
            input[2] = bufPtr[*bufIdx+2];
            *bufIdx = *bufIdx + 3;

            result =   (sdword)    (input[0] & B3MASK) << 12
                        |          (input[1] & MBMASK) << 6
                        |          (input[2] & MBMASK);
        }
        else
        {   // 4 byte encoding
            // first byte of a 4-byte encoding starts with 11110 and carries 3 bits of data
            //memcpy(input[1], bufPtr[*bufIdx], 3);
            input[1] = bufPtr[*bufIdx+1];
            input[2] = bufPtr[*bufIdx+2];
            input[3] = bufPtr[*bufIdx+3];

            *bufIdx = *bufIdx + 4;

            result =   (sdword)    (input[0] & B4MASK) << 18
                        |          (input[1] & MBMASK) << 12
                        |          (input[2] & MBMASK) << 6
                        |          (input[3] & MBMASK);
        }
    }

    MemUnlock(bufHan);

    return result;
}

void UTF8FileToGEOSBuffer()
{
    sdword      c=0;
    byte        gc=0;
    FileHandle  infile=0;
    FileHandle  outfile=0;
    byte        buf[255]={0};
    byte        charBuf[10]={0};
    byte        i=0;

    MemHandle   inBufHan = 0;
    MemHandle   outBufHan = 0;
    byte*       bufPtr = 0;
    word        bufSize = 0;
    word        bufIdx = 0;
    dword       curFilePos = 0;

    inBufHan = MemAlloc(UTF8_CACHE, HF_SWAPABLE, HAF_ZERO_INIT);
    //outBufHan = MemAlloc(BUFFER_SIZE, HF_SHARABLE | HF_SWAPABLE, 0);

    FilePushDir();
    FileSetStandardPath(SP_DOCUMENT);

    infile = FileOpen("UTEF.TXT", FILE_ACCESS_R | FILE_DENY_RW);
    //outfile = FileOpen("GEOSF.TXT", FILE_ACCESS_W | FILE_DENY_RW);
    //outfile = FileCreate("GEOSF.TXT", (FCF_NATIVE | FILE_ACCESS_W | FILE_DENY_RW | FILE_CREATE_TRUNCATE), 0);


    if ((infile != NullHandle) /*&& (outfile != NullHandle)*/)
    {
        FilePos(infile, 0, FILE_POS_START);
        //FilePos(outfile, 0, FILE_POS_START);

        do
        {
            //curFilePos = FilePos(infile, 0, FILE_POS_RELATIVE); // get current file pos

            sprintf(charBuf, "%ld", curFilePos);
            @call GContText1::MSG_VIS_TEXT_APPEND_PTR(charBuf, 0);
            @call GContText1::MSG_VIS_TEXT_APPEND_PTR(_TEXT(" = curFilePos"), 0);

            FilePos(infile, curFilePos, FILE_POS_START); // go back if previous buffer didn't end on a lead byte

            bufPtr = MemLock(inBufHan);
            bufSize = FileRead(infile, bufPtr, UTF8_CACHE, FALSE);

            if (bufSize > 0)
            {
                bufIdx = bufSize - 1;

                while (bufIdx > 0)
                {
                    if (
                            ((bufPtr[bufIdx] & 0x80)   == 0x80) ||
                            ((bufPtr[bufIdx] & B2LEAD) == B2LEAD) ||
                            ((bufPtr[bufIdx] & B3LEAD) == B3LEAD) ||
                            ((bufPtr[bufIdx] & B4LEAD) == B4LEAD)
                        )
                    {
                        bufSize = bufIdx - 1; // go one before the leading byte we just found
                        break;
                    }
                    bufIdx--;
                }
                MemUnlock(inBufHan);

                curFilePos = curFilePos + bufSize;
                bufIdx = 0;

                while(bufIdx < bufSize)
                {

                    //sprintf(charBuf, "%ld", bufIdx);
                    //@call GContText1::MSG_VIS_TEXT_APPEND_PTR(charBuf, 0);
                    //@call GContText1::MSG_VIS_TEXT_APPEND_PTR(_TEXT(" - "), 0);

                    c = GetUtf8CharFromBuffer(inBufHan, bufSize, &bufIdx);

                    //sprintf(charBuf, "%ld", c);
                    //@call GContText1::MSG_VIS_TEXT_APPEND_PTR(charBuf, 0);
                    //@call GContText1::MSG_VIS_TEXT_APPEND_PTR(_TEXT(" - "), 0);


                    //sprintf(charBuf, "%ld", bufIdx);
                    //@call GContText1::MSG_VIS_TEXT_APPEND_PTR(charBuf, 0);
                    //@call GContText1::MSG_VIS_TEXT_APPEND_PTR(_TEXT(" - "), 0);

                    if (c != INVALID)
                    {

                        gc = TranslateCharNum(c);

                        //sprintf(charBuf, "%d", gc);
                        //@call GContText1::MSG_VIS_TEXT_APPEND_PTR(charBuf, 0);
                        //@call GContText1::MSG_VIS_TEXT_APPEND_PTR(_TEXT(" - "), 0);

                        buf[0] = gc;
                        buf[1] = 0;
                        //FileWrite(outfile, buf, 2, FALSE);
                        @call GContText1::MSG_VIS_TEXT_APPEND_PTR(buf, 0);
                        @call GContText1::MSG_VIS_TEXT_APPEND_PTR(_TEXT("\r"), 0);

                        //buf[i] = gc;
                        //i++;
                    }
                }
            }
            else
            {
                MemUnlock(inBufHan);
            }
        }
        while (bufSize > 0);

        MemFree(inBufHan);
        //MemFree(outBufHan);

        //buf[i] = 0;
        //@call GContText1::MSG_VIS_TEXT_APPEND_PTR(_TEXT("---\r"), 0);
        //@call GContText1::MSG_VIS_TEXT_APPEND_PTR(buf, 0);
        //@call GContText1::MSG_VIS_TEXT_APPEND_PTR(_TEXT("\r"), 0);
        FileClose(infile, FALSE);
        //FileClose(outfile, FALSE);
    }
    FilePopDir();
}


@method GContProcessClass, MSG_GEN_PROCESS_OPEN_APPLICATION
{
    @callsuper();
    UTF8FileToGEOSBuffer();
}
