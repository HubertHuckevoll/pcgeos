#pragma +sus

/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	Copyright (C) 2000 Dirk Lausecker -- All Rights Reserved

PROJECT:	BestSound
MODULE:		BestSound Quickplayer
FILE:		subcode.goc

AUTHOR:		Dirk Lausecker

ROUTINES:
	Name			Description
	----			-----------

REVISION HISTORY:
	Name	Date		Description
	----	----		-----------
	DL	12.03.2000   	Initial version.
        DL	11.08.2000	Advanced UI and localizing for ND

DESCRIPTION:

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

@include <bsnwav.goh>		/* this include-line must be the first ! */

#include <gstring.h>
#include <Ansi/stdio.h>
#include <Ansi/string.h>

#include <timer.h>
#include <file.h>
#include <sound.h>

@include <stdapp.goh>

@include "UI/uimain.goh"
@include "Main/process.goh"
@include "Main/subcode.goh"
@include "Main/bsqp.goh"

/**********************************************************************/

#define DISP_VIEW_X1		15	/* left border Samplerate */
#define DISP_VIEW_D1		10	/* distance between fields */
#define DISP_VIEW_L1		50
#define DISP_VIEW_X2		DISP_VIEW_X1 + DISP_VIEW_L1 + DISP_VIEW_D1
#define DISP_VIEW_X3		DISP_VIEW_X2 + DISP_VIEW_L1 + DISP_VIEW_D1
#define DISP_VIEW_Y1		5
#define DISP_VIEW_S2		13	/* Height Statusdisplay */
#define DISP_VIEW_Y2		DISP_VIEW_Y1+DISP_VIEW_S2
#define DISP_VIEW_B1		DISP_VIEW_Y1 + 0
#define DISP_VIEW_H2		11	/* Textsize */

// Levelmeter
#define RMS_X_SIZE		20
#define	DISP_VIEW_RMS_X1	(DISP_VIEW_X_SIZE - 35)	/* left border */
#define	DISP_VIEW_RMS_X2	(DISP_VIEW_RMS_X1 + RMS_X_SIZE)	/* right b. */
#define	DISP_VIEW_RMS_Y0	(DISP_VIEW_Y_SIZE - 10)
#define	DISP_VIEW_RMS_DISTANCE	4	/* Y-distance */

// Timedisplay
#define DISP_VIEW_X5		(DISP_VIEW_X_SIZE/2)	/* X-Center Text 	       */
#define DISP_VIEW_X6		40			/* Cleararea left side  */
#define DISP_VIEW_X7		DISP_VIEW_RMS_X1-1	/* Cleararea right side */
#define DISP_VIEW_B2		DISP_VIEW_Y2 + 1	/* Y-Pos. Text         */
#define DISP_VIEW_H1		36			/* Textsize           */
#define DISP_VIEW_Y4		DISP_VIEW_Y_SIZE -10

// Path
#define	DISP_VIEW_H3	10
#define	DISP_VIEW_B3	(DISP_VIEW_Y4 - DISP_VIEW_H3 - 4)

#define DISP_VIEW_X4		(DISP_VIEW_X1+5)  /* Status Pause/Play/Stop */
#define DISP_VIEW_Y3		DISP_VIEW_Y2 + 5
#define DISP_VIEW_S3		18		  /* Size */
#define DISP_VIEW_Y6		DISP_VIEW_B2 +15  /* top */

/************************************************
		Strings
 ************************************************/

char	errorText[] = "???";


/************************************************

 	RedrawStatus

  	Display Playstate

        STOP  --> rectangle
        PLAY  --> triangle
        Pause --> II

 ************************************************/
#define	DISP_VIEW_PAUSE_W1	7

void RedrawStatus (GStateHandle gstate)
{
        Point	playArray[3] = {
				 {DISP_VIEW_X4,DISP_VIEW_Y6},
				 {(DISP_VIEW_X4+DISP_VIEW_S3),DISP_VIEW_Y6+(DISP_VIEW_S3/2)},
				 {DISP_VIEW_X4,DISP_VIEW_Y6+DISP_VIEW_S3}
        		       };

  	int 	notExposed;

  	if (winHan!=0)
	{
    	    notExposed = 0 ;
    	    if (gstate == NullHandle)
	    {
      		gstate = GrCreateState(winHan);
      		notExposed = 1 ;
    	    };

            // Bereich l”schen
    	    if (notExposed)
	    {
      		GrSetAreaColor(gstate,CF_INDEX,backGroundColor,0,0);
      		GrFillRect(gstate,DISP_VIEW_X4,DISP_VIEW_B2+1,DISP_VIEW_X6,DISP_VIEW_B3-1);
    	    };

    	    // --- Display Status ---
      	    GrSetAreaColor(gstate,CF_INDEX,C_WHITE,0,0);

            if (!playFlag)
            {
            	// STOP
      		GrFillRect(gstate,DISP_VIEW_X4,DISP_VIEW_Y6,DISP_VIEW_X4+DISP_VIEW_S3,DISP_VIEW_Y6+DISP_VIEW_S3);
            }
            else
            {
            	if (playFlag == BQ_PLAYFLAG_PAUSE)
                {
                    // PAUSE
      	    	    GrSetAreaColor(gstate,CF_INDEX,C_RED,0,0);

      		    GrFillRect(gstate,DISP_VIEW_X4,DISP_VIEW_Y6,DISP_VIEW_X4+DISP_VIEW_PAUSE_W1,DISP_VIEW_Y6+DISP_VIEW_S3);
      		    GrFillRect(gstate,DISP_VIEW_X6-DISP_VIEW_PAUSE_W1,DISP_VIEW_Y6,DISP_VIEW_X6,DISP_VIEW_Y6+DISP_VIEW_S3);
                }
                else
                {
                    // PLAY
                    GrFillPolygon (gstate,ODD_EVEN,&playArray,3);
                };
            };
        };
}

/************************************************

 	RedrawTime

  	Display Playtime

 IN:	bqDispStyle

 ************************************************/

void RedrawTime (GStateHandle gstate)
{
  	int 	notExposed,x;
	int	h = 0;
	int	m = 0;
	int	s,l ;
        static	int	oldsec;
        char	tmpText[30];

        dword	len;

  	if (winHan!=0)
	{
    	    notExposed = 0 ;
    	    if (gstate == NullHandle)
	    {
      		gstate = GrCreateState(winHan);
      		notExposed = 1 ;
            }
            else
            {
                // normal draw
            	oldsec = 61;
    	    };

            // length of WAV in seconds
            if (bqBits)
            {

                // remaining if option or system idle
                if ((bqDispStyle == BQ_TIME_DISP_REMAIN)||(playFlag == FALSE ))
                {
            	    len = (bqAllBytes-bqSampleBytes)/((dword)(bqBits/8) * bqChannels * bqSampleRate );
                }
                else
                {
            	    len = bqSampleBytes/((dword)(bqBits/8) * bqChannels * bqSampleRate );
                };

                // calculate h:m:s
                l = (word)len;
                h = l/ 3660;
	        l = l - (h*3660);
                m = l / 60;
                s = l - (m*60);
            }
            else
            {
            	s = 0;
            };

            // redraw only if sec has changed,
            // or no PLAY active
            if ((s != oldsec)||(!playFlag))
            {
                // erase old text
    	        if (notExposed)
	        {
      		    GrSetAreaColor(gstate,CF_INDEX,backGroundColor,0,0);
      		    GrFillRect(gstate,DISP_VIEW_X6,DISP_VIEW_B2+1,DISP_VIEW_X7+DISP_VIEW_L1,DISP_VIEW_B3);
    	        };

                // create textstring
                sprintf(tmpText,"%u:%02u:%02u",h,m,s);

                if (bqDispStyle == BQ_TIME_DISP_NORMAL)
                {
                    globalText[0] = 0;
                }
                else
                {
                    globalText[0] = '-';
                    globalText[1] = 0;
                };

                strcat(globalText,tmpText);

                // draw text
      	        GrSetFont(gstate,FID_DTC_URW_SANS,MakeWWFixed(DISP_VIEW_H1));
    	        GrSetTextColor(gstate,CF_INDEX,C_WHITE,0,0);
                x = GrTextWidth(gstate,globalText,0);
                x = x/2;
                x = DISP_VIEW_X5 - x;
	        GrDrawText(gstate, x, DISP_VIEW_B2, globalText, 0);

                // store actual sec for next turn
                oldsec = s;
            };


   	    if (notExposed)
            {
      	    	GrDestroyState(gstate);
            };
         };
}


/************************************************

 	RedrawSettings

  	Display Format (rate,bits,channels)

 ************************************************/

Boolean	_pascal RedrawSettings (GStateHandle gstate)
{
  	int 	notExposed,i,x;
        Boolean	waveOK = FALSE;

  	if (winHan!=0)
	{
    	    notExposed = 0 ;
    	    if (gstate == NullHandle)
	    {
      		gstate = GrCreateState(winHan);
      		notExposed = 1 ;
    	    };

            // erase area
    	    if (notExposed)
	    {
      		GrSetAreaColor(gstate,CF_INDEX,backGroundColor,0,0);
      		GrFillRect(gstate,DISP_VIEW_X1,0,DISP_VIEW_X3+DISP_VIEW_L1,DISP_VIEW_Y2);
    	    };

    	    // --- display format ---
    	    GrSetLineColor(gstate,CF_INDEX,C_WHITE,0,0);

            //frame 1-3
            for (i=0;i<3;i++)
            {
            	// draw frame
                x = DISP_VIEW_X1+(i*(DISP_VIEW_L1+DISP_VIEW_D1));
                GrDrawRect(gstate,x,DISP_VIEW_Y1,x+DISP_VIEW_L1,DISP_VIEW_Y2);
            };

            waveOK = (bqSampleRate && bqBits && bqChannels);

            // bad WAV  :-(
            if (!waveOK)
            {
            	strcpy(globalText,errorText);
            };

            // Textformat
      	    GrSetFont(gstate,FID_DTC_URW_SANS,MakeWWFixed(DISP_VIEW_H2));
    	    GrSetTextColor(gstate,CF_INDEX,C_WHITE,0,0);

            // Samplerate
            if (waveOK)
            {
            	sprintf(globalText,"%u",bqSampleRate);
            }
	    BQ_DrawCenterText(gstate,globalText,DISP_VIEW_X1,DISP_VIEW_B1,DISP_VIEW_L1);

            // Bits
            if (waveOK)
            {
            	sprintf(globalText,"%u Bit",(int)bqBits);
            }
	    BQ_DrawCenterText(gstate,globalText,DISP_VIEW_X2,DISP_VIEW_B1,DISP_VIEW_L1);

            // channels
	    switch (bqChannels)
            {
            	case 1  : strcpy(globalText," MONO"); break;
            	case 2  : strcpy(globalText,"STEREO"); break;
            	default : break;
            };
	    BQ_DrawCenterText(gstate,globalText,DISP_VIEW_X3,DISP_VIEW_B1,DISP_VIEW_L1);


   	    if (notExposed)
      	    GrDestroyState(gstate);
        };

	return(waveOK);
}

/************************************************

 	RedrawRMS

  	Levelmeter

 ************************************************/

void RedrawRMS (GStateHandle gstate)
{
  	int 	notExposed,i;
	int	y ;

  	if (winHan!=0)
	{
    	    notExposed = 0 ;
    	    if (gstate == NullHandle)
	    {
      		gstate = GrCreateState(winHan);
      		notExposed = 1 ;
    	    };

            // display level bars
    	    GrSetLineColor(gstate,CF_INDEX,C_WHITE,0,0);
    	    y=DISP_VIEW_RMS_Y0;
            i = 0;

            // 32 bars
	    while (i<rmsValue)
            {
                if (i>200)
                {
                    // red
		    GrSetLineColor(gstate,CF_INDEX,C_RED,0,0);
                }
                else
                {
                    if (i>120)
                    {
                    	// yellow
		    	GrSetLineColor(gstate,CF_INDEX,C_YELLOW,0,0);

                    };
                };

                // draw bars
      		GrDrawLine(gstate,DISP_VIEW_RMS_X1,y-1,DISP_VIEW_RMS_X2,y-1);
      		GrDrawLine(gstate,DISP_VIEW_RMS_X1,y  ,DISP_VIEW_RMS_X2,y  );

                // calculate next koords.
      		y=y-DISP_VIEW_RMS_DISTANCE;
		i = i + 16;
            };

            // delete trash
  	    GrSetAreaColor(gstate,CF_INDEX,backGroundColor,0,0);
      	    GrFillRect(gstate,DISP_VIEW_RMS_X1,0,DISP_VIEW_RMS_X2,y+1);

    	    if (notExposed)
            {
      	    	GrDestroyState(gstate);
            };
  	};
}

/************************************************

 	RedrawFileName

  	Draw filename into display

 IN:	(glob)	fullPath

 ************************************************/

void RedrawFileName (GStateHandle gstate)
{
  	int 	notExposed;

  	if (winHan!=0)
	{
    	    notExposed = 0 ;
    	    if (gstate == NullHandle)
	    {
      		gstate = GrCreateState(winHan);
      		notExposed = 1 ;
    	    };

            // erase area
    	    if (notExposed)
	    {
      		GrSetAreaColor(gstate,CF_INDEX,backGroundColor,0,0);
      		GrFillRect(gstate,0,DISP_VIEW_B3,DISP_VIEW_RMS_X1-5,DISP_VIEW_B3+DISP_VIEW_H3+3);
    	    };

      	    GrSetFont(gstate,FID_DTC_URW_SANS,MakeWWFixed(DISP_VIEW_H3));
    	    GrSetTextColor(gstate,CF_INDEX,C_WHITE,0,0);

            // Draw path to file
	    BQ_DrawCenterText(gstate,fullPath,0,DISP_VIEW_B3,DISP_VIEW_RMS_X1-5);

   	    if (notExposed)
            {
      	    	GrDestroyState(gstate);
            };
         };
}


/**********************************************************

	BQ_StartPlay

        Start playing WAV-File

 IN:	(glob)	fullPath	Path to file

 - Check playstate (idle ?)
 - open file
 - Create Play-Thread

 **********************************************************/
#define	BQ_TIMEOUT_1	20
// Timeout = 20/10 sec

void	_pascal	BQ_StartPlay(void)
{
	FileHandle	fh;
	word		timeout;

        // set next level of quickmode
        if (quickMode == BQ_QUICK_START)
        {
	    quickMode = BQ_QUICK_END;
        };

        // if "old" WAV-File is already playing
        // stop it and wait for free (with timeout)
        if (playFlag)
        {
            BSNWaveStop();
            timeout = 0;
            while (playFlag && (timeout<BQ_TIMEOUT_1))
            {
                TimerSleep(6);
                timeout++;
            };

            // Timeout
            if (timeout>BQ_TIMEOUT_1)
            {
            	// if needed, here Timeout-Msg !!!
            };
	};

	// prepare for playing new file
        if (playFlag)
        {
            // "Old" WAV-File is already playing
            //
	}
	else
	{
            // Open WAV-File and testing
    	    fh = FileOpen(fullPath, FILE_ACCESS_R | FILE_DENY_W);

            if (fh)
            {
	        if (BSNW_STATUS_OK != BSNWavePlayFile(fh,BSNW_SHOW_ERROR_MSG|BSNW_TEST_ONLY,0))
                {
                    // Error, WAV-file not playable
		    FileClose(fh,TRUE);
                    fh = 0;
                };

                if (fh)
                {
            	    /////// successfull opening /////////

                    // update triggers & display
		    (void)BSNWaveGetLastFormat(&bqSampleRate,&bqChannels,&bqBits);
                    RedrawSettings(0);

                    @send PLAYTrigger::MSG_GEN_REPLACE_VIS_MONIKER_TEXT(pauseText,VUM_NOW);
                    @send PLAYTrigger::MSG_GEN_SET_ENABLED(VUM_NOW);
		    RedrawFileName(0);

                    // Set Flag
                    playFlag = BQ_PLAYFLAG_PLAY;

                    // create Playthread
                    if(!ThreadCreate(PRIORITY_HIGH,		//PRIORITY_TIME_CRITICAL,
    		                     (word)fh,
		                     BQ_PlayThread,
		                     3000,
		                     GeodeGetProcessHandle()))
                    {
    	                // Error
                        SysNotify(SNF_CONTINUE,"Playthread","could not be created !");
		        (void) FileClose(fh, TRUE);
                        playFlag = 0;
                    }
                    else
                    {
    	                // no error
                        // Look at BQ_PlayThread() for the next steps !
                    };
	        };
            };
        };
}

/************************************************

 	BQ_PlayThread

 IN:	wavFile		FileHandle of WAV-file
 	(glob)		capabFlag
 OUT:	playFlag -> 	NULL if finished

 ************************************************/

word	BQ_PlayThread(word wavFile)
{
        FileHandle	fh;
        int		playState = 1;

        // casting FileHandle
        fh = (FileHandle)wavFile;

        // Show Playstate
        RedrawStatus(0);
        @send PLAYTrigger::MSG_GEN_REPLACE_VIS_MONIKER_TEXT(pauseText,VUM_NOW);

        // Play WAV-File
        // play endless if allowed
	do
        {
            if (capabFlag)
            {
	        playState = BSNWavePlayFile(fh,BSNW_SHOW_ERROR_MSG,0);
            }
            else
            {
                // Play with old WAV-Lib
                // REMOVE this line if BSNWAVE is the new
	        // standard for playing WAV's !!!
    //	    PlaySoundFromFile(fh);
            };

        } while (capabFlag
	     &&	(bqOptions & BQ_OPTION_ENDLESS)
	     && (playState == 0));

        // Close File
	(void) FileClose(fh, TRUE);

        // update PLAYTrigger
        @send PLAYTrigger::MSG_GEN_REPLACE_VIS_MONIKER_TEXT(playText,VUM_NOW);

        // Clear Flag
        playFlag = 0;

        // Show Playstate
	rmsValue = 0;
        RedrawStatus(0);
	RedrawRMS(0);

        // Set Minimized state of primary
        if (bqMinimizedState)
        {
	    @send BSQPPrimary::MSG_GEN_DISPLAY_SET_MINIMIZED();
        };

        // QuickMode --> shutdown application
        if (quickMode == BQ_QUICK_END)
        {
	    @send BSQPApp::MSG_META_QUIT();
        };

        //Thread End
	ThreadDestroy(0, 0, 0);
        return (0);
}

/**************************************************************

		BQ_DrawCenterText

  	Subroutine write text with a max width

  IN:	GStatehandle	gstate
  	char		*text
        word		x
        word		y
        word		max


 **************************************************************/
#define	BQ_DCT_BUF_LEN	250

void	_pascal BQ_DrawCenterText(GStateHandle	gstate,
				  char		*text,
        			  word		x,
        			  word		y,
        			  word		max)

{
	char	buf[BQ_DCT_BUF_LEN];
        word	w;
        int	i;

        // copy text, get width
	strcpy (buf,text);
        w = GrTextWidth(gstate,buf,0);

        //Text wider than max ?
        if (w>max)
        {
            // reducing text and appending ".."
            i = BQ_DCT_BUF_LEN-1;
            while (w > (max-7))	// ".."
            {
            	buf[i] = 0;
        	w = GrTextWidth(gstate,buf,0);
                i--;
            };

            // append".."
            buf[i] = '.';
            i++;
            buf[i] = '.';
            i++;
            buf[i] = '.';
        };

        // Center Text
        w = GrTextWidth(gstate,buf,0);
        w = max - w;
        w = w/2;

        // draw text
	GrDrawText(gstate, x+w, y, buf, 0);
}

/**************************************************************

		BQ_CheckForPlay

  	checking WAV-File for Play

  IN:	(glob)fullPath	Path to file

  OUT:	Boolean		TRUE = File OK

 **************************************************************/

Boolean	_pascal BQ_CheckForPlay(void)
{
	FileHandle	fh;
        Boolean		retVal = FALSE;

        // Open WAV-File and testing
    	fh = FileOpen(fullPath, FILE_ACCESS_R | FILE_DENY_W);

        if (fh)
        {
	    if (BSNW_STATUS_OK != BSNWavePlayFile(fh,BSNW_TEST_ONLY,0))
            {
                // Error, WAV-file not playable
		FileClose(fh,TRUE);
                fh = 0;
                bqSampleRate = 0;
                bqChannels = 0;
                bqBits = 0;
            };

            if (fh)
            {
                // update triggers & display
		bqAllBytes = BSNWaveGetLastFormat(&bqSampleRate,&bqChannels,&bqBits);
		FileClose(fh,TRUE);
            };

	    if (RedrawSettings(0))
            {
            	// WAV-File OK
	    	retVal = TRUE;

	    };

            // Display Length (h:m:s)
	    RedrawTime(0);
        }
        else
        {
            // invalid file
            bqAllBytes = 0;
        };

        return(retVal);
}
