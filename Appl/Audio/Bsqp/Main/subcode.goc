#pragma +sus

/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    Copyright (C) 2000 Dirk Lausecker -- All Rights Reserved

PROJECT:    BestSound
MODULE:     BestSound Quickplayer
FILE:       subcode.goc

AUTHOR:     Dirk Lausecker

ROUTINES:
    Name            Description
    ----            -----------

REVISION HISTORY:
    Name    Date        Description
    ----    ----        -----------
    DL  12.03.2000  Initial version.
    DL  11.08.2000  Advanced UI and localizing for ND

DESCRIPTION:

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

@include <bsnwav.goh>       /* this include-line must be the first ! */
@include <qoa.goh>

#include <gstring.h>
#include <Ansi/stdio.h>
#include <Ansi/string.h>
#include <Ansi/ctype.h>

#include <timer.h>
#include <file.h>
#include <sound.h>
#include <system.h>

@include <stdapp.goh>

@include "UI/uimain.goh"
@include "Main/process.goh"
@include "Main/subcode.goh"
@include "Main/bsqp.goh"

#include <ec.h>
#include <geode.h>


/**********************************************************************/

#define DISP_VIEW_X1        15  /* left border Samplerate */
#define DISP_VIEW_D1        10  /* distance between fields */
#define DISP_VIEW_L1        50
#define DISP_VIEW_X2        DISP_VIEW_X1 + DISP_VIEW_L1 + DISP_VIEW_D1
#define DISP_VIEW_X3        DISP_VIEW_X2 + DISP_VIEW_L1 + DISP_VIEW_D1
#define DISP_VIEW_Y1        5
#define DISP_VIEW_S2        13  /* Height Statusdisplay */
#define DISP_VIEW_Y2        DISP_VIEW_Y1+DISP_VIEW_S2
#define DISP_VIEW_B1        DISP_VIEW_Y1 + 0
#define DISP_VIEW_H2        11  /* Textsize */

// Levelmeter
#define RMS_X_SIZE          20
#define DISP_VIEW_RMS_X1    (DISP_VIEW_X_SIZE - 35) /* left border */
#define DISP_VIEW_RMS_X2    (DISP_VIEW_RMS_X1 + RMS_X_SIZE) /* right b. */
#define DISP_VIEW_RMS_Y0    (DISP_VIEW_Y_SIZE - 10)
#define DISP_VIEW_RMS_DISTANCE  4   /* Y-distance */

// Timedisplay
#define DISP_VIEW_X5        (DISP_VIEW_X_SIZE/2)    /* X-Center Text           */
#define DISP_VIEW_X6        40          /* Cleararea left side  */
#define DISP_VIEW_X7        DISP_VIEW_RMS_X1-1  /* Cleararea right side */
#define DISP_VIEW_B2        DISP_VIEW_Y2 + 1    /* Y-Pos. Text         */
#define DISP_VIEW_H1        36          /* Textsize           */
#define DISP_VIEW_Y4        DISP_VIEW_Y_SIZE -10

// Path
#define DISP_VIEW_H3        10
#define DISP_VIEW_B3        (DISP_VIEW_Y4 - DISP_VIEW_H3 - 4)

#define DISP_VIEW_X4        (DISP_VIEW_X1+5)  /* Status Pause/Play/Stop */
#define DISP_VIEW_Y3        DISP_VIEW_Y2 + 5
#define DISP_VIEW_S3        18        /* Size */
#define DISP_VIEW_Y6        DISP_VIEW_B2 +15  /* top */

static Boolean BQ_PathHasExtension(const char *path, const char *ext)
{
    const char *dot;
    if (!path || !ext)
    {
        return FALSE;
    }

    dot = strrchr(path, '.');
    if (!dot || (dot[1] == 0))
    {
        return FALSE;
    }

    dot++;
    while (*dot && *ext)
    {
        int chPath = toupper((int)(unsigned char)*dot);
        int chExt  = toupper((int)(unsigned char)*ext);
        if (chPath != chExt)
        {
            return FALSE;
        }
        dot++;
        ext++;
    }

    return (*dot == 0) && (*ext == 0);
}

static Boolean BQ_IsQOAPath(const char *path)
{
    return BQ_PathHasExtension(path, "QOA");
}

static Boolean BQ_LoadQOAInfo(FileHandle fh, QOAInfo *info)
{
    byte header[8];
    byte frameHdr[8];
    dword magic;
    dword totalFrames;
    word  channels;
    dword sampleRate;
    word  frameSamples;

    if (!info)
    {
        return FALSE;
    }

    FilePos(fh, 0, FILE_POS_START);

    if (FileRead(fh, header, sizeof(header), TRUE) != sizeof(header))
    {
        FilePos(fh, 0, FILE_POS_START);
        return FALSE;
    }

    magic = ((dword)header[0] << 24) |
            ((dword)header[1] << 16) |
            ((dword)header[2] << 8)  |
             (dword)header[3];

    if (magic != 0x716f6166UL) /* 'qoaf' */
    {
        FilePos(fh, 0, FILE_POS_START);
        return FALSE;
    }

    totalFrames = ((dword)header[4] << 24) |
                  ((dword)header[5] << 16) |
                  ((dword)header[6] << 8)  |
                   (dword)header[7];

    if (FileRead(fh, frameHdr, sizeof(frameHdr), TRUE) != sizeof(frameHdr))
    {
        FilePos(fh, 0, FILE_POS_START);
        return FALSE;
    }

    channels = (word)frameHdr[0];
    sampleRate = ((dword)frameHdr[1] << 16) |
                 ((dword)frameHdr[2] << 8)  |
                  (dword)frameHdr[3];
    frameSamples = (word)(((word)frameHdr[4] << 8) | (word)frameHdr[5]);

    if (channels == 0 || sampleRate == 0 || frameSamples == 0)
    {
        FilePos(fh, 0, FILE_POS_START);
        return FALSE;
    }

    info->channels      = channels;
    info->sampleRate    = sampleRate;
    info->totalFrames   = totalFrames;
    info->bitsPerSample = 16;

    FilePos(fh, 0, FILE_POS_START);
    return TRUE;
}

static void BQ_ApplyQOAInfo(const QOAInfo *info)
{
    dword totalFrames;
    dword channels;

    if (!info)
    {
        return;
    }

    bqSampleRate = info->sampleRate;
    bqChannels   = info->channels;
    bqBits       = 16;

    totalFrames = info->totalFrames;
    channels    = info->channels;
    bqAllBytes  = totalFrames * channels * 2UL;
}

/************************************************
        Strings
 ************************************************/

char    errorText[] = "???";


/************************************************

    RedrawStatus

    Display Playstate

        STOP  --> rectangle
        PLAY  --> triangle
        Pause --> II

 ************************************************/
#define DISP_VIEW_PAUSE_W1  7

void RedrawStatus (GStateHandle gstate)
{
    Point   playArray[3] = {
        {DISP_VIEW_X4,DISP_VIEW_Y6},
        {(DISP_VIEW_X4+DISP_VIEW_S3),DISP_VIEW_Y6+(DISP_VIEW_S3/2)},
        {DISP_VIEW_X4,DISP_VIEW_Y6+DISP_VIEW_S3}
    };

    int     notExposed;

    if (winHan!=0)
    {
        notExposed = 0 ;
        if (gstate == NullHandle)
        {
            gstate = GrCreateState(winHan);
            notExposed = 1 ;
        };

        // clear area
        if (notExposed)
        {
            GrSetAreaColor(gstate,CF_INDEX,backGroundColor,0,0);
            GrFillRect(gstate,DISP_VIEW_X4,DISP_VIEW_B2+1,DISP_VIEW_X6,DISP_VIEW_B3-1);
        };

        // --- Display Status ---
        GrSetAreaColor(gstate,CF_INDEX,C_WHITE,0,0);

        if (!playFlag)
        {
            // STOP
            GrFillRect(gstate,DISP_VIEW_X4,DISP_VIEW_Y6,DISP_VIEW_X4+DISP_VIEW_S3,DISP_VIEW_Y6+DISP_VIEW_S3);
        }
        else
        {
            if (playFlag == BQ_PLAYFLAG_PAUSE)
            {
                // PAUSE
                GrSetAreaColor(gstate,CF_INDEX,C_RED,0,0);

                GrFillRect(gstate,DISP_VIEW_X4,DISP_VIEW_Y6,DISP_VIEW_X4+DISP_VIEW_PAUSE_W1,DISP_VIEW_Y6+DISP_VIEW_S3);
                GrFillRect(gstate,DISP_VIEW_X6-DISP_VIEW_PAUSE_W1,DISP_VIEW_Y6,DISP_VIEW_X6,DISP_VIEW_Y6+DISP_VIEW_S3);
            }
            else
            {
                // PLAY
                GrFillPolygon (gstate,ODD_EVEN,&playArray,3);
            };
        };
    };
}

/************************************************

    RedrawTime

    Display Playtime

 IN:    bqDispStyle

 ************************************************/

void RedrawTime (GStateHandle gstate)
{
    int     notExposed,x;
    int h = 0;
    int m = 0;
    int s,l ;
    static  int oldsec;
    char    tmpText[30];

    dword   len;

    if (winHan!=0)
    {
        notExposed = 0 ;
        if (gstate == NullHandle)
        {
            gstate = GrCreateState(winHan);
            notExposed = 1 ;
        }
        else
        {
            // normal draw
            oldsec = 61;
        };

        // length of current file in seconds
        if (bqBits)
        {

            // remaining if option or system idle
            if ((bqDispStyle == BQ_TIME_DISP_REMAIN)||(playFlag == FALSE ))
            {
                len = (bqAllBytes-bqSampleBytes)/((dword)(bqBits/8) * bqChannels * bqSampleRate );
            }
            else
            {
                len = bqSampleBytes/((dword)(bqBits/8) * bqChannels * bqSampleRate );
            };

            // calculate h:m:s
            l = (word)len;
            h = l/ 3660;
            l = l - (h*3660);
            m = l / 60;
            s = l - (m*60);
        }
        else
        {
            s = 0;
        };

        // redraw only if sec has changed,
        // or no PLAY active
        if ((s != oldsec)||(!playFlag))
        {
            // erase old text
            if (notExposed)
            {
                GrSetAreaColor(gstate,CF_INDEX,backGroundColor,0,0);
                GrFillRect(gstate,DISP_VIEW_X6,DISP_VIEW_B2+1,DISP_VIEW_X7+DISP_VIEW_L1,DISP_VIEW_B3);
            };

            // create textstring
            sprintf(tmpText,"%u:%02u:%02u",h,m,s);

            if (bqDispStyle == BQ_TIME_DISP_NORMAL)
            {
                globalText[0] = 0;
            }
            else
            {
                globalText[0] = '-';
                globalText[1] = 0;
            };

            strcat(globalText,tmpText);

            // draw text
            GrSetFont(gstate,FID_DTC_URW_SANS,MakeWWFixed(DISP_VIEW_H1));
            GrSetTextColor(gstate,CF_INDEX,C_WHITE,0,0);
            x = GrTextWidth(gstate,globalText,0);
            x = x/2;
            x = DISP_VIEW_X5 - x;
            GrDrawText(gstate, x, DISP_VIEW_B2, globalText, 0);

            // store actual sec for next turn
            oldsec = s;
        };


        if (notExposed)
        {
            GrDestroyState(gstate);
        };
    };
}


/************************************************

    RedrawSettings

    Display Format (rate,bits,channels)

 ************************************************/

Boolean _pascal RedrawSettings (GStateHandle gstate)
{
    int     notExposed,i,x;
    Boolean waveOK = FALSE;

    if (winHan!=0)
    {
        notExposed = 0 ;
        if (gstate == NullHandle)
        {
            gstate = GrCreateState(winHan);
            notExposed = 1 ;
        };

        // erase area
        if (notExposed)
        {
            GrSetAreaColor(gstate,CF_INDEX,backGroundColor,0,0);
            GrFillRect(gstate,DISP_VIEW_X1,0,DISP_VIEW_X3+DISP_VIEW_L1,DISP_VIEW_Y2);
        };

        // --- display format ---
        GrSetLineColor(gstate,CF_INDEX,C_WHITE,0,0);

        //frame 1-3
        for (i=0; i<3; i++)
        {
            // draw frame
            x = DISP_VIEW_X1+(i*(DISP_VIEW_L1+DISP_VIEW_D1));
            GrDrawRect(gstate,x,DISP_VIEW_Y1,x+DISP_VIEW_L1,DISP_VIEW_Y2);
        };

        waveOK = (bqSampleRate && bqBits && bqChannels);

        // unsupported audio format
        if (!waveOK)
        {
            strcpy(globalText,errorText);
        };

        // Textformat
        GrSetFont(gstate,FID_DTC_URW_SANS,MakeWWFixed(DISP_VIEW_H2));
        GrSetTextColor(gstate,CF_INDEX,C_WHITE,0,0);

        // Samplerate
        if (waveOK)
        {
            sprintf(globalText,"%u",bqSampleRate);
        }
        BQ_DrawCenterText(gstate,globalText,DISP_VIEW_X1,DISP_VIEW_B1,DISP_VIEW_L1);

        // Bits
        if (waveOK)
        {
            sprintf(globalText,"%u Bit",(int)bqBits);
        }
        BQ_DrawCenterText(gstate,globalText,DISP_VIEW_X2,DISP_VIEW_B1,DISP_VIEW_L1);

        // channels
        switch (bqChannels)
        {
            case 1  : strcpy(globalText," MONO"); break;
            case 2  : strcpy(globalText,"STEREO"); break;
            default : break;
        };
        BQ_DrawCenterText(gstate,globalText,DISP_VIEW_X3,DISP_VIEW_B1,DISP_VIEW_L1);


        if (notExposed)
            GrDestroyState(gstate);
    };

    return(waveOK);
}

/************************************************

    RedrawRMS

    Levelmeter

 ************************************************/

void RedrawRMS (GStateHandle gstate)
{
    int     notExposed,i;
    int y ;

    if (winHan!=0)
    {
        notExposed = 0 ;
        if (gstate == NullHandle)
        {
            gstate = GrCreateState(winHan);
            notExposed = 1 ;
        };

        // display level bars
        GrSetLineColor(gstate,CF_INDEX,C_WHITE,0,0);
        y=DISP_VIEW_RMS_Y0;
        i = 0;

        // 32 bars
        while (i<rmsValue)
        {
            if (i>200)
            {
                // red
                GrSetLineColor(gstate,CF_INDEX,C_RED,0,0);
            }
            else
            {
                if (i>120)
                {
                    // yellow
                    GrSetLineColor(gstate,CF_INDEX,C_YELLOW,0,0);

                };
            };

            // draw bars
            GrDrawLine(gstate,DISP_VIEW_RMS_X1,y-1,DISP_VIEW_RMS_X2,y-1);
            GrDrawLine(gstate,DISP_VIEW_RMS_X1,y,DISP_VIEW_RMS_X2,y  );

            // calculate next koords.
            y=y-DISP_VIEW_RMS_DISTANCE;
            i = i + 16;
        };

        // delete trash
        GrSetAreaColor(gstate,CF_INDEX,backGroundColor,0,0);
        GrFillRect(gstate,DISP_VIEW_RMS_X1,0,DISP_VIEW_RMS_X2,y+1);

        if (notExposed)
        {
            GrDestroyState(gstate);
        };
    };
}

/************************************************

    RedrawFileName

    Draw filename into display

 IN:    (glob)  fullPath

 ************************************************/

void RedrawFileName (GStateHandle gstate)
{
    int     notExposed;

    if (winHan!=0)
    {
        notExposed = 0 ;
        if (gstate == NullHandle)
        {
            gstate = GrCreateState(winHan);
            notExposed = 1 ;
        };

        // erase area
        if (notExposed)
        {
            GrSetAreaColor(gstate,CF_INDEX,backGroundColor,0,0);
            GrFillRect(gstate,0,DISP_VIEW_B3,DISP_VIEW_RMS_X1-5,DISP_VIEW_B3+DISP_VIEW_H3+3);
        };

        GrSetFont(gstate,FID_DTC_URW_SANS,MakeWWFixed(DISP_VIEW_H3));
        GrSetTextColor(gstate,CF_INDEX,C_WHITE,0,0);

        // Draw path to file
        BQ_DrawCenterText(gstate,fullPath,0,DISP_VIEW_B3,DISP_VIEW_RMS_X1-5);

        if (notExposed)
        {
            GrDestroyState(gstate);
        };
    };
}


/**********************************************************

        BQ_StartPlay

        Start playing selected audio file

 IN:    (glob)  fullPath    Path to file

 - Check playstate (idle ?)
 - open file
 - Create Play-Thread

 **********************************************************/
#define BQ_TIMEOUT_1    20
// Timeout = 20/10 sec

void    _pascal BQ_StartPlay(void)
{
    FileHandle  fh;
    word        timeout;

    // set next level of quickmode
    if (quickMode == BQ_QUICK_START)
    {
        quickMode = BQ_QUICK_END;
    };

    // if an "old" file is already playing
    // stop it and wait for free (with timeout)
    if (playFlag)
    {
        BSNWaveStop();
        timeout = 0;
        while (playFlag && (timeout<BQ_TIMEOUT_1))
        {
            TimerSleep(6);
            timeout++;
        };

        // Timeout
        if (timeout>BQ_TIMEOUT_1)
        {
            // if needed, here Timeout-Msg !!!
        };
    };

    // prepare for playing new file
    if (playFlag)
    {
        // "Old" file is already playing
        //
    }
    else
    {
        // Open file and testing
        fh = FileOpen(fullPath, FILE_ACCESS_R | FILE_DENY_W);

        if (fh)
        {
            Boolean playable = TRUE;

            if (bqFileType == BQ_FILE_TYPE_QOA)
            {
                if (!BQ_LoadQOAInfo(fh, &bqQoaInfo))
                {
                    playable = FALSE;
                }
                else
                {
                    BQ_ApplyQOAInfo(&bqQoaInfo);
                }
            }
            else
            {
                if (BSNW_STATUS_OK != BSNWavePlayFile(fh, BSNW_SHOW_ERROR_MSG | BSNW_TEST_ONLY, 0))
                {
                    playable = FALSE;
                }
                else
                {
                    (void)BSNWaveGetLastFormat(&bqSampleRate, &bqChannels, &bqBits);
                }
            }

            if (!playable)
            {
                FileClose(fh, TRUE);
                fh = 0;
            }

            if (fh)
            {
                /////// successfull opening /////////

                // update triggers & display
                RedrawSettings(0);
                RedrawTime(0);

                @send PLAYTrigger::MSG_GEN_REPLACE_VIS_MONIKER_TEXT(pauseText,VUM_NOW);
                @send PLAYTrigger::MSG_GEN_SET_ENABLED(VUM_NOW);
                RedrawFileName(0);

                // Set Flag
                playFlag = BQ_PLAYFLAG_PLAY;
                bqSampleBytes = 0;

                // create Playthread
                if(!ThreadCreate(PRIORITY_HIGH,     //PRIORITY_TIME_CRITICAL,
                                 (word)fh,
                                 BQ_PlayThread,
                                 3000,
                                 GeodeGetProcessHandle()))
                {
                    // Error
                    SysNotify(SNF_CONTINUE,"Playthread","could not be created !");
                    (void) FileClose(fh, TRUE);
                    playFlag = 0;
                }
                else
                {
                    // no error
                    // Look at BQ_PlayThread() for the next steps !
                };
            };
        };
    };
}

/************************************************

    BQ_PlayThread

 IN:    fileWord    FileHandle of audio file
        (glob)      capabFlag
OUT:   playFlag ->     NULL if finished

************************************************/

word    BQ_PlayThread(word fileWord)
{
    FileHandle  fh;
    int     playState = 1;

    // casting FileHandle
    fh = (FileHandle)fileWord;

    // Show Playstate
    RedrawStatus(0);
    @send PLAYTrigger::MSG_GEN_REPLACE_VIS_MONIKER_TEXT(pauseText,VUM_NOW);

    // Play file
    // play endless if allowed
    do
    {
        if (capabFlag)
        {
            FilePos(fh, 0, FILE_POS_START);

            if (bqFileType == BQ_FILE_TYPE_QOA)
            {
                playState = QOAPlayFile(fh, BSNW_SHOW_ERROR_MSG, 0);
                {
                    char dbg[40];
                    sprintf(dbg, "QOAPlayFile ret=%d", playState);
                    SysNotify(SNF_CONTINUE, dbg, 0);
                }
            }
            else
            {
                playState = BSNWavePlayFile(fh, BSNW_SHOW_ERROR_MSG, 0);
            }
        }
        else
        {
            // Play with old WAV-Lib
            // REMOVE this line if BSNWAVE is the new
            // standard for playing WAV's !!!
            //      PlaySoundFromFile(fh);
        };

    } while (capabFlag
             && (bqOptions & BQ_OPTION_ENDLESS)
             && (playState == 0));

    // Close File
    (void) FileClose(fh, TRUE);

    // update PLAYTrigger
    @send PLAYTrigger::MSG_GEN_REPLACE_VIS_MONIKER_TEXT(playText,VUM_NOW);

    // Clear Flag
    playFlag = 0;

    // Show Playstate
    rmsValue = 0;
    RedrawStatus(0);
    RedrawRMS(0);

    // Set Minimized state of primary
    if (bqMinimizedState)
    {
        @send BSQPPrimary::MSG_GEN_DISPLAY_SET_MINIMIZED();
    };

    // QuickMode --> shutdown application
    if (quickMode == BQ_QUICK_END)
    {
        @send BSQPApp::MSG_META_QUIT();
    };

    //Thread End
    ThreadDestroy(0, 0, 0);
    return (0);
}

/**************************************************************

        BQ_DrawCenterText

    Subroutine write text with a max width

  IN:   GStatehandle    gstate
    char        *text
        word        x
        word        y
        word        max


 **************************************************************/
#define BQ_DCT_BUF_LEN  250

void _pascal BQ_DrawCenterText(GStateHandle  gstate,
                               char      *text,
                               word      x,
                               word      y,
                               word      max)

{
    char    buf[BQ_DCT_BUF_LEN];
    word    w;
    int i;

    // copy text, get width
    strcpy (buf,text);
    w = GrTextWidth(gstate,buf,0);

    //Text wider than max ?
    if (w>max)
    {
        // reducing text and appending ".."
        i = BQ_DCT_BUF_LEN-1;
        while (w > (max-7)) // ".."
        {
            buf[i] = 0;
            w = GrTextWidth(gstate,buf,0);
            i--;
        };

        // append".."
        buf[i] = '.';
        i++;
        buf[i] = '.';
        i++;
        buf[i] = '.';
    };

    // Center Text
    w = GrTextWidth(gstate,buf,0);
    w = max - w;
    w = w/2;

    // draw text
    GrDrawText(gstate, x+w, y, buf, 0);
}

/**************************************************************

        BQ_CheckForPlay

    checking audio file for play

  IN:   (glob)fullPath  Path to file

  OUT:  Boolean     TRUE = File OK

 **************************************************************/

Boolean _pascal BQ_CheckForPlay(void)
{
    FileHandle  fh;
    Boolean     retVal;
    Boolean     isQOA;

    retVal = FALSE;
    bqSampleBytes = 0;
    bqAllBytes    = 0;
    bqSampleRate  = 0;
    bqChannels    = 0;
    bqBits        = 0;

    isQOA = BQ_IsQOAPath(fullPath);
    bqFileType = isQOA ? BQ_FILE_TYPE_QOA : BQ_FILE_TYPE_WAV;

    fh = FileOpen(fullPath, FILE_ACCESS_R | FILE_DENY_W);

    if (fh)
    {
        if (isQOA)
        {
            if (BQ_LoadQOAInfo(fh, &bqQoaInfo))
            {
                BQ_ApplyQOAInfo(&bqQoaInfo);
                {
                    char dbg[96];
                    sprintf(dbg, "QOA meta ch=%u rate=%lu frames=%lu", bqQoaInfo.channels, bqQoaInfo.sampleRate, bqQoaInfo.totalFrames);
                    SysNotify(SNF_CONTINUE, dbg, 0);
                }
                retVal = RedrawSettings(0);
            }

            FileClose(fh, TRUE);
        }
        else
        {
            if (BSNW_STATUS_OK == BSNWavePlayFile(fh, BSNW_TEST_ONLY, 0))
            {
                bqAllBytes = BSNWaveGetLastFormat(&bqSampleRate, &bqChannels, &bqBits);
                retVal = RedrawSettings(0);
            }

            FileClose(fh, TRUE);
        }

        RedrawTime(0);
    }

    return retVal;
}
