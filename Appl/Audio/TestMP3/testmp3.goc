@include <stdapp.goh>

#include <stdint.h>
#include <string.h>
#include <geode.h>
#include <geos.h>
#include <system.h>
#include <file.h>

#include "minimp3_geos16.h"

#define MP3_FRAME_BUFFER_SIZE   (MAX_FREE_FORMAT_FRAME_SIZE + HDR_SIZE)
#define TESTMP3_INPUT_FILE      "3S.MP3"
#define TESTMP3_OUTPUT_FILE     "3S.PCM"

int _pascal decode_file(void);
dword _pascal skip_id3_tag(FileHandle inputF);

@class TestMP3ProcessClass, GenProcessClass;
    @message void MSG_START_READING();
    @message void MSG_STOP_READING();
@endc;
@classdecl TestMP3ProcessClass, neverSaved;

@start AppResource;

@visMoniker AppTextMoniker = "Test MP3";

@object GenApplicationClass AppObj = {
    GI_visMoniker = list { @AppTextMoniker };
    GI_comp = @PrimaryObj;
    gcnList(MANUFACTURER_ID_GEOWORKS, GAGCNLT_WINDOWS) = @PrimaryObj;
}

@end AppResource;

@start Interface;

@object GenPrimaryClass PrimaryObj = {
    GI_comp = @MainGroupObj;
    HINT_ORIENT_CHILDREN_VERTICALLY;
    HINT_CENTER_CHILDREN_HORIZONTALLY;
    HINT_SIZE_WINDOW_AS_DESIRED;
}

@object GenInteractionClass MainGroupObj = {
    GI_comp = @StartBut, @StopBut;
    HINT_ORIENT_CHILDREN_VERTICALLY;
    HINT_CENTER_CHILDREN_HORIZONTALLY;
}

@object GenTriggerClass StartBut = {
    GI_visMoniker = "Start";
    GTI_destination = process;
    GTI_actionMsg = MSG_START_READING;
}

@object GenTriggerClass StopBut = {
    GI_visMoniker = "Stop";
    GTI_destination = process;
    GTI_actionMsg = MSG_STOP_READING;
}

@end Interface;

int _pascal decode_file(void)
{
    FileHandle inputF = NullHandle;                                           /* Track the source MP3 handle. */
    FileHandle outputF = NullHandle;                                          /* Track the destination PCM handle. */
    MemHandle feedH = NullHandle;                                             /* Handle for the raw MP3 frame buffer. */
    MemHandle pcmH = NullHandle;                                              /* Handle for decoded PCM samples. */
    MemHandle decH = NullHandle;                                              /* Handle for decoder persistent state. */
    MemHandle scratchH = NullHandle;                                          /* Handle for decoder scratch storage. */
    uint8_t *feedP = (void*)0;                                                /* Pointer into the MP3 frame buffer. */
    mp3d_sample_t *pcmP = (void*)0;                                           /* Pointer into the PCM output buffer. */
    mp3dec_t *decP = (void*)0;                                                /* Pointer into the decoder state structure. */
    mp3dec_scratch_t *scratchP = (void*)0;                                    /* Pointer into the scratch workspace. */
    mp3dec_frame_info_t info;                                                 /* Per-frame metadata filled by the decoder. */
    dword id3Offset = 0;                                                      /* Offset where audio data begins after ID3. */
    int readResult = 0;                                                       /* Bytes read when grabbing headers from disk. */
    word frameBytes = 0;                                                      /* Total byte count for each MP3 frame. */
    word payloadBytes = 0;                                                    /* Byte count remaining after the header. */
    word bytesToWrite = 0;                                                    /* Byte count of PCM data to flush per frame. */
    int samples = 0;                                                          /* Number of PCM samples returned by decoder. */
    int status = -1;                                                          /* Default to failure until streaming finishes. */

    memset(&info, 0, sizeof(info));                                           /* Clean the frame info so debugging starts from known values. */

    feedH = MemAlloc(MP3_FRAME_BUFFER_SIZE, HF_SWAPABLE, HAF_ZERO_INIT);      /* Allocate memory for the MP3 frame staging buffer. */
    feedP = (uint8_t*)MemLock(feedH);                                         /* Lock the MP3 buffer to obtain a direct pointer. */
    pcmH = MemAlloc((MINIMP3_MAX_SAMPLES_PER_FRAME * (word)sizeof(mp3d_sample_t)), HF_SWAPABLE, HAF_ZERO_INIT); /* Allocate PCM output memory. */
    pcmP = (mp3d_sample_t*)MemLock(pcmH);                                     /* Lock the PCM buffer for immediate writes. */
    decH = MemAlloc(sizeof(mp3dec_t), HF_SWAPABLE, HAF_ZERO_INIT);            /* Allocate persistent decoder state storage. */
    decP = (mp3dec_t*)MemLock(decH);                                          /* Lock decoder state so it can be initialized. */
    scratchH = MemAlloc(sizeof(mp3dec_scratch_t), HF_SWAPABLE, HAF_ZERO_INIT);/* Allocate scratch buffer required by the decoder. */
    scratchP = (mp3dec_scratch_t*)MemLock(scratchH);                          /* Lock scratch buffer to hand to the decode routine. */

    inputF = FileOpen(TESTMP3_INPUT_FILE, (FILE_ACCESS_R | FILE_DENY_RW));    /* Open the MP3 input file for sequential reading. */
    outputF = FileCreate(TESTMP3_OUTPUT_FILE, FILE_CREATE_TRUNCATE | FCF_NATIVE | FILE_DENY_RW | FILE_ACCESS_RW, FILE_ATTR_NORMAL); /* Create the raw PCM output file. */

    id3Offset = skip_id3_tag(inputF);                                         /* Position the stream after any ID3v2 metadata. */
    (void) id3Offset;                                                         /* Leave the computed offset visible for debugging tools. */

    mp3dec_init(decP);                                                        /* Reset decoder state so frames stream cleanly. */

    readResult = FileRead(inputF, feedP, HDR_SIZE, FALSE);                    /* Pull the first MP3 frame header into the buffer. */
    while (readResult == HDR_SIZE)                                            /* Continue until FileRead no longer delivers a full header. */
    {
        frameBytes = (word)(hdr_frame_bytes(feedP, 0) + hdr_padding(feedP));  /* Calculate complete frame length from the header fields. */
        payloadBytes = frameBytes - HDR_SIZE;                                 /* Determine payload size by removing the header bytes. */
        FileRead(inputF, feedP + HDR_SIZE, payloadBytes, FALSE);              /* Read the rest of the frame directly after the header. */

        samples = mp3dec_decode_frame(scratchP, decP, feedP, frameBytes, pcmP, &info); /* Decode this frame into raw PCM samples. */
        bytesToWrite = (word)(samples * info.channels * (word)sizeof(mp3d_sample_t)); /* Translate sample count into byte count for writing. */
        FileWrite(outputF, pcmP, bytesToWrite, FALSE);                        /* Emit PCM bytes to disk in raw sample format. */

        readResult = FileRead(inputF, feedP, HDR_SIZE, FALSE);                /* Fetch the next frame header in preparation for the loop. */
    }

    status = 0;                                                               /* If we reach here the MP3 stream drained successfully. */

    FileClose(outputF, TRUE);                                                 /* Close and flush the PCM output file. */
    FileClose(inputF, TRUE);                                                  /* Close the MP3 input file. */
    MemUnlock(scratchH);                                                      /* Release the locked scratch buffer pointer. */
    MemUnlock(decH);                                                          /* Release the locked decoder state pointer. */
    MemUnlock(pcmH);                                                          /* Release the locked PCM buffer pointer. */
    MemUnlock(feedH);                                                         /* Release the locked MP3 frame buffer pointer. */
    MemFree(scratchH);                                                        /* Free the scratch buffer handle. */
    MemFree(decH);                                                            /* Free the decoder state handle. */
    MemFree(pcmH);                                                            /* Free the PCM buffer handle. */
    MemFree(feedH);                                                           /* Free the MP3 frame buffer handle. */

    return status;                                                            /* Report completion status back to the caller. */
}

dword _pascal skip_id3_tag(FileHandle inputF)
{
    byte id3Header[10];                                                       /* Local scratch buffer that captures the ID3 header. */
    dword skipBytes = 0;                                                      /* Total number of bytes that should be skipped. */

    FilePos(inputF, 0, FILE_POS_START);                                       /* Always start scanning from the beginning. */
    FileRead(inputF, id3Header, 10, FALSE);                                   /* Pull the potential ID3 header into memory. */

    if ((id3Header[0] == 'I') && (id3Header[1] == 'D') && (id3Header[2] == '3')) /* Confirm the presence of an ID3 tag. */
    {
        skipBytes = ((dword)(id3Header[6] & 0x7F) << 21) |                    /* Decode the synchsafe tag length. */
                    ((dword)(id3Header[7] & 0x7F) << 14) |
                    ((dword)(id3Header[8] & 0x7F) << 7) |
                    (dword)(id3Header[9] & 0x7F);
        skipBytes += 10;                                                      /* Include the 10-byte header. */
        if (id3Header[5] & 0x10)                                              /* Account for an optional footer when flagged. */
        {
            skipBytes += 10;
        }
        FilePos(inputF, skipBytes, FILE_POS_START);                           /* Seek to the start of compressed audio. */
    }
    else
    {
        FilePos(inputF, 0, FILE_POS_START);                                   /* No tag detected: ensure playback starts at byte 0. */
    }

    return skipBytes;                                                         /* Report how many bytes were bypassed. */
}

@method TestMP3ProcessClass, MSG_START_READING
{
    (void) decode_file();                                                     /* Trigger decoding when the Start button is pressed. */
}

@method TestMP3ProcessClass, MSG_STOP_READING
{
    /* No streaming state to tear down in this debug build. */
}
