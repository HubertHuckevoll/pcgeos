@include <stdapp.goh>

#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include <geode.h>
#include <geos.h>
#include <file.h>
#include <stdio.h>
#include "minimp3_geos16.h"


/****************************************************************************
 * Constants
 ****************************************************************************/

#define FEED_BUF_SIZE  4096  /* small is fine; bigger reduces I/O calls */
#define WAV_HEADER_SIZE 44
#define MAX_DECODE_LOOPS 100000  /* Safety limit to prevent infinite hangs */
#define TESTMP3_DUMP_PCM
#define TESTMP3_INPUT_FILE "3S.MP3"
#define TESTMP3_OUTPUT_FILE "3S.WAV"
#define TESTMP3_LOG_FILE "3S.LOG"

/****************************************************************************
 * Globals
 ****************************************************************************/

Boolean     isRunning = FALSE;

/****************************************************************************
 * Forward declarations
 ****************************************************************************/

int decode_file(const char *path);

static void write_word_le(byte *buf, word offset, word value)
{
    buf[offset] = (byte)(value & 0xFF);
    buf[offset + 1] = (byte)((value >> 8) & 0xFF);
}

static void write_dword_le(byte *buf, word offset, dword value)
{
    buf[offset] = (byte)(value & 0xFF);
    buf[offset + 1] = (byte)((value >> 8) & 0xFF);
    buf[offset + 2] = (byte)((value >> 16) & 0xFF);
    buf[offset + 3] = (byte)((value >> 24) & 0xFF);
}

/****************************************************************************
 * Class definition
 ****************************************************************************/

@class TestMP3ProcessClass, GenProcessClass;
    @message void MSG_START_READING();
    @message void MSG_STOP_READING();
@endc;
@classdecl TestMP3ProcessClass, neverSaved;

/****************************************************************************
 * UI Resources
 ****************************************************************************/

@start AppResource;

@visMoniker AppTextMoniker = "Test MP3";

@object GenApplicationClass AppObj = {
    GI_visMoniker = list { @AppTextMoniker };
    GI_comp = @PrimaryObj;
    gcnList(MANUFACTURER_ID_GEOWORKS, GAGCNLT_WINDOWS) = @PrimaryObj;
}

@end AppResource;

@start Interface;

@object GenPrimaryClass PrimaryObj = {
    GI_comp = @MainGroupObj;
    HINT_ORIENT_CHILDREN_VERTICALLY;
    HINT_CENTER_CHILDREN_HORIZONTALLY;
    HINT_SIZE_WINDOW_AS_DESIRED;
}

@object GenInteractionClass MainGroupObj = {
    GI_comp = @StartBut, @StopBut;
    HINT_ORIENT_CHILDREN_VERTICALLY;
    HINT_CENTER_CHILDREN_HORIZONTALLY;
}

@object GenTriggerClass StartBut = {
    GI_visMoniker = "Start";
    GTI_destination = process;
    GTI_actionMsg = MSG_START_READING;
}

@object GenTriggerClass StopBut = {
    GI_visMoniker = "Stop";
    GTI_destination = process;
    GTI_actionMsg = MSG_STOP_READING;
}

@end Interface;


int decode_file()
{
    FileHandle f = NullHandle;
    FileHandle outF = NullHandle;
    uint8_t  feed[FEED_BUF_SIZE];
    int      feed_len = 0;                 /* bytes currently in feed[] */
    mp3dec_frame_info_t info;
    int channels = 0;
    int out_count = 0;
    int n = 0;
    int samples = 0;
    int used = 0;
    MemHandle pcmH = NullHandle;
    int16_t* pcm = (void*) 0;
    MemHandle mp3dec_tH = NullHandle;
    mp3dec_t* dec = (void*) 0;
    Boolean eof = FALSE;
    dword totalBytes = 0;
    dword sampleRate = 0;
    word  channelCount = 0;
    byte  wavHeader[WAV_HEADER_SIZE];
    MemHandle scratchH = NullHandle;
    mp3dec_scratch_t* scratch = (void*) 0;
    dword loopCount = 0;
#ifdef TESTMP3_DUMP_PCM
    FileHandle logF = NullHandle;
    dword sampleIndex = 0;
    char logLine[96];
    int16_t leftSample = 0;
    int16_t rightSample = 0;
    dword logTimestamp = 0;
    word sampleLoop = 0;
#endif

    /* 1152*2 int16 slots */
    pcmH = MemAlloc((MINIMP3_MAX_SAMPLES_PER_FRAME * (word)sizeof(int16_t)), HF_SWAPABLE, HAF_ZERO_INIT);
    pcm = (int16_t*)MemLock(pcmH);

    mp3dec_tH = MemAlloc(sizeof(mp3dec_t), HF_SWAPABLE, HAF_ZERO_INIT);
    dec = (mp3dec_t*) MemLock(mp3dec_tH);

    scratchH = MemAlloc(sizeof(mp3dec_scratch_t), HF_SWAPABLE, HAF_ZERO_INIT);
    scratch = (mp3dec_scratch_t*) MemLock(scratchH);

    FilePushDir();
    FileSetStandardPath(SP_DOCUMENT);
    f = FileOpen(TESTMP3_INPUT_FILE, (FILE_ACCESS_R | FILE_DENY_RW));
    outF = FileCreate(TESTMP3_OUTPUT_FILE,
                  FILE_CREATE_TRUNCATE | FCF_NATIVE | FILE_DENY_RW | FILE_ACCESS_RW,
                  FILE_ATTR_NORMAL);
#ifdef TESTMP3_DUMP_PCM
    logF = FileCreate(TESTMP3_LOG_FILE,
                  FILE_CREATE_TRUNCATE | FCF_NATIVE | FILE_DENY_RW | FILE_ACCESS_W,
                  FILE_ATTR_NORMAL);
#endif

    if (outF) {
        memset(wavHeader, 0, WAV_HEADER_SIZE);
        FileWrite(outF, wavHeader, WAV_HEADER_SIZE, FALSE);
    }

    if (!f || !outF
#ifdef TESTMP3_DUMP_PCM
        || !logF
#endif
        )
    {
#ifdef TESTMP3_DUMP_PCM
        if (logF)
        {
            FileClose(logF, TRUE);
        }
#endif
        if (outF)
        {
            FileClose(outF, TRUE);
        }
        if (f)
        {
            FileClose(f, TRUE);
        }
        MemFree(pcmH);
        MemFree(mp3dec_tH);
        return -1;
    }

    mp3dec_init(dec);

    for(;;)
    {
        loopCount++;

        /* Safety check: prevent infinite loops */
        if (loopCount > MAX_DECODE_LOOPS) {
            /* Exceeded maximum iterations - exit to prevent hang */
            break;
        }

        /* Fill buffer if there's room and file not exhausted */
        if (!eof && (feed_len < FEED_BUF_SIZE)) {
            n = FileRead(f, feed + feed_len, FEED_BUF_SIZE - feed_len, FALSE);
            if (n == -1)
            {
                /* Read error - treat as EOF */
                eof = TRUE;
            }
            else if (n == 0)
            {
                /* No bytes read - could be temporary or EOF. */
                /* Try to see if we're really at EOF by checking file position */
                dword curPos = FilePos(f, 0, FILE_POS_RELATIVE);
                dword fileSize = FileSize(f);
                if (curPos >= fileSize)
                {
                    eof = TRUE;
                }
                /* else: not at EOF, just temporary 0 return - try again next iteration */
            }
            else
            {
                feed_len += n;
            }
        }

        /* Exit if buffer empty and file exhausted */
        if ((feed_len == 0) && eof)
            break;

        /* Try to decode a frame from current buffer */
        samples = mp3dec_decode_frame(scratch, dec, feed, feed_len, pcm, &info);

        /* If decoder consumed bytes, remove them from buffer */
        if (info.frame_bytes > 0) {
            used = info.frame_bytes;
            feed_len -= used;
            if (feed_len > 0)
                memmove(feed, feed + used, (size_t)feed_len);
        }
        /* If no frame found/decoded AND no bytes consumed */
        else if (samples == 0) {
            /* Only try resync if we can't get more data */
            if (eof || (feed_len >= FEED_BUF_SIZE)) {
                /* At EOF or buffer full - drop bytes to find sync */
                /* But if at EOF and no progress, give up quickly to avoid hanging */
                if (eof) {
                    /* At EOF - if we have less than a typical frame size left, */
                    /* and can't decode, just discard remaining bytes and exit. */
                    /* A full MP3 frame is typically 144-1441 bytes. */
                    if (feed_len > 0 && feed_len < 2000) {
                        /* Can't decode these trailing bytes - likely padding/metadata */
                        feed_len = 0;
                        break;
                    }
                }
                /* Drop 1 byte to try to resync */
                if (feed_len > 0) {
                    feed_len--;
                    memmove(feed, feed + 1, (size_t)feed_len);
                }
                if ((feed_len == 0) && eof) {
                    break;
                }
            }
            /* else: can read more data, loop will continue to fill buffer */
        }

        /* Write decoded samples if any */
        if (samples > 0) {
            /* Use PCM here. If stereo, data is interleaved L R L R ... */
            channels = info.channels;   /* 1 or 2 */
            out_count = samples * channels;

            if (sampleRate == 0) {
                sampleRate = info.hz;
            }
            if (channelCount == 0) {
                channelCount = (word)channels;
            }

            FileWrite(outF, pcm, sizeof(int16_t) * out_count, FALSE);
            totalBytes += (dword)(sizeof(int16_t) * out_count);
#ifdef TESTMP3_DUMP_PCM
            if (logF)
            {
                for (sampleLoop = 0; sampleLoop < (word)samples; sampleLoop++)
                {
                    if (channels == 2)
                    {
                        leftSample = pcm[(sampleLoop * 2) + 0];
                        rightSample = pcm[(sampleLoop * 2) + 1];
                    }
                    else
                    {
                        leftSample = pcm[sampleLoop];
                        rightSample = leftSample;
                    }
                    if (info.hz > 0)
                    {
                        logTimestamp = (sampleIndex * 1000UL) / info.hz;
                    }
                    else
                    {
                        logTimestamp = 0;
                    }
                    sprintf(logLine,
                            "%lu,%lu,%d,%d\r\n",
                            (unsigned long)sampleIndex,
                            (unsigned long)logTimestamp,
                            (int)leftSample,
                            (int)rightSample);
                    FileWrite(logF, logLine, (word)strlen(logLine), FALSE);
                    sampleIndex++;
                }
            }
#endif
        }
    }

    if ((totalBytes > 0) && (sampleRate > 0) && (channelCount > 0)) {
        dword byteRate;
        word  blockAlign;
        dword riffSize;

        memset(wavHeader, 0, WAV_HEADER_SIZE);
        wavHeader[0] = 'R';
        wavHeader[1] = 'I';
        wavHeader[2] = 'F';
        wavHeader[3] = 'F';

        riffSize = 36 + totalBytes;
        write_dword_le(wavHeader, 4, riffSize);

        wavHeader[8]  = 'W';
        wavHeader[9]  = 'A';
        wavHeader[10] = 'V';
        wavHeader[11] = 'E';

        wavHeader[12] = 'f';
        wavHeader[13] = 'm';
        wavHeader[14] = 't';
        wavHeader[15] = ' ';

        write_dword_le(wavHeader, 16, 16);      /* PCM fmt chunk size */
        write_word_le(wavHeader, 20, 1);        /* PCM format */
        write_word_le(wavHeader, 22, channelCount);
        write_dword_le(wavHeader, 24, sampleRate);

        blockAlign = (word)(channelCount * sizeof(int16_t));
        byteRate = sampleRate * (dword)blockAlign;

        write_dword_le(wavHeader, 28, byteRate);
        write_word_le(wavHeader, 32, blockAlign);
        write_word_le(wavHeader, 34, 16);

        wavHeader[36] = 'd';
        wavHeader[37] = 'a';
        wavHeader[38] = 't';
        wavHeader[39] = 'a';
        write_dword_le(wavHeader, 40, totalBytes);

        FilePos(outF, 0UL, FILE_POS_START);
        FileWrite(outF, wavHeader, WAV_HEADER_SIZE, FALSE);
        FileClose(outF, TRUE);
        outF = NullHandle;
    } else if (outF != NullHandle) {
        FileClose(outF, TRUE);
        outF = NullHandle;
    }

    FileClose(f, TRUE);
#ifdef TESTMP3_DUMP_PCM
    FileClose(logF, TRUE);
#endif
    FilePopDir();

    MemFree(scratchH);
    MemFree(pcmH);
    MemFree(mp3dec_tH);

    return 0;
}

@method TestMP3ProcessClass, MSG_START_READING
{
    //isRunning = TRUE;
    (void) decode_file();
}

@method TestMP3ProcessClass, MSG_STOP_READING
{
    //isRunning = FALSE;
}
