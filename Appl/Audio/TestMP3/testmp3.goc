@include <stdapp.goh>

#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include <geode.h>
#include <geos.h>
#include <file.h>
#include <stdio.h>
#include "minimp3_geos16.h"


/****************************************************************************
 * Constants
 ****************************************************************************/

#define MINIMP3_BUF_SIZE  4096
#define FEED_BUF_SIZE     (MINIMP3_BUF_SIZE + 2048)
#define WAV_HEADER_SIZE 44
#define MAX_DECODE_LOOPS 100000  /* Safety limit to prevent infinite hangs */
// #define TESTMP3_DUMP_PCM
#define TESTMP3_INPUT_FILE "3S.MP3"
#define TESTMP3_OUTPUT_FILE "3S.WAV"
#define TESTMP3_LOG_FILE "3S.LOG"

/****************************************************************************
 * Globals
 ****************************************************************************/

Boolean     isRunning = FALSE;

/****************************************************************************
 * Forward declarations
 ****************************************************************************/

int decode_file(const char *path);

static void write_word_le(byte *buf, word offset, word value)
{
    buf[offset] = (byte)(value & 0xFF);
    buf[offset + 1] = (byte)((value >> 8) & 0xFF);
}

static void write_dword_le(byte *buf, word offset, dword value)
{
    buf[offset] = (byte)(value & 0xFF);
    buf[offset + 1] = (byte)((value >> 8) & 0xFF);
    buf[offset + 2] = (byte)((value >> 16) & 0xFF);
    buf[offset + 3] = (byte)((value >> 24) & 0xFF);
}

static void drop_buffer_bytes(uint8_t *buffer, word *lengthP, word toDrop)
{
    word remaining;

    if (*lengthP <= toDrop)
    {
        *lengthP = 0;
        return;
    }
    remaining = *lengthP - toDrop;
    memmove(buffer, buffer + toDrop, (word)remaining);
    *lengthP = remaining;
}

static void skip_id3v1_tag(uint8_t *buffer, word *lengthP)
{
    word newLength;

    if (*lengthP >= 128)
    {
        if ((buffer[*lengthP - 128] == 'T') &&
            (buffer[*lengthP - 127] == 'A') &&
            (buffer[*lengthP - 126] == 'G'))
        {
            *lengthP -= 128;
            if (*lengthP >= 227)
            {
                newLength = *lengthP - 227;
                if ((buffer[newLength] == 'T') &&
                    (buffer[newLength + 1] == 'A') &&
                    (buffer[newLength + 2] == 'G') &&
                    (buffer[newLength + 3] == '+'))
                {
                    *lengthP -= 227;
                }
            }
        }
    }
}

static Boolean detect_id3v2_header(const uint8_t *buffer, word length, dword *headerSizeP)
{
    dword headerSize;

    if (length < 10)
    {
        return FALSE;
    }
    if ((buffer[0] != 'I') || (buffer[1] != 'D') || (buffer[2] != '3'))
    {
        return FALSE;
    }
    if ((buffer[5] & 0x0F) != 0)
    {
        return FALSE;
    }
    if ((buffer[6] & 0x80) || (buffer[7] & 0x80) || (buffer[8] & 0x80) || (buffer[9] & 0x80))
    {
        return FALSE;
    }
    headerSize = ((dword)(buffer[6] & 0x7F) << 21) |
                 ((dword)(buffer[7] & 0x7F) << 14) |
                 ((dword)(buffer[8] & 0x7F) << 7) |
                 (dword)(buffer[9] & 0x7F);
    headerSize += 10;
    if (buffer[5] & 0x10)
    {
        headerSize += 10;
    }
    *headerSizeP = headerSize;
    return TRUE;
}

static Boolean skip_id3v2_header(FileHandle f, uint8_t *buffer, word *lengthP, Boolean *eofP, Boolean *errorP)
{
    dword headerSize;
    dword remaining;
    word toRead;
    int readResult;

    if (*lengthP < 10)
    {
        if (*eofP)
        {
            return TRUE;
        }
        return FALSE;
    }
    if (!detect_id3v2_header(buffer, *lengthP, &headerSize))
    {
        return TRUE;
    }
    if (headerSize <= (dword)(*lengthP))
    {
        drop_buffer_bytes(buffer, lengthP, (word)headerSize);
        return TRUE;
    }
    remaining = headerSize;
    if (*lengthP > 0)
    {
        remaining -= (dword)(*lengthP);
        *lengthP = 0;
    }
    while (remaining > 0)
    {
        toRead = (remaining > (dword)FEED_BUF_SIZE) ? FEED_BUF_SIZE : (word)remaining;
        readResult = FileRead(f, buffer, toRead, FALSE);
        if (readResult < 0)
        {
            *errorP = TRUE;
            *eofP = TRUE;
            break;
        }
        if (readResult == 0)
        {
            *eofP = TRUE;
            break;
        }
        if ((word)readResult < toRead)
        {
            *eofP = TRUE;
        }
        if ((dword)readResult >= remaining)
        {
            remaining = 0;
        }
        else
        {
            remaining -= (dword)readResult;
        }
        if (*eofP && (remaining > 0))
        {
            break;
        }
    }
    *lengthP = 0;
    return TRUE;
}

static word resync_to_frame(uint8_t *buffer, word *lengthP)
{
    word index;
    word limit;
    word dropped;
    word originalLength;

    originalLength = *lengthP;
    if (*lengthP < 2)
    {
        dropped = *lengthP;
        *lengthP = 0;
        return dropped;
    }
    limit = *lengthP - 1;
    for (index = 0; index < limit; index++)
    {
        if ((buffer[index] == 0xFF) && ((buffer[index + 1] & 0xE0) == 0xE0))
        {
            if (index > 0)
            {
                drop_buffer_bytes(buffer, lengthP, index);
                dropped = index;
                return dropped;
            }
            return 0;
        }
    }
    dropped = originalLength;
    *lengthP = 0;
    return dropped;
}

static Boolean refill_input_buffer(FileHandle f, uint8_t *buffer, word *lengthP, Boolean *eofP, Boolean *errorP)
{
    Boolean didRead;
    int readResult;
    word request;

    didRead = FALSE;
    while (!(*eofP) && (*lengthP < MINIMP3_BUF_SIZE))
    {
        if (*lengthP >= FEED_BUF_SIZE)
        {
            break;
        }
        request = FEED_BUF_SIZE - *lengthP;
        readResult = FileRead(f, buffer + *lengthP, request, FALSE);
        if (readResult < 0)
        {
            *errorP = TRUE;
            *eofP = TRUE;
            break;
        }
        if (readResult == 0)
        {
            *eofP = TRUE;
            break;
        }
        *lengthP += (word)readResult;
        didRead = TRUE;
        if ((word)readResult < request)
        {
            *eofP = TRUE;
        }
    }
    if (*eofP)
    {
        skip_id3v1_tag(buffer, lengthP);
    }
    return didRead;
}

/****************************************************************************
 * Class definition
 ****************************************************************************/

@class TestMP3ProcessClass, GenProcessClass;
    @message void MSG_START_READING();
    @message void MSG_STOP_READING();
@endc;
@classdecl TestMP3ProcessClass, neverSaved;

/****************************************************************************
 * UI Resources
 ****************************************************************************/

@start AppResource;

@visMoniker AppTextMoniker = "Test MP3";

@object GenApplicationClass AppObj = {
    GI_visMoniker = list { @AppTextMoniker };
    GI_comp = @PrimaryObj;
    gcnList(MANUFACTURER_ID_GEOWORKS, GAGCNLT_WINDOWS) = @PrimaryObj;
}

@end AppResource;

@start Interface;

@object GenPrimaryClass PrimaryObj = {
    GI_comp = @MainGroupObj;
    HINT_ORIENT_CHILDREN_VERTICALLY;
    HINT_CENTER_CHILDREN_HORIZONTALLY;
    HINT_SIZE_WINDOW_AS_DESIRED;
}

@object GenInteractionClass MainGroupObj = {
    GI_comp = @StartBut, @StopBut;
    HINT_ORIENT_CHILDREN_VERTICALLY;
    HINT_CENTER_CHILDREN_HORIZONTALLY;
}

@object GenTriggerClass StartBut = {
    GI_visMoniker = "Start";
    GTI_destination = process;
    GTI_actionMsg = MSG_START_READING;
}

@object GenTriggerClass StopBut = {
    GI_visMoniker = "Stop";
    GTI_destination = process;
    GTI_actionMsg = MSG_STOP_READING;
}

@end Interface;


int decode_file()
{
    FileHandle f = NullHandle;
    FileHandle outF = NullHandle;
    mp3dec_frame_info_t info;
    int channels = 0;
    int out_count = 0;
    int samples = 0;
    word used = 0;
    MemHandle pcmH = NullHandle;
    int16_t* pcm = (void*)0;
    MemHandle mp3dec_tH = NullHandle;
    mp3dec_t* dec = (void*)0;
    Boolean eof = FALSE;
    dword totalBytes = 0;
    dword sampleRate = 0;
    word channelCount = 0;
    byte wavHeader[WAV_HEADER_SIZE];
    MemHandle scratchH = NullHandle;
    mp3dec_scratch_t* scratch = (void*)0;
    dword loopCount = 0;
    Boolean decodeError = FALSE;
    Boolean readError = FALSE;
    Boolean id3Processed = FALSE;
    MemHandle feedH = NullHandle;
    uint8_t* feed = (void*)0;
    word feed_len = 0;
    Boolean firstFrame = FALSE;
    int zeroProgress = 0;
    int result = 0;
    word writeResult = 0;
    Boolean pushedDir = FALSE;
#ifdef TESTMP3_DUMP_PCM
    FileHandle logF = NullHandle;
    dword sampleIndex = 0;
    char logLine[96];
    int16_t leftSample = 0;
    int16_t rightSample = 0;
    dword logTimestamp = 0;
    word sampleLoop = 0;
    word logLen = 0;
#endif

    feedH = MemAlloc(FEED_BUF_SIZE, HF_SWAPABLE, HAF_ZERO_INIT);
    if (!feedH)
    {
        result = -1;
        goto cleanup;
    }
    feed = (uint8_t*)MemLock(feedH);

    pcmH = MemAlloc((MINIMP3_MAX_SAMPLES_PER_FRAME * (word)sizeof(int16_t)), HF_SWAPABLE, HAF_ZERO_INIT);
    if (!pcmH)
    {
        result = -1;
        goto cleanup;
    }
    pcm = (int16_t*)MemLock(pcmH);

    mp3dec_tH = MemAlloc(sizeof(mp3dec_t), HF_SWAPABLE, HAF_ZERO_INIT);
    if (!mp3dec_tH)
    {
        result = -1;
        goto cleanup;
    }
    dec = (mp3dec_t*)MemLock(mp3dec_tH);

    scratchH = MemAlloc(sizeof(mp3dec_scratch_t), HF_SWAPABLE, HAF_ZERO_INIT);
    if (!scratchH)
    {
        result = -1;
        goto cleanup;
    }
    scratch = (mp3dec_scratch_t*)MemLock(scratchH);

    FilePushDir();
    pushedDir = TRUE;
    FileSetStandardPath(SP_DOCUMENT);
    f = FileOpen(TESTMP3_INPUT_FILE, (FILE_ACCESS_R | FILE_DENY_RW));
    outF = FileCreate(TESTMP3_OUTPUT_FILE,
                      FILE_CREATE_TRUNCATE | FCF_NATIVE | FILE_DENY_RW | FILE_ACCESS_RW,
                      FILE_ATTR_NORMAL);
#ifdef TESTMP3_DUMP_PCM
    logF = FileCreate(TESTMP3_LOG_FILE,
                      FILE_CREATE_TRUNCATE | FCF_NATIVE | FILE_DENY_RW | FILE_ACCESS_W,
                      FILE_ATTR_NORMAL);
#endif

    if (outF)
    {
        memset(wavHeader, 0, WAV_HEADER_SIZE);
        writeResult = FileWrite(outF, wavHeader, WAV_HEADER_SIZE, FALSE);
        if (writeResult != WAV_HEADER_SIZE)
        {
            decodeError = TRUE;
        }
    }

    if (!f || !outF
#ifdef TESTMP3_DUMP_PCM
        || !logF
#endif
        || decodeError)
    {
        result = -1;
        goto cleanup;
    }

    mp3dec_init(dec);

    for (;;)
    {
        loopCount++;
        if (loopCount > MAX_DECODE_LOOPS)
        {
            decodeError = TRUE;
            break;
        }

        if (!id3Processed)
        {
            if (!eof)
            {
                refill_input_buffer(f, feed, &feed_len, &eof, &readError);
            }
            if (readError)
            {
                decodeError = TRUE;
                break;
            }
            if (!skip_id3v2_header(f, feed, &feed_len, &eof, &readError))
            {
                if (readError)
                {
                    decodeError = TRUE;
                    break;
                }
                if ((feed_len == 0) && eof)
                {
                    break;
                }
                continue;
            }
            if (readError)
            {
                decodeError = TRUE;
                break;
            }
            id3Processed = TRUE;
            if ((feed_len == 0) && eof)
            {
                break;
            }
            continue;
        }

        if (!eof && (feed_len < MINIMP3_BUF_SIZE))
        {
            refill_input_buffer(f, feed, &feed_len, &eof, &readError);
            if (readError)
            {
                decodeError = TRUE;
                break;
            }
        }

        if ((feed_len == 0) && eof)
        {
            break;
        }

        samples = mp3dec_decode_frame(scratch, dec, feed, feed_len, pcm, &info);

        if (info.frame_bytes > 0)
        {
            if (info.frame_bytes > (dword)feed_len)
            {
                feed_len = 0;
            }
            else
            {
                used = (word)info.frame_bytes;
                drop_buffer_bytes(feed, &feed_len, used);

                /* Verify we're at a frame header after consuming bytes */
                /* If not at a valid frame start, resync */
                if (feed_len >= 2)
                {
                    if (!((feed[0] == 0xFF) && ((feed[1] & 0xE0) == 0xE0)))
                    {
                        /* Not at frame header - resync */
                        resync_to_frame(feed, &feed_len);
                    }
                }
            }
            zeroProgress = 0;
        }
        else if (samples > 0)
        {
            zeroProgress = 0;
        }
        else
        {
            zeroProgress++;
        }

        if (samples > 0)
        {
            channels = info.channels;
            out_count = samples * channels;

            if (!firstFrame)
            {
                sampleRate = info.hz;
                channelCount = (word)channels;
                firstFrame = TRUE;
            }
            else if ((sampleRate != info.hz) || (channelCount != (word)channels))
            {
                decodeError = TRUE;
                break;
            }

            writeResult = FileWrite(outF, pcm, (word)(sizeof(int16_t) * out_count), FALSE);
            if (writeResult != (word)(sizeof(int16_t) * out_count))
            {
                decodeError = TRUE;
                break;
            }
            totalBytes += (dword)(sizeof(int16_t) * out_count);
#ifdef TESTMP3_DUMP_PCM
            if (logF)
            {
                for (sampleLoop = 0; sampleLoop < (word)samples; sampleLoop++)
                {
                    if (channels == 2)
                    {
                        leftSample = pcm[(sampleLoop * 2) + 0];
                        rightSample = pcm[(sampleLoop * 2) + 1];
                    }
                    else
                    {
                        leftSample = pcm[sampleLoop];
                        rightSample = leftSample;
                    }
                    if (info.hz > 0)
                    {
                        logTimestamp = (sampleIndex * 1000UL) / info.hz;
                    }
                    else
                    {
                        logTimestamp = 0;
                    }
                    sprintf(logLine,
                            "%lu,%lu,%d,%d\r\n",
                            (unsigned long)sampleIndex,
                            (unsigned long)logTimestamp,
                            (int)leftSample,
                            (int)rightSample);
                    logLen = (word)strlen(logLine);
                    writeResult = FileWrite(logF, logLine, logLen, FALSE);
                    if (writeResult != logLen)
                    {
                        decodeError = TRUE;
                        break;
                    }
                    sampleIndex++;
                }
                if (decodeError)
                {
                    break;
                }
            }
#endif
        }

        if (decodeError)
        {
            break;
        }

        if (zeroProgress >= 3)
        {
            word previousFeedLen;
            word removedBytes;

            previousFeedLen = feed_len;
            removedBytes = resync_to_frame(feed, &feed_len);
            zeroProgress = 0;
            if ((feed_len > 0) && ((removedBytes == 0) || (feed_len == previousFeedLen)))
            {
                drop_buffer_bytes(feed, &feed_len, 1);
            }
            if ((feed_len == 0) && eof)
            {
                break;
            }
            continue;
        }

        if (!eof && (feed_len < MINIMP3_BUF_SIZE))
        {
            refill_input_buffer(f, feed, &feed_len, &eof, &readError);
            if (readError)
            {
                decodeError = TRUE;
                break;
            }
        }

        if ((feed_len == 0) && eof)
        {
            break;
        }
    }

    if (!decodeError && (totalBytes > 0) && (sampleRate > 0) && (channelCount > 0))
    {
        dword byteRate;
        word blockAlign;
        dword riffSize;

        memset(wavHeader, 0, WAV_HEADER_SIZE);
        wavHeader[0] = 'R';
        wavHeader[1] = 'I';
        wavHeader[2] = 'F';
        wavHeader[3] = 'F';

        riffSize = 36 + totalBytes;
        write_dword_le(wavHeader, 4, riffSize);

        wavHeader[8]  = 'W';
        wavHeader[9]  = 'A';
        wavHeader[10] = 'V';
        wavHeader[11] = 'E';

        wavHeader[12] = 'f';
        wavHeader[13] = 'm';
        wavHeader[14] = 't';
        wavHeader[15] = ' ';

        write_dword_le(wavHeader, 16, 16);
        write_word_le(wavHeader, 20, 1);
        write_word_le(wavHeader, 22, channelCount);
        write_dword_le(wavHeader, 24, sampleRate);

        blockAlign = (word)(channelCount * sizeof(int16_t));
        byteRate = sampleRate * (dword)blockAlign;

        write_dword_le(wavHeader, 28, byteRate);
        write_word_le(wavHeader, 32, blockAlign);
        write_word_le(wavHeader, 34, 16);

        wavHeader[36] = 'd';
        wavHeader[37] = 'a';
        wavHeader[38] = 't';
        wavHeader[39] = 'a';
        write_dword_le(wavHeader, 40, totalBytes);

        FilePos(outF, 0UL, FILE_POS_START);
        writeResult = FileWrite(outF, wavHeader, WAV_HEADER_SIZE, FALSE);
        if (writeResult != WAV_HEADER_SIZE)
        {
            decodeError = TRUE;
        }
    }

cleanup:
    if (outF != NullHandle)
    {
        FileClose(outF, TRUE);
        outF = NullHandle;
    }
    if (f)
    {
        FileClose(f, TRUE);
    }
#ifdef TESTMP3_DUMP_PCM
    if (logF)
    {
        FileClose(logF, TRUE);
    }
#endif
    if (pushedDir)
    {
        FilePopDir();
    }

    if (scratchH)
    {
        MemFree(scratchH);
    }
    if (pcmH)
    {
        MemFree(pcmH);
    }
    if (mp3dec_tH)
    {
        MemFree(mp3dec_tH);
    }
    if (feedH)
    {
        MemFree(feedH);
    }

    if (decodeError || (totalBytes == 0) || (sampleRate == 0) || (channelCount == 0))
    {
        result = -1;
    }
    return result;
}

@method TestMP3ProcessClass, MSG_START_READING
{
    //isRunning = TRUE;
    (void) decode_file();
}

@method TestMP3ProcessClass, MSG_STOP_READING
{
    //isRunning = FALSE;
}
