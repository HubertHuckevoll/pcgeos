@include <stdapp.goh>

#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include <geode.h>
#include <geos.h>
#include <file.h>
#include <stdio.h>
#include "minimp3_geos16.h"


/****************************************************************************
 * Constants
 ****************************************************************************/

#define FEED_BUF_SIZE  4096  /* small is fine; bigger reduces I/O calls */
#define WAV_HEADER_SIZE 44
#define TESTMP3_DUMP_PCM

/****************************************************************************
 * Globals
 ****************************************************************************/

Boolean     isRunning = FALSE;

/****************************************************************************
 * Forward declarations
 ****************************************************************************/

int decode_file(const char *path);

static void write_word_le(byte *buf, word offset, word value)
{
    buf[offset] = (byte)(value & 0xFF);
    buf[offset + 1] = (byte)((value >> 8) & 0xFF);
}

static void write_dword_le(byte *buf, word offset, dword value)
{
    buf[offset] = (byte)(value & 0xFF);
    buf[offset + 1] = (byte)((value >> 8) & 0xFF);
    buf[offset + 2] = (byte)((value >> 16) & 0xFF);
    buf[offset + 3] = (byte)((value >> 24) & 0xFF);
}

/****************************************************************************
 * Class definition
 ****************************************************************************/

@class TestMP3ProcessClass, GenProcessClass;
    @message void MSG_START_READING();
    @message void MSG_STOP_READING();
@endc;
@classdecl TestMP3ProcessClass, neverSaved;

/****************************************************************************
 * UI Resources
 ****************************************************************************/

@start AppResource;

@visMoniker AppTextMoniker = "Test MP3";

@object GenApplicationClass AppObj = {
    GI_visMoniker = list { @AppTextMoniker };
    GI_comp = @PrimaryObj;
    gcnList(MANUFACTURER_ID_GEOWORKS, GAGCNLT_WINDOWS) = @PrimaryObj;
}

@end AppResource;

@start Interface;

@object GenPrimaryClass PrimaryObj = {
    GI_comp = @MainGroupObj;
    HINT_ORIENT_CHILDREN_VERTICALLY;
    HINT_CENTER_CHILDREN_HORIZONTALLY;
    HINT_SIZE_WINDOW_AS_DESIRED;
}

@object GenInteractionClass MainGroupObj = {
    GI_comp = @StartBut, @StopBut;
    HINT_ORIENT_CHILDREN_VERTICALLY;
    HINT_CENTER_CHILDREN_HORIZONTALLY;
}

@object GenTriggerClass StartBut = {
    GI_visMoniker = "Start";
    GTI_destination = process;
    GTI_actionMsg = MSG_START_READING;
}

@object GenTriggerClass StopBut = {
    GI_visMoniker = "Stop";
    GTI_destination = process;
    GTI_actionMsg = MSG_STOP_READING;
}

@end Interface;


int decode_file()
{
    FileHandle f = NullHandle;
    FileHandle outF = NullHandle;
    uint8_t  feed[FEED_BUF_SIZE];
    int      feed_len = 0;                 /* bytes currently in feed[] */
    mp3dec_frame_info_t info;
    int channels = 0;
    int out_count = 0;
    int n = 0;
    int samples = 0;
    int used = 0;
    MemHandle pcmH = NullHandle;
    int16_t* pcm = (void*) 0;
    MemHandle mp3dec_tH = NullHandle;
    mp3dec_t* dec = (void*) 0;
    Boolean eof = FALSE;
    dword totalBytes = 0;
    dword sampleRate = 0;
    word  channelCount = 0;
    byte  wavHeader[WAV_HEADER_SIZE];
    MemHandle scratchH = NullHandle;
    mp3dec_scratch_t* scratch = (void*) 0;
#ifdef TESTMP3_DUMP_PCM
    FileHandle logF = NullHandle;
    dword sampleIndex = 0;
    char logLine[96];
    int16_t leftSample = 0;
    int16_t rightSample = 0;
    dword logTimestamp = 0;
    word sampleLoop = 0;
#endif

    /* 1152*2 int16 slots */
    pcmH = MemAlloc((MINIMP3_MAX_SAMPLES_PER_FRAME * (word)sizeof(int16_t)), HF_SWAPABLE, HAF_ZERO_INIT);
    pcm = (int16_t*)MemLock(pcmH);

    mp3dec_tH = MemAlloc(sizeof(mp3dec_t), HF_SWAPABLE, HAF_ZERO_INIT);
    dec = (mp3dec_t*) MemLock(mp3dec_tH);

    scratchH = MemAlloc(sizeof(mp3dec_scratch_t), HF_SWAPABLE, HAF_ZERO_INIT);
    scratch = (mp3dec_scratch_t*) MemLock(scratchH);

    FilePushDir();
    FileSetStandardPath(SP_DOCUMENT);
    f = FileOpen("3S.MP3", (FILE_ACCESS_R | FILE_DENY_RW));
    outF = FileCreate("3S.WAV",
                  FILE_CREATE_TRUNCATE | FCF_NATIVE | FILE_DENY_RW | FILE_ACCESS_RW,
                  FILE_ATTR_NORMAL);
#ifdef TESTMP3_DUMP_PCM
    logF = FileCreate("3S.LOG",
                  FILE_CREATE_TRUNCATE | FCF_NATIVE | FILE_DENY_RW | FILE_ACCESS_W,
                  FILE_ATTR_NORMAL);
#endif

    if (outF) {
        memset(wavHeader, 0, WAV_HEADER_SIZE);
        FileWrite(outF, wavHeader, WAV_HEADER_SIZE, FALSE);
    }

    if (!f || !outF
#ifdef TESTMP3_DUMP_PCM
        || !logF
#endif
        )
    {
#ifdef TESTMP3_DUMP_PCM
        if (logF)
        {
            FileClose(logF, TRUE);
        }
#endif
        if (outF)
        {
            FileClose(outF, TRUE);
        }
        if (f)
        {
            FileClose(f, TRUE);
        }
        MemFree(pcmH);
        MemFree(mp3dec_tH);
        return -1;
    }

    mp3dec_init(dec);

    while(isRunning == TRUE)
    {
        /* If buffer has room, read more bytes at the end */
        if (feed_len < FEED_BUF_SIZE) {
            n = FileRead(f, feed + feed_len, FEED_BUF_SIZE - feed_len, FALSE);
            if (n > 0) feed_len += n;
            if (n < 0) eof = TRUE;
        }

        /* Nothing left and no more to read? done. */
        if (feed_len == 0)
            break;

        /* Try to decode from the current buffer */
        samples = mp3dec_decode_frame(scratch, dec, feed, feed_len, pcm, &info);

        if (info.frame_bytes > 0) {
            /* Consume the bytes the decoder used */
            used = info.frame_bytes;
            feed_len -= used;
            if (feed_len > 0)
                memmove(feed, feed + used, (size_t)feed_len);
        } else {
            /* Decoder needs more bytes to find/complete a frame */
            /* If file is ended and we still canâ€™t decode, drop 1 byte to resync */
            if (eof) {
                feed_len--;
                if (feed_len > 0)
                    memmove(feed, feed + 1, (size_t)feed_len);
                else
                    break;
            }
        }

        if (samples > 0) {
            /* Use PCM here. If stereo, data is interleaved L R L R ... */
            channels = info.channels;   /* 1 or 2 */
            out_count = samples * channels;

            if (sampleRate == 0) {
                sampleRate = info.hz;
            }
            if (channelCount == 0) {
                channelCount = (word)channels;
            }

            FileWrite(outF, pcm, sizeof(int16_t) * out_count, FALSE);
            totalBytes += (dword)(sizeof(int16_t) * out_count);
#ifdef TESTMP3_DUMP_PCM
            if (logF)
            {
                for (sampleLoop = 0; sampleLoop < (word)samples; sampleLoop++)
                {
                    if (channels == 2)
                    {
                        leftSample = pcm[(sampleLoop * 2) + 0];
                        rightSample = pcm[(sampleLoop * 2) + 1];
                    }
                    else
                    {
                        leftSample = pcm[sampleLoop];
                        rightSample = leftSample;
                    }
                    if (info.hz > 0)
                    {
                        logTimestamp = (sampleIndex * 1000UL) / info.hz;
                    }
                    else
                    {
                        logTimestamp = 0;
                    }
                    sprintf(logLine,
                            "%lu,%lu,%d,%d\r\n",
                            (unsigned long)sampleIndex,
                            (unsigned long)logTimestamp,
                            (int)leftSample,
                            (int)rightSample);
                    FileWrite(logF, logLine, (word)strlen(logLine), FALSE);
                    sampleIndex++;
                }
            }
#endif
        }
    }

    if ((totalBytes > 0) && (sampleRate > 0) && (channelCount > 0)) {
        dword byteRate;
        word  blockAlign;
        dword riffSize;

        memset(wavHeader, 0, WAV_HEADER_SIZE);
        wavHeader[0] = 'R';
        wavHeader[1] = 'I';
        wavHeader[2] = 'F';
        wavHeader[3] = 'F';

        riffSize = 36 + totalBytes;
        write_dword_le(wavHeader, 4, riffSize);

        wavHeader[8]  = 'W';
        wavHeader[9]  = 'A';
        wavHeader[10] = 'V';
        wavHeader[11] = 'E';

        wavHeader[12] = 'f';
        wavHeader[13] = 'm';
        wavHeader[14] = 't';
        wavHeader[15] = ' ';

        write_dword_le(wavHeader, 16, 16);      /* PCM fmt chunk size */
        write_word_le(wavHeader, 20, 1);        /* PCM format */
        write_word_le(wavHeader, 22, channelCount);
        write_dword_le(wavHeader, 24, sampleRate);

        blockAlign = (word)(channelCount * sizeof(int16_t));
        byteRate = sampleRate * (dword)blockAlign;

        write_dword_le(wavHeader, 28, byteRate);
        write_word_le(wavHeader, 32, blockAlign);
        write_word_le(wavHeader, 34, 16);

        wavHeader[36] = 'd';
        wavHeader[37] = 'a';
        wavHeader[38] = 't';
        wavHeader[39] = 'a';
        write_dword_le(wavHeader, 40, totalBytes);

        FileClose(outF, TRUE);
        /* Close and reopen so we can rewrite the header at offset 0 reliably. */
        outF = FileOpen("MP3.WAV", FILE_ACCESS_RW | FILE_DENY_RW);
        if (outF != NullHandle) {
            FileWrite(outF, wavHeader, WAV_HEADER_SIZE, FALSE);
            FileClose(outF, TRUE);
        }
        outF = NullHandle;
    } else if (outF != NullHandle) {
        FileClose(outF, TRUE);
        outF = NullHandle;
    }

    FileClose(f, TRUE);
#ifdef TESTMP3_DUMP_PCM
    FileClose(logF, TRUE);
#endif
    FilePopDir();

    MemFree(scratchH);
    MemFree(pcmH);
    MemFree(mp3dec_tH);

    return 0;
}

@method TestMP3ProcessClass, MSG_START_READING
{
    isRunning = TRUE;
    (void) decode_file();
}

@method TestMP3ProcessClass, MSG_STOP_READING
{
    isRunning = FALSE;
}
