@include <stdapp.goh>

#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include <geode.h>
#include <geos.h>
#include <file.h>
#include <stdio.h>
#include "minimp3_geos16.h"

#define FEED_BUF_SIZE  4096  /* small is fine; bigger reduces I/O calls */


/****************************************************************************
 * Constants
 ****************************************************************************/


/****************************************************************************
 * Globals
 ****************************************************************************/

// word        MPI_currentVolume = MIXER_VOLUME_MAX;
// word        MPI_previousVolume = MIXER_DEFAULT_VOLUME;
// Boolean     MPI_muted = FALSE;
// Boolean     MPI_demoMode = TRUE;


/****************************************************************************
 * Class definition
 ****************************************************************************/

@class TestMP3ProcessClass, GenProcessClass;
    @message void MSG_START_READING();
@endc;
@classdecl TestMP3ProcessClass, neverSaved;

/****************************************************************************
 * Forward declarations
 ****************************************************************************/

int decode_file(const char *path);

/****************************************************************************
 * UI Resources
 ****************************************************************************/

@start AppResource;

@visMoniker AppTextMoniker = "Test MP3";

@object GenApplicationClass AppObj = {
    GI_visMoniker = list { @AppTextMoniker };
    GI_comp = @PrimaryObj;
    gcnList(MANUFACTURER_ID_GEOWORKS, GAGCNLT_WINDOWS) = @PrimaryObj;
}

@end AppResource;

@start Interface;

@object GenPrimaryClass PrimaryObj = {
    GI_comp = @MainGroupObj;
    HINT_ORIENT_CHILDREN_VERTICALLY;
    HINT_CENTER_CHILDREN_HORIZONTALLY;
    HINT_SIZE_WINDOW_AS_DESIRED;
}

@object GenInteractionClass MainGroupObj = {
    GI_comp = @StartBut;
    HINT_ORIENT_CHILDREN_VERTICALLY;
    HINT_CENTER_CHILDREN_HORIZONTALLY;
}

@object GenTriggerClass StartBut = {
    GI_visMoniker = "Start";
    GTI_destination = process;
    GTI_actionMsg = MSG_START_READING;
}

@end Interface;


int decode_file(const char *path)
{
    FileHandle f = NullHandle;
    FileHandle outF = NullHandle;
    mp3dec_t dec;
    uint8_t  feed[FEED_BUF_SIZE];
    int      feed_len = 0;                 /* bytes currently in feed[] */
    int16_t  pcm[MINIMP3_MAX_SAMPLES_PER_FRAME]; /* 1152*2 int16 slots */
    mp3dec_frame_info_t info;
    int channels = 0;
    int out_count = 0;
    int n = 0;
    int samples = 0;
    int used = 0;

    f = FileOpen(path, FILE_ACCESS_R | FILE_DENY_NONE);
    outF = FileOpen("MP3.pcm", FILE_ACCESS_W | FILE_DENY_NONE);
    if (!f || !outF) return -1;

    mp3dec_init(&dec);

    for (;;)
    {
        /* If buffer has room, read more bytes at the end */
        if (feed_len < FEED_BUF_SIZE) {
            //int n = fread(feed + feed_len, 1, FEED_BUF_SIZE - feed_len, f);
            n = FileRead(f, feed + feed_len, FEED_BUF_SIZE - feed_len, FALSE);
            if (n > 0) feed_len += n;
        }

        /* Nothing left and no more to read? done. */
        if (feed_len == 0)
            break;

        /* Try to decode from the current buffer */
        samples = mp3dec_decode_frame(&dec, feed, feed_len, pcm, &info);

        if (info.frame_bytes > 0) {
            /* Consume the bytes the decoder used */
            used = info.frame_bytes;
            feed_len -= used;
            if (feed_len > 0)
                memmove(feed, feed + used, (size_t)feed_len);
        } else {
            /* Decoder needs more bytes to find/complete a frame */
            /* If file is ended and we still canâ€™t decode, drop 1 byte to resync */
            if (FilePos(f, 0, FILE_POS_RELATIVE) == FilePos(f, 0, FILE_POS_END)) {
                feed_len--;
                if (feed_len > 0)
                    memmove(feed, feed + 1, (size_t)feed_len);
                else
                    break;
            }
        }

        if (samples > 0) {
            /* Use PCM here. If stereo, data is interleaved L R L R ... */
            channels = info.channels;   /* 1 or 2 */
            out_count = samples * channels;

            /* TODO: play / write PCM. Example: write to stdout or device */
            // fwrite(pcm, sizeof(int16_t), out_count, out); */
            FileWrite(outF, pcm, sizeof(int16_t) * out_count, FALSE);
        }
    }

    FileClose(f, TRUE);
    FileClose(outF, TRUE);

    mp3dec_exit();

    return 0;
}

@method TestMP3ProcessClass, MSG_START_READING
{
    (void) decode_file("MP3.MP3");
}

