/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    Copyright (C) 2000 Dirk Lausecker -- All Rights Reserved

PROJECT:    BestSound
MODULE:     Soundcheck
FILE:       subcode.goc

AUTHOR:     Dirk Lausecker

ROUTINES:
    Name            Description
    ----            -----------

REVISION HISTORY:
    Name    Date        Description
    ----    ----        -----------
    DL  12.03.2000      Initial version.
        DL  15.08.2000  Translation for ND

DESCRIPTION:

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

@include <bsnwav.goh>

#include <gstring.h>
#include <Ansi/stdio.h>
#include <Ansi/string.h>

#include <timer.h>
#include <file.h>
@include <wav.goh>
@include <stdapp.goh>

@include "UI/uimain.goh"
@include "Main/process.goh"
@include "Main/subcode.goh"
@include "Main/globals.goh"


// SoundBlaster 16 Hardware I/O Specification
// Use these as an offset from the base
// address (i.e. 0x220 + SB_IO_XX.)
#define  SB_IO_FM_REG_A                0x00
#define  SB_IO_FM_DATA_A               0x01
#define  SB_IO_FM_REG_B                0x02
#define  SB_IO_FM_DATA_B               0x03
#define  SB_IO_MIXER_REG               0x04
#define  SB_IO_MIXER_DATA              0x05
#define  SB_IO_RESET                   0x06
#define  SB_IO_FM_REG                  0x08
#define  SB_IO_FM_DATA                 0x09
#define  SB_IO_READ                    0x0A
#define  SB_IO_COMMAND                 0x0C
#define  SB_IO_STATUS                  0x0E

// SoundBlaster Commands to pass via SB_IO_COMMAND (0xc)
#define  SB_COMMAND_SET_MONO        0xA0
#define  SB_COMMAND_SET_STEREO      0xA8
#define  SB_COMMAND_SPEAKER_ON      0xD1
#define  SB_COMMAND_SPEAKER_OFF     0xD3
#define  SB_COMMAND_GET_VERSION     0xE1

#define  OPL3_REG_TIMER_CONTROL     0x04

#define  IRQ_RESET          0x80
#define  TIMER1_MASK            0x40
#define  TIMER2_MASK            0x20

// Delay values for Sound Blaster I/O operations
#define SC_DELAY       6
#define SC_LONG_DELAY  36



/************************************************

    SC_CreatePlayThread

 ************************************************/

void    _pascal SC_CreatePlayThread(void)
{

    playThreadRunState = PLAY_THREAD_RUN;

    if(!ThreadCreate(PRIORITY_HIGH,
                     (word)0,
                     PlayThreadLoop,   // Pointer to entry routine
                     3000,             // Size of the stack for the new thread
                     GeodeGetProcessHandle()))
    {
        // error
        SysNotify(SNF_CONTINUE,"Playthread","could not be created !");
    };
}

/************************************************

    SC_ControlTimer

    Play-Timer init. / disable

   IN:  playTimerID

 ************************************************/

void    _pascal SC_ControlTimer(word flags)
{
    // detect Mode (Init/Disable)
    if (flags & PLAY_TIMER_ON)
    {
        // Timer init.
        if (playTH==NullHandle)
        {
            // TimerID is zero -> OK
            playTH = TimerStart(TIMER_EVENT_CONTINUAL,
                                HandleToOptr(GeodeGetProcessHandle()),
                                1,
                                MSG_SC_PROCESS_PLAY_TIMER,
                                30,
                                &playTimerID);
        };
    }
    else
    {
        // disable Timer
        if (playTH)
        {
            TimerStop(playTH,playTimerID);
            playTimerID = 0;
            playTH = NullHandle;
        };
    };
}

/************************************************

    PlayThreadLoop

    Mainloop for PLAY


 IN:    statusFlags     playFlag

 OUT:   playThreadRunState = PLAY_THREAD_OFF

 ************************************************/

#pragma argsused
word    PlayThreadLoop(word dummy)
{

    char        fileName[13];
    word        output;
    word        error;

    while (playThreadRunState == PLAY_THREAD_RUN)
    {
        // PLAY
        // If playThreadFlag is not zero, the parameters
        // for rate, bits, channel will be read and a
        // WAV-file with the testsignal will be created.

        if (playThreadFlag)
        {
            if (lastFlag != playThreadFlag)
            {
                // get parameters from UI
                sampleRate = @call WAVSamplerateItemGroup::MSG_GEN_ITEM_GROUP_GET_SELECTION();
                bits       = @call WAVBitsItemGroup::MSG_GEN_ITEM_GROUP_GET_SELECTION();
                channels   = @call WAVChannelsItemGroup::MSG_GEN_ITEM_GROUP_GET_SELECTION();

                // create filename
                if (channels == 1)
                {
                    sprintf(fileName,"SC%dM%d.WAV",sampleRate,bits);
                }
                else
                {
                    sprintf(fileName,"SC%dST%d.WAV",sampleRate,bits);
                };

                // delete old file (not in endless mode !)
                FilePushDir();
                FileSetStandardPath(SP_DOCUMENT);

                if (playThreadFlag != PLAY_CONT)
                {
                    error = FileDelete(fileName);
                };

                // if the deleting was not successful,
                // the old file will be used
                if (error == ERROR_FILE_IN_USE)
                {
                    scfh = FileOpen(fileName,(FILE_ACCESS_R | FILE_DENY_NONE));
                    FilePopDir();
                }
                else
                {
                    scfh = 0;
                };

                // close the file if opened
                if (scfh)
                {
                    (void)FileClose(scfh,FALSE);
                }

                // scfh indicates the existence of an file
                // that can not be deleted and must be used
                // for the playing


                // create new testfile
                if ((scfh == 0) || (playThreadFlag == PLAY_FILE) )
                {
                    switch (sampleRate)
                    {
                        case 11 : sampleRate = 11025; break;
                        case 22 : sampleRate = 22050; break;
                        case 44 : sampleRate = 44100; break;
                        default : sampleRate = 44100; break;
                    };

                    SC_CreateWaveFile(fileName);
                    scfh = 0;
                };

                // rename "Play (endless)" into STOP
                if (playThreadFlag == PLAY_CONT)
                {
                    @send MainSub3Trigger2::MSG_GEN_REPLACE_VIS_MONIKER_TEXT("STOP",VUM_NOW);
                };
            };

            // save state for next loop
            lastFlag = playThreadFlag;

            // open testfile (not in "file mode")
            if (playThreadFlag != PLAY_FILE)
            {
                FilePushDir();
                FileSetStandardPath(SP_DOCUMENT);
                scfh = FileOpen(fileName,(FILE_ACCESS_R | FILE_DENY_NONE));
                FilePopDir();

                // read current selection
                output = @call OutputItemGroup::MSG_GEN_ITEM_GROUP_GET_SELECTION();

                // output
                switch (output)
                {
                    case 1 : PlaySoundFromFile(scfh) ; break;
                    case 2 : BSNWavePlayFile(scfh,
                                                 (BSNW_WAIT_FOR_FREE|BSNW_SHOW_ERROR_MSG),
                                                 0); break;
                    default: break;
                };

                (void)FileClose(scfh,FALSE);
                scfh = 0;
            };

            // reset Flag
            if (playThreadFlag != PLAY_CONT)
            {
                playThreadFlag = 0;
                lastFlag = 0;
            };
        }
        else
        {
            // idle
            TimerSleep(30);
        };
    };

    playThreadRunState = PLAY_THREAD_OFF;
    ThreadDestroy(0, 0, 0);
    return (0);
}

/**********************************************************

        SC_SetAnswerGlyph

 IN:    op  optr to GenGlyph obj
        bool    TRUE --> OK FALSE --> X

 **********************************************************/

void    _pascal SC_SetAnswerGlyph(optr op,Boolean bool)
{
    optr    vm;     // VisMoniker

    if (colorFlag)
    {
        if (bool)
        {
            vm = @OKVGAMoniker;
        }
        else
        {
            vm = @ErrorVGAMoniker;
        };
    }
    else
    {
        if (bool)
        {
            vm = @OKMonoMoniker;
        }
        else
        {
            vm = @ErrorMonoMoniker;
        };
    }

    (void)@call op::MSG_GEN_REPLACE_VIS_MONIKER_OPTR(vm,VUM_DELAYED_VIA_APP_QUEUE);

}

/***********************************************************************
 *      SC_FMCommand
 ***********************************************************************
 * SYNOPSIS:        Issue a low-level Sound Card OPL3 FM command
 *                  and return the result.
 * PARAMETERS:      int  addr   = base address for card communication (0x220|0x240|0x388)
 *                  uint reg    = OPL3 register sub-address to call on card
 *                  uint value  = data to pass to OPL3 card function
 * SIDE EFFECTS:
 * STRATEGY:        Write out to the io address with the command register,
 *                  followed by the value argument for that hardware command.
 *                  Add delays for proper timing on old hardware.
 *
 * REVISION HISTORY:
 *  Name    Date        Description
 *  ----    ----        -----------
 *  martin  2001/2/6    Initial version
 *
 ***********************************************************************/
byte SC_FMCommand(int addr, byte reg, byte value)
{
    byte result;

    /*
     * SoundBlaster 16 will work at SB_IO_FM_REG_A, but older SoundBlaster cards
     * export the Yamaha OPL2 FM functions on SB_IO_FM_REG, so we use the later.
     *   (base + 0x08 instead of base + 0x00)
     */
    addr += SB_IO_FM_REG;

    /* Output the OPL3 command through the SoundBlaster IO register. */
    SC_AsmOut (addr + SB_IO_FM_REG_A,  reg);
    SC_AsmDelay (addr + SB_IO_FM_REG_A,  SC_DELAY);
    SC_AsmOut (addr + SB_IO_FM_DATA_A, value);
    SC_AsmDelay (addr + SB_IO_FM_REG_A,  SC_LONG_DELAY);
    result = SC_AsmIn (addr + SB_IO_FM_REG_A);

    return result;
}

/***********************************************************************
 * SC_TestSoundcard
 ***********************************************************************
 * SYNOPSIS:    Test for a Yamaha OPL2, OPL3, or OPL4 audio chipset on card.
 * PARAMETERS:
 *    IN:   -
 *    OUT:  word    address / 0 --> no soundcard found
 *
 * SIDE EFFECTS:
 * STRATEGY:
 *
 * REVISION HISTORY:
 *  Name    Date        Description
 *  ----    ----        -----------
 *  DL  2000/12/3       Initial version
 *  martin  2001/2/6    Added OPL2 check, and increased address range
 *
 ***********************************************************************/
word _pascal SC_TestSoundcard(void)
{
    word     addr = 0x220;
    word     inc  = 0x020;
    Boolean  foundFlag = 0;

    // Test at: 220h..280h (SoundBlaster 1.5,Pro,16 interface)
    // And at:  388h..3a8h (Yamaha OPL3 FM interface)
    do {
        // This is the official detection sequence for OPL2 cards.
        // 1) Reset Timer 1 and Timer 2 by writing 60h to register 4.
        // 2) Reset the IRQ by writing 80h to register 4.
        // 3) Read status register.
        foundFlag = SC_FMCommand(addr, OPL3_REG_TIMER_CONTROL, TIMER1_MASK | TIMER2_MASK);
        foundFlag = SC_FMCommand(addr, OPL3_REG_TIMER_CONTROL, IRQ_RESET);
        switch (foundFlag) {
            case 0x06:  /* OPL2 found! SoundBlaster (up to Pro I) */
            case 0x00:  /* OPL3 found! SoundBlaster 16/Pro II */
            case 0x0f:  /* OPL4 found! */
            case 0x02:  /* OPL4 found! */
                foundFlag = 1;
                break;

            default:
                // If we didn't find the OPL2, then do a quick check
                // of the SB command register to make sure an older
                // card isn't skipped.
                foundFlag = SC_WaitDSP(addr + SB_IO_COMMAND, DSP_WAIT_WRITE);
                if (foundFlag) break;

                // Well, no card is at the current address, so reset "foundFlag"
                // and forward to the next address in the search range.
                foundFlag = 0;
                addr = addr + inc;
                if (addr == 0x2a0) {
                    addr = 0x388;
                    inc  = 0x010;
                }
        }

    } while ( (addr < 0x3a9) && (!foundFlag) );

    if (!foundFlag) {
        addr = 0;       // no SB-komp. soundcard found
    } else {
        foundFlag = SC_GetDSPVersion(addr);
    }

    return (addr);
}



/**********************************************************

 SC_WaitDSP

    check statusregister

 IN:    adr 2xc
 OUT:   Boolean     TRUE --> DSP is ready

    READ    2xe Bit 7=H ->data ready
    WRITE   2xc Bit 7=L ->ready for write

 **********************************************************/

#define SC_WAIT_TIMEOUT 30

Boolean _pascal SC_WaitDSP(word addr, Boolean direction)
{
    byte    input;
    int i = 0;

    if (direction == DSP_WAIT_READ)
    {
        addr = addr + 2;
    }
    do
    {
        TimerSleep(1);
        i++;

        // request state until:
        // 1. Bit 7 not set / reset (Read/Write)
        // 2. Timeoutlimit OK
        input = SC_AsmIn(addr);

    } while (   (i<SC_WAIT_TIMEOUT)
                && ((input > 128) != (direction == DSP_WAIT_READ)));

    return(i<SC_WAIT_TIMEOUT);
}

/**********************************************************

 SC_GetDSPVersion

    request DSP-Version

 OUT:   word        DSP-Version

  REVISION HISTORY:
    Name    Date        Description
    ----    ----        -----------
    DL  2000/12/3       Initial version.
    martin  2001/2/5    Revised to use SC_Out, SC_In
    martin  2001/2/7    Fixed bad detection by adding reset

***********************************************************/
word    _pascal SC_GetDSPVersion(word addr)
{
    byte    major = 0, minor = 0;
    word    ver = 0;    // Version

    // Reset the card first so we don't get the wrong version.
    SC_AsmReset(addr);

    // Now query the version number.
    SC_AsmOut(addr + SB_IO_COMMAND, SB_COMMAND_GET_VERSION);
    SC_WaitDSP(addr + SB_IO_READ, DSP_WAIT_READ);
    major = SC_AsmIn(addr + SB_IO_READ);
    SC_WaitDSP(addr + SB_IO_READ, DSP_WAIT_READ);
    minor = SC_AsmIn(addr + SB_IO_READ);

    ver = ((major << 8) | minor);
    if ((ver > 0x500) || (ver < 0x0100))
    {
        ver = 0;
    };
    dspVersion = ver;

    return (ver);
}

/**********************************************************

 SC_Create_Viertel

 IN *char   fileName
    word    sampleRate
    word    bits
    word    channels

 **********************************************************/

#define SC_SCHWINGUNG   48      //JMG 12/24/00
#define SC_CR_POSITIV   TRUE
#define SC_CR_NEGATIV   FALSE
#define SC_CR_STEIG TRUE
#define SC_CR_FALLEND   FALSE


//word  sinus[]={ {    0},{ 4663},{ 9232},{13612},{17716}, \
//                    {21458},{24764},{27566},{29807},{31441}, \
//          {32434},{32767} };

// JM 12/24/00 expanded sample list to 13 values, either used 0 to 11 or 12 to 1,
// to avoid first and last value being used twice.
// Now all three sample rates result in ~920Hz pure sinus
word    sinus[]= {   {    0},{ 4277},{ 8480},{12539},{16384},{19947},
    {23170},{25996},{28377},{30273},{31651},{32487},{32767}
};
byte    sampArray[100];

word    SC_Create_Viertel(word index,word interleave,Boolean positiv, Boolean steigend, word samples)
{
    int i=0,k,ind;
    dword   value;


    if (steigend)
    {
        ind = 0;
        k = interleave;
    }
    else
    {
        ind = 12;       // JMG 12/24/00 (runs 12 to 1 instead of 11 to 0)
        k = 0 - interleave;
    };


    for (i=0; i<samples; i++)
    {
        value = (dword)sinus[ind];

        if (bits==8)
        {
            if (positiv)
            {
                value = value + (128 * 256);
            }
            else
            {
                value = (128 * 256) - value;
            }

        }
        else
        {

            if (!positiv)
            {
                value = 0 - value;
            };
        };

        // save Samples
        ind = ind + k;

        if (bits == 16)
        {
            sampArray[index] = (byte)(value& 0x00ff);
            index++;
        };

        sampArray[index] = (byte)(value>>8);
        index++;

        if (channels == 2)
        {
// LA 19.12.2000 Bugfix for Stereo WAV's
//              ind = ind + k;

            if (bits == 16)
            {
                sampArray[index] = (byte)(value& 0x00ff);
                index++;
            };

            sampArray[index] = (byte)(value>>8);
            index++;
        };
    };

    return(index);
}

/**********************************************************

 SC_CreateWaveFile

    create WAV-file with test signal (sine wave)


 IN:    fileName    Name of file to be created
    (global)    sampleRate

 **********************************************************/

// char    completeString[] = "Eine WAV-Datei mit dem Namen \x01 wurde im DOCUMENT-Verzeichnis angelegt !";
// char    errorString[] = "An error occurred while creating the .WAV file.";
char    completeString[] = "A .WAV file with the name \x01 was created in the Document folder.";
char    errorString[] = "An error occurred while creating the .WAV file.";

void    SC_CreateWaveFile(char *fileName)
{
    word    error = 0;
    dword   len,fullLen;
    word    samples,j,interleave;
    char    tempText[30];
    word    prozent;
    word    oldprozent = 0;

    // create Header
    len = @call LenValue::MSG_GEN_VALUE_GET_INTEGER_VALUE();

    if (SC_CreateHeader(fileName, len))
    {
        // error !
    }
    else
    {
        /////////// fill WAV-files //////////////
        // initiate statusdisplay
        @call CreateProgressBox::MSG_GEN_INTERACTION_INITIATE();
        TimerSleep(20);

        // calculate number of samples
        len = len * (dword)sampleRate;

        // create wave
        interleave = (44100/sampleRate);
        samples = (word)SC_SCHWINGUNG/interleave;
        samples = samples/4;

        j = 0;
        j = SC_Create_Viertel(j,interleave,SC_CR_POSITIV,SC_CR_STEIG,samples);
        j = SC_Create_Viertel(j,interleave,SC_CR_POSITIV,SC_CR_FALLEND,samples);
        j = SC_Create_Viertel(j,interleave,SC_CR_NEGATIV,SC_CR_STEIG,samples);
        j = SC_Create_Viertel(j,interleave,SC_CR_NEGATIV,SC_CR_FALLEND,samples);

        // createloop
        fullLen = byteLen;
        while (byteLen>0 && !error)
        {
            // (Statusdisplay: (len go down to zero) )
            prozent = 100-(word)((byteLen*100)/fullLen);
            if (prozent > (oldprozent+9))
            {
                sprintf (tempText,"%d%%",prozent);
                @call CreateProgressGlyph::MSG_GEN_REPLACE_VIS_MONIKER_TEXT(tempText,VUM_NOW);
                oldprozent = prozent;
            };

            if (byteLen<(dword)j)
            {
                j = byteLen;
                byteLen = 0;
            }
            else
            {
                byteLen = byteLen - (dword)j;
            };

            error = FileWrite(scfh,
                              sampArray,
                              j,
                              FALSE);
            error = 0;
        };

        // (shutdown statusdisplay)
        @call CreateProgressBox::MSG_GEN_GUP_INTERACTION_COMMAND(IC_DISMISS);

        // "file create" mode
        if (playThreadFlag == PLAY_FILE)
        {
            if (error)
            {
                // error
                (void) UserStandardDialog((char *)0,
                                          (char *)0,
                                          (char *)0,
                                          0,        // arg1
                                          errorString,  // string
                                          (CDT_ERROR << CDBF_DIALOG_TYPE_OFFSET) |
                                          (GIT_NOTIFICATION << CDBF_INTERACTION_TYPE_OFFSET));
            }
            else
            {
                // Complete message
                (void) UserStandardDialog((char *)0,
                                          (char *)0,
                                          (char *)0,
                                          fileName, // arg1
                                          completeString,       // string
                                          (CDT_NOTIFICATION << CDBF_DIALOG_TYPE_OFFSET) |
                                          (GIT_NOTIFICATION << CDBF_INTERACTION_TYPE_OFFSET));
            };
        };


        // Close file
        (word)FileClose(scfh,FALSE);
    };
}

/*************************************
 *
 * SC_CreateHeader
 * Create a temporary file
 *
 * IN:  fileName - Name of the file to create, len - Length of the file in samples
 * OUT: TRUE Error occurred
 *  recTempFileHandle
 *
 *************************************/

Boolean _pascal SC_CreateHeader(char *fileName, dword len)
{
    Boolean     back = FALSE;   // error flag
    word        error;
    dword       avgRate;

    // initial. structure
    strncpy(bwfh.BWFH_typRIFF,"RIFF",4); // "RIFF"
    strncpy(bwfh.BWFH_formName,"WAVE",4);       //"WAVE"
    strncpy(bwfh.BWFH_typFMT,"fmt ",4);     //"fmt "
    bwfh.BWFH_fmtLen = sizeof(BSWavFormChunk);  //16
    bwfh.BWFH_fmtChunk.BWFC_dataFormat = 1;
    strncpy(bwfh.BWFH_typData,"data",4);        //"data"

    // update Header
    avgRate = (dword)sampleRate;
    avgRate = avgRate * (dword)channels;
    avgRate = avgRate * (dword)(bits/8);
    bwfh.BWFH_fmtChunk.BWFC_sampleRate = (dword)sampleRate;
    bwfh.BWFH_fmtChunk.BWFC_avgRate = avgRate;
    bwfh.BWFH_fmtChunk.BWFC_blockAlign = (channels*(bits/8));
    bwfh.BWFH_fmtChunk.BWFC_channels = (word)channels;      // channels
    bwfh.BWFH_fmtChunk.BWFC_bitsPerSample = (word)bits;
    byteLen = len * (dword)sampleRate * (bwfh.BWFH_fmtChunk.BWFC_blockAlign); // Chunk length in Bytes
    bwfh.BWFH_datLen = byteLen;
    bwfh.BWFH_fullLen = byteLen + 36;

    // create file
    FilePushDir();
    FileSetStandardPath(SP_DOCUMENT);
    scfh = FileCreate( fileName,
                       (FILE_CREATE_TRUNCATE|FCF_NATIVE|FILE_ACCESS_RW|FILE_DENY_RW),
                       FA_ARCHIVE);  /**/
    FilePopDir();

    if (scfh == NullHandle)
    {
        // error reading file
        back = TRUE;
    }
    else
    {
        // file creating OK
        // structure of header
        error = FileWrite(scfh,
                          &bwfh,
                          sizeof(BSWavFileHeader),
                          FALSE);

        back = (error==0);
    };

    return (back);
}
