/*************************************************************************
Project: BackDoor Man
Started: 17.07.99
Revision 1: 17.12.00
Author: MeyerK
Freeware
*************************************************************************/


/*Include files***********************************************************/

@include <globals.goh>
@include <utils.goh>
@include <fmtool.goh>
#include "initfile.h"
#include "file.h"


/* Global variables -----------------------------------------------------*/
Boolean                    delSLMode = FALSE;
OptionsType                opts = ((EXIT_AFTER_LAUNCH) | (SBC_TEXT) & (~MINI_MODE));
optr                       sbgOptr = NULL;

/* Fuer Arbeiten mit der INI-Datei --------------------------------------*/
shortstr                   monik          = "";
strbuf                     buffer         = "";
char*                      pb             = &buffer;

int                        fehler         = FALSE;
InitFileReadFlags          flags          = ((IFCC_INTACT << IFRF_CHAR_CONVERT_OFFSET) | IFRF_READ_ALL | IFRF_FIRST_ONLY | IFRF_SIZE);
word                       *dataSize      = NULL;

/* Diverse MemHandles -----------------------------------------------------*/
MemHandle                   FilesHan;
FilesStruct*                FilesPtr;
MemHandle                   selFiles = NullHandle; /* passed by the SendTo FM Plug */

/*Token Informationen------------------------------------------------------*/
FileExtendedAttribute      attr = FEA_TOKEN;
GeodeToken                 tokenBuffer;
word                       bufSize = 6;

MemHandle                  tdelTokenList  = NULL;
word                       tdelTokenCount = 0;

/*Flag, was gerade selektiert ist------------------------------------------*/
FilterType                 WhichApps = FT_APPS;

/*Class & Message Definitions ---------------------------------------------*/
@class  bmProcessClass, GenProcessClass;
   /* Choices */
   @message (GEN_ITEM_GROUP_APPLY_MSG) MSG_FFS_CHOOSE_FILTER_TYPE;
   @message (GEN_ITEM_GROUP_APPLY_MSG) MSG_SBC_TOGGLE_CHOICES;
   @message (GEN_BOOLEAN_GROUP_STATUS_MSG) MSG_OPTIONS_TOGGLE_STATUS;

   /* FileSelector Messages */
   @message (GEN_FILE_SELECTOR_NOTIFICATION_MSG) MSG_FILEBROW_SELECTOR_ACTION;

   /* Launcher */
   @message void MSG_ADD_SOFT_LAUNCHER();
   @message (GEN_TRIGGER_ACTION) MSG_SOFT_LAUNCHER_PRESSED;

   @message void MSG_INIT_BM_WITH_UI();
   @message void MSG_SWITCH_SHOW_MODE();
   @message void MSG_EXIT_BM();

   @message void MSG_USE_FILE();

   /* Token Messages */
   @message (GEN_DYNAMIC_LIST_QUERY_MSG) MSG_QUERY_TOKEN;
   @message (GEN_ITEM_GROUP_STATUS_MSG) MSG_TOKEN_SELECTED;
   @message void MSG_USE_TOKEN();

   /* Send To */
   @message void MSG_ADD_SEND_TO_TRIGGERS();
   @message (GEN_TRIGGER_ACTION) MSG_SEND_TO_TRIGGER_PRESSED;
   @message (GEN_TRIGGER_ACTION) MSG_SEND_TO_XCLOSE_PRESSED;
@endc

/* Klassendeklaration ----------------------------------------------------*/
@classdecl      bmProcessClass, neverSaved;

/*UI Objects --------------------------------------------------------------*/

/*Application Object-------------------------------------------------------*/
@start APPRESOURCE;

@object GenApplicationClass bmApp = {
   GI_visMoniker = list {@TextMoniker,
                         @Moniker0,
                         @Moniker1,
                         @Moniker2,
                         @Moniker3,
                         @Moniker4,
                         @Moniker5,
                         @Moniker6,
                         @Moniker7,
                         @Moniker8};

   GI_comp = @bmPrimary, @bmSendToPrimary;
   gcnList(MANUFACTURER_ID_GEOWORKS,GAGCNLT_WINDOWS) = @bmPrimary, @bmSendToPrimary;
}
@ifdef ENG
@ifdef R4
  @visMoniker TextMoniker = "BackDoor Man - R4E";
@else
  @visMoniker TextMoniker = "BackDoor Man - R3E";
@endif
@else
@ifdef R4
  @visMoniker TextMoniker = "BackDoor Man - R4D";
@else
  @visMoniker TextMoniker = "BackDoor Man - R3D";
@endif
@endif

@include "ART/moniker.goh"

@end APPRESOURCE


/*Interface ---------------------------------------------------------------*/

@start  INTERFACE;

/* Hauptfenster -----------------------------------------------------------*/
@object GenPrimaryClass bmPrimary = {
   GI_comp =
                  @OptionsMenu,
/*                @RestartText,*/
/*                @AnyValue,*/
                  @hintGlyph,
                  @bmMainGroup,
                  @bmReplyBar;

   ATTR_GEN_DISPLAY_NOT_MAXIMIZABLE;
   HINT_PRIMARY_NO_FILE_MENU;
   HINT_ORIENT_CHILDREN_VERTICALLY;
   HINT_CENTER_CHILDREN_VERTICALLY;
   HINT_SIZE_WINDOW_AS_DESIRED;
   HINT_DISPLAY_NOT_RESIZABLE;
   HINT_CENTER_WINDOW;
}

/*- Options-Menu ---------------------------------------------------------*/
@object GenInteractionClass OptionsMenu = {
   GI_comp =
              @ModeTrigger,
              @SoftLauncherChoicesGroup,
              @ToggleGroup,
              @AboutDialog;

   GII_visibility = GIV_POPUP;

   ATTR_GEN_INTERACTION_GROUP_TYPE = (GIGT_OPTIONS_MENU);
}


/* Anzeigemodus-Trigger ---------------------------------------------------*/
@object GenTriggerClass ModeTrigger = {
@ifdef ENG
   GI_visMoniker = 'M', "Switch Show Mode";
@else
   GI_visMoniker = 'm', "Anzeigemodus";
@endif
   GTI_destination = process;
   GTI_actionMsg = MSG_SWITCH_SHOW_MODE;
}

/* Choices Gruppe --------------------------------------------------------*/
@object GenItemGroupClass SoftLauncherChoices = {
      GI_comp = @IconChoice,
                @TextChoice
@ifdef R4
                ,@IconAndTextChoice,
                @BigIconAndTextChoice;
@else
                ;
@endif
      GIGI_destination = process;
      GIGI_applyMsg = MSG_SBC_TOGGLE_CHOICES;
      HINT_ORIENT_CHILDREN_VERTICALLY;
      HINT_ITEM_GROUP_RADIO_BUTTON_STYLE;
}

/* Normal GEODES choice --------------------------------------------------*/
@object GenItemClass IconChoice = {
@ifdef ENG
   GI_visMoniker = 'I', "Big Icon";
@else
   GI_visMoniker = 'I', "Grosses Icon";
@endif

   GII_identifier = SBC_ICON;
}

/* NB Apps choice --------------------------------------------------------*/
@object GenItemClass TextChoice = {
@ifdef ENG
   GI_visMoniker = 'e', "Text";
@else
   GI_visMoniker = 'e', "Text";
@endif

      GII_identifier = SBC_TEXT;
}

/* NB Apps choice --------------------------------------------------------*/
@object GenItemClass BigIconAndTextChoice = {
@ifdef ENG
   GI_visMoniker = 'n', "Big Icon With Text";
@else
   GI_visMoniker = 'n', "Grosses Icon mit Text";
@endif

      GII_identifier = SBC_BIG_ICON_AND_TEXT;
}

/* NB Apps choice --------------------------------------------------------*/
@object GenItemClass IconAndTextChoice = {
@ifdef ENG
   GI_visMoniker = 'S', "Small Icon With Text";
@else
   GI_visMoniker = 'l', "Kleines Icon mit Text";
@endif

      GII_identifier = SBC_ICON_AND_TEXT;
}


/* Toggle Group ----------------------------------------------------------*/
@object GenBooleanGroupClass ToggleGroup = {
      GI_comp = @RemoveSoftLauncherToggle,
                @ExitToggle;
      GBGI_destination = process;
      ATTR_GEN_BOOLEAN_GROUP_STATUS_MSG = MSG_OPTIONS_TOGGLE_STATUS;
}

/* Remove Toggle selbst ------------------------------------------------*/
@object GenBooleanClass RemoveSoftLauncherToggle = {
@ifdef ENG
   GI_visMoniker = 'R', "Remove 'Hot Apps' by clicking on them";
@else
   GI_visMoniker = 'f', "Schnellstarter mit Klick entfernen";
@endif
      GBI_identifier = REMOVE_ON;
}

/* Exit Toggle selbst ------------------------------------------------*/
@object GenBooleanClass ExitToggle = {
@ifdef ENG
   GI_visMoniker = 'Q', "Quit BM After Launch";
@else
   GI_visMoniker = 'V', "Nach Starten BM Verlassen";
@endif
      GBI_identifier = EXIT_AFTER_LAUNCH;
}

/* Choices Gruppe --------------------------------------------------------*/
@object GenInteractionClass SoftLauncherChoicesGroup = {
@ifdef ENG
   GI_visMoniker = 'A', "'Hot Apps' View";
@else
   GI_visMoniker = 'A', "Schnellstarter Ansicht";
@endif
   GI_comp = @SoftLauncherChoices;
   GII_visibility = GIV_POPUP;
}

/* TextObjekt -------------------------------------------------------------*/
@object GenTextClass RestartText = {
   GI_attrs = @default;
   GTXI_maxLength = 3000;
   GTXI_destination = process;
   GTXI_text = "";
}

/* Numbers ----------------------------------------------------------------*/
@object GenValueClass AnyValue = {
    GI_visMoniker = "Numbers";
    GVLI_destination = process;
    GVLI_minimum = MakeWWFixed(0);
    GVLI_maximum = MakeWWFixed(1000);
    GVLI_increment = MakeWWFixed(1.0);
}

/* TextObjekt -------------------------------------------------------------*/
@object GenGlyphClass hintGlyph = {
}

/* Haupt Gruppe -----------------------------------------------------------*/
@object GenInteractionClass bmMainGroup = {
   GI_comp =
                  @FileSelectorGroup;

   HINT_ORIENT_CHILDREN_HORIZONTALLY;
   HINT_CENTER_CHILDREN_HORIZONTALLY;
   HINT_EXPAND_WIDTH_TO_FIT_PARENT;
}

/* File-Selector Gruppe ---------------------------------------------------*/
@object GenInteractionClass FileSelectorGroup = {
   GI_comp =
              @bmFileSelector,
              @FilterChoices;

   HINT_ORIENT_CHILDREN_VERTICALLY;
   HINT_EXPAND_HEIGHT_TO_FIT_PARENT;
}

/* File Selector ----------------------------------------------------------*/
@object GenFileSelectorClass bmFileSelector = {
   GFSI_destination = process;
   GFSI_notificationMsg = MSG_FILEBROW_SELECTOR_ACTION;
   GFSI_attrs =           ((FSA_ALLOW_CHANGE_DIRS) & (~FSA_SHOW_FILES_DISABLED) & (~FSA_HAS_OPEN_DIR_BUTTON) & (~FSA_HAS_CHANGE_DIRECTORY_LIST))
                        | ((FSA_HAS_FILE_LIST) & (~FSA_SHOW_FIXED_DISKS_ONLY) & (~FSA_HAS_CLOSE_DIR_BUTTON) & (~FSA_HAS_DOCUMENT_BUTTON)& (~FSA_HAS_CHANGE_DRIVE_LIST))
                        | ((FSA_USE_VIRTUAL_ROOT));

   GFSI_fileCriteria =      ((FSFC_DIRS) & (~FSFC_NON_GEOS_FILES))
                          | ((FSFC_GEOS_EXECUTABLES) & (~FSFC_GEOS_NON_EXECUTABLES));

   ATTR_GEN_FILE_SELECTOR_VIRTUAL_ROOT = {SP_APPLICATION, ""};
   ATTR_GEN_PATH_DATA = {SP_APPLICATION, ""};
   HINT_FILE_SELECTOR_FILE_LIST_WIDTH = 40;
   HINT_FILE_SELECTOR_NUMBER_OF_FILES_TO_SHOW = 20;
}

/* Choices Gruppe --------------------------------------------------------*/
@object GenItemGroupClass FilterChoices = {
      GI_comp =
                /*@SeeAppsChoice,
                @SeeNBAppsChoice*/;
      GIGI_destination = process;
      GIGI_applyMsg = MSG_FFS_CHOOSE_FILTER_TYPE;
      GIGI_selection = FT_APPS;

      HINT_ORIENT_CHILDREN_HORIZONTALLY;
}

/* Normal GEODES choice --------------------------------------------------*/
@object GenItemClass SeeAppsChoice = {
@ifdef ENG
   GI_visMoniker = 'A', "Applications";
@else
   GI_visMoniker = 'A', "Applikationen";
@endif

   GII_identifier = FT_APPS;
}

/* NB Apps choice --------------------------------------------------------*/
@object GenItemClass SeeNBAppsChoice = {
@ifdef ENG
   GI_visMoniker = 'N', "NewBasic Applications";
@else
   GI_visMoniker = 'N', "NewBasic Applikationen";
@endif

      GII_identifier = FT_NB_APPS;
}

/* ReplyBar ----------------------------------------------------------------*/
@object GenInteractionClass bmReplyBar = {
   GI_comp = @UseFileTrigger,
             @SelectTokenDialog,
             @AddTrigger;

   HINT_MAKE_REPLY_BAR;
}

/* Ok-Button --------------------------------------------------------------*/
@object GenTriggerClass UseFileTrigger = {
@ifdef ENG
   GI_visMoniker = 'u', "Launch";
@else
   GI_visMoniker = 'r', "Starten";
@endif

   GTI_destination = process;
   GTI_actionMsg = MSG_USE_FILE;

   ATTR_GEN_FOCUS_HELP = @launch_bub;
   HINT_DEFAULT_DEFAULT_ACTION;
   HINT_SEEK_REPLY_BAR;
}

/* Add-Button -------------------------------------------------------------*/
@object GenTriggerClass AddTrigger = {
@ifdef ENG
   GI_visMoniker = 'o', "Make a 'Hot App'";
@else
   GI_visMoniker = 'l', "Als 'Schnellstarter'";
@endif

   GTI_destination = process;
   GTI_actionMsg = MSG_ADD_SOFT_LAUNCHER;

   ATTR_GEN_FOCUS_HELP = @hotapp_bub;
   HINT_SEEK_REPLY_BAR;
}
@end INTERFACE;


@start TEMPLATES;

/* SoftLauncherBar-Selector Gruppe -------------------------------------------*/
@object GenInteractionClass SoftLauncherGroupTempl = {
@ifdef ENG
   GI_visMoniker = " 'Hot Apps': ";
@else
   GI_visMoniker = " 'Schnellstarter': ";
@endif

   GI_states = @default & (~GS_USABLE);
   GII_visibility = GIV_POPOUT;

   HINT_DRAW_IN_BOX;
   HINT_ORIENT_CHILDREN_VERTICALLY;
   HINT_LEFT_JUSTIFY_CHILDREN;
   HINT_ALLOW_CHILDREN_TO_WRAP;
   HINT_WRAP_AFTER_CHILD_COUNT = 10;
}

/* SoftLaunchTrigger ------------------------------------------------------*/
@object GenTriggerClass SoftLauncherTempl = {
   GI_states = @default & ~GS_USABLE;
   GI_visMoniker = "";
   GTI_destination = process;
   GTI_actionMsg = MSG_SOFT_LAUNCHER_PRESSED;

   HINT_EXPAND_WIDTH_TO_FIT_PARENT;
}

/* SendToTriggerTempl ------------------------------------------------------*/
@object GenTriggerClass SendToTriggerTempl = {
   GI_states = @default & ~GS_USABLE;
   GI_visMoniker = "";
   GTI_destination = process;
   GTI_actionMsg = MSG_SEND_TO_TRIGGER_PRESSED;

   HINT_EXPAND_WIDTH_TO_FIT_PARENT;
}

@end TEMPLATES;


/*Send To Interface -------------------------------------------------------*/
@start  SENDTORSC;

/* zweites Primary f�r SendTo Funktion... ----------------------------------*/
@object GenPrimaryClass bmSendToPrimary = {
  GI_visMoniker = "";
  GI_states = @default & (~GS_USABLE);
  GI_comp =
            @XCloseGroup,
            @SendToDocumentTrigger,
            @SendToWorldTrigger,
            @SendToTrayTrigger,
            @SendToHelpTrigger,
            @SendToBackupTrigger;

  HINT_NO_BORDERS_ON_MONIKERS;
  ATTR_GEN_DISPLAY_NOT_MINIMIZABLE;
  ATTR_GEN_DISPLAY_NOT_MAXIMIZABLE;
  ATTR_GEN_DISPLAY_NOT_RESTORABLE;
  HINT_DISPLAY_MENU_BAR_HIDDEN_ON_STARTUP;
  HINT_TOOLBOX;
  HINT_WINDOW_MINIMIZE_TITLE_BAR;
  HINT_WINDOW_NO_SYS_MENU;
  HINT_POSITION_WINDOW_AT_MOUSE;
  HINT_PRIMARY_NO_FILE_MENU;
  HINT_PRIMARY_NO_EXPRESS_MENU;
  HINT_NO_TALLER_THAN_CHILDREN_REQUIRE;
  HINT_NO_WIDER_THAN_CHILDREN_REQUIRE;
  HINT_MINIMIZE_CHILD_SPACING;
  HINT_RIGHT_JUSTIFY_CHILDREN;
  HINT_EXPAND_WIDTH_TO_FIT_PARENT;
}

@object GenInteractionClass XCloseGroup = {
@ifdef ENG
   GI_visMoniker = "Send To...";
@else
   GI_visMoniker = "Senden nach...";
@endif
  GI_comp = @XCloseTrigger;

  HINT_ORIENT_CHILDREN_HORIZONTALLY;
}

@object GenTriggerClass XCloseTrigger = {
  GI_visMoniker = "x";
  GTI_destination = process;
  GTI_actionMsg = MSG_SEND_TO_XCLOSE_PRESSED;

  HINT_TRIGGER_TOOL_STYLE_BUTTON;
}

@object GenTriggerClass SendToDocumentTrigger = {
  GI_visMoniker = "Document";
  GTI_destination = process;
  GTI_actionMsg = MSG_SEND_TO_TRIGGER_PRESSED;
  ATTR_GEN_PATH_DATA = {SP_DOCUMENT, "\0"};
  HINT_EXPAND_WIDTH_TO_FIT_PARENT;
}

@object GenTriggerClass SendToWorldTrigger = {
  GI_visMoniker = "World";
  GTI_destination = process;
  GTI_actionMsg = MSG_SEND_TO_TRIGGER_PRESSED;
  ATTR_GEN_PATH_DATA = {SP_APPLICATION, "\0"};
  HINT_EXPAND_WIDTH_TO_FIT_PARENT;
}

@object GenTriggerClass SendToTrayTrigger = {
  GI_visMoniker = "System Tray";
  GTI_destination = process;
  GTI_actionMsg = MSG_SEND_TO_TRIGGER_PRESSED;
  ATTR_GEN_PATH_DATA = {SP_SYS_APPLICATION, "TRAY\0"};
  HINT_EXPAND_WIDTH_TO_FIT_PARENT;
}

@object GenTriggerClass SendToHelpTrigger = {
  GI_visMoniker = "Help";
  GTI_destination = process;
  GTI_actionMsg = MSG_SEND_TO_TRIGGER_PRESSED;
  ATTR_GEN_PATH_DATA = {SP_HELP_FILES, "\0"};
  HINT_EXPAND_WIDTH_TO_FIT_PARENT;
}

@object GenTriggerClass SendToBackupTrigger = {
  GI_visMoniker = "Backup";
  GTI_destination = process;
  GTI_actionMsg = MSG_SEND_TO_TRIGGER_PRESSED;
  ATTR_GEN_PATH_DATA = {SP_BACKUP, "\0"};
  HINT_EXPAND_WIDTH_TO_FIT_PARENT;
}

@end SENDTORSC;

@start ABOUTRSC;
   @include <about.goh>
@end ABOUTRSC;


@start TOKENRSC;
/* Token-Dialog -------------------------------------------------------*/
@object GenInteractionClass SelectTokenDialog = {
@ifdef ENG
   GI_visMoniker = 'i', "Assign";
@else
   GI_visMoniker = 'k', "Verkn�pfen";
@endif

   GI_comp = @SelectTokenGlyph,
             @TokenMonikerList,
             @SelectTokenReplyBar;
   GII_visibility = GIV_DIALOG;

   ATTR_GEN_FOCUS_HELP = @assign_bub;
   HINT_SEEK_REPLY_BAR;
   HINT_PLACE_MONIKER_ABOVE;
   HINT_ORIENT_CHILDREN_VERTICALLY;
}

/* Token-Glyph -----------------------------------------------------------*/
@object GenGlyphClass SelectTokenGlyph = {
@ifdef ENG
   GI_visMoniker = "Select the token to be displayed for this type of file:";
@else
   GI_visMoniker = "Icon f�r die Anzeige von Dateien dieses Typs ausw�hlen:";
@endif
}

/* Tokenliste ------------------------------------------------------------*/
@object GenDynamicListClass TokenMonikerList = {
      GIGI_selection = 0;
      GIGI_applyMsg = MSG_TOKEN_SELECTED;
      GIGI_destination = process;
      GIGI_behaviorType = GIGBT_EXCLUSIVE;
      GDLI_numItems = 0;
      GDLI_queryMsg = MSG_QUERY_TOKEN;

      HINT_ITEM_GROUP_SCROLLABLE;
      HINT_ORIENT_CHILDREN_HORIZONTALLY;
      HINT_EXPAND_WIDTH_TO_FIT_PARENT;
      HINT_INITIAL_SIZE = {SST_PIXELS | 490, SST_PIXELS | 60, 7};
}

/* ReplyBar --------------------------------------------------------------*/
@object GenInteractionClass SelectTokenReplyBar = {
   GI_comp =   @SelectTokenTrigger;
   HINT_MAKE_REPLY_BAR;
}

/* SelectTokenTrigger-Button ---------------------------------------------*/
@object GenTriggerClass SelectTokenTrigger = {
   GI_attrs = @default | GA_SIGNAL_INTERACTION_COMPLETE;
@ifdef ENG
   GI_visMoniker = 'U', "Use This Token";
@else
   GI_visMoniker = 'D', "Dieses Icon";
@endif
   GTI_destination = process;
   GTI_actionMsg = MSG_USE_TOKEN;

   HINT_DEFAULT_DEFAULT_ACTION;
   HINT_SEEK_REPLY_BAR;
}

@end TOKENRSC;

/* "Feste" Strings ---------------------------------------------------------*/
@start BUBBLEHELP, data;
@ifdef ENG
   @chunk char launch_bub[]   = "Starts the selected application";
   @chunk char assign_bub[]   = "Always open this type of file with the selected application";
   @chunk char hotapp_bub[]   = "Adds the selected application to the 'Hot Apps' section";
@else
   @chunk char launch_bub[]   = "Startet die angew�hlte Applikation";
   @chunk char assign_bub[]   = "Dateien diesen Typs immer mit der angew�hlten Applikation starten";
   @chunk char hotapp_bub[]   = "Angew�hlte Applikation den 'Schnellstartern' hinzuf�gen";
@endif
@end BUBBLEHELP;


/* "Feste" Strings ---------------------------------------------------------*/
@start STRINGS, data;

   @chunk char nbcat[]                    = "gandalf";
   @chunk char nbentry[]                  = "bas0";

   @chunk char owninicat[]                = "BackDoor Man";
   @chunk char owninikey[]                = "SoftIconBar";
   @chunk char sendtokey[]                = "SendToDestinations";
   @chunk char optskey[]                  = "options";

   @chunk char inicat[]                   = "fileManager";
   @chunk char inikey[]                   = "filenameTokens";
   @chunk char inientry[]                 = "        *.* = \"FILE\",0,\"FROC\",17";

@ifdef ENG
   @chunk char restart_text[]           = "The assignments of DOS files with NewDeal applications have been changed.\rYou have to restart NewDeal to activate these changes.";
   @chunk char app_works_with[]         = "Select an application that works with ";
   @chunk char app_to_launch[]          = "Select an application to launch:";
   @chunk char maxi_str[]               = "Show Full User Interface";
   @chunk char mini_str[]               = "Show Only 'Hot Apps'";
   @chunk char delSLmode_str[]          = "Warning: You can now use the mouse to delete 'Hot Apps' that you don't need anymore.\rTo make the mouse work as usual again, simply disable the 'Remove Hot App'-mode in the 'Options' menu.";
   @chunk char FilesOnlyInfo[]          = "Sorry, you can only work with files, not with folders.";
   @chunk char SourceAndTargetIdentic[] = "Source and target path may not be equal.";
   @chunk char copy_error[]             = "An error occured while copying files.";
@else
   @chunk char restart_text[]           = "Die Verkn�pfungen von DOS-Dateien mit NewDeal Applikationen haben sich ge�ndert.\rNewDeal muss neu gestartet werden damit diese �nderungen wirksam werden.";
   @chunk char app_works_with[]         = "Applikation zum Bearbeiten folgender Datei: ";
   @chunk char app_to_launch[]          = "W�hlen Sie eine Applikation:";
   @chunk char maxi_str[]               = "Vollst�ndige Benutzeroberfl�che";
   @chunk char mini_str[]               = "Zeige nur 'Schnellstarter'";
   @chunk char delSLmode_str[]          = "Warnung: Sie k�nnen jetzt die Maus benutzen, um nicht mehr ben�tigte 'Schnellstarter' zu entfernen. Um diesen Modus auszuschalten, deaktivieren sie die entsprechende Option wieder !";
   @chunk char FilesOnlyInfo[]          = "Sie k�nnen nur Dateien senden, keine Verzeichnisse.";
   @chunk char SourceAndTargetIdentic[] = "Quell- und Zielpfad d�rfen nicht identisch sein.";
   @chunk char copy_error[]             = "Beim Kopieren ist ein Fehler aufgetreten !";
@endif

@end STRINGS;



/**************************************************************************
Begin des Codes fuer bmProcessClass
***************************************************************************/
/***********************************************************************
Konvertiert GeodeToken in String
************************************************************************/
void GeodeToken2String(char* returnBuffer, GeodeToken *tok)
{
   /* Token der zu verknuepfenden Applikation anhaengen */

   sprintf(returnBuffer, "%c%c%c%c%c%u%s",
           tokenBuffer.GT_chars[0],
           tokenBuffer.GT_chars[1],
           tokenBuffer.GT_chars[2],
           tokenBuffer.GT_chars[3],
           ',',
           tok->GT_manufID,
           "\000"
          );
}

/***********************************************************************
Konvertiert String in GeodeToken
************************************************************************/
void String2GeodeToken(char* passedBuffer, GeodeToken *tok)
{
   sdword i = 0;

   tok->GT_chars[0] = passedBuffer[0];
   tok->GT_chars[1] = passedBuffer[1];
   tok->GT_chars[2] = passedBuffer[2];
   tok->GT_chars[3] = passedBuffer[3];

   UtilAsciiToHex32(passedBuffer+5, &i);
   tok->GT_manufID   = (dword) (i);
}

/***********************************************************************
String fuer Schreiben in INI-Datei zusammenfuehren
************************************************************************/
void MergeSoftLauncherEntry(char* returnBuffer, shortstr moni_str, GeodeToken *tok)
{
   strcpy(returnBuffer, "");

   /* Token der zu verknuepfenden Applikation anhaengen */

   strcpy(returnBuffer, moni_str);
   strcat(returnBuffer, ",");

   GeodeToken2String(returnBuffer+ (strlen(moni_str)+1), tok);
}

/***********************************************************************
String aus dem Block in Moniker und GeodeToken zerlegen
************************************************************************/
void ParseSoftLauncherEntry(strbuf entrystr, shortstr moni_str, GeodeToken* tok)
{
   char*       komma_pos      = 0;
   int         anz_bis_komma  = 0;

   strcpy(moni_str,"");

   if (strident(entrystr, "\000") == FALSE)
   {
      komma_pos     = strchr(entrystr, 44);
      anz_bis_komma = ((int) komma_pos) - ((int) entrystr);

      strncpy(moni_str, entrystr, anz_bis_komma);
      moni_str[(anz_bis_komma+1)] = 0;

      String2GeodeToken((entrystr + anz_bis_komma + 1), tok);
   }
}

/***********************************************************************
 Moniker auf Button legen
 ***********************************************************************/
void SetObjectMoniker(optr button, GeodeToken* tok)
{
   if (opts & SBC_ICON)
   {UseIconicMonikerFromTokenDB(button, tok); return;}

   if (opts & SBC_TEXT)
   {UseTextMonikerFromTokenDB(button, tok); return;}

@ifdef R4

   if (opts & SBC_ICON_AND_TEXT)
   {UseTextAndSmallIconicMonikerFromTokenDB(button, tok); return;}

   if (opts & SBC_BIG_ICON_AND_TEXT)
   {UseTextAndBigIconicMonikerFromTokenDB(button, tok); return;}

@endif
}

/***********************************************************************
 Moniker auf Buttons legen
 ***********************************************************************/
void InitSoftLauncher(void)
{
   MemHandle      strHan = NULL;
   char*          ergebnis = NULL;
   optr           newLauncher = NULL;
   int            i  = -1;

   if (sbgOptr)
   {
     @call sbgOptr::MSG_GEN_SET_NOT_USABLE(VUM_NOW);
     @call bmMainGroup::MSG_GEN_REMOVE_CHILD(sbgOptr, CCF_MARK_DIRTY);
     sbgOptr = NULL;

   }

   sbgOptr = @call SoftLauncherGroupTempl::MSG_GEN_COPY_TREE(OptrToHandle(@bmMainGroup),
                                                             OptrToChunk(@bmMainGroup),
                                                             (CCF_MARK_DIRTY | CCO_LAST));

   strHan = MemAlloc(sizeof(strbuf), HF_SWAPABLE, HAF_ZERO_INIT);
   ergebnis = MemLock(strHan);
   fehler = 0;

   while(i == i) /* hack */
   {
      i++;
      strcpy(ergebnis, "");
      fehler = InitFileReadStringSectionBuffer(LOCK(@owninicat), LOCK(@owninikey), i, ergebnis, flags, dataSize);
      UNLOCK(@owninicat);
      UNLOCK(@owninikey);
      if (fehler || strident(ergebnis, "")) break;

      ParseSoftLauncherEntry(ergebnis, monik, &tokenBuffer);

      newLauncher = @call SoftLauncherTempl::MSG_GEN_COPY_TREE(OptrToHandle(sbgOptr),
                                                               OptrToChunk(sbgOptr),
                                                               (CCF_MARK_DIRTY | CCO_LAST));

      @call newLauncher::MSG_GEN_REPLACE_VIS_MONIKER_TEXT(monik, VUM_NOW);
      SetObjectMoniker(newLauncher, &tokenBuffer);

      @call newLauncher::MSG_GEN_SET_USABLE(VUM_NOW);
   }

   @send bmPrimary::MSG_GEN_RESET_TO_INITIAL_SIZE(VUM_NOW);
   @send sbgOptr::MSG_GEN_RESET_TO_INITIAL_SIZE(VUM_NOW);
   @call sbgOptr::MSG_GEN_SET_USABLE(VUM_NOW);

   MemUnlock(strHan);
   MemFree(strHan);
}

/***********************************************************************
Datei mit Dateinamen fuer NewBasic Programm erzeugen...
************************************************************************/
void PassNBFileName(void)
{
FileHandle paraFile = 0;

   FilePushDir();
   FileSetStandardPath(SP_TOP);

   (void) FileDelete("nbpara.txt");

   FilesPtr = MemLock(FilesHan);

   if (strcmp(FilesPtr->datafname,"") > 0)
   {
      paraFile = FileCreate("nbpara.txt",
                                 ((FILE_CREATE_TRUNCATE | FCF_NATIVE) | (FILE_ACCESS_W | FILE_DENY_W)),
                                 0);
      strcpy(buffer, "");
      strcpy(buffer, FilesPtr->datafname);
      pb = buffer;

      (void) FileConstructFullPath(&pb, sizeof(strbuf), FilesPtr->datadh, FilesPtr->datadirn, TRUE);

      if (buffer[strlen(buffer)-1] != 92) strcat(buffer, "\\");
      strcat(buffer, FilesPtr->datafname);

      (void) FileWrite(paraFile, buffer, strlen(buffer), TRUE);

      (void) FileCommit(paraFile, FALSE);
      (void) FileClose(paraFile, 1);
   }

   MemUnlock(FilesHan);
   FilePopDir();
}

/***********************************************************************

 ***********************************************************************/
void DeleteBlobEntry(optr inic, optr inik, char* blob_str)
{
int section = -1;
int erg = 0;

   do
   {
      section ++;
      erg = InitFileReadStringSectionBuffer(LOCK(inic), LOCK(inik), section, buffer, flags, dataSize);
      UNLOCK(inic);
      UNLOCK(inik);
      if ((strstr(buffer, blob_str) != 0))
      {
         InitFileDeleteStringSection(LOCK(inic), LOCK(inik), section);
         InitFileCommit();
         UNLOCK(inic);
         UNLOCK(inik);
      }
   }
   while (erg == 0);
}

/***********************************************************************
 Tokens aus TokenDatabase einlesen...
 ***********************************************************************/
void GetTokensFromDatabase(Boolean freeOld)
{
            dword ret;
            /*char buf[20];*/

            if(freeOld)                     /* free old token data? */
               MemFree(tdelTokenList);
            ret = TokenListTokens(TRF_ONLY_GSTRING, 0, 0);
            tdelTokenList = TokenListTokensHandleFromDWord(ret);
            tdelTokenCount = TokenListTokensCountFromDWord(ret);
            @send SelectTokenTrigger::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);
            @send TokenMonikerList::MSG_GEN_DYNAMIC_LIST_INITIALIZE(tdelTokenCount);
}

/***********************************************************************
 TokenID aus Tokennummer ermitteln...
 ***********************************************************************/
void GetTokenFromList(word item, GeodeToken *t)
{
            GeodeToken *toklist;

            toklist = MemLock(tdelTokenList);
            *t = toklist[item];
            MemUnlock(tdelTokenList);
}

/***********************************************************************
 BackDoor Man mit UI initalisieren
 ***********************************************************************/
@method bmProcessClass, MSG_INIT_BM_WITH_UI
{
MemHandle      strHan   = NULL;
char*          tstr     = NULL;
OptionsType    ot       = 0;

      /* String Ressource bereitmachen */
      strHan = MemAlloc(sizeof(strbuf), HF_SWAPABLE, HAF_ZERO_INIT);
      tstr = MemLock(strHan);

      /* Start mit UI */
      strcpy(tstr, "");

      /* Moniker ueber dem Hauptfileselektor anpassen */
      FilesPtr = MemLock(FilesHan);
      if (strlen(FilesPtr->datafname) <= 1)
      {
         strcpy(tstr, LOCK(@app_to_launch));
         UNLOCK(@app_to_launch);
      }
      else
      {
         strcpy(tstr, LOCK(@app_works_with));
         UNLOCK(@app_works_with);
         strcat(tstr, FilesPtr->datafname);
      }
      MemUnlock(FilesHan);
      @call hintGlyph::MSG_GEN_REPLACE_VIS_MONIKER_TEXT(tstr, VUM_NOW);
      MemFree(strHan);

      /* Tokens fuer Tokenauswahl einlesen */
      GetTokensFromDatabase(FALSE);

      /* Moniker der Schnellstarter anpassen */
      InitSoftLauncher();

      /* Welche Auswahl fuer SoftLauncherChoices */
      if (opts & SBC_ICON)
      {ot |= SBC_ICON;}
      else
      {
         if (opts & SBC_TEXT)
         {ot |= SBC_TEXT;}
         else
         {if (opts & SBC_ICON_AND_TEXT) ot |= SBC_ICON_AND_TEXT;}
      }
      @call SoftLauncherChoices::MSG_GEN_ITEM_GROUP_SET_SINGLE_SELECTION(ot, FALSE);

      if (opts & EXIT_AFTER_LAUNCH)
      {@call ToggleGroup::MSG_GEN_BOOLEAN_GROUP_SET_BOOLEAN_STATE(EXIT_AFTER_LAUNCH, TRUE);}
      else
      {@call ToggleGroup::MSG_GEN_BOOLEAN_GROUP_SET_BOOLEAN_STATE(EXIT_AFTER_LAUNCH, FALSE);}

      if (opts & MINI_MODE) {opts &= ~MINI_MODE;} else {opts |= MINI_MODE;}
      @call process::MSG_SWITCH_SHOW_MODE();

      /* Hauptfenster sichtbar machen */
      @call bmPrimary::MSG_GEN_SET_USABLE(VUM_NOW);
}

/***********************************************************************
 Beim Programmstart....
 ***********************************************************************/
@method bmProcessClass, MSG_GEN_PROCESS_OPEN_APPLICATION
{
AppLaunchBlock*     start_param;
FilesHan            = MemAlloc(sizeof(FilesStruct), HF_SWAPABLE, HAF_ZERO_INIT);

/*- Startparameter auswerten -*/
   start_param = MemLock(launchBlock);
   FilesPtr = MemLock(FilesHan);
   FilesPtr->datadh = start_param->ALB_diskHandle;
   strcpy(FilesPtr->datadirn, start_param->ALB_path);
   strcpy(FilesPtr->datafname, start_param->ALB_dataFile);
   selFiles = start_param->ALB_extraData;
   MemUnlock(launchBlock);

   @call bmPrimary::MSG_GEN_SET_NOT_USABLE(VUM_NOW);

/*- Superklasse aufrufen -*/
   @callsuper();

/* Options auslesen */
   InitFileReadInteger(LOCK(@owninicat), LOCK(@optskey), &opts);
   UNLOCK(@owninicat);
   UNLOCK(@optskey);

   MemUnlock(FilesHan);

   if (selFiles)
   {
     @call oself::MSG_ADD_SEND_TO_TRIGGERS();
     @send, forceQueue bmSendToPrimary::MSG_GEN_SET_USABLE(VUM_NOW);
   }
   else
   {
     @send, forceQueue process::MSG_INIT_BM_WITH_UI();
   }

}

/*************************************************************************
 "BackDoor Man" Show Modus umschalten
 *************************************************************************/
@method bmProcessClass, MSG_SWITCH_SHOW_MODE
{
   if (opts & MINI_MODE)
   {
       @call ModeTrigger::MSG_GEN_REPLACE_VIS_MONIKER_TEXT(LOCK(@mini_str), VUM_NOW);
       UNLOCK(@mini_str);

       @call bmPrimary::MSG_GEN_SET_NOT_USABLE(VUM_NOW);

       @call hintGlyph::MSG_GEN_SET_USABLE(VUM_NOW);
       @call FileSelectorGroup::MSG_GEN_SET_USABLE(VUM_NOW);
       @call bmReplyBar::MSG_GEN_SET_USABLE(VUM_NOW);

       @call bmPrimary::MSG_GEN_SET_USABLE(VUM_NOW);
       opts &= ~MINI_MODE;
   }
   else
   {
       @call ModeTrigger::MSG_GEN_REPLACE_VIS_MONIKER_TEXT(LOCK(@maxi_str), VUM_NOW);
       UNLOCK(@maxi_str);

       @call bmPrimary::MSG_GEN_SET_NOT_USABLE(VUM_NOW);

       @call hintGlyph::MSG_GEN_SET_NOT_USABLE(VUM_NOW);
       @call FileSelectorGroup::MSG_GEN_SET_NOT_USABLE(VUM_NOW);
       @call bmReplyBar::MSG_GEN_SET_NOT_USABLE(VUM_NOW);

       @call bmPrimary::MSG_GEN_RESET_TO_INITIAL_SIZE(VUM_NOW);

       @call bmPrimary::MSG_GEN_SET_USABLE(VUM_NOW);
       opts |= MINI_MODE;
   }
}

/*************************************************************************
 Beim Beenden
 *************************************************************************/
@method bmProcessClass, MSG_GEN_PROCESS_CLOSE_APPLICATION
{
      InitFileWriteInteger(LOCK(@owninicat), LOCK(@optskey), opts);
      InitFileCommit();
      UNLOCK(@owninicat);
      UNLOCK(@optskey);

      if (tdelTokenList != NULL) MemFree(tdelTokenList);
      if (FilesHan != NULL) MemFree(FilesHan);

      @callsuper();
      return NULL;
}

/*************************************************************************
 Datei auswaehlen
 *************************************************************************/
@method bmProcessClass, MSG_FILEBROW_SELECTOR_ACTION
{
   if (GFS_GET_ENTRY_TYPE(entryFlags) == (GFSET_SUBDIR))
   {
      @call UseFileTrigger::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);
      @call SelectTokenDialog::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);
      @call AddTrigger::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);
   }

   if (GFS_GET_ENTRY_TYPE(entryFlags) == (GFSET_FILE))
   {
      FilesPtr = MemLock(FilesHan);

      FilesPtr->dh = @call bmFileSelector::MSG_GEN_PATH_GET_DISK_HANDLE();
      @call bmFileSelector::MSG_GEN_PATH_GET(FilesPtr->dirn, sizeof(FilesPtr->dirn));
      @call bmFileSelector::MSG_GEN_FILE_SELECTOR_GET_SELECTION(FilesPtr->fname);

      @call UseFileTrigger::MSG_GEN_SET_ENABLED(VUM_NOW);

      if (WhichApps == FT_APPS)
      {
         if (strlen(FilesPtr->datafname) > 1) @call SelectTokenDialog::MSG_GEN_SET_ENABLED(VUM_NOW);
         @call AddTrigger::MSG_GEN_SET_ENABLED(VUM_NOW);
      }

      (void) FileSetCurrentPath(FilesPtr->dh, FilesPtr->dirn);
      FileGetPathExtAttributes(FilesPtr->fname,  attr, (&tokenBuffer), bufSize);

      MemUnlock(FilesHan);

      if (entryFlags & GFSEF_OPEN)
      { /* Wenn Doppelklick, dann Programm starten */
         @call UseFileTrigger::MSG_GEN_TRIGGER_SEND_ACTION(FALSE);
      }
   }
}

/*************************************************************************
 Programm mit Datei starten
 *************************************************************************/
@method bmProcessClass, MSG_USE_FILE
{
      FilesPtr = MemLock(FilesHan);

      if (/* Wenn Builder .... */
            (strcmp(FilesPtr->datafname, "")     >  0 ) &&
            (tokenBuffer.GT_chars[0] == 'B') &&
            (tokenBuffer.GT_chars[1] == 'L') &&
            (tokenBuffer.GT_chars[2] == 'D') &&
            (tokenBuffer.GT_chars[3] == 'R') &&
            (tokenBuffer.GT_manufID  ==  0)
          )
      {
         strcpy(buffer, "");
         pb = buffer;

         (void) FileConstructFullPath(&pb, sizeof(strbuf), FilesPtr->datadh, FilesPtr->datadirn, TRUE);
         strcat(buffer,"\\"); strcat(buffer, FilesPtr->datafname);

         InitFileWriteString(LOCK(@nbcat), LOCK(@nbentry), buffer);
         UNLOCK(@nbcat);
         UNLOCK(@nbentry);
         InitFileCommit();
      }

      if (WhichApps == FT_NB_APPS) /* Wenn NewBasic Applikation zu starten */
      {
         tokenBuffer.GT_chars[0] = 'L'; tokenBuffer.GT_chars[1] = 'A';  tokenBuffer.GT_chars[2] = 'U'; tokenBuffer.GT_chars[3] = 'N';
         tokenBuffer.GT_manufID = 0;
         PassNBFileName();

         FilesPtr->datadh = FilesPtr->dh;
         strcpy(FilesPtr->datadirn, FilesPtr->dirn);
         strcpy(FilesPtr->datafname, FilesPtr->fname);

      }

      MemUnlock(FilesHan);

      LaunchApp(&tokenBuffer, FilesHan);
      @send process::MSG_EXIT_BM();
}


/*************************************************************************
 Add-Button gedrueckt
 *************************************************************************/
@method bmProcessClass, MSG_ADD_SOFT_LAUNCHER
{
MemHandle      strHan = NULL;
char*          ergebnis = NULL;
optr           newLauncher = NULL;


   newLauncher = @call SoftLauncherTempl::MSG_GEN_COPY_TREE(OptrToHandle(sbgOptr),
                                                            OptrToChunk(sbgOptr),
                                                            (CCF_MARK_DIRTY | CCO_LAST));

   FilesPtr = MemLock(FilesHan);
   @call newLauncher::MSG_GEN_REPLACE_VIS_MONIKER_TEXT(FilesPtr->fname, VUM_NOW);
   SetObjectMoniker(@dup(newLauncher), &tokenBuffer);
   @call newLauncher::MSG_GEN_SET_USABLE(VUM_NOW);

   if (strcmp(FilesPtr->fname,"") > 0)
   {
      /* String Ressource bereitmachen */
      strHan = MemAlloc(sizeof(strbuf), HF_SWAPABLE, HAF_ZERO_INIT);
      ergebnis = MemLock(strHan);
      strcpy(ergebnis, "");

      MergeSoftLauncherEntry(ergebnis, FilesPtr->fname, &tokenBuffer);

      /*  In Ini-Datei schreiben */
      InitFileWriteStringSection(LOCK(@owninicat), LOCK(@owninikey), ergebnis);
      InitFileCommit();

      UNLOCK(@owninicat);
      UNLOCK(@owninikey);
      MemFree(strHan);
   }

   MemUnlock(FilesHan);
}
/*************************************************************************
 Soft Launcher gedrueckt
 *************************************************************************/
@method bmProcessClass, MSG_SOFT_LAUNCHER_PRESSED
{
word launcher_nr = 0;

   launcher_nr = (@call sbgOptr::MSG_GEN_FIND_CHILD(trigger));

   if (delSLMode == FALSE)
   {/*Wenn Nicht-Remove-Mode starte Applikation */
      strcpy(buffer,"");
      fehler = InitFileReadStringSectionBuffer(LOCK(@owninicat), LOCK(@owninikey), launcher_nr, buffer, flags, dataSize);
      UNLOCK(@owninicat);
      UNLOCK(@owninikey);
      ParseSoftLauncherEntry(buffer, monik, &tokenBuffer);
      @send process::MSG_USE_FILE();
   }
   else
   {/*Wenn Remove-Mode Remove SoftLauncher */
      @call trigger::MSG_GEN_DESTROY(VUM_NOW, CCF_MARK_DIRTY);
      @send sbgOptr::MSG_GEN_RESET_TO_INITIAL_SIZE(VUM_NOW);
      @send bmPrimary::MSG_GEN_RESET_TO_INITIAL_SIZE(VUM_NOW);
      InitFileDeleteStringSection(LOCK(@owninicat), LOCK(@owninikey), launcher_nr);
      UNLOCK(@owninicat);
      UNLOCK(@owninikey);
      InitFileCommit();
   }
}

/*************************************************************************
 File Selector umschalten zwischen NewBasic und normalen Applikationen
 *************************************************************************/
@method bmProcessClass, MSG_FFS_CHOOSE_FILTER_TYPE
{
      @call bmFileSelector::MSG_GEN_FILE_SELECTOR_SUSPEND();

      @call bmFileSelector::MSG_META_DELETE_VAR_DATA(ATTR_GEN_FILE_SELECTOR_NAME_MASK);
      @call bmFileSelector::MSG_META_DELETE_VAR_DATA(ATTR_GEN_FILE_SELECTOR_CREATOR_MATCH);
      @call bmFileSelector::MSG_GEN_FILE_SELECTOR_SET_FILE_CRITERIA(0);

      switch (selection)
      {
         case 0: {
                        WhichApps = FT_APPS;
                        @call SelectTokenDialog::MSG_GEN_SET_ENABLED(VUM_NOW);
                        @call AddTrigger::MSG_GEN_SET_ENABLED(VUM_NOW);
                        @call bmFileSelector::MSG_GEN_FILE_SELECTOR_SET_FILE_CRITERIA(
                                              ((FSFC_DIRS) | (FSFC_GEOS_EXECUTABLES))
                                              & ((~FSFC_GEOS_NON_EXECUTABLES) & (~FSFC_NON_GEOS_FILES)));
                        break;
                     }
         case 1: {
                        WhichApps = FT_NB_APPS;
                        @call SelectTokenDialog::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);
                        @call AddTrigger::MSG_GEN_SET_NOT_ENABLED(VUM_NOW);
                        @call bmFileSelector::MSG_GEN_FILE_SELECTOR_SET_FILE_CRITERIA(
                                                           ((FSFC_DIRS)
                                                         | (FSFC_GEOS_NON_EXECUTABLES))
                                                         & ((~FSFC_NON_GEOS_FILES)
                                                         & (~FSFC_GEOS_EXECUTABLES))
                                                         );

                        @call bmFileSelector::MSG_GEN_FILE_SELECTOR_SET_MASK(
                                                         "*.BC");
/*                      @call bmFileSelector::MSG_GEN_FILE_SELECTOR_SET_CREATOR(
                                                         SET_TOKEN_CHARS('L','A','U','N'),
                                                         0);*/
                        break;
                     }
      }
      @call bmFileSelector::MSG_GEN_FILE_SELECTOR_END_SUSPEND();
}

/*************************************************************************
 Optionen umschalten, von wegen SoftLauncher Moniker
 *************************************************************************/
@method bmProcessClass, MSG_SBC_TOGGLE_CHOICES
{
   opts = (opts & ~SBC_ICON & ~SBC_TEXT & ~SBC_ICON_AND_TEXT);
   opts |= selection;
   @send bmPrimary::MSG_GEN_SET_NOT_USABLE(VUM_NOW);
   InitSoftLauncher();
   @send bmPrimary::MSG_GEN_SET_USABLE(VUM_NOW);
}

/**************************************************************************
 Wenn in Tokenliste Icon selected...
 **************************************************************************/
@method bmProcessClass, MSG_TOKEN_SELECTED
{
            @call SelectTokenTrigger::MSG_GEN_SET_ENABLED(VUM_NOW);
}

/**************************************************************************
 Wenn Tokenliste die Moniker abfragt...
 **************************************************************************/
@method bmProcessClass, MSG_QUERY_TOKEN
{
            GeodeToken t;

            GetTokenFromList(item,&t);
            @call TokenMonikerList::MSG_GEN_DYNAMIC_LIST_REPLACE_ITEM_MONIKER(
             item,0,30,48,0,VMDT_TOKEN,VMST_FPTR,(dword)&t);
}

/**************************************************************************
 Wenn dieses Token benutzt werden soll....
 **************************************************************************/
@method bmProcessClass, MSG_USE_TOKEN
{
word           item;
GeodeToken     t;

MemHandle      strHan = NULL;
char*          strPtr = NULL;

            item = @call TokenMonikerList::MSG_GEN_ITEM_GROUP_GET_SELECTION();
                                                            /* get currently selected token */
            if(item == GIGS_NONE)             /* no effect if no item is selected */
               return;

            GetTokenFromList(item, &t);      /* get token to be assigned */

            /* Dateien verknuepfen */

            /* String Ressource bereitmachen */
            strHan = MemAlloc(sizeof(strbuf), HF_SWAPABLE, HAF_ZERO_INIT);
            strPtr = MemLock(strHan);

            FilesPtr = MemLock(FilesHan);

            /* Auffuellen */
            sprintf(strPtr, "%s%s%s%c%c%c%c%s%u%s%c%c%c%c%s%u%s",
                        "        *",
                        strrchr(FilesPtr->datafname, (int) 46), /* "*" + ".TXT" => Dateiendung abschneiden */
                        " = \"",
                        t.GT_chars[0],
                        t.GT_chars[1],
                        t.GT_chars[2],
                        t.GT_chars[3],
                        "\",",
                        t.GT_manufID,
                        ",\"",
                        tokenBuffer.GT_chars[0],
                        tokenBuffer.GT_chars[1],
                        tokenBuffer.GT_chars[2],
                        tokenBuffer.GT_chars[3],
                        "\",",
                        tokenBuffer.GT_manufID,
                        "\0"
                      );

            DeleteBlobEntry(@inicat, @inikey, strrchr(FilesPtr->datafname, (int) 46));

            MemUnlock(FilesHan);

            /* In Ini-Datei schreiben */
            InitFileWriteStringSection(LOCK(@inicat), LOCK(@inikey), strPtr);
            InitFileCommit();

            UNLOCK(@inicat);
            UNLOCK(@inikey);
            MemFree(strHan);
            MsgBox(CDT_NOTIFICATION, @restart_text);

}

/**************************************************************************
 BackDoor Man Optionen ein/ausschalten
 **************************************************************************/
@method bmProcessClass, MSG_OPTIONS_TOGGLE_STATUS
{
   if (changedBooleans & REMOVE_ON)
   {
      if (selectedBooleans & REMOVE_ON) /*von Remove nach Nicht-Remove  ...*/
      {
         MsgBox(CDT_WARNING, @delSLmode_str);
         delSLMode = TRUE;
      }
      else
      {  delSLMode = FALSE;}
   }

   if (changedBooleans & EXIT_AFTER_LAUNCH)
   {
      if (selectedBooleans & EXIT_AFTER_LAUNCH) /*von Remove nach Nicht-Remove  ...*/
      {  opts |= EXIT_AFTER_LAUNCH; }
      else
      {  opts &= ~EXIT_AFTER_LAUNCH;}
   }
}

/*************************************************************************
 Laufwerk finden
 *************************************************************************/
DiskHandle GetDriveA(void)
{
  byte            firstDrive = 0;
  DiskHandle      dh = 0;

  if (DriveGetStatus(firstDrive) & DS_PRESENT)
  {
    dh = DiskRegisterDiskSilently(firstDrive);

    if (dh)
    {
      return dh;
    }
  }

  return NULL;
}

/*************************************************************************
 Send To Trigger aus Ini lesen und hinzuf�gen
 *************************************************************************/
@method bmProcessClass, MSG_ADD_SEND_TO_TRIGGERS
{
   MemHandle      strHan = NULL;
   char*          ergebnis = NULL;
   optr           newTrigger = NULL;
   int            i  = -1;
   DiskHandle     dh = NULL;


   @call bmSendToPrimary::MSG_GEN_SET_NOT_USABLE(VUM_NOW);

   strHan = MemAlloc(sizeof(strbuf), HF_SWAPABLE, HAF_ZERO_INIT);
   ergebnis = (char*) MemLock(strHan);
   fehler = 0;

   dh = GetDriveA();

   if (dh)
   {
      newTrigger = @call SendToTriggerTempl::MSG_GEN_COPY_TREE(OptrToHandle(@bmSendToPrimary),
                                                               OptrToChunk(@bmSendToPrimary),
                                                               (CCF_MARK_DIRTY | CCO_LAST));

      @call newTrigger::MSG_GEN_REPLACE_VIS_MONIKER_TEXT("A:\\", VUM_NOW);
      @call newTrigger::MSG_GEN_PATH_SET("", dh);
      @call newTrigger::MSG_GEN_SET_USABLE(VUM_NOW);
    }

   while(i == i) /* hack */
   {
      i++;
      strcpy(ergebnis, "");
      fehler = InitFileReadStringSectionBuffer(LOCK(@owninicat), LOCK(@sendtokey), i, ergebnis, flags, dataSize);
      UNLOCK(@owninicat);
      UNLOCK(@sendtokey);
      if (fehler || strident(ergebnis, "")) break;

      FilePushDir();
      dh = FileSetCurrentPath(0, ergebnis);

      if (dh)
      {
        newTrigger = @call SendToTriggerTempl::MSG_GEN_COPY_TREE(OptrToHandle(@bmSendToPrimary),
                                                                 OptrToChunk(@bmSendToPrimary),
                                                                 (CCF_MARK_DIRTY | CCO_LAST));

        @call newTrigger::MSG_GEN_REPLACE_VIS_MONIKER_TEXT(ergebnis, VUM_NOW);
        ergebnis = ergebnis + 2;
        @call newTrigger::MSG_GEN_PATH_SET(ergebnis, dh);

        @call newTrigger::MSG_GEN_SET_USABLE(VUM_NOW);
      }

      FilePopDir();
   }

   @call bmSendToPrimary::MSG_GEN_RESET_TO_INITIAL_SIZE(VUM_NOW);
   @call bmSendToPrimary::MSG_GEN_SET_USABLE(VUM_NOW);

   MemUnlock(strHan);
   MemFree(strHan);
}

/**************************************************************************
 Send To Trigger pressed
 **************************************************************************/
@method bmProcessClass, MSG_SEND_TO_TRIGGER_PRESSED
{
  FileQuickTransferHeader*   HeaderPtr   = NULL;
  FileQuickTransferHeader*   tempPtr     = NULL;
  FileOperationInfoEntry*    EntriesPtr  = NULL;
  word                       i           = NULL;
  DiskHandle                 srcDisk     = NULL;
  DiskHandle                 destDisk    = NULL;
  const char                 srcStr[FILE_LONGNAME_BUFFER_SIZE + PATH_BUFFER_SIZE] = "";
  const char                 destStr[FILE_LONGNAME_BUFFER_SIZE + PATH_BUFFER_SIZE] = "";

         if (selFiles)
         {
             destDisk = @call trigger::MSG_GEN_PATH_GET_DISK_HANDLE();

             HeaderPtr  = (FileQuickTransferHeader*) MemLock(selFiles);
             srcDisk    = HeaderPtr->FQTH_diskHandle;
             tempPtr    = HeaderPtr + 1;
             EntriesPtr = (FileOperationInfoEntry*) tempPtr;

             i = 0;
             do
             {
                /* Quellpfad aus Quicktransfer Header ermitteln */
                strcpy(srcStr, HeaderPtr->FQTH_pathname);
                if (strlen(srcStr) > 0)
                {
                  if (srcStr[strlen(srcStr)-1] != '\\') {strcat(srcStr, "\\");}
                }
                else
                {
                  strcat(srcStr, "\\");
                }
                strcat(srcStr, EntriesPtr->FOIE_name);

                /* Zielpfad aus Trigger ermitteln */
                strcpy(destStr, "");
                @call trigger::MSG_GEN_PATH_GET(destStr, FILE_LONGNAME_BUFFER_SIZE + PATH_BUFFER_SIZE);
                if (strlen(destStr) > 0)
                {
                  if (destStr[strlen(destStr)-1] != '\\') {strcat(destStr, "\\");}
                }
                else
                {
                  strcat(destStr, "\\");
                }
                strcat(destStr, EntriesPtr->FOIE_name);

                if  (
                       (strident(srcStr, destStr) == TRUE)
                    && (srcDisk == destDisk)
                    )
                {
                   MsgBox(CDT_ERROR, @SourceAndTargetIdentic);
                   break;
                }

                if (EntriesPtr->FOIE_type != GFT_DIRECTORY)
                {
                   if (FileCopy(srcStr, destStr, srcDisk, destDisk) != NULL)
                   {
                     MsgBox(CDT_ERROR, @copy_error);
                     break;
                   }
                }
                else
                {
                  MsgBox(CDT_ERROR, @FilesOnlyInfo);
                }

                EntriesPtr = (FileOperationInfoEntry*) EntriesPtr + 1;
                i++;
             }
             while (i <= (HeaderPtr->FQTH_numFiles - 1));

             MemUnlock(selFiles);
             MemFree(selFiles);
             selFiles = NULL;
         }

         @send application::MSG_META_QUIT();
}

/**************************************************************************
 Wenn BM zu beenden
 **************************************************************************/
@method bmProcessClass, MSG_SEND_TO_XCLOSE_PRESSED
{
  if (selFiles)
  {
    MemUnlock(selFiles);
    MemFree(selFiles);
  }

  @send application::MSG_META_QUIT();
}

/**************************************************************************
 Wenn BM zu beenden
 **************************************************************************/
@method bmProcessClass, MSG_EXIT_BM
{
   if (opts & EXIT_AFTER_LAUNCH)
   {
      @send application::MSG_META_QUIT();
   }
}

